╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═════════════════╗
║  █████╗ ██████╗  ██████╗██╗  ██╗██╗████████╗███████╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗ ║
║ ██╔══██╗██╔══██╗██╔════╝██║  ██║██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗██╔════╝ ║
║ ███████║██████╔╝██║     ███████║██║   ██║   █████╗  ██║        ██║   ██║   ██║██████╔╝█████╗   ║
║ ██╔══██║██╔══██╗██║     ██╔══██║██║   ██║   ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗██╔══╝   ║
║ ██║  ██║██║  ██║╚██████╗██║  ██║██║   ██║   ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║███████╗ ║
║ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝ ║
║                                                                              ╔═════════════════╝
║          The project's technical structure, standards, and patterns.         ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       GUIDING DESIGN PRINCIPLES                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This project's development is guided by the SOLID principles to ensure the ║
║   codebase remains clean, maintainable, and scalable.                        ║
║                                                                              ║
║   █  Single Responsibility Principle (SRP): Every script should have one,    ║
║      and only one, reason to change. This is why we separate level building  ║
║      from entity spawning, and UI appearance from UI logic.                  ║
║                                                                              ║
║   █  Open/Closed Principle: Code should be open for extension, but closed for║
║      modification. We achieve this with patterns like the State Pattern,     ║
║      where adding a new player ability means adding a new file, not changing ║
║      existing, stable code.                                                  ║
║                                                                              ║
║   █  Liskov Substitution Principle: Subclasses must be substitutable for their║
║      base classes. A `FireBoss` must be able to do everything a `BaseBoss` can.║
║                                                                              ║
║   █  Interface Segregation Principle: We avoid creating "fat" classes that   ║
║      are forced to have functions they don't need.                           ║
║                                                                              ║
║   █  Dependency Inversion Principle: High-level code (like `game.gd`) should ║
║      not depend on the specific implementation of low-level code (like the   ║
║      `ArenaBuilder`). It should depend on an abstraction (the `build_level()`║
║      function contract). Signals are a key tool for this.                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       KEY ARCHITECTURAL PATTERNS                     ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  The State Pattern: This is the primary pattern for managing complex     ║
║      entities. The logic for each state (e.g., `Move`, `Attack`, `Dash`) is  ║
║      encapsulated in its own class file. The entity (`Player`, `BaseBoss`)   ║
║      then acts as a "Context", holding a reference to the current state and  ║
║      delegating all processing to it. This keeps the entity's main script    ║
║      clean and makes adding or changing abilities highly modular.            ║
║                                                                              ║
║   █  Singleton-Driven Core: Global systems are managed by Autoload singletons.║
║      ░  `Palette.gd`: Manages all game colors for a cohesive aesthetic.      ║
║      ░  `AssetPaths.gd`: A central, pre-loading registry for all assets.     ║
║      ░  Other singletons (`AudioManager`, `Constants`, etc.) serve dedicated roles.║
║                                                                              ║
║   █  Asynchronous Loading with Pre-warming: To ensure smooth transitions, a  ║
║      `LoadingScreen` orchestrates all setup. It pre-warms shaders by         ║
║      flashing entities in an off-screen viewport and calls the               ║
║      `ArenaBuilder` to construct the level in non-blocking batches.          ║
║                                                                              ║
║   █  Component-Based and Procedural UI: The UI is built from self-contained, ║
║      reusable scenes (`StyledMenuItem`). These components will draw          ║
║      themselves procedurally using shaders, allowing for a highly polished   ║
║      and animatable interface without relying on static images.              ║
║                                                                              ║
║   █  Component-to-Owner Communication (via Signals): Components encapsulate  ║
║      logic but should not directly control their owner. To maintain this     ║
║      decoupling, components use Godot's built-in signals to announce that    ║
║      something has happened. The owner node (e.g., `player.gd`) listens for  ║
║      these signals and decides how to react. For example, the               ║
║      `CombatComponent` emits `pogo_bounce_requested`, and the `Player` script║
║      implements the actual physics bounce. This keeps components reusable    ║
║      and the owner in full control of its own state.                         ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         COLLABORATION WORKFLOW                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   1. Define Goal: The Human defines a small, achievable goal based on the TODO.║
║   2. AI Solution: The AI provides complete, regenerated files and explains changes.║
║   3. Implement & Test: The Human implements and thoroughly tests the changes.║
║   4. Document & Commit: The Human updates documentation, then the AI provides a commit message.║
║   5. Confirm & Proceed: The Human confirms success and defines the next goal.║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

ARCHITECTURE SUMMARY
====================

Purpose
-------
Capture the runtime architecture after the refactor. This doc focuses on:
- The component-based entity model
- State machines and lifecycle
- Autoload singletons and their responsibilities
- Damage/hit contracts and flow

High-level ASCII diagram
------------------------
Entities (Node2D)
  ├─ components (ComponentInterface)
  └─ state_machine (BaseStateMachine)
         ├─ state: BaseState
         └─ state: BaseState

Singletons (autoloads)
----------------------
- EventBus      — pub/sub decoupling for cross-systems events
- SceneManager  — load/unload top-level scenes safely (async)
- Sequencer     — sequence manager for cutscene-like flows and blocking scripts
- ObjectPool    — pooled nodes (projectiles, FX, temporary entities)
- CombatUtils   — canonical damage application & hit resolution helpers
- AssetPaths    — centralized resource path map (optional)
- Palette       — color / theme constants (optional)

Core contracts & API
--------------------
ComponentInterface (convention)
- Purpose: reusable behavior units attached to Entities.
- Expected methods:
  - `func setup(config: Dictionary) -> void`    # apply param set; called on entity init
  - `func teardown() -> void`                  # cleanup (disconnect signals, timers)
- Lifetime: components are owned by their entity; teardown must undo everything added.

BaseState / BaseStateMachine
- BaseState exposes:
  - `func enter(data = null) -> void`
  - `func exit() -> void`
  - `func physics_process(delta: float) -> void`
- BaseStateMachine:
  - holds `current_state: BaseState`
  - `change_state(new_state: BaseState, data = null)` performs exit → transition → enter
  - States should be lightweight and free of leaked timers/signals (teardown on exit).

IDamageable
- Entities that can be damaged must implement the IDamageable contract:
  - `func receive_damage(damage_info: Dictionary) -> void`
  - `func is_invulnerable() -> bool` (optional)
- CombatUtils is the recommended façade to resolve hits:
  - `CombatUtils.apply_damage(source, target, damage_info)`

Damage / Hit Flow (canonical)
1. A hit is detected (Area2D overlap, raycast, or collision callback).
2. A DamageSource object/dictionary is created (type, amount, knockback, owner, hit_flags).
3. `CombatUtils.apply_damage(...)` is called.
4. CombatUtils:
   - Normalizes damage_info
   - Checks IDamageable contract and invulnerability windows
   - Applies HP change and notifies EventBus (eg. `EventBus.emit("damage_taken", {...})`)
   - Handles FX via ObjectPool

EventBus usage (example)
- Emit:
  `EventBus.emit("player_died", {"player": player})`
- Subscribe:
  `EventBus.on("player_died", self, "_on_player_died")`

File organization notes
- `src/core/` => autoloads + shared utilities
- `src/entities/` => entity scenes, component scripts, and state scripts
- `src/arenas/` => procedural/serialized arena builders & layouts
- `docs/` => architecture and design docs (update when APIs change)

Performance / lifecycle guidance
- Use ObjectPool for high-frequency nodes (bullets, hitFX).
- Keep async scene loads in SceneManager to avoid frame stalls.
- Pre-warm shaders/materials on load if you see first-frame hitches.
- Always disconnect EventBus listeners and clear timers in `_exit_tree`.

Common places to check when adding features:
- Combat: `src/core/CombatUtils.gd`
- Eventing: `src/core/EventBus.gd`
- State machine base: `src/core/BaseStateMachine.gd`
- Component contract: `src/entities/ComponentInterface.gd`
- Pools: `src/core/ObjectPool.gd`

(When you update any of these, please mirror the change into this doc.)
