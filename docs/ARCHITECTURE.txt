╔══════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                  ║
║  █████╗ ██████╗  ██████╗██╗  ██╗██╗████████╗███████╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗   ║
║ ██╔══██╗██╔══██╗██╔════╝██║  ██║██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗██╔════╝   ║
║ ███████║██████╔╝██║     ███████║██║   ██║   █████╗  ██║        ██║   ██║   ██║██████╔╝█████╗     ║
║ ██╔══██╗██╔══██╗██║     ██╔══██║██║   ██║   ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗██╔══╝     ║
║ ██║  ██║██║  ██║╚██████╗██║  ██║██║   ██║   ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║███████╗   ║
║ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝   ║
║                                                                                                  ║
║                     A high-level summary of the project's technical patterns.                    ║
║                                                                                                  ║
╠══════════════════════════════════════════════════════════════════════════════════════════════════╣

# 1. CORE PATTERNS

## Service Locator & Dependency Injection
*   **Pattern:** Global access is managed via a `ServiceLocator` autoload.
*   **Injection:** Entities/Components DO NOT access Autoloads directly.
    *   **Entities:** Receive the locator via `build_entity()` or Spawners.
    *   **Components:** Receive dependencies via `setup(owner, dependencies)`.
*   **Benefit:** Allows easy swapping of systems (e.g., `FakeEventBus`) during Unit Testing.

## Entity-Component (ECS-Lite)
*   **BaseEntity:** The physical shell (`CharacterBody2D`). Handles strictly physics execution (`move_and_slide`).
*   **Archetype:** A Resource defining which component scenes to instantiate.
*   **Components:** Logic containers (Health, Input, Combat). They manipulate data/state, but the Entity applies the result.

## Strategy & Command
*   **Logic as Data:** Complex behaviors are Resources, not hardcoded scripts.
    *   `AttackLogic`: Defines *how* an attack executes.
    *   `MovementLogic`: Defines *how* an enemy moves.
*   **Benefit:** "Programming in the Inspector." New enemies can be created by mixing and matching existing logic resources.

---

# 2. KEY SYSTEMS

## Viewport Cabinet (Resolution Management)
*   **Problem:** Pixel art games need integer scaling, but modern UI needs high-res (1440p).
*   **Solution:**
    *   **Root Window:** 2560x1440 (QHD). Handles UI and Post-Process Shaders.
    *   **SubViewport:** 1000x1000 (Logical Arena). Handles Gameplay.
    *   **Coordinate Mapping:** `ViewportCabinet.world_to_screen_pos()` maps game coordinates to screen UVs for shaders (Shockwave, etc).

## Safety Hooks (Memory Management)
*   **Problem:** Godot objects can leave dangling references in global singletons (EventBus) when scenes change.
*   **Solution:** `ISceneController` interface.
    *   **Contract:** Scenes must implement `scene_exiting()`.
    *   **Flow:** `SceneManager` calls `scene_exiting()` -> Entities call `teardown()` -> Components disconnect signals -> Scene changes.

## Input Abstraction
*   **Interface:** `IInputProvider`.
*   **Implementation:** `StandardInputProvider` wraps Godot's `Input` singleton.
*   **Benefit:** Unit tests use `FakeInputProvider` to simulate key presses frame-by-frame without needing OS-level input simulation.

---

# 3. DATA & CONFIGURATION

## Resource-Driven Tuning
*   **Config Resources:** All magic numbers (speed, damage, cooldowns) live in `PlayerConfig.tres` or `EnemyConfig.tres`.
*   **State Resources:** Runtime data lives in `PlayerStateData` or `BossStateData`, passed between components. Components are stateless logic processors; Resources hold the state.

## VFX & Shader Management
*   **Object Pooling:** `HitSpark` and Projectiles are pooled to prevent GC stutter.
*   **Shader Pre-warming:** A Loading Screen renders hidden instances of heavy shaders to force compilation before gameplay starts, preventing the "first-hit stutter."

---

# 4. COMMUNICATION RULES

## Local (Signal)
*   **Scope:** Inside a single scene file (Parent <-> Child).
*   **Usage:** Component emits `health_changed`, Entity owner reacts.

## Global (EventBus)
*   **Scope:** System to System (Entity <-> HUD, Encounter <-> Music).
*   **Usage:** Player emits `player_died` -> EventBus -> HUD shows Game Over.
*   **Rule:** If the sender doesn't know the receiver exists, use EventBus.
