╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═════════════════╗
║  █████╗ ██████╗  ██████╗██╗  ██╗██╗████████╗███████╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗ ║
║ ██╔══██╗██╔══██╗██╔════╝██║  ██║██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗██╔════╝ ║
║ ███████║██████╔╝██║     ███████║██║   ██║   █████╗  ██║        ██║   ██║   ██║██████╔╝█████╗   ║
║ ██╔══██║██╔══██╗██║     ██╔══██║██║   ██║   ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗██╔══╝   ║
║ ██║  ██║██║  ██║╚██████╗██║  ██║██║   ██║   ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║███████╗ ║
║ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝ ║
║                                                                              ╔═════════════════╝
║          The project's technical structure, standards, and patterns.         ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓-▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       GUIDING DESIGN PRINCIPLES                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This project's development is guided by the SOLID principles to ensure the ║
║   codebase remains clean, maintainable, and scalable.                        ║
║                                                                              ║
║   █  Single Responsibility Principle (SRP): Every script should have one,    ║
║      and only one, reason to change. This is why we separate level building  ║
║      from entity spawning, and UI appearance from UI logic.                  ║
║                                                                              ║
║   █  Open/Closed Principle: Code should be open for extension, but closed for║
║      modification. We achieve this with patterns like the State Pattern,     ║
║      where adding a new player ability means adding a new file, not changing ║
║      existing, stable code.                                                  ║
║                                                                              ║
║   █  Dependency Inversion Principle: High-level code (like `player.gd`) should ║
║      not depend on the specific implementation of low-level code (like an    ║
║      individual state script). It should depend on an abstraction (the `BaseState`║
║      contract).                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       KEY ARCHITECTURAL PATTERNS                     ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  The State Pattern: This is the primary pattern for managing complex     ║
║      entities. The logic for each state (e.g., `Move`, `Attack`, `Dash`) is  ║
║      encapsulated in its own class file (`BaseState` extending `Object`). The║
║      entity (`Player`, `BaseBoss`) then acts as a "Context", holding a       ║
║      reference to the current state and delegating all processing to it.     ║
║                                                                              ║
║   █  Singleton-Driven Core: Global systems are managed by Autoload singletons.║
║      ░  These are primarily for stateless utility services (`CombatUtils`,   ║
║      ░  `GridUtils`), cross-system communication (`EventBus`), and asset     ║
║      ░  management (`ObjectPool`, `AssetPaths`, `Palette`).                  ║
║                                                                              ║
║   █  Data-Driven Design via Resources: All tunable gameplay values (damage,  ║
║      cooldowns, health) are defined in custom `Resource` files (`.tres`).    ║
║      This decouples game balance from game logic and allows for rapid tuning ║
║      directly in the Godot Inspector using `@export` variables.              ║
║                                                                              ║
║   █  Component-to-Owner Communication (via Signals): Components encapsulate  ║
║      logic but should not directly control their owner. To maintain this     ║
║      decoupling, components use Godot's built-in signals to announce that    ║
║      something has happened. The owner node (e.g., `player.gd`) listens for  ║
║      these signals and decides how to react.                                 ║
║                                                                              ║
║   █  Dependency Injection: The Official Pattern                              ║
║      ░  **The Rule:** Components and States must be fully decoupled from     ║
║      ░  global systems. They should **NEVER** call a global singleton like   ║
║      ░  `CombatDB`, `Palette`, or `AssetPaths` directly. All external        ║
║      ░  dependencies must be passed in by their owner.                       ║
║      ░                                                                       ║
║      ░  **The Pattern: Owner-Driven Injection.** This is the project standard.║
║      ░  It is performed within an entity's `_ready()` function, which aligns ║
║      ░  perfectly with Godot's Node Lifecycle. By the time `_ready()` is     ║
║      ░  called, the engine guarantees that the node and all of its children  ║
║      ░  are instantiated and accessible. The owner node is therefore the     ║
║      ░  ideal place to wire its own components together.                     ║
║      ░                                                                       ║
║      ░  Example (`player.gd`):                                               ║
║      ░  ```gdscript                                                          ║
║      ░  func _ready():                                                       ║
║      ░      # The Player gets its child nodes (e.g., input_component) and    ║
║      ░      # its global dependencies (e.g., CombatDB.config). It then       ║
║      ░      # "injects" them into the component via a setup dictionary.      ║
║      ░      input_component.setup(self, {                                    ║
║      ░          "data_resource": p_data,                                     ║
║      ░          "state_machine": state_machine,                              ║
║      ░          "combat_component": combat_component,                        ║
║      ░          "config": CombatDB.config                                    ║
║      ░      })                                                               ║
║      ░  ```                                                                  ║
║      ░                                                                       ║
║      ░  This pattern makes dependencies explicit, improves testability, and  ║
║      ░  makes components highly reusable in different contexts.              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         COLLABORATION WORKFLOW                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   1. Define Goal: The Human defines a small, achievable goal based on the TODO.║
║   2. AI Solution: The AI provides complete, regenerated files and explains changes.║
║   3. Implement & Test: The Human implements and thoroughly tests the changes.║
║   4. Document & Commit: The Human updates documentation, then the AI provides a commit message.║
║   5. Confirm & Proceed: The Human confirms success and defines the next goal.║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
ARCHITECTURE SUMMARY
====================

Purpose
-------
Capture the runtime architecture after the refactor. This doc focuses on:
- The component-based entity model
- State machines and lifecycle
- Autoload singletons and their responsibilities
- Damage/hit contracts and flow

High-level ASCII diagram
------------------------
Entities (Node2D)
  ├─ components (ComponentInterface)
  └─ state_machine (BaseStateMachine)
         ├─ state: BaseState
         └─ state: BaseState

Singletons (autoloads)
----------------------
- EventBus      — pub/sub decoupling for cross-systems events
- SceneManager  — load/unload top-level scenes safely (async)
- Sequencer     — sequence manager for cutscene-like flows and blocking scripts
- ObjectPool    — pooled nodes (projectiles, FX, temporary entities)
- CombatUtils   — canonical damage application & hit resolution helpers
- AssetPaths    — centralized resource path map (optional)
- Palette       — color / theme constants (optional)

Core contracts & API
--------------------
ComponentInterface (convention)
- Purpose: reusable behavior units attached to Entities.
- Expected methods:
  - `func setup(config: Dictionary) -> void`    # apply param set; called on entity init
  - `func teardown() -> void`                  # cleanup (disconnect signals, timers)
- Lifetime: components are owned by their entity; teardown must undo everything added.

BaseState / BaseStateMachine
- BaseState exposes:
  - `func enter(data = null) -> void`
  - `func exit() -> void`
  - `func physics_process(delta: float) -> void`
- BaseStateMachine:
  - holds `current_state: BaseState`
  - `change_state(new_state: BaseState, data = null)` performs exit → transition → enter
  - States should be lightweight and free of leaked timers/signals (teardown on exit).

IDamageable
- Entities that can be damaged must implement the IDamageable contract:
  - `func receive_damage(damage_info: Dictionary) -> void`
  - `func is_invulnerable() -> bool` (optional)
- CombatUtils is the recommended façade to resolve hits:
  - `CombatUtils.apply_damage(source, target, damage_info)`

Damage / Hit Flow (canonical)
1. A hit is detected (Area2D overlap, raycast, or collision callback).
2. A DamageSource object/dictionary is created (type, amount, knockback, owner, hit_flags).
3. `CombatUtils.apply_damage(...)` is called.
4. CombatUtils:
   - Normalizes damage_info
   - Checks IDamageable contract and invulnerability windows
   - Applies HP change and notifies EventBus (eg. `EventBus.emit("damage_taken", {...})`)
   - Handles FX via ObjectPool

EventBus usage (example)
- Emit:
  `EventBus.emit("player_died", {"player": player})`
- Subscribe:
  `EventBus.on("player_died", self, "_on_player_died")`

File organization notes
- `src/core/` => autoloads + shared utilities
- `src/entities/` => entity scenes, component scripts, and state scripts
- `src/arenas/` => procedural/serialized arena builders & layouts
- `docs/` => architecture and design docs (update when APIs change)

Performance / lifecycle guidance
- Use ObjectPool for high-frequency nodes (bullets, hitFX).
- Keep async scene loads in SceneManager to avoid frame stalls.
- Pre-warm shaders/materials on load if you see first-frame hitches.
- Always disconnect EventBus listeners and clear timers in `_exit_tree`.

Common places to check when adding features:
- Combat: `src/core/CombatUtils.gd`
- Eventing: `src/core/EventBus.gd`
- State machine base: `src/core/BaseStateMachine.gd`
- Component contract: `src/entities/ComponentInterface.gd`
- Pools: `src/core/ObjectPool.gd`

(When you update any of these, please mirror the change into this doc.)




Damage / Hit Flow (canonical)
1. A hit is detected (Area2D overlap, raycast, or collision callback).
2. The damage-dealing script (e.g., `player_shot.gd`) creates and populates a
   `DamageInfo` resource, setting the amount and source node.
3. The script calls `CombatUtils.find_damageable(target_node)` to get the component
   that can receive damage.
4. If a valid `damageable` component is found, the script calls `damageable.apply_damage(damage_info)`.
5. The `HealthComponent` processes the `DamageInfo`, applies health changes,
   calculates knockback, and returns a typed `DamageResult` resource.
6. The original script receives the `DamageResult` and can react to it (e.g.,
   by applying the knockback velocity to the player).