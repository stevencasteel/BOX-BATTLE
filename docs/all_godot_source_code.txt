+---------------------------------+
|       B O X  B A T T L E        |
|  Godot Project Source Context   |
+---------------------------------+
Generated on: Fri Aug  8 11:13:32 CDT 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
├── README.md
├── default_bus_layout.tres
├── docs
│   ├── ARCHITECTURE.txt
│   ├── ARENA_CONCEPTS.txt
│   ├── ASSETS.txt
│   ├── BRAINSTORM.txt
│   ├── BUGS.txt
│   ├── CHANGELOG.txt
│   ├── DESIGN.txt
│   ├── DOCS_PROTOCOL.txt
│   ├── LICENSE
│   ├── PLAYTESTING.txt
│   ├── ROADMAP.txt
│   ├── TODO.txt
│   ├── all_godot_source_code.txt
│   └── create_all_godot_source_code_txt.sh
├── icon.svg
├── progess
│   └── progress_001-1.jpg
├── project.godot
└── src
    ├── arenas
    │   ├── arena_00_encounter.gd
    │   └── arena_00_layout.gd
    ├── core
    │   ├── arena_builder.gd
    │   ├── asset_paths.gd
    │   ├── audio_manager.gd
    │   ├── builders
    │   │   ├── encounter_director.gd
    │   │   ├── level_build_data.gd
    │   │   ├── level_parser.gd
    │   │   └── terrain_builder.gd
    │   ├── constants.gd
    │   ├── cursor_manager.gd
    │   ├── game_manager.gd
    │   └── settings.gd
    ├── entities
    │   ├── boss
    │   │   ├── base_boss.gd
    │   │   ├── base_boss.tscn
    │   │   └── states
    │   │       ├── state_boss_attack.gd
    │   │       ├── state_boss_base.gd
    │   │       ├── state_boss_cooldown.gd
    │   │       ├── state_boss_idle.gd
    │   │       └── state_boss_patrol.gd
    │   └── player
    │       ├── player.gd
    │       ├── player.tscn
    │       └── states
    │           ├── state_attack.gd
    │           ├── state_base.gd
    │           ├── state_dash.gd
    │           ├── state_fall.gd
    │           ├── state_heal.gd
    │           ├── state_hurt.gd
    │           ├── state_jump.gd
    │           ├── state_move.gd
    │           └── state_wall_slide.gd
    ├── projectiles
    │   ├── boss_shot.gd
    │   ├── boss_shot.tscn
    │   ├── player_shot.gd
    │   └── player_shot.tscn
    ├── scenes
    │   ├── game
    │   │   ├── game.gd
    │   │   └── game.tscn
    │   ├── loading
    │   │   ├── loading_screen.gd
    │   │   └── loading_screen.tscn
    │   └── main
    │       ├── main.gd
    │       └── main.tscn
    └── ui
        ├── components
        │   └── custom_slider
        │       └── custom_slider.gd
        ├── game_hud
        │   ├── game_hud.gd
        │   └── game_hud.tscn
        ├── global_hud
        │   ├── global_hud.gd
        │   └── global_hud.tscn
        ├── menu_manager
        │   └── menu_manager.gd
        └── screens
            ├── controls_menu
            │   ├── controls_menu.gd
            │   └── controls_menu.tscn
            ├── credits_menu
            │   ├── credits_menu.gd
            │   └── credits_menu.tscn
            ├── game_over_screen
            │   ├── game_over_screen.gd
            │   └── game_over_screen.tscn
            ├── options_menu
            │   ├── options_menu.gd
            │   └── options_menu.tscn
            ├── sound_menu
            │   ├── sound_menu.gd
            │   └── sound_menu.tscn
            ├── title_screen
            │   ├── title_screen.gd
            │   └── title_screen.tscn
            └── victory_screen
                ├── victory_screen.gd
                └── victory_screen.tscn

31 directories, 80 files


=====================================
FILE: ./docs/TODO.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ████████╗ ██████╗ ██████╗  ██████╗                                         ║
║   ╚══██╔══╝██╔═══██╗██╔══██╗██╔═══██╗                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ╚██████╔╝██████╔╝╚██████╔╝                                        ║
║      ╚═╝    ╚═════╝ ╚═════╝  ╚═════╝                                         ║
║                                                                              ║
║                  Immediate Work Items & Actionable Tasks                     ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 1: THE CORE SYSTEMS REFACTOR                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This phase is our highest priority. We will refactor the existing code to  ║
║   align with professional design principles. This is the hard, foundational ║
║   work that enables all future features to be built cleanly and efficiently. ║
║                                                                              ║
║   █  1. Implement the Event Bus                                              ║
║      ░  WHY: This is the new central nervous system for the game. It will    ║
║      ░  decouple all our systems, from UI to gameplay to audio, making the   ║
║      ░  entire codebase more modular and easier to manage (Dependency Inversion).║
║      ░  HOW:                                                                 ║
║      ░    1. Create a new autoload singleton: `EventBus.gd`.                 ║
║      ░    2. Implement three core functions: `on(event, callback)`,          ║
║      ░       `off(event, callback)`, and `emit(event, payload)`.             ║
║      ░    3. Create `EventCatalog.gd` to store all event names as constants. ║
║      ░    4. Refactor existing direct signal connections (e.g., in `game_hud.gd`)║
║      ░       to use the Event Bus. The HUD will listen for global events like ║
║      ░       `EventCatalog.PLAYER_HEALTH_CHANGED` instead of connecting directly.║
║                                                                              ║
║   █  2. Refactor Player to use the State Pattern                             ║
║      ░  WHY: `player.gd` is a large, monolithic script. This refactor will   ║
║      ░  decouple the logic for each state into its own class, making the     ║
║      ░  system cleaner and easier to extend (Open/Closed Principle).         ║
║      ░  HOW: Follow the detailed plan to create a `states` subdirectory for  ║
║      ░  the player, create a `PlayerState` base class, and migrate the logic ║
║      ░  for each state into its own file. `player.gd` will become a "Context"║
║      ░  that simply manages the current state object.                        ║
║                                                                              ║
║   █  3. Implement the Centralized Sequencer                                  ║
║      ░  WHY: To eliminate scattered `Timer` nodes and `await` calls for      ║
║      ░  scripted events. This provides a clean, readable way to create       ║
║      ░  cinematic sequences like boss intros or multi-stage attacks.         ║
║      ░  HOW: Create a new autoload singleton: `Sequencer.gd`. Implement a    ║
║      ░  `run_sequence(steps: Array)` function that can process a list of     ║
║      ░  commands like `wait`, `emit` (on Event Bus), and `call` (a function).║
║                                                                              ║
║   █  4. Refactor Base Boss to use the State Pattern                          ║
║      ░  WHY: To mirror the player's clean architecture, preparing the boss   ║
║      ░  for the advanced "kitchen sink" mechanics planned for a later phase. ║
║      ░  HOW: Apply the exact same State Pattern as used for the Player,      ║
║      ░  creating a `states` subdirectory and migrating state logic into      ║
║      ░  separate, focused class files.                                       ║
║                                                                              ║
║   █  5. Refactor ArenaBuilder using Single Responsibility Principle (SRP)    ║
║      ░  WHY: `ArenaBuilder.gd` currently has too many jobs. Separating these ║
║      ░  roles will make the level generation pipeline more robust and easier ║
║      ░  to maintain.                                                         ║
║      ░  HOW: Split the current logic into three new classes:                 ║
║      ░    - `LevelParser.gd`: Reads data from layout/encounter files.        ║
║      ░    - `TerrainBuilder.gd`: Creates the static level geometry (tiles).  ║
║      ░    - `EncounterDirector.gd`: Spawns all dynamic entities (player, boss).║
║      ░  `ArenaBuilder.gd` will become a simple coordinator of these new classes.║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            PHASE 2: DATA-DRIVEN & VISUAL FOUNDATION                  ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This phase separates hard-coded values from our logic and builds the key   ║
║   visual components needed to achieve our "Framer + Geometry Wars" aesthetic.║
║                                                                              ║
║   ▓  1. Implement Data-Driven Configs (JSON)                                 ║
║      ░  WHY: To centralize all tuning and balancing numbers (damage, health, ║
║      ░  cooldowns) into external, human-readable files. This allows for rapid║
║      ░  iteration without changing any code.                                 ║
║      ░  HOW: Create a `Config.gd` singleton that loads `.json` files on start.║
║      ░  Move all combat-related values from `Constants.gd` into a new        ║
║      ░  `combat_config.json`. Refactor code to pull values from this config. ║
║                                                                              ║
║   ▓  2. Implement the Global Palette System                                  ║
║      ░  WHY: To enforce a consistent, project-wide color scheme. This is a   ║
║      ░  critical prerequisite for the UI overhaul.                           ║
║      ░  HOW: Create a `Palette.gd` singleton. Define the 32-step grayscale   ║
║      ░  array and create semantic constant names (e.g., `COLOR_PLAYER`).     ║
║      ░  Replace all hard-coded colors with calls to this new Palette.        ║
║                                                                              ║
║   ▓  3. UI Overhaul Part 1: The `StyledMenuItem`                             ║
║      ░  WHY: To create the cornerstone visual component for our new UI. We   ║
║      ░  will perfect this one piece before replacing the entire menu system. ║
║      ░  HOW: Create a new scene, `StyledMenuItem.tscn`, that extends `Control`.║
║      ░  It will use the `_draw()` function and shaders to render itself      ║
║      ░  procedurally with frosted glass, backlighting, and reactive effects, ║
║      ░  all driven by the `Palette` and `EventBus`.                          ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 3: GAMEPLAY & FEEL ENHANCEMENT                    ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   With a solid architecture, we can now focus on making the game feel amazing.║
║                                                                              ║
║   ▒  1. Refine Player Combat Mechanics ("Game Juice")                        ║
║      ░  □ Enhanced Melee Hitbox: Implement a two-part hitbox where the inner ║
║      ░    box deals 1.5x damage and the outer deals 1.0x damage.             ║
║      ░  □ Input Buffering: Add buffering for attack and dash inputs.         ║
║      ░  □ Pogo-Fall Prevention: Add a brief grace period after a pogo to     ║
║      ░    prevent accidental fast-falling.                                   ║
║                                                                              ║
║   ▒  2. Implement "Kitchen Sink" Base Boss Features                          ║
║      ░  □ Health Phases: Boss transitions to new states at health thresholds.║
║      ░  □ Armor/Weak Points: Implement an `is_armored` state.                ║
║      ░  □ Clear Attack Telegraphing: Create a dedicated `Telegraph` state.   ║
║                                                                              ║
║   ▒  3. Implement a Minion Enemy Type                                        ║
║      ░  Create a simple Turret enemy to test our data-driven spawning and    ║
║      ░  component-based architecture (e.g., by reusing the HealthComponent). ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██           PHASE 4: FUTURE EXPANSION & DEFERRED TASKS                 ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of lower-priority goals to be addressed after the core loop is solid.║
║                                                                              ║
║   ░  Full UI System Replacement (using `StyledMenuItem`)                     ║
║   ░  Diegetic UI Implementation                                              ║
║   ░  Dynamic Music Layering System                                           ║
║   ░  Adaptive Boss AI Tactics Layer                                          ║
║   ░  Player Loadout System                                                   ║
║   ░  Special Game Modes (Boss Rush, Time Attack)                             ║
║   ░  Screen Shake (Explicitly deferred to avoid visual noise during debugging)║
║   ░  Dynamic Camera (Explicitly deferred per design decision)                ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/DESIGN.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ███████╗███████╗██╗ ██████╗ ███╗   ██╗                             ║
║   ██╔══██╗██╔════╝██╔════╝██║██╔════╝ ████╗  ██║                             ║
║   ██║  ██║█████╗  ███████╗██║██║  ███╗██╔██╗ ██║                             ║
║   ██║  ██║██╔══╝  ╚════██║██║██║   ██║██║╚██╗██║                             ║
║   ██████╔╝███████╗███████║██║╚██████╔╝██║ ╚████║                             ║
║   ╚═════╝ ╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝                             ║
║                                                                              ║
║      The official documentation for game mechanics and design philosophy.    ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         DESIGN PHILOSOPHY                            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Sublime Movement by Default: The player is given a complete, perfected, ║
║      and expressive moveset from the beginning. The joy of the game comes    ║
║      from mastering these tools, not from unlocking them.                    ║
║                                                                              ║
║   █  Aesthetic Minimalism, Technical Maximalism: The visual style will be    ║
║      clean, minimalist, and beautiful, inspired by high-end web design       ║
║      (e.g., Framer websites). We will use advanced shaders, procedural       ║
║      generation, and particle effects to create a polished, "expensive"      ║
║      look with elements like frosted glass, backlighting, and subtle gradients.║
║                                                                              ║
║   █  Robust, Maintainable Code: Development will adhere to the SOLID principles║
║      (Single Responsibility, Open/Closed, etc.) to ensure the codebase is    ║
║      scalable, easy to debug, and a pleasure to work on. We refactor first.  ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                           CORE MECHANICS                             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ▓  Player Movement                                                         ║
║      ░ ■ Coyote Time & Jump Buffering for forgiving platforming.             ║
║      ░ ■ 4-directional Dash with a cooldown.                                 ║
║      ░ ■ Wall-Sliding and Wall-Jumping for verticality.                      ║
║      ░ ■ Fast-Fall: Holding 'Down' in the air increases gravity.             ║
║                                                                              ║
║   ▓  Combat System                                                           ║
║      ░ ■ Primary Melee: A fast, close-range attack.                          ║
║      ░ ■ Charged Shot: A long-range projectile attack.                       ║
║      ░ ■ Pogo Attack: A downward aerial attack that bounces on enemies.      ║
║      ░ ■ Dash Invincibility: The player cannot take damage during a dash.    ║
║                                                                              ║
║   ▓  Planned Combat Refinements                                              ║
║      ░ ■ Enhanced Melee Hitbox: The melee swing will have two hitboxes. The  ║
║      ░   inner box (close to the player) will deal 1.5x damage, rewarding    ║
║      ░   risky positioning. The outer box will deal 1.0x damage.             ║
║      ░ ■ Input Buffering: Attack and dash inputs will be buffered just like  ║
║      ░   the jump input, making the controls feel more responsive.           ║
║      ░ ■ Pogo-Fall Prevention: A brief window after a pogo will prevent      ║
║      ░   accidental fast-falling.                                            ║
║                                                                              ║
║   ▓  Health and Healing: The Determination System                            ║
║      ░  Healing is a resource earned by dealing damage. Landing hits fills a ║
║      ░  `determination_counter` to grant a `healing_charge`.                 ║
║                                                                              ║
║   ▓  Boss Design Template (The "Kitchen Sink")                               ║
║      ░  Our `base_boss` will be a template with a library of toggleable mechanics:║
║      ░  ■ Health Phases: Boss behavior and attacks change at health thresholds.║
║      ░  ■ Armor / Weak Points: Boss can enter armored states where it takes  ║
║      ░    no damage, punctuated by moments of vulnerability.                 ║
║      ░  ■ Clear Telegraphing: All attacks will be preceded by clear visual/audio║
║      ░    cues, ensuring tough but fair encounters.                          ║
║      ░  ■ Modular Movement: Bosses can be configured to fly, dash, jump, etc.║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                 ARENA & BOSS BATTLE CONCEPTS                         ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Each boss battle is a unique mechanical challenge inspired by a classic    ║
║   arcade game loop. The player's sublime moveset is the constant tool used to║
║   solve these varied combat puzzles.                                         ║
║                                                                              ║
║   ▒  Beat Box (Rhythm Game): Platforms appear/disappear on a musical beat.   ║
║   ▒  Sandbox (Momentum Vampirism): Boss steals player momentum on hit.       ║
║   ▒  Circuit Box (Tempest-like): Central core protected by rotating shields. ║
║   ▒  Garden Box (Centipede-like): Segmented boss weaves through obstacles.   ║
║   ▒  Traffic Box (Frogger-like): Cross "lanes" of projectiles to reach boss. ║
║   ▒  Gravity Box (Gravity Man-inspired): Gravity reverses periodically.      ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/ROADMAP.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗  ██████╗  █████╗ ██████╗ ███╗   ███╗ █████╗ ██████╗                ║
║   ██╔══██╗██╔═══██╗██╔══██╗██╔══██╗████╗ ████║██╔══██╗██╔══██╗               ║
║   ██████╔╝██║   ██║███████║██║  ██║██╔████╔██║███████║██████╔╝               ║
║   ██╔══██╗██║   ██║██╔══██║██║  ██║██║╚██╔╝██║██╔══██║██╔═══╝                ║
║   ██║  ██║╚██████╔╝██║  ██║██████╔╝██║ ╚═╝ ██║██║  ██║██║                    ║
║   ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝                    ║
║                                                                              ║
║          The long-term vision and planned features for the project.          ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              VERSION 1.0 GOALS - THE POLISHED SLICE                  ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   The primary objective is to create a single, complete, and highly          ║
║   polished gameplay loop that serves as a benchmark for the entire game.     ║
║                                                                              ║
║   █  A Dynamic Boss: Arena 00 boss is fully functional with multiple,        ║
║      telegraphed attack patterns and basic AI (patrolling, facing player).   ║
║                                                                              ║
║   █  Functional HUD: Clear displays for player health, boss health, and      ║
║      healing charges.                                                        ║
║                                                                              ║
║   █  Satisfying Feedback: All core actions are accompanied by appropriate    ║
║      SFX, VFX (hit-flash, particles), and screen shake. The game feels good. ║
║                                                                              ║
║   █  Complete Flow: Player can go from Title -> Game -> Win/Loss -> Title    ║
║      with smooth transitions.                                                ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         FUTURE VERSIONS                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ▓  v1.1 - "The Content Expansion"                                          ║
║      Focus shifts to expanding content and adding a new dimension to combat. ║
║      ░  ■ Introduce a Second Arena & Boss (e.g., a flying or agile enemy).   ║
║      ░  ■ Introduce a "Minion" Enemy Type for more varied encounters.        ║
║      ░  ■ Refine Player Combat Indicators (Fizzle & Charge Meter).           ║
║                                                                              ║
║   ▓  v2.0 - "The Full Game Loop"                                             ║
║      Transforms the project from encounters into a cohesive game.            ║
║      ░  ■ Implement a Stage Select Screen.                                   ║
║      ░  ■ Basic Progression (Defeating a boss unlocks the next stage).       ║
║      ░  ■ Introduce More Enemy Variety (e.g., a stationary turret).          ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         DREAM FEATURES                               ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A "blue sky" list of ideas to explore once the core game is robust.        ║
║                                                                              ║
║   ■  Advanced Boss Mechanics (Multi-stage health, cinematic `Path2D` moves). ║
║   ■  Expanded Player Abilities (Unlockable weapons/skills post-boss fight).  ║
║   ■  Deeper Lore & Narrative (Expand on "Determination" theme).              ║
║   ■  Official GitHub Wiki for community documentation.                       ║
║   ■  Robust Debug Tools (More hotkeys and overlays).                         ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/PLAYTESTING.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ██╗      █████╗ ██╗   ████   ████╗███████╗████████╗██╗███╗   ██╗ ██████╗ ║
║   ██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔════╝╚══██╔══╝██║████╗  ██║██╔════╝ ║
║   ██████╔╝██║     ███████║ ╚████╔╝    ██║   █████╗     ██║   ██║██╔██╗ ██║███████╗ ║
║   ██╔═══╝ ██║     ██╔══██║  ╚██╔╝     ██║   ██╔══╝     ██║   ██║██║╚██╗██║██╔════╝ ║
║   ██║     ███████╗██║  ██║   ██║      ██║   ███████╗   ██║   ██║██║ ╚████║███████╗ ║
║   ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝   ╚═╝   ╚═╝╚═╝  ╚═══╝╚══════╝ ║
║                                                                              ║
║           A log of all playtesting sessions and resulting feedback.          ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       PLAYTEST SESSION LOG                           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   (New playtest session reports should be added here, most recent at top.)   ║
║                                                                              ║
║  --------------------------------------------------------------------------  ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                      TEST SESSION TEMPLATE                           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Date: YYYY-MM-DD                                                        ║
║   █  Tester: [Name or description, e.g., "Developer," "Friend A"]            ║
║   █  Build Version: [e.g., 0.1.0]                                            ║
║   █  Session Goal: [e.g., "Test boss fight fairness", "Check menu UI"]       ║
║                                                                              ║
║   ▓  General Observations & Player Behavior                                  ║
║      ░  What did the player do? Did they understand the goals? Where did     ║
║      ░  they go first? (e.g., "Tester immediately tried to wall-jump.")      ║
║                                                                              ║
║   ▓  Issues & Bugs Found                                                     ║
║      ░  List any bugs, crashes, or moments of confusion. Was anything        ║
║      ░  frustrating or unfair?                                               ║
║                                                                              ║
║   ▓  Positive Feedback                                                       ║
║      ░  What did the player say they enjoyed? What felt good to them?        ║
║      ░  (e.g., "Player audibly said 'nice' after a successful pogo.")        ║
║                                                                              ║
║   ▓  Suggestions & Ideas                                                     ║
║      ░  What did the player suggest? Did they have any ideas for new         ║
║      ░  features or changes?                                                 ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/BUGS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ██╗   ██╗ ██████╗ ███████╗                                         ║
║   ██╔══██╗██║   ██║██╔════╝ ██╔════╝                                         ║
║   ██████╔╝██║   ██║██║  ███╗███████╗                                         ║
║   ██╔══██╗██║   ██║██║   ██║╚════██║                                         ║
║   ██████╔╝╚██████╔╝╚██████╔╝███████║                                         ║
║   ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝                                         ║
║                                                                              ║
║             A tracker for all known issues, their status, and solutions.     ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                             OPEN ISSUES                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   (All known bugs have been resolved.)                                       ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                             FIXED ISSUES                             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   □  [BUG-F007] Intermittent major hitch on first run or debug mode toggle.  ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Implemented a shader pre-warming system in `LoadingScreen`.║
║      ░  An off-screen `SubViewport` is used to instantiate key entities      ║
║      ░  (Player, Boss, Projectiles) for a single frame, which forces the     ║
║      ░  engine to compile their shaders before they are needed in the main   ║
║      ░  game scene. This eliminates the first-appearance stutter.            ║
║                                                                              ║
║   □  [BUG-F006] Significant stutter/hitch occurred on arena load.            ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Replaced the synchronous, blocking level generation with a ║
║      ░  new asynchronous system in `ArenaBuilder.gd`. The `build_level_async`║
║      ░  function now creates the level in batches, using `await` to yield    ║
║      ░  control back to the engine between batches. This prevents the main   ║
║      ░  thread from freezing, resulting in a smooth loading sequence managed ║
║      ░  by a new `LoadingScreen`.                                            ║
║                                                                              ║
║   □  [BUG-F005] Player death caused a physics crash.                         ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Scene changes in `game.gd`'s `_on_player_died` and         ║
║      ░  `_on_boss_died` functions were changed to `get_tree().call_deferred()`.║
║      ░  This prevents the engine from trying to delete a physics body while  ║
║      ░  it is still processing a physics callback.                           ║
║                                                                              ║
║   □  [BUG-F004] Hazard tiles did not deal contact damage.                    ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Corrected the implementation in `ArenaBuilder.gd`. The     ║
║      ░  `_create_hazard_tile` function now creates a single `StaticBody2D`   ║
║      ░  that exists on both the "world" and "hazard" collision layers and is ║
║      ░  part of both corresponding groups, ensuring it's both solid and damaging.║
║                                                                              ║
║   □  [BUG-F003] Drop-through platforms ("-") were not functioning.           ║
║      ░  FIXED: 2025-08-06                                                    ║
║      ░  SOLUTION: Re-implemented the Down+Jump logic in the player's         ║
║      ░  `state_move` function. Corrected the platform's collision shape      ║
║      ░  position and group assignment in `game.gd`.                          ║
║                                                                              ║
║   □  [BUG-F002] Player pogo attack was not working correctly on all surfaces.║
║      ░  FIXED: 2025-08-05                                                    ║
║      ░  SOLUTION: Re-implemented the `_check_for_immediate_pogo()` physics   ║
║      ░  query to allow instant bounces on surfaces directly below the        ║
║      ░  player. Updated the `_trigger_pogo()` function to correctly handle   ║
║      ░  bouncing on enemy projectiles in addition to standard enemies.       ║
║                                                                              ║
║   □  [BUG-F001] Player was not taking contact damage from boss/hazards.      ║
║      ░  FIXED: 2025-08-05                                                    ║
║      ░  SOLUTION: During the state machine refactor, the player's            ║
║      ░  `CharacterBody2D` `collision_mask` was changed to ignore the         ║
║      ░  "enemy" and "hazard" layers. The mask was updated in `player.tscn`   ║
║      ░  to correctly detect these layers again, allowing the existing        ║
║      ░  `_check_for_contact_damage()` function to work as intended.          ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/DOCS_PROTOCOL.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗  ██████╗  ██████╗ ███████╗                                         ║
║   ██╔══██╗██╔═══██╗██╔════╝ ██╔════╝                                         ║
║   ██║  ██║██║   ██║██║      ███████╗                                         ║
║   ██║  ██║██║   ██║██║   ██╗╚════██║                                         ║
║   ██████╔╝╚██████╔╝╚██████╔╝███████║                                         ║
║   ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝                                         ║
║                                                                              ║
║    ██████╗ ██████╗  ██████╗ ████████╗ ██████╗  ██████╗  ██████╗ ██╗          ║
║    ██╔══██╗██╔══██╗██╔═══██╗╚══██╔══╝██╔═══██╗██╔════╝ ██╔═══██╗██║          ║
║    ██████╔╝██████╔╝██║   ██║   ██║   ██║   ██║██║      ██║   ██║██║          ║
║    ██╔═══╝ ██╔══██╗██║   ██║   ██║   ██║   ██║██║   ██╗██║   ██║██║          ║
║    ██║     ██║  ██║╚██████╔╝   ██║   ╚██████╔╝╚██████╔╝╚██████╔╝███████╗     ║
║    ╚═╝     ╚═╝  ╚═╝ ╚═════╝    ╚═╝    ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝     ║
║                                                                              ║
║           Project Documentation & Communication Formatting Standard          ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       DOCUMENTATION STANDARDS                        ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This document defines the visual and structural standards for all `.txt`   ║
║   project files. Its purpose is to maintain a cohesive, readable, and        ║
║   thematically appropriate aesthetic that reflects the game's design.        ║
║                                                                              ║
║   █  FILE STRUCTURE                                                          ║
║      All `.md` files essential for GitHub integration (README.md,            ║
║      LICENSE.md) will remain as Markdown. All other project documents        ║
║      (TODO, ROADMAP, DESIGN, etc.) will be `.txt` files following this guide.║
║                                                                              ║
║   █  DOCUMENT FRAME                                                          ║
║      Each document will be enclosed in a double-line box frame.              ║
║      (Characters: ╔ ╗ ╚ ╝ ║ ═ ╠ ╣)                                           ║
║                                                                              ║
║   █  TITLE BLOCK                                                             ║
║      Each document begins with its custom ASCII art title block, followed    ║
║      by a one-line subtitle describing its purpose.                          ║
║                                                                              ║
║   █  SECTION HEADERS                                                         ║
║      Major sections are demarcated with a dithered block header. The text    ║
║      should be centered and padded within the solid blocks.                  ║
║                                                                              ║
║        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ║
║        ██                        SECTION TITLE                         ██    ║
║        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ║
║                                                                              ║
║   █  BODY TEXT & PARAGRAPHS                                                  ║
║      Standard body text should be indented by 2 spaces from the main frame.  ║
║      Paragraphs should have a single blank line between them for spacing.    ║
║      Text should be manually wrapped to fit within the document frame.       ║
║                                                                              ║
║   █  BULLET POINTS & HIERARCHY (PRIORITY GRADIENT)                           ║
║      Lists will use dithered blocks to indicate importance or sequence.      ║
║      All bullet points should be indented by 3 spaces. Sub-points should     ║
║      be indented an additional 2 spaces using the `░` character.             ║
║                                                                              ║
║        █  Primary Point / Critical Item / Most Important                     ║
║        ▓  Secondary Point / High Priority                                    ║
║        ▒  Tertiary Point / Medium Priority                                   ║
║        ░  Note, Sub-point, or Low Priority Item                              ║
║                                                                              ║
║        ■  Checklist item (complete).                                         ║
║        □  Checklist item (incomplete).                                       ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                 ARCHIVE OF ADVANCED & ESOTERIC STYLES                ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   The following are alternative formatting ideas. They are archived here for ║
║   future inspiration but are not part of the current standard to maintain    ║
║   simplicity and consistency.                                                ║
║                                                                              ║
║   ▒  Progress Bars & Status Indicators                                       ║
║      Use the priority gradient to create visual progress meters.             ║
║                                                                              ║
║      ░  LOADING       █████████████▓▓▓▓▒▒▒░░░ 73%                            ║
║      ░  BOSS HEALTH   ████████▓▓▓▓▒▒▒▒░░░░░░░░ 58%                           ║
║                                                                              ║
║   ▒  Circuit Board Style                                                     ║
║      A highly technical aesthetic for documents like ARCHITECTURE.txt.       ║
║                                                                              ║
║      ┌─┬─┬─┬─┬─┬─┬─┬─┬── SECTION ──┬─┬─┬─┬─┬─┬─┬─┬─┐                         ║
║      │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │                         ║
║      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘                         ║
║                                                                              ║
║   ▒  PETSCII-style Graphics                                                  ║
║      A retro computer aesthetic using block and pattern characters.          ║
║                                                                              ║
║      ▗▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▖     ║
║      ▐ ▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚  SECTION TITLE HERE  ▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚ ▌     ║
║      ▝▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▘     ║
║                                                                              ║
║   ▒  Geometric Separators                                                    ║
║      Use repeating patterns to divide sections instead of headers.           ║
║                                                                              ║
║      ◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇                    ║
║      ▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼            ║
║                                                                              ║
║   ▒  Square Density Patterns                                                 ║
║      An alternative to the priority gradient for status tracking.            ║
║                                                                              ║
║      ■■■■■■■■■■ COMPLETE                                                     ║
║      ■■■■■■■□□□ IN PROGRESS                                                  ║
║      ■□□□□□□□□□ PLANNED                                                      ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/ARCHITECTURE.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    █████╗ ██████╗  ██████╗██╗  ██╗██╗████████╗███████╗ ██████╗████████╗██╗   ██╗ ║
║   ██╔══██╗██╔══██╗██╔════╝██║  ██║██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║   ██║ ║
║   ███████║██████╔╝██║     ███████║██║   ██║   █████╗  ██║        ██║   ██║   ██║ ║
║   ██╔══██║██╔══██╗██║     ██╔══██║██║   ██║   ██╔══╝  ██║        ██║   ██║   ██║ ║
║   ██║  ██║██║  ██║╚██████╗██║  ██║██║   ██║   ███████╗╚██████╗   ██║   ╚██████╔╝ ║
║   ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝  ║
║                                                                              ║
║          The project's technical structure, standards, and patterns.         ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       GUIDING DESIGN PRINCIPLES                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This project's development is guided by the SOLID principles to ensure the ║
║   codebase remains clean, maintainable, and scalable.                        ║
║                                                                              ║
║   █  Single Responsibility Principle (SRP): Every script should have one,    ║
║      and only one, reason to change. This is why we separate level building  ║
║      from entity spawning, and UI appearance from UI logic.                  ║
║                                                                              ║
║   █  Open/Closed Principle: Code should be open for extension, but closed for║
║      modification. We achieve this with patterns like the State Pattern,     ║
║      where adding a new player ability means adding a new file, not changing ║
║      existing, stable code.                                                  ║
║                                                                              ║
║   █  Liskov Substitution Principle: Subclasses must be substitutable for their║
║      base classes. A `FireBoss` must be able to do everything a `BaseBoss` can.║
║                                                                              ║
║   █  Interface Segregation Principle: We avoid creating "fat" classes that   ║
║      are forced to have functions they don't need.                           ║
║                                                                              ║
║   █  Dependency Inversion Principle: High-level code (like `game.gd`) should ║
║      not depend on the specific implementation of low-level code (like the   ║
║      `ArenaBuilder`). It should depend on an abstraction (the `build_level()`║
║      function contract). Signals are a key tool for this.                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       KEY ARCHITECTURAL PATTERNS                     ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  The State Pattern: This is the primary pattern for managing complex     ║
║      entities. The logic for each state (e.g., `Move`, `Attack`, `Dash`) is  ║
║      encapsulated in its own class file. The entity (`Player`, `BaseBoss`)   ║
║      then acts as a "Context", holding a reference to the current state and  ║
║      delegating all processing to it. This keeps the entity's main script    ║
║      clean and makes adding or changing abilities highly modular.            ║
║                                                                              ║
║   █  Singleton-Driven Core: Global systems are managed by Autoload singletons.║
║      ░  `Palette.gd`: Manages all game colors for a cohesive aesthetic.      ║
║      ░  `AssetPaths.gd`: A central, pre-loading registry for all assets.     ║
║      ░  Other singletons (`AudioManager`, `Constants`, etc.) serve dedicated roles.║
║                                                                              ║
║   █  Asynchronous Loading with Pre-warming: To ensure smooth transitions, a  ║
║      `LoadingScreen` orchestrates all setup. It pre-warms shaders by         ║
║      flashing entities in an off-screen viewport and calls the               ║
║      `ArenaBuilder` to construct the level in non-blocking batches.          ║
║                                                                              ║
║   █  Component-Based and Procedural UI: The UI is built from self-contained, ║
║      reusable scenes (`StyledMenuItem`). These components will draw          ║
║      themselves procedurally using shaders, allowing for a highly polished   ║
║      and animatable interface without relying on static images.              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         COLLABORATION WORKFLOW                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   1. Define Goal: The Human defines a small, achievable goal based on the TODO.║
║   2. AI Solution: The AI provides complete, regenerated files and explains changes.║
║   3. Implement & Test: The Human implements and thoroughly tests the changes.║
║   4. Document & Commit: The Human updates documentation, then the AI provides a commit message.║
║   5. Confirm & Proceed: The Human confirms success and defines the next goal.║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/ASSETS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    █████╗ ███████╗███████╗███████╗████████╗███████╗                          ║
║   ██╔══██╗██╔════╝██╔════╝██╔════╝╚══██╔══╝██╔════╝                          ║
║   ███████║███████╗███████╗███████╗   ██║   ███████╗                          ║
║   ██╔══██║╚════██║╚════██║██╔════╝   ██║   ╚════██║                          ║
║   ██║  ██║███████║███████║███████╗   ██║   ███████║                          ║
║   ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝   ╚═╝   ╚══════╝                          ║
║                                                                              ║
║        A registry for asset sources, licenses, and style guidelines.         ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                            STYLE GUIDE                               ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Visual Style                                                            ║
║      ░  Overall: Clean, minimalist, and geometric.                           ║
║      ░  Color Palette: High-contrast grayscale for placeholders.             ║
║      ░  Shape Language: A strict adherence to square-based geometry.         ║
║      ░  Rectangles are only permitted for static environmental elements.     ║
║                                                                              ║
║   █  Audio Style                                                             ║
║      ░  Music: Chiptune-inspired, melodic, and loopable tracks.              ║
║      ░  Sound Effects: Crisp, digital, and immediately recognizable SFX.     ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                           ASSET SOURCES                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Graphics                                                                ║
║      ░  Source: All current visual assets (sprites, icons) are original      ║
║      ░  creations for this project.                                          ║
║      ░  License: N/A (Internal)                                              ║
║                                                                              ║
║   █  Audio                                                                   ║
║      ░  Source: All audio assets were generated by the project creator using ║
║      ░  paid subscriptions to ElevenLabs (SFX) and Udio (Music).             ║
║      ░  License: CC0 1.0 Universal (Public Domain).                          ║
║                                                                              ║
║   █  Fonts                                                                   ║
║      ░  Source: "M PLUS Rounded 1c" by the M+ FONTS PROJECT.                 ║
║      ░  License: SIL Open Font License (OFL).                                ║
║      ░  Source Link: `https://fonts.google.com/specimen/M+PLUS+Rounded+1c`   ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                      ATTRIBUTION REQUIREMENTS                        ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Per the CC0 license for audio and original creation for graphics, no       ║
║   attribution is required for any asset. It is good practice to keep the     ║
║   OFL.txt for the font with the project files.                               ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/CHANGELOG.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    ██████╗██╗  ██╗ █████╗ ███╗   ██╗ ██████╗ ██████╗  ██████╗                ║
║   ██╔════╝██║  ██║██╔══██╗████╗  ██║██╔════╝ ██╔══██╗██╔════╝                ║
║   ██║     ███████║███████║██╔██╗ ██║██║  ███╗██████╔╝███████╗                ║
║   ██║     ██╔══██║██╔══██║██║╚██╗██║██║   ██║██╔══██╗██╔════╝                ║
║   ╚██████╗██║  ██║██║  ██║██║ ╚████║╚██████╔╝██║  ██║███████╗                ║
║    ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝                ║
║                                                                              ║
║                  A log of all notable changes to the project.                ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                            [UNRELEASED]                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Changed                                                                 ║
║      ░ ■ Refactored the ArenaBuilder to strictly adhere to the Single        ║
║      ░   Responsibility Principle. Its duties have been decoupled into new,  ║
║      ░   focused classes: `LevelParser`, `TerrainBuilder`, and              ║
║      ░   `EncounterDirector`. ArenaBuilder now acts as a high-level coordinator.║
║      ░ ■ Refactored the BaseBoss node to use the State Pattern, mirroring the║
║      ░   Player's architecture for improved scalability and maintainability. ║
║      ░ ■ Refactored the Player node to use the State Pattern. All state logic║
║      ░   (Move, Fall, Dash, etc.) has been decoupled into individual classes ║
║      ░   in `src/entities/player/states/` for improved scalability and      ║
║      ░   maintainability, adhering to SOLID principles.                      ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██        [0.2.0] - THE ARCHITECTURAL REFACTOR - 2025-08-07             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This version represents a foundational overhaul of the project's technical ║
║   architecture. The focus was on implementing professional design patterns   ║
║   (SOLID, State Pattern) and eliminating performance issues to prepare for   ║
║   future content and feature development.                                    ║
║                                                                              ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Overhauled level loading to use an asynchronous, batch-based system ║
║      ░   in `ArenaBuilder`, eliminating stuttering when entering the arena.  ║
║      ░ ■ Implemented a shader pre-warming system in a new `LoadingScreen` to ║
║      ░   prevent any "first-appearance" hitches for entities.                ║
║      ░ ■ Formalized the project's guiding principles (SOLID, DRY, KISS) in  ║
║      ░   the official documentation.                                        ║
║                                                                              ║
║   █  Bug Fixes                                                               ║
║      ░ ■ Resolved a critical stutter/hitch on arena load via async generation.║
║      ░ ■ Eliminated intermittent stutter on first run via shader pre-warming.║
║      ░ ■ Resolved a physics crash on entity death by using `call_deferred`   ║
║      ░   for scene transitions.                                              ║
║      ░ ■ Corrected implementation of hazard tiles to ensure contact damage.  ║
║                                                                              ║
║   █  Documentation                                                           ║
║      ░ ■ Overhauled `TODO.txt` with a new, multi-phase development roadmap. ║
║      ░ ■ Updated `DESIGN.txt` and `ARCHITECTURE.txt` to reflect the new     ║
║      ░   design philosophies, patterns, and planned features.               ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       [0.1.0] - 2025-08-05                           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This version marks the initial architectural overhaul, transforming the    ║
║   project from a functional prototype into a robust and scalable foundation. ║
║                                                                              ║
║   █  Added                                                                   ║
║      ░ ■ Player Character with rich moveset (dash, wall-jump, etc.).         ║
║      ░ ■ Combat System with melee, charged shot, and pogo mechanics.         ║
║      ░ ■ "Determination" healing system & Data-Driven Arena system.          ║
║      ░ ■ Basic Boss entity framework & Reusable Menu System.                 ║
║      ░ ■ Full suite of initial project documentation (.txt files).           ║
║                                                                              ║
║   █  Changed                                                                 ║
║      ░ ■ Complete Architectural Refactor to use professional design patterns.║
║      ░ ■ Player Logic: Migrated from boolean flags to a formal FSM.          ║
║      ░ ■ Global Singletons: Centralized constants and asset paths.           ║
║      ░ ■ File Organization: Restructured project directories.                ║
║                                                                              ║
║   █  Fixed                                                                   ║
║      ░ ■ Restored player contact damage from enemies and hazards.            ║
║      ░ ■ Fully restored the pogo mechanic.                                   ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/BRAINSTORM.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═══════╗
║    ██████╗ ██████╗  █████╗ ██╗███╗   ██╗███████╗████████╗ ██████╗ ██████╗ ███╗  ███╗ ║
║   ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗████╗ ████║ ║
║   ██████╔╝██████╔╝███████║██║██╔██╗ ██║███████╗   ██║   ██║   ██║██████╔╝██╔████╔██║ ║
║   ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║╚════██║   ██║   ██║   ██║██╔══██╗██║╚██╔╝██║ ║
║   ██████╔╝██║  ██║██║  ██║██║██║ ╚████║███████║   ██║   ╚██████╔╝██║  ██║██║ ╚═╝ ██║ ║
║   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝ ║
║                                                                              ╔═══════╝
║              A free-form collection of creative ideas and experiments.       ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓-▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       BOX BATTLE BOSS CONCEPTS                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A categorized list of all potential boss ideas for the game. Each concept  ║
║   includes ideas for its theme, mechanics, and unique shader effects.        ║
║                                                                              ║
║   █  PUN-BASED CONCEPTS                                                      ║
║      ░ ■ Beat Box: Rhythm-based boss. Platforms and attacks sync to a beat.  ║
║      ░ ■ Sandbox: Deforms terrain, uses momentum-stealing attacks.           ║
║      ░ ■ Matchbox: Fire-themed, tight vertical arena, limited dash.          ║
║      ░ ■ Toolbox: Utility-themed, projectile-only combat.                    ║
║      ░ ■ Gearbox: Mechanical theme with rotating platforms and gravity shifts.║
║      ░ ■ Strongbox: Defense-themed, tries to corner player.                  ║
║      ░ ■ Icebox: Slippery physics, reduced friction.                         ║
║      ░ ■ Shoebox: Cramped arena, precise movement required.                  ║
║      ░ ■ Jukebox: Different songs change the environmental physics.          ║
║      ░ ■ Mailbox: Arena is filled with flying "letters" as platforms.        ║
║      ░ ■ Puzzle Box: Arena rearranges itself as movement puzzles are solved. ║
║      ░ ■ Shadow Box: Past movements leave shadow trails that become platforms.║
║      ░ ■ Cardboard Box: Platforms are fragile and break after use.           ║
║      ░ ■ Pandora's Box: Randomly opens to release temporary chaos effects.   ║
║      ░ ■ Rubik's Box: Arena rotates in 90-degree chunks.                     ║
║                                                                              ║
║   █  MEGA MAN-INSPIRED CONCEPTS                                              ║
║      ░ ■ Flame Box (Heat Man): Teleports in fire bursts, leaves flame trails.║
║      ░ ■ Ice Box (Ice Man): Slides with momentum, freezes platforms.         ║
║      ░ ■ Electric Box (Elec Man): Zips in straight lines at high speed.      ║
║      ░ ■ Wind Box (Air Man): Constant wind pushes player, affects jumps.     ║
║      ░ ■ Gravity Box (Gravity Man): Gravity flips, ceiling becomes floor.    ║
║      ░ ■ Time Box (Flash Man): Slow-motion bursts, delayed attacks.          ║
║      ░ ■ Plant Box (Wood Man): Platforms grow and shrink, sticky surfaces.   ║
║      ░ ■ Slash Box (Zero/Harpuia): Fast strikes cut through platforms.       ║
║      ░ ■ Phantom Box (Phantom): Stealth/clone attacks, false reflections.    ║
║                                                                              ║
║   █  LOOP-THEMED CONCEPTS                                                    ║
║      ░ ■ Infinite Box: Arena wraps around (left edge connects to right).     ║
║      ░ ■ Möbius Box: Twisted space; jumping up can make you fall down.       ║
║      ░ ■ Pendulum Box: Gravity shifts left/right in a rhythmic swing.        ║
║      ░ ■ Echo Box: Player inputs are repeated after a short delay.           ║
║      ░ ■ Ouroboros Box: The room slowly "eats" itself from the edges inward. ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                        SHADER & VFX BRAINSTORM                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of potential shader and visual effect ideas.                        ║
║                                                                              ║
║   ▒  Prism Box: Chromatic aberration effect, splits attacks into RGB channels.║
║   ▒  Void Box: Black hole distortion that pulls the player and projectiles.  ║
║   ▒  Static Box: Digital noise/glitch effects that can corrupt controls.     ║
║   ▒  Mirror Box: Kaleidoscope/reflection effects, duplicates player attacks. ║
║   ▒  Pulse Box: Rhythmic, concentric shockwave rings.                        ║
║   ▒  Phase Box: Flickers in and out of existence, unpredictable collision.   ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                   ADVANCED MOVEMENT & MECHANICS                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ▒  Parrying System: A simple parry could stun the boss or grant the player ║
║      a momentum boost, rewarding precise timing.                             ║
║                                                                              ║
║   ▒  Ledge Grab: A brief pause/slowdown when hitting the top edge of a wall  ║
║      to create a more forgiving window for wall-jumping.                     ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/ARENA_CONCEPTS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    █████╗ ██████╗ ███████╗███╗   ██╗ █████╗     ██████╗  ██████╗ ███╗   ███╗ ║
║   ██╔══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗   ██╔═══██╗██╔═══██╗████╗ ████║ ║
║   ███████║██████╔╝█████╗  ██╔██╗ ██║███████║   ██║   ██║██║   ██║██╔████╔██║ ║
║   ██╔══██║██╔══██╗██╔══╝  ██║╚██╗██║██╔══██║   ██║   ██║██║   ██║██║╚██╔╝██║ ║
║   ██║  ██║██║  ██║███████╗██║ ╚████║██║  ██║   ╚██████╔╝╚██████╔╝██║ ╚═╝ ██║ ║
║   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝    ╚═════╝  ╚═════╝ ╚═╝     ╚═╝ ║
║                                                                              ║
║           A visual library of potential boss battle arena layouts.           ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       PUN-THEMED ARENA MOCKUPS                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  "SANDBOX" - Momentum Vampirism                                          ║
║      SPECIAL RULE: No Wall-Jump ability. Boss steals player speed on hit.    ║
║      ####################                                                    ║
║      #..................#                                                    ║
║      #..@...........&...#                                                    ║
║      #..................#                                                    ║
║      #....##########....#                                                    ║
║      #....#........#....#                                                    ║
║      #....#..^^^^..#....#                                                    ║
║      #....#........#....#                                                    ║
║      #....##--##--##....#                                                    ║
║      #..................#                                                    ║
║      #..##...........##.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..#......--.....#.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..##...........##.#                                                    ║
║      #..................#                                                    ║
║      #^^^^^^^^....^^^^^^#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║   █  "MATCHBOX" - Fire Theme                                                 ║
║      SPECIAL RULE: Only ONE dash per ground contact.                         ║
║      ####################                                                    ║
║      #@.................#                                                    ║
║      #..................#                                                    ║
║      #..####....####....#                                                    ║
║      #..#..#....#..#....#                                                    ║
║      #..#..######..#....#                                                    ║
║      #..#..........#....#                                                    ║
║      #..#..--##--..#....#                                                    ║
║      #..#........&.#....#                                                    ║
║      #..#..--##--..#....#                                                    ║
║      #..#..........#....#                                                    ║
║      #..#..######..#....#                                                    ║
║      #..#..#....#..#....#                                                    ║
║      #..####....####....#                                                    ║
║      #..................#                                                    ║
║      #..^^^^^^^^^^^^^^..#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║   █  "ICEBOX" - Slippery Mechanics                                           ║
║      SPECIAL RULE: Reduced friction - momentum carries much further.         ║
║      ####################                                                    ║
║      #@................&#                                                    ║
║      #--................#                                                    ║
║      #..................#                                                    ║
║      #......########....#                                                    ║
║      #......#......#....#                                                    ║
║      #......#..--..#....#                                                    ║
║      #......#......#....#                                                    ║
║      #......########....#                                                    ║
║      #..................#                                                    ║
║      #........^^^^......#                                                    ║
║      #..................#                                                    ║
║      #......########....#                                                    ║
║      #......#......#....#                                                    ║
║      #......#..--..#....#                                                    ║
║      #......#......#....#                                                    ║
║      #......########....#                                                    ║
║      #..................#                                                    ║
║      #................--#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                     CLASSIC ARCADE-THEMED MOCKUPS                    ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  "CIRCUIT BOX" - Tempest-style                                           ║
║      MECHANIC: Boss in center shoots through tunnels. Player circles outer ring.║
║      ####################                                                    ║
║      #..................#                                                    ║
║      #..###############.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..#..##########.#.#                                                    ║
║      #..#..#........#.#.#                                                    ║
║      #..#..#..####..#.#.#                                                    ║
║      #..#..#..#&&#..#.#.#                                                    ║
║      #..#..#..####..#.#.#                                                    ║
║      #..#..#..@.....#.#.#                                                    ║
║      #..#..##########.#.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..###############.#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║   █  "GARDEN BOX" - Centipede-style                                          ║
║      MECHANIC: Boss is a long segmented entity weaving between obstacles.    ║
║      ####################                                                    ║
║      #@................&#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝


=====================================
FILE: ./README.md
=====================================
# BOX BATTLE

```
██████╗  ██████╗ ██╗  ██╗    ██████╗  █████╗ ████████╗████████╗██╗     ███████╗
██╔══██╗██╔═══██╗╗██╗██╔╝    ██╔══██╗██╔══██╗╚══██╔══╝╚══██╔══╝██║     ██╔════╝
██████╔╝██║   ██║╚███╔╝      ██████╔╝███████║   ██║      ██║   ██║     █████╗  
██╔══██╗██║   ██║██╔██╗      ██╔══██╗██╔══██║   ██║      ██║   ██║     ██╔══╝  
██████╔╝╚██████╔╝██╔╝ ██╗    ██████╔╝██║  ██║   ██║      ██║   ███████╗███████╗
╚═════╝  ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚══════╝
```

A combat-focused 2D action game built in Godot 4, showcasing clean architecture and comprehensive game systems.

## What Makes This Code Notable

### Architectural Excellence
- **Centralized Asset Management**: All file paths are managed through a single `AssetPaths` singleton, eliminating broken references and making refactoring trivial
- **Singleton-Based Core Systems**: Audio, settings, cursor management, and constants are globally accessible without tight coupling
- **Modular Arena System**: Level layouts and encounters are separated into data-only scripts, making level creation declarative and maintainable

### Advanced Player Controller
- **Robust State Machine**: Clean finite state machine handling movement, combat, dashing, wall-sliding, and healing states
- **Physics-Driven Design**: Implements coyote time, jump buffering, wall jumping, and variable jump height for responsive controls
- **Pogo Mechanics**: Sophisticated downward attack system with instant collision detection and momentum preservation
- **Determination System**: Risk/reward mechanics where dealing damage builds healing charges

### Production-Quality UI
- **Custom Menu Navigation**: Unified system supporting both keyboard and mouse input with audio feedback
- **Global HUD Management**: Context-aware UI elements that appear/disappear based on current scene
- **Real-time Settings Sync**: Audio sliders and checkboxes update immediately without save/load cycles
- **Custom Slider Component**: Self-contained, reusable UI widget with proper mouse interaction

### Smart Audio Architecture
- **Pooled SFX Players**: Multiple AudioStreamPlayer instances prevent sound cutoff during rapid-fire events
- **Context-Aware Sounds**: Different menu actions trigger appropriate audio cues (back vs select vs error)
- **Robust Music Management**: Prevents music restarts when switching between menu screens

### Clean Code Practices
- **Extensive Documentation**: Every script explains its purpose and key design decisions
- **Consistent Naming**: Clear, descriptive variable and function names throughout
- **Proper Signal Usage**: Decoupled communication between components using Godot's signal system
- **Layer-Based Physics**: Thoughtful collision layer setup for different object types and interactions

### Noteworthy Technical Solutions
- **Fake Cursor System**: Custom cursor that works consistently across all platforms with proper click-through behavior
- **Immediate Pogo Detection**: Proactive collision checking prevents frame-delay issues in fast-paced combat
- **Hazard Dual-Layer System**: Terrain that's both solid (world layer) and damaging (hazard layer) for consistent physics
- **Deferred Scene Changes**: Proper scene transition handling to prevent physics errors

## Getting Started

1. Clone the repository
2. Open the project in Godot 4.4+
3. Run the project - it starts at the title screen

## Controls

- **Movement**: WASD / Arrow Keys
- **Jump**: Space / X / Period
- **Attack**: C / Comma / Alt + Shift
- **Dash**: Z / Slash / Shift + Ctrl
- **Heal**: Hold Down + Jump while on ground (requires healing charges)

## Project Structure

```
src/
├── core/           # Singleton systems (audio, settings, etc.)
├── entities/       # Player and enemy classes
├── projectiles/    # Bullet and shot behaviors
├── scenes/         # Main game scenes
├── ui/             # Menu systems and components
└── arenas/         # Level data and encounter scripts
```

This codebase demonstrates how to structure a Godot project for maintainability, extensibility, and professional polish. Every system is designed to be modular, well-documented, and easy to extend.

## License

This project is released under CC0 1.0 Universal - dedicated to the public domain. Use it however you like!

=====================================
FILE: ./default_bus_layout.tres
=====================================
[gd_resource type="AudioBusLayout" format=3 uid="uid://c65ja7dwrkbrc"]

[resource]
bus/1/name = &"Music"
bus/1/solo = false
bus/1/mute = false
bus/1/bypass_fx = false
bus/1/volume_db = 0.0
bus/1/send = &"Master"
bus/2/name = &"SFX"
bus/2/solo = false
bus/2/mute = false
bus/2/bypass_fx = false
bus/2/volume_db = 0.0
bus/2/send = &"Master"

=====================================
FILE: ./project.godot
=====================================
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="BOX BATTLE"
run/main_scene="res://src/scenes/main/main.tscn"
config/features=PackedStringArray("4.4", "Mobile")
config/icon="res://icon.svg"

[autoload]

Settings="*res://src/core/settings.gd"
AudioManager="*res://src/core/audio_manager.gd"
CursorManager="*res://src/core/cursor_manager.gd"
Constants="*res://src/core/constants.gd"
AssetPaths="*res://src/core/asset_paths.gd"
GlobalHud="*res://src/ui/global_hud/global_hud.tscn"
GameManager="*res://src/core/game_manager.gd"
ArenaBuilder="*res://src/core/arena_builder.gd"

[display]

window/size/viewport_width=1000
window/size/viewport_height=1000
window/size/resizable=false
window/stretch/mode="canvas_items"

[input]

ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194319,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":13,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":0,"axis_value":-1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
]
}
ui_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194321,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":14,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":0,"axis_value":1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
]
}
ui_up={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194320,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":11,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":1,"axis_value":-1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
]
}
ui_down={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194322,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":12,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":1,"axis_value":1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
]
}
ui_jump={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":32,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":88,"physical_keycode":88,"key_label":0,"unicode":120,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":46,"physical_keycode":46,"key_label":0,"unicode":46,"location":0,"echo":false,"script":null)
]
}
ui_attack={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":67,"physical_keycode":67,"key_label":0,"unicode":99,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":44,"physical_keycode":44,"key_label":0,"unicode":44,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":true,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777218,"physical_keycode":16777218,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":2,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
ui_dash={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":90,"physical_keycode":90,"key_label":0,"unicode":122,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":47,"physical_keycode":47,"key_label":0,"unicode":47,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":true,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777217,"physical_keycode":16777217,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":3,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="player"
2d_physics/layer_2="world"
2d_physics/layer_3="enemy"
2d_physics/layer_4="hazard"
2d_physics/layer_5="enemy_projectile"
2d_physics/layer_6="player_hitbox"
2d_physics/layer_7="player_hurtbox"

[rendering]

renderer/rendering_method="mobile"
environment/defaults/default_clear_color=Color(0, 0, 0, 1)


=====================================
FILE: ./src/ui/game_hud/game_hud.gd
=====================================
# src/ui/game_hud/game_hud.gd
#
# Manages the in-game heads-up display. It connects to signals from the
# player and boss to update health bars and other UI elements in real-time.
extends CanvasLayer

# --- Node References ---
@onready var player_health_value: Label = $PlayerInfo/PlayerHealthHBox/PlayerHealthValue
@onready var player_heal_charges_value: Label = $PlayerInfo/PlayerHealChargesHBox/PlayerHealChargesValue
@onready var boss_health_bar: ProgressBar = $BossHealthBar

func _ready():
	# Wait until the main scene tree is ready before trying to connect signals.
	await get_tree().process_frame
	
	var player = get_tree().get_first_node_in_group("player")
	var boss = get_tree().get_first_node_in_group("enemy")

	if is_instance_valid(player):
		# Connect to the player's signals.
		player.health_changed.connect(on_player_health_changed)
		player.healing_charges_changed.connect(on_player_healing_charges_changed)
	
	if is_instance_valid(boss):
		# Connect to the boss's signals.
		boss.health_changed.connect(on_boss_health_changed)

# --- Signal Callbacks ---

func on_player_health_changed(current_health: int, max_health: int):
	player_health_value.text = str(current_health) + " / " + str(max_health)

func on_player_healing_charges_changed(current_charges: int):
	player_heal_charges_value.text = str(current_charges)

func on_boss_health_changed(current_health: int, max_health: int):
	# Set the max_value of the progress bar first in case it has changed.
	boss_health_bar.max_value = max_health
	# Update the current value.
	boss_health_bar.value = current_health

=====================================
FILE: ./src/ui/game_hud/game_hud.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://c1qkhw0snj226"]

[ext_resource type="Script" path="res://src/ui/game_hud/game_hud.gd" id="1_3f8wa"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_1"]
bg_color = Color(0.262745, 0.262745, 0.262745, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_2"]
bg_color = Color(0.8, 0.2, 0.2, 1)

[node name="GameHUD" type="CanvasLayer"]
script = ExtResource("1_3f8wa")

[node name="PlayerInfo" type="VBoxContainer" parent="."]
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 20.0
offset_top = -100.0
offset_right = 220.0
offset_bottom = -20.0
grow_vertical = 0

[node name="PlayerHealthHBox" type="HBoxContainer" parent="PlayerInfo"]
layout_mode = 2

[node name="PlayerHealthLabel" type="Label" parent="PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Health:"

[node name="PlayerHealthValue" type="Label" parent="PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "5 / 5"

[node name="PlayerHealChargesHBox" type="HBoxContainer" parent="PlayerInfo"]
layout_mode = 2

[node name="PlayerHealChargesLabel" type="Label" parent="PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Heal Charges:"

[node name="PlayerHealChargesValue" type="Label" parent="PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"

[node name="BossHealthBar" type="ProgressBar" parent="."]
anchors_preset = 10
anchor_right = 1.0
offset_left = 250.0
offset_top = 20.0
offset_right = -250.0
offset_bottom = 50.0
grow_horizontal = 2
theme_override_styles/background = SubResource("StyleBoxFlat_1")
theme_override_styles/fill = SubResource("StyleBoxFlat_2")
max_value = 30.0
step = 1.0
value = 30.0
show_percentage = false

=====================================
FILE: ./src/ui/global_hud/global_hud.gd
=====================================
# src/ui/global_hud/global_hud.gd
#
# This autoloaded scene is always present. Its main job is to manage the
# global mute button that appears in the top-right corner of menu screens.
extends Control

# Preload icons into constants for performance and safety.
const ICON_SOUND_ON = preload(AssetPaths.SPRITE_ICON_SOUND_ON)
const ICON_SOUND_OFF = preload(AssetPaths.SPRITE_ICON_SOUND_OFF)

var mute_button: TextureButton

const MENU_SCENES = [
	AssetPaths.SCENE_TITLE_SCREEN,
	AssetPaths.SCENE_OPTIONS_MENU,
	AssetPaths.SCENE_SOUND_MENU,
	AssetPaths.SCENE_CONTROLS_MENU,
	AssetPaths.SCENE_CREDITS_MENU,
]

func _ready():
	mute_button = TextureButton.new()
	add_child(mute_button)

	var padding = 40
	# Wait for the viewport to be ready before positioning.
	await get_tree().process_frame

	# FIX: Revert to the original, correct positioning logic.
	# The dynamic calculation was flawed because the button's size is 0 before its texture is set.
	mute_button.position = Vector2(get_viewport_rect().size.x - 120, padding)

	# Connect signals for interaction.
	mute_button.pressed.connect(_on_mute_button_pressed)
	mute_button.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
	mute_button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

	# Set the initial icon state.
	_update_icon()

func _process(_delta):
	if not get_tree().current_scene: return

	var current_scene_path = get_tree().current_scene.scene_file_path
	mute_button.visible = current_scene_path in MENU_SCENES

	if mute_button.visible:
		var is_muted_in_settings = Settings.music_muted
		var icon_is_off = mute_button.texture_normal == ICON_SOUND_OFF

		# If the setting and the icon are out of sync, update the icon.
		if is_muted_in_settings != icon_is_off:
			_update_icon()

func _on_mute_button_pressed():
	# Toggle the setting, play a sound, and update the icon.
	Settings.music_muted = not Settings.music_muted
	AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_SELECT)
	_update_icon()

func _update_icon():
	# Set the button's texture based on the current setting.
	if Settings.music_muted:
		mute_button.texture_normal = ICON_SOUND_OFF
	else:
		mute_button.texture_normal = ICON_SOUND_ON

=====================================
FILE: ./src/ui/global_hud/global_hud.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dpcsg3wmlvabm"]

[ext_resource type="Script" path="res://src/ui/global_hud/global_hud.gd" id="1_hud_script"]

[node name="GlobalHUD" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
mouse_filter = 2
script = ExtResource("1_hud_script")

=====================================
FILE: ./src/ui/menu_manager/menu_manager.gd
=====================================
# src/ui/menu_manager/menu_manager.gd
#
# A reusable script for creating keyboard and mouse-navigable menus. An instance
# of this is created by each menu scene to manage its own set of buttons.
extends Node

# --- Inner Class: MenuItem ---
# A simple data structure to bundle a button node with its "type" (for sounds).
class MenuItem:
	var button: TextureButton
	var type: String

	func _init(btn: TextureButton, btn_type: String):
		self.button = btn
		self.type = btn_type

# --- Variables ---
var menu_items = []
var current_selection = 0
var cursor_left: TextureRect
var cursor_right: TextureRect

func _ready():
	# Create the cursor sprites using the safe path from AssetPaths.
	cursor_left = TextureRect.new()
	cursor_left.texture = load(AssetPaths.SPRITE_MENU_CURSOR)
	cursor_left.flip_h = true # Point it inwards.
	add_child(cursor_left)

	cursor_right = TextureRect.new()
	cursor_right.texture = load(AssetPaths.SPRITE_MENU_CURSOR)
	add_child(cursor_right)

	cursor_left.visible = false
	cursor_right.visible = false

# The main setup function, called by the parent menu scene.
func setup_menu(items: Array):
	menu_items = items
	if menu_items.is_empty(): return

	for i in range(menu_items.size()):
		var menu_item = menu_items[i]
		# Connect signals for each button.
		# When the mouse enters a button, we call our own function to handle it.
		menu_item.button.mouse_entered.connect(_on_mouse_entered.bind(i))
		# When the mouse leaves, we tell the cursor manager to reset the cursor state.
		menu_item.button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))
		# When the button is pressed (by click or keyboard), we handle the sound.
		menu_item.button.pressed.connect(_on_item_pressed.bind(i))

	# Set the initial selection to the first item.
	current_selection = 0
	# Wait one frame to ensure all buttons have their positions calculated.
	await get_tree().process_frame
	# Now update the cursors to point to the first item.
	_update_cursors()
	cursor_left.visible = true
	cursor_right.visible = true

# Catches unhandled input for keyboard/controller navigation.
func _unhandled_input(event):
	if event.is_action_pressed("ui_down"):
		_change_selection(1)
	elif event.is_action_pressed("ui_up"):
		_change_selection(-1)
	elif event.is_action_pressed("ui_accept"):
		if not menu_items.is_empty():
			menu_items[current_selection].button.emit_signal("pressed")

# Plays context-specific sounds based on the button type.
func _on_item_pressed(index: int):
	if index < 0 or index >= menu_items.size(): return

	var item_type = menu_items[index].type
	match item_type:
		"BACK":
			AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_BACK)
		"START":
			AudioManager.play_sfx(AssetPaths.AUDIO_SFX_START_CHIME)
		_: # Default case for "SELECT" or any other type.
			AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_SELECT)

# Handles the logic for changing the selected item via keyboard.
func _change_selection(amount: int):
	if menu_items.size() <= 1:
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_ERROR)
		return

	var new_selection = (current_selection + amount + menu_items.size()) % menu_items.size()

	if new_selection != current_selection:
		current_selection = new_selection
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_MOVE)
		_update_cursors()
	else:
		# This case can happen if there's only one item.
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_ERROR)

# Called when the mouse pointer enters a button's collision shape.
func _on_mouse_entered(index: int):
	CursorManager.set_pointer_state(true)
	if current_selection != index:
		current_selection = index
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_MOVE)
		_update_cursors()

# Moves the visual cursors to frame the currently selected button.
func _update_cursors():
	if menu_items.is_empty(): return

	var selected_button = menu_items[current_selection].button
	var button_pos = selected_button.position
	var button_size = selected_button.size
	var cursor_padding = 40

	cursor_left.position.x = button_pos.x - cursor_left.size.x - cursor_padding
	cursor_left.position.y = button_pos.y + (button_size.y - cursor_left.size.y) / 2

	cursor_right.position.x = button_pos.x + button_size.x + cursor_padding
	cursor_right.position.y = button_pos.y + (button_size.y - cursor_right.size.y) / 2

=====================================
FILE: ./src/ui/screens/game_over_screen/game_over_screen.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://dnlf14n0wfxm1"]

[ext_resource type="Script" path="res://src/ui/screens/game_over_screen/game_over_screen.gd" id="1_goscr"]

[sub_resource type="LabelSettings" id="LabelSettings_1"]
font_size = 96
font_color = Color(0.8, 0.2, 0.2, 1)

[node name="GameOverScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_goscr")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -291.0
offset_top = -123.0
offset_right = 291.0
offset_bottom = 123.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "GAME OVER"
label_settings = SubResource("LabelSettings_1")
horizontal_alignment = 1

[node name="ReturnButton" type="TextureButton" parent="VBoxContainer"]
layout_mode = 2

=====================================
FILE: ./src/ui/screens/game_over_screen/game_over_screen.gd
=====================================
# src/ui/screens/game_over_screen/game_over_screen.gd
#
# This screen is shown when the player's health reaches zero.
extends Control

@onready var return_button: TextureButton = $VBoxContainer/ReturnButton

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	# Configure the button and connect its signal.
	return_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	return_button.pressed.connect(_on_return_button_pressed)

	# Set up the menu manager for keyboard/controller navigation.
	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(return_button, "BACK")])

func _on_return_button_pressed():
	get_tree().change_scene_to_file(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/ui/screens/controls_menu/controls_menu.gd
=====================================
# src/ui/screens/controls_menu/controls_menu.gd
#
# Displays a static list of the game's controls.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)
	var bold_font = load(AssetPaths.FONT_BOLD)
	var regular_font = load(AssetPaths.FONT_REGULAR)

	# --- Title ---
	var title_label = Label.new()
	title_label.text = "Controls"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 96)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80

	# --- Controls List ---
	# FIX: Restoring the original, more detailed controls data.
	var controls_data = [
		{ "action": "Movement", "keys": "Arrow Keys / WASD / Mouse" },
		{ "action": "Primary Action", "keys": "X / . / Space / Left-Click" },
		{ "action": "Secondary Action", "keys": "C / , / Shift / Right-Click" },
		{ "action": "Tertiary Action", "keys": "Z / / / Ctrl / Middle-Click" },
		{ "action": "Pause / Menu", "keys": "Enter / P / Escape" },
		{ "action": "Back / Cancel", "keys": "Escape / Backspace" }
	]

	var start_y = 300
	var item_gap = 70

	for i in range(controls_data.size()):
		var data = controls_data[i]
		var y_pos = start_y + i * item_gap

		var action_label = Label.new()
		action_label.text = data.action
		add_child(action_label)
		action_label.add_theme_font_override("font", bold_font)
		action_label.add_theme_font_size_override("font_size", 36)
		# FIX: Restoring original x-size for alignment.
		action_label.size.x = 390
		action_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		action_label.position = Vector2(0, y_pos)

		var keys_label = Label.new()
		keys_label.text = data.keys
		add_child(keys_label)
		keys_label.add_theme_font_override("font", regular_font)
		keys_label.add_theme_font_size_override("font_size", 36)
		# FIX: Restoring original x-position for alignment.
		keys_label.position = Vector2(460, y_pos)

	# --- Back Button ---
	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position.x = (get_viewport_rect().size.x - back_button.size.x) / 2
	back_button.position.y = 800
	back_button.pressed.connect(_on_back_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(back_button, "BACK")])

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)

=====================================
FILE: ./src/ui/screens/controls_menu/controls_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cghquk5y1qjwg"]

[ext_resource type="Script" path="res://src/ui/screens/controls_menu/controls_menu.gd" id="1_controls_script"]

[node name="ControlsMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_controls_script")

=====================================
FILE: ./src/ui/screens/credits_menu/credits_menu.gd
=====================================
# src/ui/screens/credits_menu/credits_menu.gd
#
# Displays game credits using a RichTextLabel to handle formatted text and URLs.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)

	var title_label = Label.new()
	title_label.text = "Credits"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 96)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80

	# --- Credits RichTextLabel ---
	var credits_label = RichTextLabel.new()
	add_child(credits_label)
	credits_label.mouse_filter = Control.MOUSE_FILTER_PASS
	credits_label.add_theme_font_override("normal_font", load(AssetPaths.FONT_REGULAR))
	credits_label.add_theme_font_size_override("normal_font_size", 38)
	credits_label.add_theme_color_override("default_color", Color.WHITE)
	credits_label.position = Vector2(0, 220)
	credits_label.size.x = get_viewport_rect().size.x
	credits_label.size.y = 550
	credits_label.bbcode_enabled = true # This MUST be true to parse the [url] tags.

	credits_label.text = """
[center]A Game By Steven Casteel[/center]
[center][url=https://www.stevencasteel.com/]www.stevencasteel.com[/url][/center]

[center]Built with the [url=https://godotengine.org/]Godot Engine[/url][/center]
[center]AI-Assisted by [url=https://gemini.google.com/]Gemini[/url][/center]

[center]Find me on [url=https://www.youtube.com/@stevencasteel]YouTube[/url] and [url=http://github.com/stevencasteel]GitHub[/url][/center]
"""
	# --- Connect Signals for RichTextLabel ---
	credits_label.meta_clicked.connect(_on_meta_clicked)
	credits_label.meta_hover_started.connect(func(_meta): CursorManager.set_pointer_state(true))
	credits_label.meta_hover_ended.connect(func(_meta): CursorManager.set_pointer_state(false))

	# --- Back Button ---
	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position.x = (get_viewport_rect().size.x - back_button.size.x) / 2
	back_button.position.y = 800
	back_button.pressed.connect(_on_back_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(back_button, "BACK")])

# Called when a URL inside the RichTextLabel is clicked.
func _on_meta_clicked(meta):
	# OS.shell_open() opens the URL in the user's default web browser.
	OS.shell_open(str(meta))

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)

=====================================
FILE: ./src/ui/screens/credits_menu/credits_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b8txy2d7jrhwg"]

[ext_resource type="Script" path="res://src/ui/screens/credits_menu/credits_menu.gd" id="1_credits_script"]

[node name="CreditsMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_credits_script")

=====================================
FILE: ./src/ui/screens/options_menu/options_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://ddgtf7n0tqvot"]

[ext_resource type="Script" path="res://src/ui/screens/options_menu/options_menu.gd" id="1_options_script"]

[node name="OptionsMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_options_script")

=====================================
FILE: ./src/ui/screens/options_menu/options_menu.gd
=====================================
# src/ui/screens/options_menu/options_menu.gd
#
# Manages the Options menu, which acts as a hub to navigate to other screens.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)
	
	# --- Create UI Elements ---
	var title_label = Label.new()
	title_label.text = "Options"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 96)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80
	
	var sound_button = TextureButton.new()
	sound_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_SOUND)
	add_child(sound_button)
	sound_button.position = Vector2((get_viewport_rect().size.x - sound_button.size.x) / 2, 300)
	
	var controls_button = TextureButton.new()
	controls_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_CONTROLS)
	add_child(controls_button)
	controls_button.position = Vector2((get_viewport_rect().size.x - controls_button.size.x) / 2, 450)

	var credits_button = TextureButton.new()
	credits_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_CREDITS)
	add_child(credits_button)
	credits_button.position = Vector2((get_viewport_rect().size.x - credits_button.size.x) / 2, 600)
	
	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position = Vector2((get_viewport_rect().size.x - back_button.size.x) / 2, 800)
	
	# --- Connect Signals ---
	sound_button.pressed.connect(_on_sound_button_pressed)
	controls_button.pressed.connect(_on_controls_button_pressed)
	credits_button.pressed.connect(_on_credits_button_pressed)
	back_button.pressed.connect(_on_back_button_pressed)
	
	# --- Initialize Menu Navigation ---
	var menu = MenuManager.new()
	add_child(menu)
	
	var menu_items = [
		MenuManager.MenuItem.new(sound_button, "SELECT"),
		MenuManager.MenuItem.new(controls_button, "SELECT"),
		MenuManager.MenuItem.new(credits_button, "SELECT"),
		MenuManager.MenuItem.new(back_button, "BACK")
	]
	menu.setup_menu(menu_items)

# --- Button Press Handlers ---

func _on_sound_button_pressed():
	get_tree().change_scene_to_file(AssetPaths.SCENE_SOUND_MENU)

func _on_controls_button_pressed():
	get_tree().change_scene_to_file(AssetPaths.SCENE_CONTROLS_MENU)

func _on_credits_button_pressed():
	get_tree().change_scene_to_file(AssetPaths.SCENE_CREDITS_MENU)

func _on_back_button_pressed():
	get_tree().change_scene_to_file(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/ui/screens/sound_menu/sound_menu.gd
=====================================
# src/ui/screens/sound_menu/sound_menu.gd
#
# Manages the sound settings screen, connecting UI elements to the global
# Settings singleton so changes are applied in real-time.
extends Control

const CustomSliderScript = preload(AssetPaths.SCRIPT_CUSTOM_SLIDER)
const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# We need to store references to our UI elements to update them in _process
var master_volume_label: Label
var music_volume_label: Label
var sfx_volume_label: Label
var master_mute_checkbox: TextureButton
var music_mute_checkbox: TextureButton
var sfx_mute_checkbox: TextureButton

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)

	var title_label = Label.new()
	title_label.text = "Sound Settings"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 80)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80

	# FIX: The 'initial_mute' argument is no longer needed here.
	_create_volume_row("MASTER", 300, Settings.master_volume, "master")
	_create_volume_row("MUSIC", 450, Settings.music_volume, "music")
	_create_volume_row("SFX", 600, Settings.sfx_volume, "sfx")

	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position.x = (get_viewport_rect().size.x - back_button.size.x) / 2
	back_button.position.y = 800
	back_button.pressed.connect(_on_back_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(back_button, "BACK")])

# This function now runs every frame to ensure the UI is always in sync.
func _process(_delta):
	# Sync volume labels
	master_volume_label.text = str(int(Settings.master_volume * 100))
	music_volume_label.text = str(int(Settings.music_volume * 100))
	sfx_volume_label.text = str(int(Settings.sfx_volume * 100))
	
	# Sync checkboxes
	_update_checkbox_texture(master_mute_checkbox, Settings.master_muted)
	_update_checkbox_texture(music_mute_checkbox, Settings.music_muted)
	_update_checkbox_texture(sfx_mute_checkbox, Settings.sfx_muted)

# FIX: The 'initial_mute' parameter has been removed from the function definition.
func _create_volume_row(label_text: String, y_pos: int, initial_volume: float, type: String):
	var row_label = Label.new()
	row_label.text = label_text
	add_child(row_label)
	row_label.add_theme_font_override("font", load(AssetPaths.FONT_BOLD))
	row_label.add_theme_font_size_override("font_size", 48)
	row_label.size.x = 250
	row_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	row_label.position = Vector2(40, y_pos)

	var slider = CustomSliderScript.new()
	add_child(slider)
	slider.set_value(initial_volume)
	slider.position = Vector2(300, y_pos + 25)

	var volume_label = Label.new()
	volume_label.add_theme_font_override("font", load(AssetPaths.FONT_REGULAR))
	volume_label.add_theme_font_size_override("font_size", 48)
	volume_label.size.x = 100
	volume_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	volume_label.position = Vector2(720, y_pos)
	add_child(volume_label)

	var checkbox = TextureButton.new()
	checkbox.position = Vector2(850, y_pos + 14)
	add_child(checkbox)
	
	match type:
		"master":
			master_volume_label = volume_label
			master_mute_checkbox = checkbox
			slider.value_changed.connect(func(new_value): Settings.master_volume = new_value)
			checkbox.pressed.connect(func(): Settings.master_muted = not Settings.master_muted)
		"music":
			music_volume_label = volume_label
			music_mute_checkbox = checkbox
			slider.value_changed.connect(func(new_value): Settings.music_volume = new_value)
			checkbox.pressed.connect(func(): Settings.music_muted = not Settings.music_muted)
		"sfx":
			sfx_volume_label = volume_label
			sfx_mute_checkbox = checkbox
			slider.value_changed.connect(func(new_value): Settings.sfx_volume = new_value)
			checkbox.pressed.connect(func(): Settings.sfx_muted = not Settings.sfx_muted)

func _update_checkbox_texture(button_ref: TextureButton, is_muted: bool):
	var new_texture = load(AssetPaths.SPRITE_CHECKBOX_UNCHECKED)
	if is_muted:
		new_texture = load(AssetPaths.SPRITE_CHECKBOX_CHECKED)
	
	if button_ref.texture_normal != new_texture:
		button_ref.texture_normal = new_texture

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)


=====================================
FILE: ./src/ui/screens/sound_menu/sound_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bapc10ey0j27g"]

[ext_resource type="Script" path="res://src/ui/screens/sound_menu/sound_menu.gd" id="1_sound_script"]

[node name="SoundMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_sound_script")

=====================================
FILE: ./src/ui/screens/victory_screen/victory_screen.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cx6i2wt2j05y4"]

[ext_resource type="Script" path="res://src/ui/screens/victory_screen/victory_screen.gd" id="1_vsscr"]

[sub_resource type="LabelSettings" id="LabelSettings_1"]
font_size = 96
font_color = Color(0.2, 0.8, 0.2, 1)

[node name="VictoryScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_vsscr")

[node name="VBoxContainer" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="VBoxContainer"]
layout_mode = 2
text = "VICTORY"
label_settings = SubResource("LabelSettings_1")
horizontal_alignment = 1

[node name="ReturnButton" type="TextureButton" parent="VBoxContainer"]
layout_mode = 2

=====================================
FILE: ./src/ui/screens/victory_screen/victory_screen.gd
=====================================
# src/ui/screens/victory_screen/victory_screen.gd
#
# This screen is shown when the player defeats the boss.
extends Control

@onready var return_button: TextureButton = $VBoxContainer/ReturnButton

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	# Configure the button and connect its signal.
	return_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	return_button.pressed.connect(_on_return_button_pressed)

	# Set up the menu manager for keyboard/controller navigation.
	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(return_button, "BACK")])

func _on_return_button_pressed():
	get_tree().change_scene_to_file(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/ui/screens/title_screen/title_screen.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cglqfxtqgxwul"]

[ext_resource type="Script" path="res://src/ui/screens/title_screen/title_screen.gd" id="1_title_script"]

[node name="TitleScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_title_script")

=====================================
FILE: ./src/ui/screens/title_screen/title_screen.gd
=====================================
# src/ui/screens/title_screen/title_screen.gd
#
# This script controls the main title screen. It displays the game title, menu
# buttons, plays the title music, and sets up menu navigation.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	await get_tree().process_frame
	AudioManager.play_music(AssetPaths.AUDIO_MUSIC_TITLE)

	var title_graphic = TextureRect.new()
	title_graphic.texture = load(AssetPaths.SPRITE_TITLE)
	add_child(title_graphic)
	title_graphic.position = Vector2((get_viewport_rect().size.x - title_graphic.size.x) / 2, 220)

	var start_button = TextureButton.new()
	start_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_START)
	add_child(start_button)
	start_button.position = Vector2((get_viewport_rect().size.x - start_button.size.x) / 2, 450)

	var options_button = TextureButton.new()
	options_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_OPTIONS)
	add_child(options_button)
	options_button.position = Vector2((get_viewport_rect().size.x - options_button.size.x) / 2, 600)

	start_button.pressed.connect(_on_start_button_pressed)
	options_button.pressed.connect(_on_options_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	
	var menu_items = [
		MenuManager.MenuItem.new(start_button, "START"),
		MenuManager.MenuItem.new(options_button, "SELECT")
	]
	menu.setup_menu(menu_items)

# --- MODIFIED FUNCTION ---
func _on_start_button_pressed():
	# Step 1: Tell the GameManager which level we want to play.
	GameManager.current_encounter_script_path = AssetPaths.SCRIPT_ARENA_00_ENCOUNTER
	
	# Step 2: Transition to the generic loading screen directly.
	get_tree().change_scene_to_file(AssetPaths.SCENE_LOADING_SCREEN)

func _on_options_button_pressed():
	# Changed to direct scene change for consistency.
	get_tree().change_scene_to_file(AssetPaths.SCENE_OPTIONS_MENU)


=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.gd
=====================================
# src/ui/components/custom_slider/custom_slider.gd
#
# A self-contained, reusable custom slider component. It emits a 'value_changed'
# signal that the parent menu (SoundMenu) listens for.
extends TextureRect

signal value_changed(value)

var knob: TextureRect
var is_dragging = false
var min_x = 0.0
var max_x = 0.0
var drag_offset = 0.0
var _initial_value = -1.0

func _ready():
	# Load textures using safe paths from the AssetPaths singleton.
	self.texture = load(AssetPaths.SPRITE_SLIDER_TRACK)
	
	knob = TextureRect.new()
	knob.texture = load(AssetPaths.SPRITE_SLIDER_KNOB)
	add_child(knob)
	
	# Connect signals for mouse interaction.
	knob.mouse_entered.connect(_on_knob_mouse_entered)
	knob.mouse_exited.connect(_on_knob_mouse_exited)
	
	# Wait for the node's size and position to be finalized before calculating bounds.
	await get_tree().process_frame
	
	knob.position.y = (size.y - knob.size.y) / 2
	min_x = global_position.x
	max_x = global_position.x + size.x - knob.size.x
	
	if _initial_value >= 0.0:
		var new_x_pos = min_x + (max_x - min_x) * _initial_value
		# 'clamp' ensures the value stays within the min/max range.
		knob.global_position.x = clamp(new_x_pos, min_x, max_x)

# Public function called by the Sound Menu to set the initial volume.
func set_value(initial_value: float):
	_initial_value = initial_value

func _process(_delta):
	# This code only runs if the user is actively dragging the knob.
	if is_dragging:
		var global_mouse_pos = get_global_mouse_position()
		# Move the knob to follow the mouse, but clamped within the slider's bounds.
		knob.global_position.x = clamp(global_mouse_pos.x - drag_offset, min_x, max_x)
		
		if (max_x - min_x) > 0:
			# Calculate the current value as a fraction (0.0 to 1.0).
			var current_value = (knob.global_position.x - min_x) / (max_x - min_x)
			# Emit our custom signal, sending the new value to the sound menu.
			emit_signal("value_changed", current_value)

# This function handles mouse clicks on the slider track.
func _gui_input(event):
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		var knob_rect = knob.get_global_rect()
		
		if event.is_pressed():
			# Check if the click was on the knob to initiate dragging.
			if knob_rect.has_point(event.global_position):
				is_dragging = true
				# Calculate offset to make dragging feel smooth and natural.
				drag_offset = event.global_position.x - knob.global_position.x
		else:
			# When the button is released, stop dragging.
			is_dragging = false
			# Reset the cursor if the mouse is no longer over the knob.
			if not knob_rect.has_point(get_global_mouse_position()):
				CursorManager.set_pointer_state(false)
			drag_offset = 0.0

func _on_knob_mouse_entered():
	CursorManager.set_pointer_state(true)

func _on_knob_mouse_exited():
	# Only reset the cursor if we are NOT currently dragging the knob.
	# This prevents the cursor from flickering while dragging.
	if not is_dragging:
		CursorManager.set_pointer_state(false)

=====================================
FILE: ./src/scenes/loading/loading_screen.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://loading_screen_scene_id"]

[ext_resource type="Script" path="res://src/scenes/loading/loading_screen.gd" id="1_loading_script"]

[node name="LoadingScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_loading_script")

[node name="ColorRect" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="Label" type="Label" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -75.0
offset_top = -16.5
offset_right = 75.0
offset_bottom = 16.5
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 30
text = "Loading..."
horizontal_alignment = 1
vertical_alignment = 1

[node name="ShaderPrewarmViewport" type="SubViewportContainer" parent="."]
custom_minimum_size = Vector2(1, 1)
layout_mode = 0
offset_left = -10.0
offset_top = -10.0
offset_right = -9.0
offset_bottom = -9.0
stretch = true

[node name="SubViewport" type="SubViewport" parent="ShaderPrewarmViewport"]
handle_input_locally = false
size = Vector2i(1, 1)
render_target_update_mode = 4

=====================================
FILE: ./src/scenes/loading/loading_screen.gd
=====================================
# src/scenes/loading/loading_screen.gd
#
# This script handles the pre-building of the level AND pre-warming shaders
# to prevent stuttering. It calls the ArenaBuilder to construct the level
# in memory and flashes key entities in an off-screen viewport.
extends Control

# --- Node References ---
@onready var prewarm_viewport: SubViewport = $ShaderPrewarmViewport/SubViewport

# An array of scenes with unique shaders we want to pre-compile.
# This makes it easy to add new enemies or effects in the future.
const SHADER_PREWARM_SCENES = [
	AssetPaths.SCENE_PLAYER,
	AssetPaths.SCENE_BASE_BOSS,
	AssetPaths.SCENE_PLAYER_SHOT,
	AssetPaths.SCENE_BOSS_SHOT
]

func _ready():
	if GameManager.current_encounter_script_path.is_empty():
		print("ERROR: No encounter script specified in GameManager. Returning to title.")
		get_tree().change_scene_to_file(AssetPaths.SCENE_TITLE_SCREEN)
		return

	# Start the full asynchronous loading process.
	_load_level()

func _load_level():
	# Yield to make sure the "Loading..." text renders before we start heavy work.
	await get_tree().process_frame
	
	# --- NEW: Pre-warm shaders ---
	await _prewarm_shaders()
	
	# Tell the ArenaBuilder to construct the level asynchronously.
	GameManager.prebuilt_level = await ArenaBuilder.build_level_async()
	
	# Yield to ensure all creation processes are finalized before we switch.
	await get_tree().process_frame
	
	# Proceed to the main game scene.
	get_tree().change_scene_to_file(AssetPaths.SCENE_GAME)

# --- NEW FUNCTION ---
# This function forces the compilation of shaders by briefly instantiating
# and rendering key game objects in an invisible, off-screen viewport.
func _prewarm_shaders() -> void:
	print("Starting shader pre-warming...")
	for scene_path in SHADER_PREWARM_SCENES:
		var instance = load(scene_path).instantiate()
		
		# Add the object to our off-screen viewport.
		prewarm_viewport.add_child(instance)
		
		# CRITICAL STEP: Wait for the next frame. This gives the rendering server
		# time to process the new object and compile its shader if it hasn't already.
		await get_tree().process_frame
		
		# Now that the shader is compiled and cached by the engine,
		# we can safely remove the temporary instance.
		instance.queue_free()
	
	print("Shader pre-warming complete.")


=====================================
FILE: ./src/scenes/game/game.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://game_scene_unique_id"]

[ext_resource type="Script" path="res://src/scenes/game/game.gd" id="1_game_script"]

[node name="Game" type="Node"]
script = ExtResource("1_game_script")

=====================================
FILE: ./src/scenes/game/game.gd
=====================================
# src/scenes/game/game.gd
#
# This script orchestrates the setup of an arena battle. It now also manages
# the overall game flow by listening for signals from the player and boss.
extends Node

var player_node: Node = null
var boss_node: Node = null

func _ready():
	if GameManager.prebuilt_level:
		add_child(GameManager.prebuilt_level)
		GameManager.prebuilt_level = null
		await get_tree().process_frame
	elif not GameManager.current_encounter_script_path.is_empty():
		var level_container = await ArenaBuilder.build_level_async()
		add_child(level_container)
		await get_tree().process_frame
	else:
		print("ERROR: Game scene loaded without a pre-built level or encounter path. Returning to title.")
		get_tree().change_scene_to_file(AssetPaths.SCENE_TITLE_SCREEN)
		return
	
	player_node = get_tree().get_first_node_in_group("player")
	boss_node = get_tree().get_first_node_in_group("enemy")

	# --- Connect signals to the correct handler functions ---
	if is_instance_valid(player_node):
		player_node.died.connect(_on_player_died)
	if is_instance_valid(boss_node):
		boss_node.died.connect(_on_boss_died)

# --- Signal Handlers for Game Flow ---

func _on_player_died():
	print("Game Manager: Player death detected. Initiating Game Over.")
	# FIX: Defer the scene change to prevent physics crash.
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_GAME_OVER_SCREEN)

func _on_boss_died():
	print("Game Manager: Boss death detected. Initiating Victory.")
	# FIX: Defer the scene change to prevent physics crash.
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_VICTORY_SCREEN)


func _exit_tree():
	# CRITICAL: Unpause the game when this scene is exited.
	get_tree().paused = false


=====================================
FILE: ./src/scenes/main/main.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bt1c5p8wphc4a"]

[ext_resource type="Script" uid="uid://coxyesem6rn3k" path="res://src/scenes/main/main.gd" id="1_main_script"]

[node name="Main" type="Node"]
script = ExtResource("1_main_script")


=====================================
FILE: ./src/scenes/main/main.gd
=====================================
# src/scenes/main/main.gd
# This is the main entry point for the game, as defined in project.godot.
# Its only job is to immediately load and switch to the first real scene,
# which is our title screen.
extends Node

func _ready():
	# Using AssetPaths makes this transition type-safe and easy to manage.
	# CRITICAL FIX: 'call_deferred' is REQUIRED here. The main scene cannot be
	# replaced immediately in its own _ready function, as the scene tree is
	# busy being set up. This defers the change to a safe point after the
	# current frame's processing.
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/core/settings.gd
=====================================
# src/core/settings.gd
#
# This script is a "Singleton" (also known as an "Autoload" in Godot).
# A singleton is a script that Godot loads once at the very start of the game
# and is always available globally. We can access its variables from any other
# script in the project, which makes it perfect for managing game-wide settings.
#
# We defined this as a singleton in: Project -> Project Settings -> Autoload
extends Node

# --- Audio Settings ---
# These variables store the current sound settings for the game.
# The '@export' keyword tells Godot to show this variable in the Inspector panel
# when this node is viewed in the editor. While we don't edit it there for a
# singleton, it's a common way to mark important, configurable variables.

# A 'float' is a number that can have a decimal point (e.g., 0.5, 1.0).
# Volume values typically range from 0.0 (silent) to 1.0 (full volume).
@export var master_volume: float = 1.0
@export var music_volume: float = 1.0
@export var sfx_volume: float = 1.0

# A 'bool' is a boolean value, which can only be 'true' or 'false'.
# We use these to track whether a sound category is muted.
@export var master_muted: bool = false
@export var music_muted: bool = true # Start with music muted by default.
@export var sfx_muted: bool = false

=====================================
FILE: ./src/core/builders/level_parser.gd
=====================================
# src/core/builders/level_parser.gd
#
# Responsibility: To parse the raw data from layout and encounter scripts and
# organize it into a structured LevelBuildData object. This class does not
# create any nodes; it only processes data.
class_name LevelParser
extends RefCounted

# FIX: Removed redundant preload. We can now use the global class name directly.

# The single public method of this class. It takes the instantiated arena
# scripts and returns a complete LevelBuildData resource.
func parse_level_data(layout_script: Object, encounter_script: Object) -> LevelBuildData:
	var data = LevelBuildData.new()
	data.encounter_script_object = encounter_script

	for y in range(layout_script.TERRAIN_DATA.size()):
		var row_string: String = layout_script.TERRAIN_DATA[y]
		for x in range(row_string.length()):
			var tile_char: String = row_string[x]
			var tile_pos := Vector2(x * Constants.TILE_SIZE, y * Constants.TILE_SIZE) + Vector2(Constants.TILE_SIZE / 2.0, Constants.TILE_SIZE / 2.0)

			match tile_char:
				'#':
					data.terrain_tiles.append(tile_pos)
				'-':
					data.oneway_platforms.append(tile_pos)
				'^':
					data.hazard_tiles.append(tile_pos)
				_:
					if tile_char == encounter_script.PLAYER_SPAWN_MARKER:
						data.player_spawn_pos = tile_pos
					elif tile_char == encounter_script.BOSS_SPAWN_MARKER:
						data.boss_spawn_pos = tile_pos
	
	return data


=====================================
FILE: ./src/core/builders/terrain_builder.gd
=====================================
# src/core/builders/terrain_builder.gd
#
# Responsibility: To create all static level geometry (solid tiles,
# one-way platforms, hazards) based on parsed LevelBuildData.
class_name TerrainBuilder
extends RefCounted

# The main public method. It takes the parent node, the data, and a valid
# SceneTree reference, then builds the tiles asynchronously in batches.
func build_terrain_async(parent_node: Node, build_data: LevelBuildData, tree: SceneTree) -> void:
	const BATCH_SIZE = 20 # How many tiles to create before yielding a frame.

	for i in range(build_data.terrain_tiles.size()):
		_create_solid_tile(parent_node, build_data.terrain_tiles[i])
		if i % BATCH_SIZE == 0:
			await tree.process_frame

	for i in range(build_data.oneway_platforms.size()):
		_create_oneway_platform(parent_node, build_data.oneway_platforms[i])
		if i % BATCH_SIZE == 0:
			await tree.process_frame

	for i in range(build_data.hazard_tiles.size()):
		_create_hazard_tile(parent_node, build_data.hazard_tiles[i])
		if i % BATCH_SIZE == 0:
			await tree.process_frame
	
	await tree.process_frame

# --- Tile Creation Functions (Moved from ArenaBuilder) ---

func _create_solid_tile(parent_node: Node, pos: Vector2) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = 2 # 'world' layer
	static_body.add_to_group("world")
	
	var collision_shape := CollisionShape2D.new()
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	
	static_body.add_child(collision_shape)
	parent_node.add_child(static_body)

func _create_oneway_platform(parent_node: Node, pos: Vector2) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = 2 # 'world' layer
	static_body.add_to_group("world")
	static_body.add_to_group("oneway_platforms")
	
	var collision_shape := CollisionShape2D.new()
	collision_shape.one_way_collision = true
	collision_shape.position.y = -(Constants.TILE_SIZE / 2.0) + 5
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, 10)
	collision_shape.shape = rectangle_shape
	
	static_body.add_child(collision_shape)
	parent_node.add_child(static_body)

func _create_hazard_tile(parent_node: Node, pos: Vector2) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = 10 # world | hazard
	static_body.add_to_group("world")
	static_body.add_to_group("hazard")
	
	var collision_shape := CollisionShape2D.new()
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	
	static_body.add_child(collision_shape)
	parent_node.add_child(static_body)


=====================================
FILE: ./src/core/builders/level_build_data.gd
=====================================
# src/core/builders/level_build_data.gd
#
# A custom Resource script that acts as a data container. Its only purpose is to
# hold all the parsed information about a level in one clean, portable object.
# This prevents us from having to pass many individual arrays and variables between
# our different builder classes.
class_name LevelBuildData
extends Resource

var terrain_tiles: Array[Vector2] = []
var oneway_platforms: Array[Vector2] = []
var hazard_tiles: Array[Vector2] = []
var player_spawn_pos: Vector2 = Vector2.ZERO
var boss_spawn_pos: Vector2 = Vector2.ZERO
var encounter_script_object: Object = null

=====================================
FILE: ./src/core/builders/encounter_director.gd
=====================================
# src/core/builders/encounter_director.gd
#
# Responsibility: To spawn all dynamic entities (Player, Boss, HUD) based on
# the parsed LevelBuildData.
class_name EncounterDirector
extends RefCounted

# The main public method. It takes the parent node, the data, and a valid
# SceneTree reference, then spawns the entities asynchronously.
func spawn_entities_async(parent_node: Node, build_data: LevelBuildData, tree: SceneTree) -> void:
	await _spawn_player_async(parent_node, build_data.player_spawn_pos, tree)
	await _spawn_boss_async(parent_node, build_data.boss_spawn_pos, build_data.encounter_script_object, tree)
	await _spawn_hud_async(parent_node, tree)

# --- Entity Spawning Functions (Moved from ArenaBuilder) ---

func _spawn_player_async(parent_node: Node, pos: Vector2, tree: SceneTree):
	var player_instance = load(AssetPaths.SCENE_PLAYER).instantiate()
	player_instance.global_position = pos
	parent_node.add_child(player_instance)
	await tree.process_frame

func _spawn_boss_async(parent_node: Node, pos: Vector2, encounter: Object, tree: SceneTree):
	var boss_scene: PackedScene = encounter.BOSS_SCENE if encounter else null
	if not boss_scene:
		push_error("EncounterDirector: Could not find BOSS_SCENE in encounter script.")
		return
		
	var boss_instance = boss_scene.instantiate()
	boss_instance.global_position = pos
	parent_node.add_child(boss_instance)
	await tree.process_frame

func _spawn_hud_async(parent_node: Node, tree: SceneTree):
	var hud_instance = load(AssetPaths.SCENE_GAME_HUD).instantiate()
	parent_node.add_child(hud_instance)
	await tree.process_frame

=====================================
FILE: ./src/core/game_manager.gd
=====================================
# src/core/game_manager.gd
#
# A simple singleton to manage the state of the game session, such as
# which level is currently being loaded or played.
extends Node

# This variable will hold the resource path to the encounter script for the
# level that the player has chosen to play.
var current_encounter_script_path: String = ""

# --- NEW VARIABLE ---
# This will hold the fully constructed, but currently hidden, level node.
var prebuilt_level: Node = null

=====================================
FILE: ./src/core/arena_builder.gd
=====================================
# src/core/arena_builder.gd
#
# This singleton is now a high-level "Coordinator". Its single responsibility
# is to manage the overall process of level construction by delegating tasks
# to specialized builder classes.
extends Node

# This function is now much cleaner and easier to read. It's a clear,
# step-by-step recipe for building a level.
func build_level_async() -> Node:
	var level_container := Node.new()
	level_container.name = "LevelContainer"

	# --- 1. Load Raw Data ---
	var encounter_path: String = GameManager.current_encounter_script_path
	if encounter_path.is_empty():
		push_error("ArenaBuilder: No encounter script specified in GameManager.")
		return level_container
		
	var layout_path: String = encounter_path.replace("encounter.gd", "layout.gd")
	var layout_script: Script = load(layout_path)
	var encounter_script: Script = load(encounter_path)

	if not layout_script or not encounter_script:
		push_error("ArenaBuilder: Failed to load layout or encounter script.")
		return level_container

	# --- 2. Parse Data ---
	var parser = LevelParser.new()
	var build_data = parser.parse_level_data(layout_script.new(), encounter_script.new())
	
	await get_tree().process_frame

	# --- 3. Build Terrain ---
	var terrain_builder = TerrainBuilder.new()
	# FIX: Pass the SceneTree reference to the builder.
	await terrain_builder.build_terrain_async(level_container, build_data, get_tree())

	# --- 4. Spawn Entities ---
	var encounter_director = EncounterDirector.new()
	# FIX: Pass the SceneTree reference to the director.
	await encounter_director.spawn_entities_async(level_container, build_data, get_tree())

	# --- 5. Finalize ---
	await get_tree().process_frame
	
	return level_container


=====================================
FILE: ./src/core/audio_manager.gd
=====================================
# src/core/audio_manager.gd
#
# This singleton is responsible for all audio playback. By centralizing all
# audio logic here, any other script can simply call `AudioManager.play_sfx()`
# without worrying about the implementation details.
extends Node

var sfx_players = []
var sfx_player_index = 0
var music_player: AudioStreamPlayer

func _ready():
	for i in range(Constants.NUM_SFX_PLAYERS):
		var player = AudioStreamPlayer.new()
		add_child(player)
		player.bus = "SFX"
		sfx_players.append(player)

	music_player = AudioStreamPlayer.new()
	add_child(music_player)
	music_player.bus = "Music"

func _process(_delta):
	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Master"), linear_to_db(Settings.master_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Master"), Settings.master_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Music"), linear_to_db(Settings.music_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Music"), Settings.music_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("SFX"), linear_to_db(Settings.sfx_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("SFX"), Settings.sfx_muted)

# --- Public Functions ---

func play_sfx(sound_path: String):
	var player = sfx_players[sfx_player_index]
	player.stream = load(sound_path)
	player.play()
	sfx_player_index = (sfx_player_index + 1) % Constants.NUM_SFX_PLAYERS

func play_music(music_path: String):
	# ROBUSTNESS FIX: Check the resource path instead of the instance.
	# This correctly prevents the music from restarting if it's already playing.
	if music_player.stream and music_player.stream.resource_path == music_path and music_player.playing:
		return

	music_player.stream = load(music_path)
	music_player.play()

func stop_music():
	music_player.stop()

=====================================
FILE: ./src/core/cursor_manager.gd
=====================================
# src/core/cursor_manager.gd
#
# This singleton manages the game's custom "fake" cursor, giving us full
# control over its appearance on all platforms. It draws on a high layer
# to ensure it's always on top of other UI and game elements.
extends CanvasLayer

var cursor_sprite: TextureRect

# We preload our cursor images using the AssetPaths singleton for safety and clarity.
const CURSOR_DEFAULT = preload(AssetPaths.SPRITE_CURSOR_DEFAULT)
const CURSOR_POINTER = preload(AssetPaths.SPRITE_CURSOR_POINTER)

func _ready():
	# A high layer number ensures the cursor renders above everything else.
	layer = 10
	# Hide the computer's default mouse cursor.
	Input.set_mouse_mode(Input.MOUSE_MODE_HIDDEN)

	cursor_sprite = TextureRect.new()
	cursor_sprite.texture = CURSOR_DEFAULT

	# CRITICAL: This makes our cursor sprite "click-through," so it never
	# blocks mouse events intended for buttons or objects underneath it.
	cursor_sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE

	add_child(cursor_sprite)

func _process(_delta):
	# On every frame, our custom cursor's position is synced to the real mouse position.
	cursor_sprite.position = get_viewport().get_mouse_position()

# Public function to change the cursor's appearance (e.g., when hovering a button).
func set_pointer_state(is_pointing: bool):
	if is_pointing:
		cursor_sprite.texture = CURSOR_POINTER
	else:
		cursor_sprite.texture = CURSOR_DEFAULT

=====================================
FILE: ./src/core/asset_paths.gd
=====================================
# src/core/asset_paths.gd
#
# This singleton provides a central registry for all asset file paths.
# If an asset is moved or renamed, we only need to update the path in this
# one file, preventing broken references throughout the project.
extends Node

# --- Scenes ---
const SCENE_MAIN = "res://src/scenes/main/main.tscn"
const SCENE_GAME = "res://src/scenes/game/game.tscn"
const SCENE_GAME_HUD = "res://src/ui/game_hud/game_hud.tscn"
const SCENE_GAME_OVER_SCREEN = "res://src/ui/screens/game_over_screen/game_over_screen.tscn" # <-- NEW
const SCENE_VICTORY_SCREEN = "res://src/ui/screens/victory_screen/victory_screen.tscn" # <-- NEW
const SCENE_LOADING_SCREEN = "res://src/scenes/loading/loading_screen.tscn"
const SCENE_TITLE_SCREEN = "res://src/ui/screens/title_screen/title_screen.tscn"
const SCENE_OPTIONS_MENU = "res://src/ui/screens/options_menu/options_menu.tscn"
const SCENE_SOUND_MENU = "res://src/ui/screens/sound_menu/sound_menu.tscn"
const SCENE_CONTROLS_MENU = "res://src/ui/screens/controls_menu/controls_menu.tscn"
const SCENE_CREDITS_MENU = "res://src/ui/screens/credits_menu/credits_menu.tscn"
const SCENE_PLAYER = "res://src/entities/player/player.tscn"
const SCENE_BASE_BOSS = "res://src/entities/boss/base_boss.tscn"
const SCENE_PLAYER_SHOT = "res://src/projectiles/player_shot.tscn"
const SCENE_BOSS_SHOT = "res://src/projectiles/boss_shot.tscn"

# --- Scripts ---
const SCRIPT_MENU_MANAGER = "res://src/ui/menu_manager/menu_manager.gd"
const SCRIPT_CUSTOM_SLIDER = "res://src/ui/components/custom_slider/custom_slider.gd"
const SCRIPT_ARENA_00_LAYOUT = "res://src/arenas/arena_00_layout.gd"
const SCRIPT_ARENA_00_ENCOUNTER = "res://src/arenas/arena_00_encounter.gd"

# --- Audio ---
const AUDIO_MUSIC_TITLE = "res://assets/audio/music/title-screen-loop.mp3"
const AUDIO_SFX_MENU_BACK = "res://assets/audio/sfx/menu-back.mp3"
const AUDIO_SFX_MENU_ERROR = "res://assets/audio/sfx/menu-error.mp3"
const AUDIO_SFX_MENU_MOVE = "res://assets/audio/sfx/menu-move.mp3"
const AUDIO_SFX_MENU_SELECT = "res://assets/audio/sfx/menu-select.mp3"
const AUDIO_SFX_START_CHIME = "res://assets/audio/sfx/start-chime.mp3"

# --- Fonts ---
const FONT_BLACK = "res://assets/fonts/MPLUSRounded1c-Black.ttf"
const FONT_BOLD = "res://assets/fonts/MPLUSRounded1c-Bold.ttf"
const FONT_REGULAR = "res://assets/fonts/MPLUSRounded1c-Regular.ttf"

# --- UI Sprites ---
const SPRITE_TITLE = "res://assets/sprites/ui/title/box_battle_title.png"
const SPRITE_MENU_CURSOR = "res://assets/sprites/ui/menu/menu-cursor.png"
const SPRITE_MENU_ITEM_START = "res://assets/sprites/ui/menu/menu-item-start.png"
const SPRITE_MENU_ITEM_OPTIONS = "res://assets/sprites/ui/menu/menu-item-options.png"
const SPRITE_MENU_ITEM_SOUND = "res://assets/sprites/ui/menu/menu-item-sound.png"
const SPRITE_MENU_ITEM_CONTROLS = "res://assets/sprites/ui/menu/menu-item-controls.png"
const SPRITE_MENU_ITEM_CREDITS = "res://assets/sprites/ui/menu/menu-item-credits.png"
const SPRITE_MENU_ITEM_BACK = "res://assets/sprites/ui/menu/menu-item-back.png"
const SPRITE_CURSOR_DEFAULT = "res://assets/sprites/ui/cursors/cursor_default.png"
const SPRITE_CURSOR_POINTER = "res://assets/sprites/ui/cursors/cursor_pointer.png"
const SPRITE_SLIDER_TRACK = "res://assets/sprites/ui/slider/slider-track.png"
const SPRITE_SLIDER_KNOB = "res://assets/sprites/ui/slider/slider-knob.png"
const SPRITE_CHECKBOX_CHECKED = "res://assets/sprites/ui/checkbox/checkbox-checked.png"
const SPRITE_CHECKBOX_UNCHECKED = "res://assets/sprites/ui/checkbox/checkbox-unchecked.png"
const SPRITE_ICON_SOUND_ON = "res://assets/sprites/ui/icons/icon-sound-on.png"
const SPRITE_ICON_SOUND_OFF = "res://assets/sprites/ui/icons/icon-sound-off.png"

=====================================
FILE: ./src/core/constants.gd
=====================================
# src/core/constants.gd
#
# This singleton holds global game design constants. Centralizing these values
# makes it much easier to balance and tune the game's feel without having to
# hunt through multiple files.
extends Node

# --- Audio ---
const NUM_SFX_PLAYERS = 8 # The number of sound effects that can play at once.

# --- Arena Design ---
const TILE_SIZE = 50

# --- General Physics ---
const GRAVITY = 1200.0

# --- Player Physics ---
const PLAYER_SPEED = 450.0
const PLAYER_JUMP_FORCE = 680.0
const POGO_FORCE = 450.0
const COYOTE_TIME = 0.1
const JUMP_BUFFER = 0.1
const JUMP_RELEASE_DAMPENER = 0.4
const WALL_COYOTE_TIME = 0.05
const FAST_FALL_GRAVITY_MULTIPLIER = 1.4
# Set to 0 to disable double jump for testing. Set back to 1 to re-enable.
const MAX_AIR_JUMPS = 0
const DASH_SPEED = 1400.0
const DASH_DURATION = 0.15
const DASH_COOLDOWN = 0.5
const WALL_SLIDE_SPEED = 120.0
const WALL_JUMP_FORCE_X = 1650.0
const WALL_JUMP_FORCE_Y = 680.0

# --- Player Combat & Health ---
const PLAYER_MAX_HEALTH = 5
const PLAYER_HEAL_DURATION = 2.0 # How many seconds it takes to heal.
const PLAYER_MAX_HEALING_CHARGES = 1 # The maximum number of heal charges the player can store.
const ATTACK_COOLDOWN = 0.12
const CHARGE_TIME = 0.35
const ATTACK_DURATION = 0.1
const PLAYER_ATTACK_FRICTION = 2000.0
const KNOCKBACK_SPEED = 700.0
const KNOCKBACK_DURATION = 0.1
const HAZARD_KNOCKBACK_SPEED = 400.0
const DETERMINATION_PER_CHARGE = 10
const PLAYER_INVINCIBILITY_DURATION = 1.5

# --- Boss Stats ---
const BOSS_HEALTH = 30

=====================================
FILE: ./src/arenas/arena_00_layout.gd
=====================================
# src/arenas/arena_00_layout.gd
#
# This file defines the physical terrain for Arena 00.
# It is a simple, open box for testing and debugging.
extends Node

# --- COORDINATE LEGEND ---
#
#    A B C D E F G H I J K L M N O P Q R S T
# 1  # # # # # # # # # # # # # # # # # # # #
# 2  # . . . . . . . . . . . . . . . . . . #
# 3  # . . . . @ . . . . . . . . . . . . . #
# 4  # . . . . . . . . . . . . & . . . . . #
# 5  # . . . . . . . . . # - - # . . . . . #
# 6  # . . . . . . . . . # . . # . . . . . #
# 7  # . . . . . . . . . # - - # . . . . . #
# 8  # . . . . . . . . . # . . # . . . . . #
# 9  # . . . . . . . . . # . . # . . . . . #
# 10 # . . . . . . . . . # . . # . . . . . #
# 11 # . . . . . . . . . . . . . . . . . . #
# 12 # . . . . . . . . . . . . . . . . . . #
# 13 # . . . . . . . . . # # # # . . . . . #
# 14 # . . . . . . . . . # # # # . . . . . #
# 15 # . . . . . . . . . # # # # . . . . . #
# 16 # # # # . . . . . . # # # # . . . . . #
# 17 # # # # . . . . . . # # # # . . . . . #
# 18 # # # # . . . . . . . . . . . . . . . #
# 19 # . . . . . . . . . . . . . . . . . . #
# 20 # # # # # # # # # # # # # # # ^ ^ ^ # #
#
# --- TERRAIN LEGEND ---
# # = Solid Wall/Floor
# - = Oneway Platform
# ^ = Hazard
# . = Empty Space
#
# --- ENTITY MARKERS (For visual reference only) ---
# @ = Player Spawn
# & = Boss Spawn
#
const TERRAIN_DATA = [
	"####################", # 1
	"#..................#", # 2
	"#....@.............#", # 3
	"#............&.....#", # 4
	"#.........#--#.....#", # 5
	"#.........#..#.....#", # 6
	"#.........#--#.....#", # 7
	"#.........#..#.....#", # 8
	"#.........#..#.....#", # 9
	"#.........#..#.....#", # 10
	"#..................#", # 11
	"#..................#", # 12
	"#.........####.....#", # 13
	"#.........####.....#", # 14
	"#.........####.....#", # 15
	"####......####.....#", # 16
	"####......####.....#", # 17
	"####...............#", # 18
	"#..................#", # 19
	"###############^^^##"  # 20
]


=====================================
FILE: ./src/arenas/arena_00_encounter.gd
=====================================
# src/arenas/arena_00_encounter.gd
#
# This file defines the dynamic entities and patterns for Arena 00.
# It acts as a "level script" or "director" for the fight.
extends Node

# --- BOSS DATA ---
# Preload the boss scene using the safe path from our singleton.
const BOSS_SCENE = preload(AssetPaths.SCENE_BASE_BOSS)
# The character in the layout that marks the boss's spawn point.
const BOSS_SPAWN_MARKER = "&"

# --- PLAYER DATA ---
const PLAYER_SPAWN_MARKER = "@"

=====================================
FILE: ./src/projectiles/player_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cmdkxwvysirh1"]

[ext_resource type="Script" path="res://src/projectiles/player_shot.gd" id="1_4wg7x"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playershot"]
size = Vector2(40, 40)

[node name="PlayerShot" type="Area2D"]
collision_layer = 0
collision_mask = 22
script = ExtResource("1_4wg7x")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.5, 0.8, 1, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playershot")

=====================================
FILE: ./src/projectiles/boss_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cxnmr7yrvchve"]

[ext_resource type="Script" path="res://src/projectiles/boss_shot.gd" id="1_4qgog"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossshot"]
size = Vector2(60, 60)

[node name="BossShot" type="Area2D"]
collision_layer = 16
collision_mask = 0
script = ExtResource("1_4qgog")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.8, 0.4, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossshot")

=====================================
FILE: ./src/projectiles/player_shot.gd
=====================================
# src/projectiles/player_shot.gd
#
# Controls the behavior of the player's charged projectile.
extends Area2D

var direction = Vector2.RIGHT
var speed = 1000.0
var damage = 2 # Charged shots do more damage than melee

func _ready():
	# Connect signals to handle collisions with both solid bodies and other areas.
	body_entered.connect(_on_body_entered)
	area_entered.connect(_on_area_entered)

func _physics_process(delta):
	position += direction * speed * delta

func _on_body_entered(body):
	# Check if the body hit is an enemy.
	if body.is_in_group("enemy"):
		body.take_damage(damage)
		queue_free() # Destroy self on hit.
		return # Stop further processing.

	# Check if the body hit is part of the solid world.
	if body.is_in_group("world"):
		queue_free() # Destroy self on hitting a wall.

# This function is called when this projectile's area overlaps with another Area2D.
func _on_area_entered(area):
	# Check if the area we hit is an enemy projectile.
	if area.is_in_group("enemy_projectile"):
		# Destroy both this projectile and the enemy one.
		queue_free()
		area.queue_free()

=====================================
FILE: ./src/projectiles/boss_shot.gd
=====================================
# src/projectiles/boss_shot.gd
#
# Controls the behavior of the boss's projectile.
extends Area2D

var direction = Vector2.LEFT
var speed = 400.0

func _ready():
	# This projectile's purpose is to be detected by the player's hurtbox.
	# The physics layers are set in the scene file.
	add_to_group("enemy_projectile")

func _physics_process(delta):
	position += direction * speed * delta

# This function is not used because the projectile itself doesn't need to detect
# things. Instead, the player's hurtbox detects this projectile. We leave the
# Area2D's monitoring property on by default, but we don't connect its signals.

=====================================
FILE: ./src/entities/boss/base_boss.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://dmej4a7ykn2q0"]

[ext_resource type="Script" path="res://src/entities/boss/base_boss.gd" id="1_26qjf"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossbody"]
size = Vector2(60, 60)

[node name="BaseBoss" type="CharacterBody2D"]
collision_layer = 12
collision_mask = 3
script = ExtResource("1_26qjf")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.6, 0.6, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossbody")

[node name="CooldownTimer" type="Timer" parent="."]
wait_time = 1.5
one_shot = true

[node name="PatrolTimer" type="Timer" parent="."]
wait_time = 3.0
one_shot = true

[node name="HitFlashTimer" type="Timer" parent="."]
wait_time = 0.4
one_shot = true

[connection signal="timeout" from="CooldownTimer" to="." method="_on_cooldown_timer_timeout"]
[connection signal="timeout" from="PatrolTimer" to="." method="_on_patrol_timer_timeout"]
[connection signal="timeout" from="HitFlashTimer" to="." method="_on_hit_flash_timer_timeout"]

=====================================
FILE: ./src/entities/boss/states/state_boss_idle.gd
=====================================
# src/entities/boss/states/state_boss_idle.gd
# The state for when the boss is pausing before an attack.
extends "res://src/entities/boss/states/state_boss_base.gd"
class_name BossStateIdle

func enter(_msg := {}) -> void:
	boss.velocity.x = 0
	boss.change_state(boss.State.ATTACK)

func process_physics(_delta: float) -> void:
	# This state is instantaneous, so it does nothing in the physics process.
	pass


=====================================
FILE: ./src/entities/boss/states/state_boss_base.gd
=====================================
# src/entities/boss/states/state_boss_base.gd
# Base class / contract for all Boss states.
# Modeled after src/entities/player/states/state_base.gd
class_name BossState

var boss: CharacterBody2D

func _init(boss_node: CharacterBody2D) -> void:
	self.boss = boss_node

# Called when this state becomes active.
func enter(_msg := {}) -> void:
	pass

# Called when this state is being replaced by another state.
func exit() -> void:
	pass

# Main per-physics-frame update for the state.
func process_physics(_delta: float) -> void:
	pass

# Optional input handling for state-specific input semantics.
func process_input(_event: InputEvent) -> void:
	pass


=====================================
FILE: ./src/entities/boss/states/state_boss_cooldown.gd
=====================================
# src/entities/boss/states/state_boss_cooldown.gd
# The state for when the boss is waiting after an attack.
extends "res://src/entities/boss/states/state_boss_base.gd"
class_name BossStateCooldown

func enter(_msg := {}) -> void:
	boss.velocity.x = 0
	boss.cooldown_timer.start()

func process_physics(_delta: float) -> void:
	# The state itself does nothing; it's just waiting for the timer.
	pass


=====================================
FILE: ./src/entities/boss/states/state_boss_attack.gd
=====================================
# src/entities/boss/states/state_boss_attack.gd
# This state executes an attack and immediately transitions to Cooldown.
extends "res://src/entities/boss/states/state_boss_base.gd"
class_name BossStateAttack

func enter(_msg := {}) -> void:
	var attack_keys = boss.AttackPattern.keys()
	var chosen_attack_name = attack_keys[randi() % attack_keys.size()]
	boss.current_attack = boss.AttackPattern[chosen_attack_name]
	print("Boss chose attack: ", chosen_attack_name)
	
	match boss.current_attack:
		boss.AttackPattern.SINGLE_SHOT:
			boss.fire_shot_at_player()
		boss.AttackPattern.VOLLEY_SHOT:
			var tween = boss.get_tree().create_tween()
			tween.tween_callback(boss.fire_shot_at_player)
			tween.tween_interval(0.2)
			tween.tween_callback(boss.fire_shot_at_player)
			tween.tween_interval(0.2)
			tween.tween_callback(boss.fire_shot_at_player)
			
	boss.change_state(boss.State.COOLDOWN)

func process_physics(_delta: float) -> void:
	# This state is instantaneous, so it does nothing in the physics process.
	pass


=====================================
FILE: ./src/entities/boss/states/state_boss_patrol.gd
=====================================
# src/entities/boss/states/state_boss_patrol.gd
# The state responsible for the boss's back-and-forth movement.
extends "res://src/entities/boss/states/state_boss_base.gd"
class_name BossStatePatrol

func enter(_msg := {}) -> void:
	boss.patrol_timer.start()

func process_physics(_delta: float) -> void:
	boss.velocity.x = boss.facing_direction * boss.patrol_speed


=====================================
FILE: ./src/entities/boss/base_boss.gd
=====================================
# src/entities/boss/base_boss.gd
# This is the "Context" script for the Boss State Machine. It holds all
# shared data and delegates all per-frame logic to its current state object.
extends CharacterBody2D

# --- Signals ---
signal health_changed(current_health, max_health)
signal died

# --- State Machine Enum (Globally Accessible as BaseBoss.State) ---
enum State { IDLE, ATTACK, COOLDOWN, PATROL }
enum AttackPattern { SINGLE_SHOT, VOLLEY_SHOT }

# --- Node References ---
@onready var visual_sprite: ColorRect = $ColorRect
@onready var cooldown_timer: Timer = $CooldownTimer
@onready var patrol_timer: Timer = $PatrolTimer
@onready var hit_flash_timer: Timer = $HitFlashTimer

# --- Preloads ---
const BossShotScene = preload(AssetPaths.SCENE_BOSS_SHOT)
# REFINEMENT: Removed preload constants for states as they are now global classes.

# --- State Machine ---
var states: Dictionary
var current_state: BossState

# --- Boss Stats & Properties (Shared Data) ---
var health = Constants.BOSS_HEALTH
var player: CharacterBody2D = null
var facing_direction = -1.0
var patrol_speed = 100.0
var original_color: Color
var current_attack: AttackPattern

# --- Engine Functions ---
func _ready():
	add_to_group("enemy")
	original_color = visual_sprite.color
	player = get_tree().get_first_node_in_group("player")
	
	# REFINEMENT: Initialize states using their global class names.
	states = {
		State.IDLE: BossStateIdle.new(self),
		State.ATTACK: BossStateAttack.new(self),
		State.COOLDOWN: BossStateCooldown.new(self),
		State.PATROL: BossStatePatrol.new(self),
	}
	
	change_state(State.COOLDOWN)
	health_changed.emit(health, Constants.BOSS_HEALTH)

func _physics_process(delta):
	if not is_on_floor():
		velocity.y += Constants.GRAVITY * delta

	if current_state:
		current_state.process_physics(delta)
	
	move_and_slide()
	
	if states.find_key(current_state) == State.PATROL and is_on_wall():
		facing_direction *= -1.0

# --- State Management ---
func change_state(new_state_key: State):
	if not states.has(new_state_key):
		print("Boss state key not found: ", new_state_key)
		return
	if current_state == states[new_state_key]:
		return
		
	if current_state:
		current_state.exit()
	
	current_state = states[new_state_key]
	print("Boss entering state: ", State.keys()[new_state_key])
	current_state.enter()

# --- Helper Functions (used by states) ---
func _update_player_tracking():
	if is_instance_valid(player):
		var direction_to_player = player.global_position.x - global_position.x
		if not is_zero_approx(direction_to_player):
			facing_direction = sign(direction_to_player)
	self.scale.x = facing_direction
	
func fire_shot_at_player():
	if not is_instance_valid(player): return
	_update_player_tracking()
	var shot_instance = BossShotScene.instantiate()
	get_parent().add_child(shot_instance)
	shot_instance.global_position = global_position
	var direction_to_player = (player.global_position - global_position).normalized()
	shot_instance.direction = direction_to_player
	
func take_damage(damage_amount: int):
	health -= damage_amount
	health_changed.emit(health, Constants.BOSS_HEALTH)
	_trigger_hit_flash()
	print("Boss took ", damage_amount, " damage! Health remaining: ", health)
	if health <= 0:
		die()

func die():
	print("Boss has been defeated!")
	died.emit()
	queue_free()

func _trigger_hit_flash():
	visual_sprite.color = Color.DODGER_BLUE
	hit_flash_timer.start()

# --- Signal Callbacks (handle state transitions) ---
func _on_hit_flash_timer_timeout():
	visual_sprite.color = original_color

func _on_cooldown_timer_timeout():
	if states.find_key(current_state) == State.COOLDOWN:
		change_state(State.PATROL)

func _on_patrol_timer_timeout():
	if states.find_key(current_state) == State.PATROL:
		change_state(State.IDLE)


=====================================
FILE: ./src/entities/player/player.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://c6vknl71ea1bo"]

[ext_resource type="Script" path="res://src/entities/player/player.gd" id="1_4d1td"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerbody"]
size = Vector2(40, 40)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerhitbox"]
size = Vector2(40, 40)

[node name="Player" type="CharacterBody2D"]
collision_layer = 1
collision_mask = 14
script = ExtResource("1_4d1td")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.941176, 0.941176, 0.941176, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playerbody")

[node name="Hitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 20

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hitbox"]
shape = SubResource("RectangleShape2D_playerhitbox")
disabled = true

[node name="Hurtbox" type="Area2D" parent="."]
collision_layer = 64
collision_mask = 28

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hurtbox"]
shape = SubResource("RectangleShape2D_playerbody")

[node name="InvincibilityTimer" type="Timer" parent="."]
one_shot = true

[node name="HealingTimer" type="Timer" parent="."]
one_shot = true

[node name="HitFlashTimer" type="Timer" parent="."]
wait_time = 0.4
one_shot = true

[connection signal="timeout" from="InvincibilityTimer" to="." method="_on_invincibility_timer_timeout"]
[connection signal="timeout" from="HealingTimer" to="." method="_on_healing_timer_timeout"]
[connection signal="timeout" from="HitFlashTimer" to="." method="_on_hit_flash_timer_timeout"]

=====================================
FILE: ./src/entities/player/player.gd
=====================================
# src/entities/player/player.gd
# This script is the "Context" for the State Machine. Its primary jobs are to:
# 1. Hold all shared player data (health, velocity, timers, etc.).
# 2. Manage the transitions between states.
# 3. Provide centralized helper functions for states to use (DRY principle).
extends CharacterBody2D

# --- Signals ---
signal health_changed(current_health, max_health)
signal healing_charges_changed(current_charges)
signal died

# --- REFINEMENT: The State enum is now globally accessible via Player.State ---
enum State {MOVE, JUMP, FALL, DASH, WALL_SLIDE, ATTACK, HURT, HEAL}

# --- Node References ---
@onready var visual_sprite: ColorRect = $ColorRect
@onready var hitbox: Area2D = $Hitbox
@onready var hurtbox: Area2D = $Hurtbox
@onready var invincibility_timer: Timer = $InvincibilityTimer
@onready var healing_timer: Timer = $HealingTimer
@onready var hit_flash_timer: Timer = $HitFlashTimer
@onready var hitbox_shape: CollisionShape2D = $Hitbox/CollisionShape2D

# --- Preloads ---
const PlayerShotScene = preload(AssetPaths.SCENE_PLAYER_SHOT)
const MoveState = preload("res://src/entities/player/states/state_move.gd")
const FallState = preload("res://src/entities/player/states/state_fall.gd")
const JumpState = preload("res://src/entities/player/states/state_jump.gd")
const DashState = preload("res://src/entities/player/states/state_dash.gd")
const WallSlideState = preload("res://src/entities/player/states/state_wall_slide.gd")
const AttackState = preload("res://src/entities/player/states/state_attack.gd")
const HurtState = preload("res://src/entities/player/states/state_hurt.gd")
const HealState = preload("res://src/entities/player/states/state_heal.gd")

# --- State Machine ---
var states: Dictionary
var current_state: PlayerState
const ACTION_ALLOWED_STATES = [State.MOVE, State.FALL, State.JUMP, State.WALL_SLIDE]

# --- Player Stats & Timers (Shared Data) ---
var health = Constants.PLAYER_MAX_HEALTH
var air_jumps_left = 0
var coyote_timer = 0.0
var jump_buffer_timer = 0.0
var wall_coyote_timer = 0.0
var knockback_timer = 0.0
var is_invincible = false
var is_dash_invincible = false
var facing_direction = 1
var last_wall_normal = Vector2.ZERO
var determination_counter = 0
var healing_charges = 0
var dash_duration_timer = 0.0
var dash_cooldown_timer = 0.0
var attack_duration_timer = 0.0
var attack_cooldown_timer = 0.0
var is_charging = false
var charge_timer = 0.0
var is_pogo_attack = false
var can_dash = true
var original_color: Color

# --- Engine Functions ---
func _ready():
	add_to_group("player")
	original_color = visual_sprite.color
	hitbox.body_entered.connect(_on_hitbox_body_entered)
	hitbox.area_entered.connect(_on_hitbox_area_entered)
	hurtbox.area_entered.connect(_on_hurtbox_area_entered)
	health_changed.emit(health, Constants.PLAYER_MAX_HEALTH)
	healing_charges_changed.emit(healing_charges)
	states = {
		State.MOVE: MoveState.new(self), State.FALL: FallState.new(self),
		State.JUMP: JumpState.new(self), State.DASH: DashState.new(self),
		State.WALL_SLIDE: WallSlideState.new(self), State.ATTACK: AttackState.new(self),
		State.HURT: HurtState.new(self), State.HEAL: HealState.new(self),
	}
	current_state = states[State.FALL]
	current_state.enter()

func _physics_process(delta):
	_update_timers(delta)
	_poll_global_inputs()
	current_state.process_physics(delta)
	move_and_slide()
	_check_for_contact_damage()
	if is_on_wall() and not is_on_floor():
		wall_coyote_timer = Constants.WALL_COYOTE_TIME
		last_wall_normal = get_wall_normal()

func _unhandled_input(event: InputEvent):
	current_state.process_input(event)

func _update_timers(delta):
	coyote_timer = max(0.0, coyote_timer - delta)
	jump_buffer_timer = max(0.0, jump_buffer_timer - delta)
	dash_cooldown_timer = max(0.0, dash_cooldown_timer - delta)
	dash_duration_timer = max(0.0, dash_duration_timer - delta)
	attack_duration_timer = max(0.0, attack_duration_timer - delta)
	attack_cooldown_timer = max(0.0, attack_cooldown_timer - delta)
	knockback_timer = max(0.0, knockback_timer - delta)
	wall_coyote_timer = max(0.0, wall_coyote_timer - delta)
	if is_charging and Input.is_action_pressed("ui_attack"):
		charge_timer += delta

func _poll_global_inputs():
	if Input.is_action_just_pressed("ui_jump"):
		jump_buffer_timer = Constants.JUMP_BUFFER

	if not states.find_key(current_state) in ACTION_ALLOWED_STATES:
		return

	if Input.is_action_just_pressed("ui_attack") and attack_cooldown_timer <= 0:
		is_charging = true; charge_timer = 0.0
	
	if Input.is_action_just_released("ui_attack"):
		if is_charging:
			if charge_timer >= Constants.CHARGE_TIME: _fire_shot()
			else: change_state(State.ATTACK)
			is_charging = false
	
	if Input.is_action_just_pressed("ui_dash") and can_dash and dash_cooldown_timer <= 0:
		change_state(State.DASH)
		
	if is_on_floor() and Input.is_action_pressed("ui_down") and Input.is_action_pressed("ui_jump") and healing_charges > 0 and is_zero_approx(velocity.x):
		change_state(State.HEAL)

func change_state(new_state_key: State):
	if not states.has(new_state_key) or current_state == states[new_state_key]: return
	current_state.exit()
	current_state = states[new_state_key]
	current_state.enter()

# --- REFINEMENT: Centralized helper function for states (DRY Principle) ---
func apply_horizontal_movement():
	velocity.x = Input.get_axis("ui_left", "ui_right") * Constants.PLAYER_SPEED
	if not is_zero_approx(velocity.x):
		facing_direction = sign(velocity.x)

# --- Public Action & Helper Functions (Unchanged) ---
func take_damage(damage_amount: int, damage_source = null):
	if is_invincible or is_dash_invincible: return
	health -= damage_amount
	health_changed.emit(health, Constants.PLAYER_MAX_HEALTH)
	_trigger_hit_flash()
	is_invincible = true
	invincibility_timer.start(Constants.PLAYER_INVINCIBILITY_DURATION)
	if damage_source:
		var knockback_dir = (global_position - damage_source.global_position).normalized()
		var knockback_str = Constants.KNOCKBACK_SPEED
		if damage_source.is_in_group("hazard"): knockback_str = Constants.HAZARD_KNOCKBACK_SPEED
		velocity = (knockback_dir + Vector2.UP * 0.5).normalized() * knockback_str
	change_state(State.HURT)
	if health <= 0: die()

func die(): died.emit()

func _check_for_contact_damage():
	for i in range(get_slide_collision_count()):
		var col = get_slide_collision(i)
		if col and (col.get_collider().is_in_group("enemy") or col.get_collider().is_in_group("hazard")):
			take_damage(1, col.get_collider()); break

func _on_damage_dealt():
	if healing_charges >= Constants.PLAYER_MAX_HEALING_CHARGES: return
	determination_counter += 1
	if determination_counter >= Constants.DETERMINATION_PER_CHARGE:
		determination_counter = 0; healing_charges += 1
		healing_charges_changed.emit(healing_charges)

func _cancel_heal():
	if healing_timer.is_stopped(): return
	healing_timer.stop(); print("Healing canceled.")
	
# --- BUG FIX STARTS HERE ---
func _trigger_hit_flash():
	visual_sprite.color = Color.DODGER_BLUE
	hit_flash_timer.start() # This line was missing.
# --- BUG FIX ENDS HERE ---

func _fire_shot():
	attack_cooldown_timer = Constants.ATTACK_COOLDOWN
	var shot_dir = Vector2(facing_direction, 0)
	if Input.is_action_pressed("ui_up"): shot_dir = Vector2.UP
	elif Input.is_action_pressed("ui_down"): shot_dir = Vector2.DOWN
	var shot = PlayerShotScene.instantiate(); shot.direction = shot_dir
	shot.position = global_position + (shot_dir * 60)
	get_parent().add_child(shot)

func _trigger_pogo(pogo_target):
	velocity.y = -Constants.POGO_FORCE
	position.y -= 1
	can_dash = true
	air_jumps_left = Constants.MAX_AIR_JUMPS
	change_state(State.FALL)
	if pogo_target:
		if pogo_target.has_method("take_damage"):
			pogo_target.take_damage(1); _on_damage_dealt()
		elif pogo_target.is_in_group("enemy_projectile"):
			pogo_target.queue_free()

# --- Signal Callbacks ---
func _on_hit_flash_timer_timeout(): visual_sprite.color = original_color

func _on_hitbox_body_entered(body):
	if is_pogo_attack: _trigger_pogo(body)
	elif body.is_in_group("enemy"): body.take_damage(1); _on_damage_dealt()

func _on_hitbox_area_entered(area):
	if area.is_in_group("enemy_projectile"):
		if is_pogo_attack: _trigger_pogo(area)
		else: area.queue_free()

func _on_hurtbox_area_entered(area):
	if area.is_in_group("enemy_projectile"): take_damage(1, area); area.queue_free()

func _on_invincibility_timer_timeout(): is_invincible = false

func _on_healing_timer_timeout():
	if states.find_key(current_state) == State.HEAL:
		health = min(health + 1, Constants.PLAYER_MAX_HEALTH); healing_charges -= 1
		health_changed.emit(health, Constants.PLAYER_MAX_HEALTH)
		healing_charges_changed.emit(healing_charges)
		change_state(State.MOVE)


=====================================
FILE: ./src/entities/player/states/state_jump.gd
=====================================
# src/entities/player/states/state_jump.gd
# Handles the player's upward movement (jump).
extends PlayerState

func enter():
	player.velocity.y = -Constants.PLAYER_JUMP_FORCE
	player.coyote_timer = 0
	player.jump_buffer_timer = 0

func process_physics(delta: float):
	# REFINEMENT: Call the centralized movement function.
	player.apply_horizontal_movement()
	
	if Input.is_action_just_released("ui_jump") and player.velocity.y < 0:
		player.velocity.y *= Constants.JUMP_RELEASE_DAMPENER

	_apply_gravity(delta)
	
	if player.is_on_floor():
		player.change_state(player.State.MOVE)
		return

	_check_for_wall_slide()

func _apply_gravity(delta):
	player.velocity.y += Constants.GRAVITY * delta
	if player.velocity.y > 0.0:
		player.change_state(player.State.FALL)

func _check_for_wall_slide():
	if player.wall_coyote_timer > 0 and not player.is_on_floor() and Input.get_axis("ui_left", "ui_right") != 0 and sign(Input.get_axis("ui_left", "ui_right")) == -player.last_wall_normal.x:
		player.change_state(player.State.WALL_SLIDE)


=====================================
FILE: ./src/entities/player/states/state_dash.gd
=====================================
# src/entities/player/states/state_dash.gd
# Handles the player's dashing state.
extends PlayerState

func enter():
	player.is_dash_invincible = true
	player.can_dash = false
	player.dash_duration_timer = Constants.DASH_DURATION
	player.dash_cooldown_timer = Constants.DASH_COOLDOWN
	player.velocity = _get_dash_direction() * Constants.DASH_SPEED

func exit():
	player.is_dash_invincible = false
	# A small safety check to ensure player doesn't stick to walls after a dash.
	player.velocity = player.velocity * 0.5 

func process_physics(_delta: float):
	if player.dash_duration_timer <= 0:
		player.change_state(player.State.FALL)

func _get_dash_direction():
	if Input.is_action_pressed("ui_up"): return Vector2.UP
	if Input.is_action_pressed("ui_down"): return Vector2.DOWN
	return Vector2(player.facing_direction, 0)


=====================================
FILE: ./src/entities/player/states/state_heal.gd
=====================================
# src/entities/player/states/state_heal.gd
# Handles the player's healing state.
extends PlayerState

func enter():
	player.velocity = Vector2.ZERO
	player.healing_timer.start(Constants.PLAYER_HEAL_DURATION)
	print("Healing started...")

func exit():
	player._cancel_heal()

func process_physics(_delta: float):
	# Cancel healing if conditions are broken (e.g., player moves or is no longer grounded)
	if not Input.is_action_pressed("ui_down") or not Input.is_action_pressed("ui_jump") or not is_zero_approx(player.velocity.x) or not player.is_on_floor():
		player.change_state(player.State.MOVE)


=====================================
FILE: ./src/entities/player/states/state_base.gd
=====================================
# src/entities/player/states/state_base.gd
# This is the parent class for all Player states. It defines the "contract"
# that every state must adhere to. It ensures that every state has the necessary
# functions, even if they don't do anything in a particular state.
class_name PlayerState

var player: CharacterBody2D

func _init(player_node: CharacterBody2D):
	self.player = player_node

func enter():
	pass

func exit():
	pass

func process_physics(_delta: float):
	pass

# This function is now used for state-specific input that isn't global,
# like checking for jump release to dampen jump height.
func process_input(_event: InputEvent):
	pass


=====================================
FILE: ./src/entities/player/states/state_wall_slide.gd
=====================================
# src/entities/player/states/state_wall_slide.gd
# Handles the player's wall sliding state.
extends PlayerState

func enter():
	player.can_dash = true
	player.air_jumps_left = Constants.MAX_AIR_JUMPS

func exit():
	if player.last_wall_normal != Vector2.ZERO:
		player.facing_direction = player.last_wall_normal.x

func process_physics(delta: float):
	player.velocity.y = min(player.velocity.y + Constants.GRAVITY * delta, Constants.WALL_SLIDE_SPEED)
	player.facing_direction = -player.last_wall_normal.x
	
	if player.jump_buffer_timer > 0:
		_perform_wall_jump()
		return
	
	# Check if player is no longer holding into the wall
	if Input.get_axis("ui_left", "ui_right") * -player.last_wall_normal.x < 0.8:
		player.change_state(player.State.FALL)
		return
		
	# Check if wall coyote time has run out
	if player.wall_coyote_timer <= 0:
		player.change_state(player.State.FALL)
		return

	if player.is_on_floor():
		player.change_state(player.State.MOVE)
		return

func _perform_wall_jump():
	player.velocity.y = -Constants.WALL_JUMP_FORCE_Y
	player.velocity.x = player.last_wall_normal.x * Constants.WALL_JUMP_FORCE_X
	player.jump_buffer_timer = 0
	player.coyote_timer = 0
	player.wall_coyote_timer = 0
	player.change_state(player.State.JUMP)

=====================================
FILE: ./src/entities/player/states/state_attack.gd
=====================================
# src/entities/player/states/state_attack.gd
# Handles the player's melee attack.
extends PlayerState

func enter():
	player.attack_duration_timer = Constants.ATTACK_DURATION
	player.attack_cooldown_timer = Constants.ATTACK_COOLDOWN
	player.hitbox_shape.disabled = false
	player.is_pogo_attack = false
	
	if Input.is_action_pressed("ui_down"):
		player.is_pogo_attack = true
		player.hitbox.position = Vector2(0, 60)
		
		# If we're on the floor, we know the ground is there, so just trigger the bounce.
		if player.is_on_floor():
			player._trigger_pogo(null) # Pass null because the floor isn't a damageable target.
			return
		
		# If we're in the air, do the physics check for enemies/projectiles.
		if _check_for_immediate_pogo():
			return
			
	elif Input.is_action_pressed("ui_up"):
		player.hitbox.position = Vector2(0, -60)
	else:
		player.hitbox.position = Vector2(player.facing_direction * 60, 0)

func exit():
	player.hitbox_shape.call_deferred("set", "disabled", true)
	player.is_pogo_attack = false

func process_physics(delta: float):
	# Apply friction only if not pogoing. A pogo attack should preserve momentum.
	if not player.is_pogo_attack:
		player.velocity = player.velocity.move_toward(Vector2.ZERO, Constants.PLAYER_ATTACK_FRICTION * delta)
	
	if player.attack_duration_timer <= 0:
		player.change_state(player.State.FALL)

func _check_for_immediate_pogo() -> bool:
	var query = PhysicsShapeQueryParameters2D.new()
	query.shape = player.hitbox_shape.shape
	query.transform = player.global_transform * player.hitbox.transform
	query.collision_mask = 2 | 4 | 8 | 16 # World, Enemy, Hazard, Enemy Projectile
	query.exclude = [player]
	
	var results = player.get_world_2d().direct_space_state.intersect_shape(query)
	
	if not results.is_empty():
		player._trigger_pogo(results[0].collider)
		return true
		
	return false


=====================================
FILE: ./src/entities/player/states/state_hurt.gd
=====================================
# src/entities/player/states/state_hurt.gd
# Handles player knockback and invincibility.
extends PlayerState

func enter():
	player.is_charging = false
	player._cancel_heal()
	player.knockback_timer = Constants.KNOCKBACK_DURATION

func process_physics(delta):
	player.velocity.y += Constants.GRAVITY * delta
	
	if player.knockback_timer <= 0:
		player.change_state(player.State.FALL)

=====================================
FILE: ./src/entities/player/states/state_fall.gd
=====================================
# src/entities/player/states/state_fall.gd
# Handles the player's falling state.
extends PlayerState

func process_physics(delta: float):
	# REFINEMENT: Call the centralized movement function.
	player.apply_horizontal_movement()
	_apply_gravity(delta)

	if player.is_on_floor():
		player.change_state(player.State.MOVE)
		return

	_check_for_wall_slide()

	if player.jump_buffer_timer > 0:
		if player.wall_coyote_timer > 0:
			_perform_wall_jump()
		elif player.coyote_timer > 0:
			player.change_state(player.State.JUMP)
		elif player.air_jumps_left > 0:
			_perform_air_jump()

func _apply_gravity(delta):
	var gravity_multiplier = 1.0
	if Input.is_action_pressed("ui_down"):
		gravity_multiplier = Constants.FAST_FALL_GRAVITY_MULTIPLIER
	player.velocity.y += Constants.GRAVITY * gravity_multiplier * delta

func _check_for_wall_slide():
	if player.wall_coyote_timer > 0 and not player.is_on_floor() and Input.get_axis("ui_left", "ui_right") != 0 and sign(Input.get_axis("ui_left", "ui_right")) == -player.last_wall_normal.x:
		player.change_state(player.State.WALL_SLIDE)

func _perform_air_jump():
	player.air_jumps_left -= 1
	player.change_state(player.State.JUMP)
	
func _perform_wall_jump():
	player.velocity.x = player.last_wall_normal.x * Constants.WALL_JUMP_FORCE_X
	player.coyote_timer = 0
	player.wall_coyote_timer = 0
	player.change_state(player.State.JUMP)


=====================================
FILE: ./src/entities/player/states/state_move.gd
=====================================
# src/entities/player/states/state_move.gd
# Handles the player's grounded movement state.
extends PlayerState

func enter():
	player.air_jumps_left = Constants.MAX_AIR_JUMPS
	player.can_dash = true

func process_physics(delta: float):
	player.coyote_timer = Constants.COYOTE_TIME
	
	player.velocity.y += Constants.GRAVITY * delta
	# REFINEMENT: Call the centralized movement function.
	player.apply_horizontal_movement()

	if not player.is_on_floor():
		# REFINEMENT: Use global enum syntax for clarity.
		player.change_state(player.State.FALL)
		return
	
	if Input.is_action_pressed("ui_down") and Input.is_action_just_pressed("ui_jump"):
		if player.get_last_slide_collision():
			var floor_collider = player.get_last_slide_collision().get_collider()
			if floor_collider and floor_collider.is_in_group("oneway_platforms"):
				player.position.y += 2
				player.jump_buffer_timer = 0
				player.change_state(player.State.FALL)
				return
	
	if player.jump_buffer_timer > 0:
		player.change_state(player.State.JUMP)
		return


