+---------------------------------+
|       B O X  B A T T L E        |
|  Godot Project Source Context   |
+---------------------------------+
Generated on: Thu Aug 21 15:54:05 CDT 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
├── LICENSE
├── README.md
├── addons
│   └── gut
│       ├── GutScene.gd
│       ├── GutScene.tscn
│       ├── LICENSE.md
│       ├── UserFileViewer.gd
│       ├── UserFileViewer.tscn
│       ├── autofree.gd
│       ├── awaiter.gd
│       ├── cli
│       │   ├── change_project_warnings.gd
│       │   ├── gut_cli.gd
│       │   └── optparse.gd
│       ├── collected_script.gd
│       ├── collected_test.gd
│       ├── comparator.gd
│       ├── compare_result.gd
│       ├── diff_formatter.gd
│       ├── diff_tool.gd
│       ├── double_templates
│       │   ├── function_template.txt
│       │   ├── init_template.txt
│       │   └── script_template.txt
│       ├── double_tools.gd
│       ├── doubler.gd
│       ├── dynamic_gdscript.gd
│       ├── fonts
│       │   ├── AnonymousPro-Bold.ttf
│       │   ├── AnonymousPro-BoldItalic.ttf
│       │   ├── AnonymousPro-Italic.ttf
│       │   ├── AnonymousPro-Regular.ttf
│       │   ├── CourierPrime-Bold.ttf
│       │   ├── CourierPrime-BoldItalic.ttf
│       │   ├── CourierPrime-Italic.ttf
│       │   ├── CourierPrime-Regular.ttf
│       │   ├── LobsterTwo-Bold.ttf
│       │   ├── LobsterTwo-BoldItalic.ttf
│       │   ├── LobsterTwo-Italic.ttf
│       │   ├── LobsterTwo-Regular.ttf
│       │   └── OFL.txt
│       ├── gui
│       │   ├── BottomPanelShortcuts.gd
│       │   ├── BottomPanelShortcuts.tscn
│       │   ├── GutBottomPanel.gd
│       │   ├── GutBottomPanel.tscn
│       │   ├── GutControl.gd
│       │   ├── GutControl.tscn
│       │   ├── GutRunner.gd
│       │   ├── GutRunner.tscn
│       │   ├── GutSceneTheme.tres
│       │   ├── MinGui.tscn
│       │   ├── NormalGui.tscn
│       │   ├── OutputText.gd
│       │   ├── OutputText.tscn
│       │   ├── ResizeHandle.gd
│       │   ├── ResizeHandle.tscn
│       │   ├── ResultsTree.gd
│       │   ├── ResultsTree.tscn
│       │   ├── RunAtCursor.gd
│       │   ├── RunAtCursor.tscn
│       │   ├── RunResults.gd
│       │   ├── RunResults.tscn
│       │   ├── Settings.tscn
│       │   ├── ShortcutButton.gd
│       │   ├── ShortcutButton.tscn
│       │   ├── arrow.png
│       │   ├── editor_globals.gd
│       │   ├── gut_config_gui.gd
│       │   ├── gut_gui.gd
│       │   ├── gut_user_preferences.gd
│       │   ├── panel_controls.gd
│       │   ├── play.png
│       │   ├── run_from_editor.gd
│       │   ├── run_from_editor.tscn
│       │   └── script_text_editor_controls.gd
│       ├── gut.gd
│       ├── gut_cmdln.gd
│       ├── gut_config.gd
│       ├── gut_loader.gd
│       ├── gut_loader_the_scene.tscn
│       ├── gut_plugin.gd
│       ├── gut_to_move.gd
│       ├── gut_vscode_debugger.gd
│       ├── hook_script.gd
│       ├── icon.png
│       ├── images
│       │   ├── Folder.svg
│       │   ├── Script.svg
│       │   ├── green.png
│       │   ├── red.png
│       │   └── yellow.png
│       ├── inner_class_registry.gd
│       ├── input_factory.gd
│       ├── input_sender.gd
│       ├── junit_xml_export.gd
│       ├── lazy_loader.gd
│       ├── logger.gd
│       ├── method_maker.gd
│       ├── one_to_many.gd
│       ├── orphan_counter.gd
│       ├── parameter_factory.gd
│       ├── parameter_handler.gd
│       ├── plugin.cfg
│       ├── printers.gd
│       ├── result_exporter.gd
│       ├── script_parser.gd
│       ├── signal_watcher.gd
│       ├── source_code_pro.fnt
│       ├── spy.gd
│       ├── strutils.gd
│       ├── stub_params.gd
│       ├── stubber.gd
│       ├── summary.gd
│       ├── test.gd
│       ├── test_collector.gd
│       ├── thing_counter.gd
│       ├── utils.gd
│       ├── version_conversion.gd
│       ├── version_numbers.gd
│       └── warnings_manager.gd
├── default_bus_layout.tres
├── docs
│   ├── ARCHITECTURE.txt
│   ├── ARENA_CONCEPTS.txt
│   ├── ASSETS.txt
│   ├── BRAINSTORM.txt
│   ├── BUGS.txt
│   ├── CHANGELOG.txt
│   ├── DEPRECATION.md
│   ├── DESIGN.txt
│   ├── DOCS_PROTOCOL.txt
│   ├── HOW_TO_ADD_AN_EFFECT.md
│   ├── PLAYTESTING.txt
│   ├── ROADMAP.txt
│   ├── TODO.txt
│   ├── all_godot_source_code.txt
│   ├── all_script_errors.txt
│   ├── create_all_godot_source_code_txt.command
│   ├── create_all_godot_source_code_txt.sh
│   ├── last_commit_command.txt
│   └── sprint_0_audit
│       ├── ADR-002_Communication_Patterns.md
│       ├── ADR.md
│       ├── ADR.mdADR-001_Service_Locator_Pattern.md
│       ├── ARCH-001_Refactoring_Principles.md
│       ├── ARCH-002_Acceptance_Criteria.md
│       ├── EVENT-001_Event_Flow_Map.md
│       ├── FSM-001_Entity_State_Flows.md
│       ├── STYLE-001_GDScript_Style_Guide.md
│       ├── TEST-001_Baseline_Metrics.md
│       ├── TEST-002_Smoke_Tests.md
│       ├── TEST-003_Regression_Checklist.md
│       ├── config_usage.txt
│       ├── event_usage.txt
│       ├── singleton_map.txt
│       └── state_machine_flow.md
├── export_presets.cfg
├── icon.svg
├── materials
│   ├── entity_hit_flash_material.tres
│   ├── sdf_panel_material.tres
│   └── shockwave_material.tres
├── pico.save
├── progess
│   └── progress_001-1.jpg
├── project.godot
├── shaders
│   ├── entity
│   │   ├── dissolve.gdshader
│   │   ├── red_hit_flash_test.gdshader
│   │   └── red_hit_flash_test.gdshader.save
│   ├── fullscreen
│   │   └── shockwave.gdshader
│   ├── includes
│   │   ├── color.gdshaderinc
│   │   ├── common_math.gdshaderinc
│   │   ├── fx_blend.gdshaderinc
│   │   └── noise.gdshaderinc
│   └── ui
│       └── sdf_panel.gdshader
├── src
│   ├── api
│   │   ├── combat
│   │   │   ├── damage_info.gd
│   │   │   └── damage_result.gd
│   │   ├── global_preloader.gd
│   │   └── interfaces
│   │       ├── IComponent.gd
│   │       ├── IDamageable.gd
│   │       ├── IPoolable.gd
│   │       └── ISceneController.gd
│   ├── arenas
│   ├── core
│   │   ├── DEPRECATION.md
│   │   ├── README.md
│   │   ├── building
│   │   │   ├── arena_builder.gd
│   │   │   ├── level_build_data.gd
│   │   │   ├── level_parser.gd
│   │   │   └── terrain_builder.gd
│   │   ├── data
│   │   │   ├── config
│   │   │   │   ├── combat_config.gd
│   │   │   │   └── settings.gd
│   │   │   ├── effects
│   │   │   │   ├── boss_death_shake.tres
│   │   │   │   ├── boss_phase_change_shake.tres
│   │   │   │   ├── dissolve_effect.tres
│   │   │   │   ├── player_damage_shake.tres
│   │   │   │   ├── player_hit_spark_effect.tres
│   │   │   │   ├── screen_shake_effect.gd
│   │   │   │   ├── shader_effect.gd
│   │   │   │   ├── shockwave_effect.tres
│   │   │   │   └── vfx_effect.gd
│   │   │   └── game_state_data.gd
│   │   ├── events
│   │   │   ├── event_bus.gd
│   │   │   ├── event_catalog.gd
│   │   │   └── typed_events
│   │   │       ├── boss_health_changed_event.gd
│   │   │       ├── player_healing_charges_changed_event.gd
│   │   │       └── player_health_changed_event.gd
│   │   ├── sequencing
│   │   │   ├── sequence_handle.gd
│   │   │   ├── sequence_step.gd
│   │   │   ├── sequencer.gd
│   │   │   └── steps
│   │   │       ├── callable_step.gd
│   │   │       ├── emit_step.gd
│   │   │       └── wait_step.gd
│   │   ├── systems
│   │   │   ├── audio_manager.gd
│   │   │   ├── camera_manager.gd
│   │   │   ├── camera_shaker.gd
│   │   │   ├── camera_shaker.tscn
│   │   │   ├── cursor_manager.gd
│   │   │   ├── dialogue_manager.gd
│   │   │   ├── fx_bindings
│   │   │   │   ├── fullscreen_shader_binding.gd
│   │   │   │   └── ui_shader_binding.gd
│   │   │   ├── fx_manager.gd
│   │   │   ├── game_manager.gd
│   │   │   ├── object_pool.gd
│   │   │   └── scene_manager.gd
│   │   └── util
│   │       ├── asset_paths.gd
│   │       ├── combat_utils.gd
│   │       ├── constants.gd
│   │       ├── grid_utils.gd
│   │       ├── identifiers.gd
│   │       ├── palette.gd
│   │       ├── physics_layers.gd
│   │       └── scene_validator.gd
│   ├── data
│   │   ├── audio
│   │   │   ├── sfx_player_footsteps.tres
│   │   │   └── sfx_player_impact.tres
│   │   ├── combat_config.tres
│   │   ├── dialogue
│   │   │   ├── dialogue_data.gd
│   │   │   └── test_conversation.tres
│   │   ├── effects
│   │   │   ├── entity_hit_flash_effect.tres
│   │   │   └── shaders
│   │   ├── encounters
│   │   │   ├── encounter_00.tres
│   │   │   └── encounter_data.gd
│   │   └── layouts
│   │       ├── layout_00.tres
│   │       └── level_layout.gd
│   ├── entities
│   │   ├── README.md
│   │   ├── archetypes
│   │   │   ├── boss_archetype.tres
│   │   │   ├── entity_archetype.gd
│   │   │   ├── player_archetype.tres
│   │   │   └── turret_archetype.tres
│   │   ├── base_entity.gd
│   │   ├── boss
│   │   │   ├── attack_patterns
│   │   │   │   ├── attack_logic.gd
│   │   │   │   ├── attack_pattern.gd
│   │   │   │   ├── homing_omni_burst_logic.gd
│   │   │   │   ├── homing_omni_burst_logic.tres
│   │   │   │   ├── homing_omni_burst_pattern.tres
│   │   │   │   ├── lunge_attack.tres
│   │   │   │   ├── lunge_logic.gd
│   │   │   │   ├── lunge_logic.tres
│   │   │   │   ├── projectile_logic.gd
│   │   │   │   ├── single_shot.tres
│   │   │   │   ├── single_shot_logic.tres
│   │   │   │   ├── volley_3_shot.tres
│   │   │   │   ├── volley_5_shot.tres
│   │   │   │   └── volley_shot_logic.tres
│   │   │   ├── base_boss.gd
│   │   │   ├── base_boss.tscn
│   │   │   ├── boss_state_data.gd
│   │   │   └── states
│   │   │       ├── state_boss_attack.gd
│   │   │       ├── state_boss_cooldown.gd
│   │   │       ├── state_boss_idle.gd
│   │   │       ├── state_boss_lunge.gd
│   │   │       └── state_boss_patrol.gd
│   │   ├── components
│   │   │   ├── base_state.gd
│   │   │   ├── base_state_machine.gd
│   │   │   ├── base_state_machine.tscn
│   │   │   ├── combat_component.gd
│   │   │   ├── combat_component.tscn
│   │   │   ├── fx_component.gd
│   │   │   ├── fx_component.tscn
│   │   │   ├── health_component.gd
│   │   │   ├── health_component.tscn
│   │   │   ├── input_component.gd
│   │   │   ├── input_component.tscn
│   │   │   ├── telegraph_component.gd
│   │   │   └── telegraph_component.tscn
│   │   ├── minions
│   │   │   ├── states
│   │   │   │   ├── state_turret_attack.gd
│   │   │   │   └── state_turret_idle.gd
│   │   │   ├── turret.gd
│   │   │   ├── turret.tscn
│   │   │   └── turret_state_data.gd
│   │   └── player
│   │       ├── components
│   │       │   ├── player_ability_component.gd
│   │       │   ├── player_ability_component.tscn
│   │       │   ├── player_physics_component.gd
│   │       │   ├── player_physics_component.tscn
│   │       │   ├── player_resource_component.gd
│   │       │   └── player_resource_component.tscn
│   │       ├── data
│   │       │   ├── forward_attack_shape.tres
│   │       │   ├── player_state_data.gd
│   │       │   └── upward_attack_shape.tres
│   │       ├── player.gd
│   │       ├── player.tscn
│   │       └── states
│   │           ├── state_attack.gd
│   │           ├── state_dash.gd
│   │           ├── state_fall.gd
│   │           ├── state_heal.gd
│   │           ├── state_hurt.gd
│   │           ├── state_jump.gd
│   │           ├── state_move.gd
│   │           ├── state_pogo.gd
│   │           └── state_wall_slide.gd
│   ├── projectiles
│   │   ├── boss_shot.gd
│   │   ├── boss_shot.tscn
│   │   ├── homing_boss_shot.gd
│   │   ├── homing_boss_shot.tscn
│   │   ├── player_shot.gd
│   │   ├── player_shot.tscn
│   │   ├── turret_shot.gd
│   │   └── turret_shot.tscn
│   ├── scenes
│   │   ├── game
│   │   │   ├── encounter_scene.gd
│   │   │   └── encounter_scene.tscn
│   │   ├── game_over
│   │   │   ├── game_over_screen.gd
│   │   │   └── game_over_screen.tscn
│   │   ├── loading
│   │   │   ├── loading_screen.gd
│   │   │   └── loading_screen.tscn
│   │   ├── main
│   │   │   ├── main.gd
│   │   │   └── main.tscn
│   │   ├── menus
│   │   │   ├── controls_screen.gd
│   │   │   ├── controls_screen.tscn
│   │   │   ├── credits_screen.gd
│   │   │   ├── credits_screen.tscn
│   │   │   ├── options_screen.gd
│   │   │   ├── options_screen.tscn
│   │   │   ├── sound_screen.gd
│   │   │   ├── sound_screen.tscn
│   │   │   ├── title_screen.gd
│   │   │   └── title_screen.tscn
│   │   └── victory
│   │       ├── victory_screen.gd
│   │       └── victory_screen.tscn
│   ├── tests
│   │   ├── data
│   │   │   ├── test_encounter.tres
│   │   │   └── test_layout.tres
│   │   ├── integration
│   │   │   └── test_integration_combat_loop.gd
│   │   ├── isolation
│   │   │   └── test_player_lifecycle.gd
│   │   └── unit
│   │       ├── test_combat_component.gd
│   │       ├── test_combat_utils.gd
│   │       ├── test_health_component.gd
│   │       ├── test_input_component.gd
│   │       ├── test_level_parser.gd
│   │       ├── test_memory_leaks.gd
│   │       ├── test_object_pool.gd
│   │       └── test_player_resource_component.gd
│   ├── ui
│   │   ├── components
│   │   │   ├── custom_slider
│   │   │   │   └── custom_slider.gd
│   │   │   ├── logo_display
│   │   │   │   ├── logo_display.gd
│   │   │   │   └── logo_display.tscn
│   │   │   ├── mute_button
│   │   │   │   ├── mute_button.gd
│   │   │   │   └── mute_button.tscn
│   │   │   └── styled_menu_item
│   │   │       ├── styled_menu_item.gd
│   │   │       └── styled_menu_item.tscn
│   │   ├── dev
│   │   │   ├── debug_overlay.gd
│   │   │   └── debug_overlay.tscn
│   │   ├── dialogue
│   │   │   ├── dialogue_box.gd
│   │   │   └── dialogue_box.tscn
│   │   ├── game_hud
│   │   │   ├── game_hud.gd
│   │   │   └── game_hud.tscn
│   │   └── menu_manager
│   │       └── menu_manager.gd
│   └── vfx
│       ├── hit_spark.gd
│       └── hit_spark.tscn
└── tools
    ├── fx_playground.gd
    ├── fx_playground.tscn
    └── mock_entity.gd

78 directories, 357 files


=====================================
FILE: ./.gutconfig.json
=====================================
{
    "dirs": [
        "res://src/tests"
    ]
}


=====================================
FILE: ./tools/fx_playground.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://qfvxrbic3utx"]

[ext_resource type="Script" uid="uid://chl2ii0j6x47a" path="res://tools/fx_playground.gd" id="1_script"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_effect"]
[ext_resource type="PackedScene" uid="uid://g7h8jaj0k1l2" path="res://src/entities/components/fx_component.tscn" id="3_fx_component"]

[node name="FXPlayground" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")
_hit_flash_effect = ExtResource("2_effect")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.1, 0.1, 0.1, 1)

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="TestSubject" type="ColorRect" parent="CenterContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(200, 200)
layout_mode = 2
color = Color(0.8, 0.8, 0.8, 1)

[node name="FXComponent" parent="CenterContainer/TestSubject" instance=ExtResource("3_fx_component")]

[node name="Button" type="Button" parent="."]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -100.0
offset_top = -100.0
offset_right = 100.0
offset_bottom = -50.0
grow_horizontal = 2
grow_vertical = 0
text = "Play Hit-Flash Effect"

[connection signal="pressed" from="Button" to="." method="_on_button_pressed"]


=====================================
FILE: ./tools/mock_entity.gd
=====================================
# tools/mock_entity.gd
## A mock entity for testing components in isolation, particularly for use with
## the DebugOverlay or in unit tests. It provides the properties that various
## systems expect an entity to have, without the overhead of a full scene.
class_name MockEntity
extends Node

@export var fx_component: FXComponent
@export var state_machine: BaseStateMachine
@export var health_component: HealthComponent

# Mimic CharacterBody2D methods for the overlay's checks to prevent errors.
func is_on_floor() -> bool:
	return true

=====================================
FILE: ./tools/fx_playground.gd
=====================================
# tools/fx_playground.gd
@tool
extends Control

@export var _hit_flash_effect: ShaderEffect

@onready var test_subject: ColorRect = %TestSubject
@onready var fx_component: FXComponent = %TestSubject/FXComponent

func _ready() -> void:
	if not Engine.is_editor_hint():
		# In a real game, the entity owner (Player, Boss) would do this.
		# Here, the playground itself is the owner.
		fx_component.setup(test_subject, {"visual_node": test_subject})

func _on_button_pressed() -> void:
	if not is_instance_valid(_hit_flash_effect):
		print("ERROR: No ShaderEffect resource assigned or could not be loaded.")
		return
	
	# The playground's only job is to tell the component to play the effect.
	fx_component.play_effect(_hit_flash_effect)


=====================================
FILE: ./materials/sdf_panel_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3]

# TODO: Link this material to its corresponding .gdshader file.


=====================================
FILE: ./materials/entity_hit_flash_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://entity_hit_flash_mat"]

[ext_resource type="Shader" path="res://shaders/entity/red_hit_flash_test.gdshader" id="1_shader"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/fx_progress = 0.0
shader_parameter/tint_color = Color(1, 0, 0, 1)

=====================================
FILE: ./materials/shockwave_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3]

# TODO: Link this material to its corresponding .gdshader file.


=====================================
FILE: ./addons/gut/parameter_factory.gd
=====================================
## Creates parameter structures for parameterized tests.
##
## This is a static class accessible in a [GutTest] script through
## [member GutTest.ParameterFactory].  It contains methods for constructing parameters to be
## used in parameterized tests.  It currently only has one, if you have anyu
## ideas for more, make an issue.  More of them would be great since I prematurely
## decided to make this static class and it has such a long name.  I'd feel a lot
## better about it if there was more in here.
## [br]
## Additional Helper Ideas?[br]
## [li]File.  IDK what it would look like.  csv maybe.[/li]
## [li]Random values within a range?[/li]
## [li]All int values in a range or add an optioanal step.[/li]




## Creates an array of dictionaries.  It pairs up the names array with each set
## of values in values.  If more names than values are specified then the missing
## values will be filled with nulls.  If more values than names are specified
## those values will be ignored.
##
## Example:
##[codeblock]
## create_named_parameters(['a', 'b'], [[1, 2], ['one', 'two']]) returns
##    [{a:1, b:2}, {a:'one', b:'two'}]
##[/codeblock]
## [br]
## This allows you to increase readability of your parameterized tests:
## [br]
##[codeblock]
## var params = create_named_parameters(['a', 'b'], [[1, 2], ['one', 'two']])
## func test_foo(p = use_parameters(params)):
##    assert_eq(p.a, p.b)
##[/codeblock]
## [br]
## Parameters:[br]
##[li]names:  an array of names to be used as keys in the dictionaries[/li]
##[li]values:  an array of arrays of values.[/li]
static func named_parameters(names, values):
	var named = []
	for i in range(values.size()):
		var entry = {}

		var parray = values[i]
		if(typeof(parray) != TYPE_ARRAY):
			parray = [values[i]]

		for j in range(names.size()):
			if(j >= parray.size()):
				entry[names[j]] = null
			else:
				entry[names[j]] = parray[j]
		named.append(entry)

	return named



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This is the home for all parameter creation helpers.  These functions should
# all return an array of values to be used as parameters for parameterized
# tests.
# ##############################################################################

=====================================
FILE: ./addons/gut/gut_loader.gd
=====================================
# ------------------------------------------------------------------------------
# This script should be loaded as soon as possible when running tests.  This
# will disable warnings and then load all scripts that are registered with the
# LazyLoader.
#
# Once you are ready to run tests, restore_ignore_addons should be called so
# that it has the expected value.  This should be done after whatever loaded
# this is done loading and doing setup stuff.
#
# This was created after a first attempt to suppress all GUT warnings did not
# work for the strictest warning settings.  This has turned the LazyLoader into
# just a Loader...so maybe all that should be reworked or renamed.  A problem
# for a time when we are absolutely sure that all warnings are being correctly
# suppressed I suppose.
#
# You can use the cli script test/resources/change_project_warnings.gd to
# quickly alter project warning levels for testing purposes.
# 	gdscript test/resources/change_project_warnings.gd --headless ++ -h
#
# You can set project warning settings from the command line with:
#	godot -s addons/gut/cli/change_project_warnings.gd ++ -h
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
const WARNING_PATH : String = 'debug/gdscript/warnings/'


static var were_addons_disabled : bool = true


@warning_ignore("unsafe_method_access")
@warning_ignore("unsafe_property_access")
@warning_ignore("untyped_declaration")
static func _static_init() -> void:
	were_addons_disabled = ProjectSettings.get(str(WARNING_PATH, 'exclude_addons'))
	ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), true)

	var WarningsManager = load('res://addons/gut/warnings_manager.gd')

	# Turn everything back on (if it originally was on) if the warnings manager
	# is disabled.  This makes sure we see all the warnings for all the scripts
	# in the LazyLoader (except WarningsManager, but that's not a big deal).
	#
	# With the warnings manager disabled and all_warn warnings:
	#	test_warnings_manager.gd 	-> 5471 errors
	#	full run 				 	-> 131,742 errors
	#
	# With the warnings manager disabled and gut_default warnings:
	#	test_warnings_manager.gd 	-> 46 errors
	#	full run 					-> 165 errors.
	if(WarningsManager.disabled):
		ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), were_addons_disabled)

	# Force a reference to utils.gd by path.  Using the class_name would cause
	# utils.gd to load when this script loads, before we could turn off the
	# warnings.
	var _utils : Object = load('res://addons/gut/utils.gd')

	# Since load_all exists on the LazyLoader, it should be done now so nothing
	# sneaks in later...This essentially defeats the "lazy" part of the
	# LazyLoader, but not the "loader" part of LazyLoader.
	_utils.LazyLoader.load_all()

	# Make sure that the values set in WarningsManager's static_init actually
	# reflect the project settings and not whatever we do here to make things
	# not warn.
	WarningsManager._project_warnings.exclude_addons = were_addons_disabled


# this can be called before tests are run to reinstate whatever exclude_addons
# was set to before this script disabled it.
static func restore_ignore_addons() -> void:
	ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), were_addons_disabled)




# ##############################################################################
# (G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/version_numbers.gd
=====================================
# ##############################################################################
#
# ##############################################################################
class VerNumTools:

	static func _make_version_array_from_string(v):
		var parts = Array(v.split('.'))
		for i in range(parts.size()):
			var int_val = parts[i].to_int()
			if(str(int_val) == parts[i]):
				parts[i] = parts[i].to_int()
		return parts


	static func make_version_array(v):
		var to_return = []
		if(typeof(v) == TYPE_STRING):
			to_return = _make_version_array_from_string(v)
		elif(typeof(v) == TYPE_DICTIONARY):
			return [v.major, v.minor, v.patch]
		elif(typeof(v) == TYPE_ARRAY):
			to_return = v
		return to_return


	static func make_version_string(version_parts):
		var to_return = 'x.x.x'
		if(typeof(version_parts) == TYPE_ARRAY):
			to_return =  ".".join(version_parts)
		elif(typeof(version_parts) == TYPE_DICTIONARY):
			to_return = str(version_parts.major,  '.',  version_parts.minor,  '.',  version_parts.patch)
		elif(typeof(version_parts) == TYPE_STRING):
			to_return = version_parts
		return to_return


	static func is_version_gte(version, required):
		var is_ok = null
		var v = make_version_array(version)
		var r = make_version_array(required)

		var idx = 0
		while(is_ok == null and idx < v.size() and idx < r.size()):
			if(v[idx] > r[idx]):
				is_ok = true
			elif(v[idx] < r[idx]):
				is_ok = false

			idx += 1

		# still null means each index was the same.
		return GutUtils.nvl(is_ok, true)


	static func is_version_eq(version, expected):
		var version_array = make_version_array(version)
		var expected_array = make_version_array(expected)

		if(expected_array.size() > version_array.size()):
			return false

		var is_version = true
		var i = 0
		while(i < expected_array.size() and i < version_array.size() and is_version):
			if(expected_array[i] == version_array[i]):
				i += 1
			else:
				is_version = false

		return is_version


	static func is_godot_version_eq(expected):
		return VerNumTools.is_version_eq(Engine.get_version_info(), expected)


	static func is_godot_version_gte(expected):
		return VerNumTools.is_version_gte(Engine.get_version_info(), expected)




# ##############################################################################
#
# ##############################################################################
var gut_version = '0.0.0'
var required_godot_version = '0.0.0'

func _init(gut_v = gut_version, required_godot_v = required_godot_version):
	gut_version = gut_v
	required_godot_version = required_godot_v


# ------------------------------------------------------------------------------
# Blurb of text with GUT and Godot versions.
# ------------------------------------------------------------------------------
func get_version_text():
	var v_info = Engine.get_version_info()
	var gut_version_info =  str('GUT version:  ', gut_version)
	var godot_version_info  = str('Godot version:  ', v_info.major,  '.',  v_info.minor,  '.',  v_info.patch)
	return godot_version_info + "\n" + gut_version_info


# ------------------------------------------------------------------------------
# Returns a nice string for erroring out when we have a bad Godot version.
# ------------------------------------------------------------------------------
func get_bad_version_text():
	var info = Engine.get_version_info()
	var gd_version = str(info.major, '.', info.minor, '.', info.patch)
	return 'GUT ' + gut_version + ' requires Godot ' + required_godot_version + \
		' or greater.  Godot version is ' + gd_version


# ------------------------------------------------------------------------------
# Checks the Godot version against required_godot_version.
# ------------------------------------------------------------------------------
func is_godot_version_valid():
	return VerNumTools.is_version_gte(Engine.get_version_info(), required_godot_version)


func make_godot_version_string():
	return VerNumTools.make_version_string(Engine.get_version_info())


=====================================
FILE: ./addons/gut/LICENSE.md
=====================================
The MIT License (MIT)
=====================

Copyright (c) 2018 Tom "Butch" Wesley

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


=====================================
FILE: ./addons/gut/thing_counter.gd
=====================================
var things = {}

func get_unique_count():
	return things.size()


func add_thing_to_count(thing):
	if(!things.has(thing)):
		things[thing] = 0


func add(thing):
	if(things.has(thing)):
		things[thing] += 1
	else:
		things[thing] = 1


func has(thing):
	return things.has(thing)


func count(thing):
	var to_return = 0
	if(things.has(thing)):
		to_return = things[thing]
	return to_return


func sum():
	var to_return = 0
	for key in things:
		to_return += things[key]
	return to_return


func to_s():
	var to_return = ""
	for key in things:
		to_return += str(key, ":  ", things[key], "\n")
	to_return += str("sum: ", sum())
	return to_return


func get_max_count():
	var max_val = null
	for key in things:
		if(max_val == null or things[key] > max_val):
			max_val = things[key]
	return max_val


func add_array_items(array):
	for i in range(array.size()):
		add(array[i])


=====================================
FILE: ./addons/gut/printers.gd
=====================================
# ------------------------------------------------------------------------------
# Interface and some basic functionality for all printers.
# ------------------------------------------------------------------------------
class Printer:
	var _format_enabled = true
	var _disabled = false
	var _printer_name = 'NOT SET'
	var _show_name = false # used for debugging, set manually

	func get_format_enabled():
		return _format_enabled

	func set_format_enabled(format_enabled):
		_format_enabled = format_enabled

	func send(text, fmt=null):
		if(_disabled):
			return

		var formatted = text
		if(fmt != null and _format_enabled):
			formatted = format_text(text, fmt)

		if(_show_name):
			formatted = str('(', _printer_name, ')') + formatted

		_output(formatted)

	func get_disabled():
		return _disabled

	func set_disabled(disabled):
		_disabled = disabled

	# --------------------
	# Virtual Methods (some have some default behavior)
	# --------------------
	func _output(text):
		pass

	func format_text(text, fmt):
		return text

# ------------------------------------------------------------------------------
# Responsible for sending text to a GUT gui.
# ------------------------------------------------------------------------------
class GutGuiPrinter:
	extends Printer
	var _textbox = null

	var _colors = {
			red = Color.RED,
			yellow = Color.YELLOW,
			green = Color.GREEN
	}

	func _init():
		_printer_name = 'gui'

	func _wrap_with_tag(text, tag):
		return str('[', tag, ']', text, '[/', tag, ']')

	func _color_text(text, c_word):
		return '[color=' + c_word + ']' + text + '[/color]'

	# Remember, we have to use push and pop because the output from the tests
	# can contain [] in it which can mess up the formatting.  There is no way
	# as of 3.4 that you can get the bbcode out of RTL when using push and pop.
	#
	# The only way we could get around this is by adding in non-printable
	# whitespace after each "[" that is in the text.  Then we could maybe do
	# this another way and still be able to get the bbcode out, or generate it
	# at the same time in a buffer (like we tried that one time).
	#
	# Since RTL doesn't have good search and selection methods, and those are
	# really handy in the editor, it isn't worth making bbcode that can be used
	# there as well.
	#
	# You'll try to get it so the colors can be the same in the editor as they
	# are in the output.  Good luck, and I hope I typed enough to not go too
	# far that rabbit hole before finding out it's not worth it.
	func format_text(text, fmt):
		if(_textbox == null):
			return

		if(fmt == 'bold'):
			_textbox.push_bold()
		elif(fmt == 'underline'):
			_textbox.push_underline()
		elif(_colors.has(fmt)):
			_textbox.push_color(_colors[fmt])
		else:
			# just pushing something to pop.
			_textbox.push_normal()

		_textbox.add_text(text)
		_textbox.pop()

		return ''

	func _output(text):
		if(_textbox == null):
			return

		_textbox.add_text(text)

	func get_textbox():
		return _textbox

	func set_textbox(textbox):
		_textbox = textbox

	# This can be very very slow when the box has a lot of text.
	func clear_line():
		_textbox.remove_line(_textbox.get_line_count() - 1)
		_textbox.queue_redraw()

	func get_bbcode():
		return _textbox.text

	func get_disabled():
		return _disabled and _textbox != null

# ------------------------------------------------------------------------------
# This AND TerminalPrinter should not be enabled at the same time since it will
# result in duplicate output.  printraw does not print to the console so i had
# to make another one.
# ------------------------------------------------------------------------------
class ConsolePrinter:
	extends Printer
	var _buffer = ''

	func _init():
		_printer_name = 'console'

	# suppresses output until it encounters a newline to keep things
	# inline as much as possible.
	func _output(text):
		if(text.ends_with("\n")):
			print(_buffer + text.left(text.length() -1))
			_buffer = ''
		else:
			_buffer += text

# ------------------------------------------------------------------------------
# Prints text to terminal, formats some words.
# ------------------------------------------------------------------------------
class TerminalPrinter:
	extends Printer

	var escape = PackedByteArray([0x1b]).get_string_from_ascii()
	var cmd_colors  = {
		red = escape + '[31m',
		yellow = escape + '[33m',
		green = escape + '[32m',

		underline = escape + '[4m',
		bold = escape + '[1m',

		default = escape + '[0m',

		clear_line = escape + '[2K'
	}

	func _init():
		_printer_name = 'terminal'

	func _output(text):
		# Note, printraw does not print to the console.
		printraw(text)

	func format_text(text, fmt):
		return cmd_colors[fmt] + text + cmd_colors.default

	func clear_line():
		send(cmd_colors.clear_line)

	func back(n):
		send(escape + str('[', n, 'D'))

	func forward(n):
		send(escape + str('[', n, 'C'))


=====================================
FILE: ./addons/gut/gut_plugin.gd
=====================================
@tool
extends EditorPlugin
var VersionConversion = load("res://addons/gut/version_conversion.gd")
var _bottom_panel = null

func _init():
	if(VersionConversion.error_if_not_all_classes_imported()):
		return


func _version_conversion():
	var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")
	EditorGlobals.create_temp_directory()

	if(VersionConversion.error_if_not_all_classes_imported()):
		return false

	VersionConversion.convert()
	return true


func _enter_tree():
	if(!_version_conversion()):
		return

	_bottom_panel = preload('res://addons/gut/gui/GutBottomPanel.tscn').instantiate()

	var button = add_control_to_bottom_panel(_bottom_panel, 'GUT')
	button.shortcut_in_tooltip = true

	# ---------
	# I removed this delay because it was causing issues with the shortcut button.
	# The shortcut button wouldn't work right until load_shortcuts is called., but
	# the delay gave you 3 seconds to click it before they were loaded.  This
	# await came with the conversion to 4 and probably isn't needed anymore.
	# I'm leaving it here becuase I don't know why it showed up to begin with
	# and if it's needed, it will be pretty hard to debug without seeing this.
	#
	# This should be deleted after the next release or two if not needed.
	# await get_tree().create_timer(3).timeout
	# ---
	_bottom_panel.set_interface(get_editor_interface())
	_bottom_panel.set_plugin(self)
	_bottom_panel.set_panel_button(button)
	_bottom_panel.load_shortcuts()


func _exit_tree():
	# Clean-up of the plugin goes here
	# Always remember to remove_at it from the engine when deactivated
	remove_control_from_bottom_panel(_bottom_panel)
	_bottom_panel.free()


# This seems like a good idea at first, but it deletes the settings for ALL
# projects.  If by chance you want to do that you can uncomment this, reload the
# project and then disable GUT.
# func _disable_plugin():
#	var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
# 	GutEditorGlobals.user_prefs.erase_all()

=====================================
FILE: ./addons/gut/version_conversion.gd
=====================================
class ConfigurationUpdater:
	var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")

	func warn(message):
		print('GUT Warning:  ', message)


	func info(message):
		print("GUT Info:  ", message)


	func moved_file(from, to):
		if(FileAccess.file_exists(from) and !FileAccess.file_exists(to)):
			info(str('Copying [', from, '] to [', to, ']'))
			var result = DirAccess.copy_absolute(from, to)
			if(result != OK):
				warn(str('Could not copy [', from, '] to [', to, ']'))

		if(FileAccess.file_exists(from) and FileAccess.file_exists(to)):
			warn(str('File [', from, '] has been moved to [', to, "].\n    You can delete ", from))


	func move_user_file(from, to):
		if(from.begins_with('user://') and to.begins_with('user://')):
			if(FileAccess.file_exists(from) and !FileAccess.file_exists(to)):
				info(str('Moving [', from, '] to [', to, ']'))
				var result = DirAccess.copy_absolute(from, to)
				if(result == OK):
					info(str('    ', 'Created ', to))
					result = DirAccess.remove_absolute(from)
					if(result != OK):
						warn(str('    ', 'Could not delete ', from))
					else:
						info(str('    ', 'Deleted ', from))
				else:
					warn(str('    ', 'Could not copy [', from, '] to [', to, ']'))
		else:
			warn(str('Attempt to move_user_file with files not in user:// ', from, '->', to))


	func remove_user_file(which):
		if(which.begins_with('user://') and FileAccess.file_exists(which)):
			info(str('Deleting obsolete file ', which))
			var result = DirAccess.remove_absolute(which)
			if(result != OK):
				warn(str('    ', 'Could not delete ', which))
			else:
				info(str('    ', 'Deleted ', which))

class v9_2_0:
	extends ConfigurationUpdater

	func validate():
		moved_file('res://.gut_editor_config.json', EditorGlobals.editor_run_gut_config_path)
		moved_file('res://.gut_editor_shortcuts.cfg', EditorGlobals.editor_shortcuts_path)
		remove_user_file('user://.gut_editor.bbcode')
		remove_user_file('user://.gut_editor.json')

# list=Array[Dictionary]([{
# "base": &"RefCounted",
# "class": &"DynamicGutTest",
# "icon": "",
# "language": &"GDScript",
# "path": "res://test/resources/tools/dynamic_gut_test.gd"
# }, {
# "base": &"RefCounted",
# "class": &"GutDoubleTestInnerClasses",
# "icon": "",
# "language": &"GDScript",
# "path": "res://test/resources/doubler_test_objects/inner_classes.gd"
# }, ... ])
static func get_missing_gut_class_names() -> Array:
	var gut_class_names = ["GutHookScript",
		"GutInputFactory",
		"GutInputSender",
		"GutMain",
		"GutStringUtils",
		"GutTest",
		"GutUtils",]

	var class_cach_path = 'res://.godot/global_script_class_cache.cfg'
	var cfg = ConfigFile.new()
	cfg.load(class_cach_path)

	var all_class_names = {}
	var missing  = []
	var class_cache_entries = cfg.get_value('', 'list', [])

	for entry in class_cache_entries:
		if(entry.path.begins_with(&"res://addons/gut/")):
			# print(entry["class"], ':  ', entry["path"])
			all_class_names[entry["class"]] = entry

	for cn in gut_class_names:
		if(!all_class_names.has(cn)):
			missing.append(cn)

	return missing


static func error_if_not_all_classes_imported() -> bool:
	var missing_class_names = get_missing_gut_class_names()
	if(missing_class_names.size() > 0):
		push_error(str("Some GUT class_names have not been imported.  Please restart the Editor or run godot --headless --import\n",
			"Missing class_names:  ",
			missing_class_names))
		return true
	else:
		return false




static func convert():
	var inst = v9_2_0.new()
	inst.validate()


=====================================
FILE: ./addons/gut/gut_vscode_debugger.gd
=====================================
# ------------------------------------------------------------------------------
# Entry point for using the debugger through VSCode.  The gut-extension for
# VSCode launches this instead of gut_cmdln.gd when running tests through the
# debugger.
#
# This could become more complex overtime, but right now all we have to do is
# to make sure the console printer is enabled or you do not get any output.
# ------------------------------------------------------------------------------
extends 'res://addons/gut/gut_cmdln.gd'

func run_tests(runner):
	runner.get_gut().get_logger().disable_printer('console', false)
	runner.run_tests()


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/dynamic_gdscript.gd
=====================================
@tool
var default_script_name_no_extension = 'gut_dynamic_script'
var default_script_resource_path = 'res://addons/gut/not_a_real_file/'
var default_script_extension = "gd"

var _created_script_count = 0


# Creates a loaded script from the passed in source.  This loaded script is
# returned unless there is an error.  When an error occcurs the error number
# is returned instead.
func create_script_from_source(source, override_path=null):
	_created_script_count += 1
	var r_path = str(default_script_resource_path,
		default_script_name_no_extension, '_', _created_script_count, ".",
		default_script_extension)

	if(override_path != null):
		r_path = override_path

	var DynamicScript = GDScript.new()
	DynamicScript.source_code = source.dedent()
	# The resource_path must be unique or Godot thinks it is trying
	# to load something it has already loaded and generates an error like
	# ERROR: Another resource is loaded from path 'workaround for godot
	# issue #65263' (possible cyclic resource inclusion).
	DynamicScript.resource_path = r_path
	var result = DynamicScript.reload()
	if(result != OK):
		DynamicScript = result

	return DynamicScript



=====================================
FILE: ./addons/gut/summary.gd
=====================================
# ------------------------------------------------------------------------------
# Prints things, mostly.  Knows too much about gut.gd, but it's only supposed to
# work with gut.gd, so I'm fine with that.
# ------------------------------------------------------------------------------
# a _test_collector to use when one is not provided.
var _gut = null


func _init(gut=null):
	_gut = gut

# ---------------------
# Private
# ---------------------
func _log_end_run_header(gut):
	var lgr = gut.get_logger()
	lgr.log("\n\n\n")
	lgr.log('==============================================', lgr.fmts.yellow)
	lgr.log("= Run Summary", lgr.fmts.yellow)
	lgr.log('==============================================', lgr.fmts.yellow)


func _log_what_was_run(gut):
	if(!GutUtils.is_null_or_empty(gut._select_script)):
		gut.p('Ran Scripts matching "' + gut._select_script + '"')
	if(!GutUtils.is_null_or_empty(gut._unit_test_name)):
		gut.p('Ran Tests matching "' + gut._unit_test_name + '"')
	if(!GutUtils.is_null_or_empty(gut._inner_class_name)):
		gut.p('Ran Inner Classes matching "' + gut._inner_class_name + '"')


func _log_orphans_and_disclaimer(gut):
	var lgr = gut.get_logger()
	if(!lgr.is_type_enabled('orphan')):
		return

	var counter = gut.get_orphan_counter()
	# Do not count any of the test scripts since these will be released when GUT
	# is released.
	var do_not_count_orphans = counter.get_count("pre_run") + gut.get_test_script_count()
	var total_run_orphans = counter.orphan_count() - do_not_count_orphans

	if(total_run_orphans > 0):
		lgr.orphan(str("Total orphans in run ", total_run_orphans))
		gut.p("Note:  This count does not include GUT objects that will be freed upon exit.")
		gut.p("       It also does not include any orphans created by global scripts")
		gut.p("       loaded before tests were ran.")
		gut.p(str("Total orphans = ", counter.orphan_count()))
		gut.p('')


func _total_fmt(text, value):
	var space = 18
	if(str(value) == '0'):
		value = 'none'
	return str(text.rpad(space), value)


func _log_non_zero_total(text, value, lgr):
	if(str(value) != '0'):
		lgr.log(_total_fmt(text, value))
		return 1
	else:
		return 0


func _log_totals(gut, totals):
	var lgr = gut.get_logger()
	lgr.log()

	lgr.log("---- Totals ----")
	var issue_count = 0
	issue_count += _log_non_zero_total('Errors', totals.errors, lgr)
	issue_count += _log_non_zero_total('Warnings', totals.warnings, lgr)
	issue_count += _log_non_zero_total('Deprecated', totals.deprecated, lgr)
	if(issue_count > 0):
		lgr.log("")

	lgr.log(_total_fmt( 'Scripts', totals.scripts))
	lgr.log(_total_fmt( 'Tests', gut.get_test_collector().get_ran_test_count()))
	lgr.log(_total_fmt( '  Passing', totals.passing_tests))
	_log_non_zero_total('  Failing', totals.failing_tests, lgr)
	_log_non_zero_total('  Risky/Pending', totals.risky + totals.pending, lgr)
	lgr.log(_total_fmt( 'Asserts', totals.passing + totals.failing))
	lgr.log(_total_fmt( 'Time', str(gut.get_elapsed_time(), 's')))

	return totals


func _log_nothing_run(gut):
	var lgr = gut.get_logger()
	lgr.error("Nothing was run.")
	lgr.log('On the one hand nothing failed, on the other hand nothing did anything.')


# ---------------------
# Public
# ---------------------
func log_all_non_passing_tests(gut=_gut):
	var test_collector = gut.get_test_collector()
	var lgr = gut.get_logger()

	var to_return = {
		passing = 0,
		non_passing = 0
	}

	for test_script in test_collector.scripts:
		lgr.set_indent_level(0)

		if(test_script.was_skipped or test_script.get_fail_count() > 0 or test_script.get_pending_count() > 0):
			lgr.log("\n" + test_script.get_full_name(), lgr.fmts.underline)

		if(test_script.was_skipped):
			lgr.inc_indent()
			var skip_msg = str('[Risky] Script was skipped:  ', test_script.skip_reason)
			lgr.log(skip_msg, lgr.fmts.yellow)
			lgr.dec_indent()

		for test in test_script.tests:
			if(test.was_run):
				if(test.is_passing()):
					to_return.passing += 1
				else:
					to_return.non_passing += 1
					lgr.log(str('- ', test.name))
					lgr.inc_indent()

					for i in range(test.fail_texts.size()):
						lgr.failed(test.fail_texts[i])
					for i in range(test.pending_texts.size()):
						lgr.pending(test.pending_texts[i])
					if(test.is_risky()):
						lgr.risky('Did not assert')
					lgr.dec_indent()

	return to_return


func log_the_final_line(totals, gut):
	var lgr = gut.get_logger()
	var grand_total_text = ""
	var grand_total_fmt = lgr.fmts.none
	if(totals.failing_tests > 0):
		grand_total_text = str(totals.failing_tests, " failing tests")
		grand_total_fmt = lgr.fmts.red
	elif(totals.risky > 0 or totals.pending > 0):
		grand_total_text = str(totals.risky + totals.pending, " pending/risky tests.")
		grand_total_fmt = lgr.fmts.yellow
	else:
		grand_total_text = "All tests passed!"
		grand_total_fmt = lgr.fmts.green

	lgr.log(str("---- ", grand_total_text, " ----"), grand_total_fmt)


func log_totals(gut, totals):
	var lgr = gut.get_logger()
	var orig_indent = lgr.get_indent_level()
	lgr.set_indent_level(0)
	_log_totals(gut, totals)
	lgr.set_indent_level(orig_indent)


func get_totals(gut=_gut):
	var tc = gut.get_test_collector()
	var lgr = gut.get_logger()

	var totals = {
		failing = 0,
		failing_tests = 0,
		passing = 0,
		passing_tests = 0,
		pending = 0,
		risky = 0,
		scripts = tc.get_ran_script_count(),
		tests = 0,

		deprecated = lgr.get_deprecated().size(),
		errors = lgr.get_errors().size(),
		warnings = lgr.get_warnings().size(),
	}

	for s in tc.scripts:
		# assert totals
		totals.passing += s.get_pass_count()
		totals.pending += s.get_pending_count()
		totals.failing += s.get_fail_count()

		# test totals
		totals.tests += s.get_ran_test_count()
		totals.passing_tests += s.get_passing_test_count()
		totals.failing_tests += s.get_failing_test_count()
		totals.risky += s.get_risky_count()

	return totals


func log_end_run(gut=_gut):
	var totals = get_totals(gut)
	if(totals.tests == 0):
		_log_nothing_run(gut)
		return

	_log_end_run_header(gut)
	var lgr = gut.get_logger()

	log_all_non_passing_tests(gut)
	log_totals(gut, totals)
	lgr.log("\n")

	_log_orphans_and_disclaimer(gut)
	_log_what_was_run(gut)
	log_the_final_line(totals, gut)
	lgr.log("")


=====================================
FILE: ./addons/gut/input_factory.gd
=====================================
class_name GutInputFactory
## Static class full of helper methods to make InputEvent instances.
##
## This thing makes InputEvents.  Enjoy.

# Implemented InputEvent* convenience methods
# 	InputEventAction
# 	InputEventKey
# 	InputEventMouseButton
# 	InputEventMouseMotion

# Yet to implement InputEvents
# 	InputEventJoypadButton
# 	InputEventJoypadMotion
# 	InputEventMagnifyGesture
# 	InputEventMIDI
# 	InputEventPanGesture
# 	InputEventScreenDrag
# 	InputEventScreenTouch


static func _to_scancode(which):
	var key_code = which
	if(typeof(key_code) == TYPE_STRING):
		key_code = key_code.to_upper().to_ascii_buffer()[0]
	return key_code


## Creates a new button with the given propoerties.
static func new_mouse_button_event(position, global_position, pressed, button_index) -> InputEventMouseButton:
	var event = InputEventMouseButton.new()
	event.position = position
	if(global_position != null):
		event.global_position = global_position
	event.pressed = pressed
	event.button_index = button_index

	return event


## Returns an [InputEventKey] event with [code]pressed = false[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
static func key_up(which) -> InputEventKey:
	var event = InputEventKey.new()
	event.keycode = _to_scancode(which)
	event.pressed = false
	return event


## Returns an [InputEventKey] event with [code]pressed = true[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
static func key_down(which) -> InputEventKey:
	var event = InputEventKey.new()
	event.keycode = _to_scancode(which)
	event.pressed = true
	return event


## Returns an "action up" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
static func action_up(which, strength=1.0) -> InputEventAction:
	var event  = InputEventAction.new()
	event.action = which
	event.strength = strength
	return event


## Returns an "action down" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
static func action_down(which, strength=1.0) -> InputEventAction:
	var event  = InputEventAction.new()
	event.action = which
	event.strength = strength
	event.pressed = true
	return event


## Returns a "button down" [InputEventMouseButton] for the left mouse button.
static func mouse_left_button_down(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, true, MOUSE_BUTTON_LEFT)
	return event


## Returns a "button up" [InputEventMouseButton] for the left mouse button.
static func mouse_left_button_up(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_LEFT)
	return event


## Returns a "double click" [InputEventMouseButton] for the left mouse button.
static func mouse_double_click(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_LEFT)
	event.double_click = true
	return event


## Returns a "button down" [InputEventMouseButton] for the right mouse button.
static func mouse_right_button_down(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, true, MOUSE_BUTTON_RIGHT)
	return event


## Returns a "button up" [InputEventMouseButton] for the right mouse button.
static func mouse_right_button_up(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_RIGHT)
	return event


## Returns a [InputEventMouseMotion] to move the mouse the specified positions.
static func mouse_motion(position, global_position=null) -> InputEventMouseMotion:
	var event = InputEventMouseMotion.new()
	event.position = position
	if(global_position != null):
		event.global_position = global_position
	return event


## Returns an [InputEventMouseMotion] that moves the mouse [param offset]
## from the last [method mouse_motion] or [method mouse_motion] call.
static func mouse_relative_motion(offset, last_motion_event=null, speed=Vector2(0, 0)) -> InputEventMouseMotion:
	var event = null
	if(last_motion_event == null):
		event = mouse_motion(offset)
		event.velocity = speed
	else:
		event = last_motion_event.duplicate()
		event.position += offset
		event.global_position += offset
		event.relative = offset
		event.velocity = speed
	return event

# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Description
# -----------
# ##############################################################################


=====================================
FILE: ./addons/gut/stubber.gd
=====================================
# -------------
# returns{} and parameters {} have the followin structure
# -------------
# {
# 	inst_id_or_path1:{
# 		method_name1: [StubParams, StubParams],
# 		method_name2: [StubParams, StubParams]
# 	},
# 	inst_id_or_path2:{
# 		method_name1: [StubParams, StubParams],
# 		method_name2: [StubParams, StubParams]
# 	}
# }
var returns = {}
var _lgr = GutUtils.get_logger()
var _strutils = GutUtils.Strutils.new()
var _class_db_name_hash = {}

func _init():
	_class_db_name_hash = _make_crazy_dynamic_over_engineered_class_db_hash()

# So, I couldn't figure out how to get to a reference for a GDNative Class
# using a string.  ClassDB has all thier names...so I made a hash using those
# names and the classes.  Then I dynmaically make a script that has that as
# the source and grab the hash out of it and return it.  Super Rube Golbergery,
# but tons of fun.
func _make_crazy_dynamic_over_engineered_class_db_hash():
	var text = "var all_the_classes: Dictionary = {\n"
	for classname in ClassDB.get_class_list():
		if(ClassDB.can_instantiate(classname)):
			text += str('"', classname, '": ', classname, ", \n")
		else:
			text += str('# ', classname, "\n")
	text += "}"
	var inst =  GutUtils.create_script_from_source(text).new()
	return inst.all_the_classes


func _find_matches(obj, method):
	var matches = null
	var last_not_null_parent = null

	# Search for what is passed in first.  This could be a class or an instance.
	# We want to find the instance before we find the class.  If we do not have
	# an entry for the instance then see if we have an entry for the class.
	if(returns.has(obj) and returns[obj].has(method)):
		matches = returns[obj][method]
	elif(GutUtils.is_instance(obj)):
		var parent = obj.get_script()
		var found = false
		while(parent != null and !found):
			found = returns.has(parent)

			if(!found):
				last_not_null_parent = parent
				parent = parent.get_base_script()

		# Could not find the script so check to see if a native class of this
		# type was stubbed.
		if(!found):
			var base_type = last_not_null_parent.get_instance_base_type()
			if(_class_db_name_hash.has(base_type)):
				parent = _class_db_name_hash[base_type]
				found = returns.has(parent)

		if(found and returns[parent].has(method)):
			matches = returns[parent][method]

	return matches


# Searches returns for an entry that matches the instance or the class that
# passed in obj is.
#
# obj can be an instance, class, or a path.
func _find_stub(obj, method, parameters=null, find_overloads=false):
	var to_return = null
	var matches = _find_matches(obj, method)

	if(matches == null):
		return null

	var param_match = null
	var null_match = null
	var overload_match = null

	for i in range(matches.size()):
		var cur_stub = matches[i]
		if(cur_stub.parameters == parameters):
			param_match = cur_stub

		if(cur_stub.parameters == null and !cur_stub.is_param_override_only()):
			null_match = cur_stub

		if(cur_stub.has_param_override()):
			if(overload_match == null || overload_match.is_script_default):
				overload_match = cur_stub

	if(find_overloads and overload_match != null):
		to_return = overload_match
	# We have matching parameter values so return the stub value for that
	elif(param_match != null):
		to_return = param_match
	# We found a case where the parameters were not specified so return
	# parameters for that.  Only do this if the null match is not *just*
	# a paramerter override stub.
	elif(null_match != null):
		to_return = null_match

	return to_return



# ##############
# Public
# ##############

func add_stub(stub_params):
	stub_params._lgr = _lgr
	var key = stub_params.stub_target

	if(!returns.has(key)):
		returns[key] = {}

	if(!returns[key].has(stub_params.stub_method)):
		returns[key][stub_params.stub_method] = []

	returns[key][stub_params.stub_method].append(stub_params)


# Gets a stubbed return value for the object and method passed in.  If the
# instance was stubbed it will use that, otherwise it will use the path and
# subpath of the object to try to find a value.
#
# It will also use the optional list of parameter values to find a value.  If
# the object was stubbed with no parameters than any parameters will match.
# If it was stubbed with specific parameter values then it will try to match.
# If the parameters do not match BUT there was also an empty parameter list stub
# then it will return those.
# If it cannot find anything that matches then null is returned.for
#
# Parameters
# obj:  this should be an instance of a doubled object.
# method:  the method called
# parameters:  optional array of parameter vales to find a return value for.
func get_return(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	if(stub_info != null):
		return stub_info.return_val
	else:
		_lgr.info(str('Call to [', method, '] was not stubbed for the supplied parameters ', parameters, '.  Null was returned.'))
		return null


func should_call_super(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	var is_partial = false
	if(typeof(obj) != TYPE_STRING): # some stubber tests test with strings
		is_partial = obj.__gutdbl.is_partial
	var should = is_partial

	if(stub_info != null):
		should = stub_info.call_super
	elif(!is_partial):
		# this log message is here because of how the generated doubled scripts
		# are structured.  With this log msg here, you will only see one
		# "unstubbed" info instead of multiple.
		_lgr.info('Unstubbed call to ' + method + '::' + _strutils.type2str(obj))
		should = false

	return should


func get_call_this(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	if(stub_info != null):
		return stub_info.call_this


func get_parameter_count(obj, method):
	var to_return = null
	var stub_info = _find_stub(obj, method, null, true)

	if(stub_info != null and stub_info.has_param_override()):
		to_return = stub_info.parameter_count

	return to_return


func get_default_value(obj, method, p_index):
	var to_return = null
	var stub_info = _find_stub(obj, method, null, true)

	if(stub_info != null and
		stub_info.parameter_defaults != null and
		stub_info.parameter_defaults.size() > p_index):

		to_return = stub_info.parameter_defaults[p_index]

	return to_return


func clear():
	returns.clear()


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


func to_s():
	var text = ''
	for thing in returns:
		text += str("-- ", thing, " --\n")
		for method in returns[thing]:
			text += str("\t", method, "\n")
			for i in range(returns[thing][method].size()):
				text += "\t\t" + returns[thing][method][i].to_s() + "\n"

	if(text == ''):
		text = 'Stubber is empty';

	return text


func stub_defaults_from_meta(target, method_meta):
	var params = GutUtils.StubParams.new(target, method_meta)
	params.is_script_default = true
	add_stub(params)


=====================================
FILE: ./addons/gut/utils.gd
=====================================
@tool
class_name GutUtils
extends Object

const GUT_METADATA = '__gutdbl'

# Note, these cannot change since places are checking for TYPE_INT to determine
# how to process parameters.
enum DOUBLE_STRATEGY{
	INCLUDE_NATIVE,
	SCRIPT_ONLY,
}

enum DIFF {
	DEEP,
	SIMPLE
}

const TEST_STATUSES = {
	NO_ASSERTS = 'no asserts',
	SKIPPED = 'skipped',
	NOT_RUN = 'not run',
	PENDING = 'pending',
	# These two got the "ed" b/c pass is a reserved word and I could not
	# think of better words.
	FAILED = 'fail',
	PASSED = 'pass'
}

const DOUBLE_TEMPLATES = {
	FUNCTION = 'res://addons/gut/double_templates/function_template.txt',
	INIT = 'res://addons/gut/double_templates/init_template.txt',
	SCRIPT = 'res://addons/gut/double_templates/script_template.txt',
}


static var GutScene = load('res://addons/gut/GutScene.tscn')
static var LazyLoader = load('res://addons/gut/lazy_loader.gd')
static var VersionNumbers = load("res://addons/gut/version_numbers.gd")
static var WarningsManager = load("res://addons/gut/warnings_manager.gd")
static var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")
# --------------------------------
# Lazy loaded scripts.  These scripts are lazy loaded so that they can be
# declared, but will not load when this script is loaded.  This gives us a
# window at the start of a run to adjust warning levels prior to loading
# everything.
# --------------------------------
static var AutoFree = LazyLoader.new('res://addons/gut/autofree.gd'):
	get: return AutoFree.get_loaded()
	set(val): pass
static var Awaiter = LazyLoader.new('res://addons/gut/awaiter.gd'):
	get: return Awaiter.get_loaded()
	set(val): pass
static var Comparator = LazyLoader.new('res://addons/gut/comparator.gd'):
	get: return Comparator.get_loaded()
	set(val): pass
static var CollectedTest = LazyLoader.new('res://addons/gut/collected_test.gd'):
	get: return CollectedTest.get_loaded()
	set(val): pass
static var CollectedScript = LazyLoader.new('res://addons/gut/collected_script.gd'):
	get: return CollectedScript.get_loaded()
	set(val): pass
static var CompareResult = LazyLoader.new('res://addons/gut/compare_result.gd'):
	get: return CompareResult.get_loaded()
	set(val): pass
static var DiffFormatter = LazyLoader.new("res://addons/gut/diff_formatter.gd"):
	get: return DiffFormatter.get_loaded()
	set(val): pass
static var DiffTool = LazyLoader.new('res://addons/gut/diff_tool.gd'):
	get: return DiffTool.get_loaded()
	set(val): pass
static var DoubleTools = LazyLoader.new("res://addons/gut/double_tools.gd"):
	get: return DoubleTools.get_loader()
	set(val): pass
static var Doubler = LazyLoader.new('res://addons/gut/doubler.gd'):
	get: return Doubler.get_loaded()
	set(val): pass
static var DynamicGdScript = LazyLoader.new("res://addons/gut/dynamic_gdscript.gd") :
	get: return DynamicGdScript.get_loaded()
	set(val): pass
static var Gut = LazyLoader.new('res://addons/gut/gut.gd'):
	get: return Gut.get_loaded()
	set(val): pass
static var GutConfig = LazyLoader.new('res://addons/gut/gut_config.gd'):
	get: return GutConfig.get_loaded()
	set(val): pass
static var HookScript = LazyLoader.new('res://addons/gut/hook_script.gd'):
	get: return HookScript.get_loaded()
	set(val): pass
static var InnerClassRegistry = LazyLoader.new('res://addons/gut/inner_class_registry.gd'):
	get: return InnerClassRegistry.get_loaded()
	set(val): pass
static var InputFactory = LazyLoader.new("res://addons/gut/input_factory.gd"):
	get: return InputFactory.get_loaded()
	set(val): pass
static var InputSender = LazyLoader.new("res://addons/gut/input_sender.gd"):
	get: return InputSender.get_loaded()
	set(val): pass
static var JunitXmlExport = LazyLoader.new('res://addons/gut/junit_xml_export.gd'):
	get: return JunitXmlExport.get_loaded()
	set(val): pass
static var GutLogger = LazyLoader.new('res://addons/gut/logger.gd') : # everything should use get_logger
	get: return GutLogger.get_loaded()
	set(val): pass
static var MethodMaker = LazyLoader.new('res://addons/gut/method_maker.gd'):
	get: return MethodMaker.get_loaded()
	set(val): pass
static var OneToMany = LazyLoader.new('res://addons/gut/one_to_many.gd'):
	get: return OneToMany.get_loaded()
	set(val): pass
static var OrphanCounter = LazyLoader.new('res://addons/gut/orphan_counter.gd'):
	get: return OrphanCounter.get_loaded()
	set(val): pass
static var ParameterFactory = LazyLoader.new('res://addons/gut/parameter_factory.gd'):
	get: return ParameterFactory.get_loaded()
	set(val): pass
static var ParameterHandler = LazyLoader.new('res://addons/gut/parameter_handler.gd'):
	get: return ParameterHandler.get_loaded()
	set(val): pass
static var Printers = LazyLoader.new('res://addons/gut/printers.gd'):
	get: return Printers.get_loaded()
	set(val): pass
static var ResultExporter = LazyLoader.new('res://addons/gut/result_exporter.gd'):
	get: return ResultExporter.get_loaded()
	set(val): pass
static var ScriptCollector = LazyLoader.new('res://addons/gut/script_parser.gd'):
	get: return ScriptCollector.get_loaded()
	set(val): pass
static var SignalWatcher = LazyLoader.new('res://addons/gut/signal_watcher.gd'):
	get: return SignalWatcher.get_loaded()
	set(val): pass
static var Spy = LazyLoader.new('res://addons/gut/spy.gd'):
	get: return Spy.get_loaded()
	set(val): pass
static var Strutils = LazyLoader.new('res://addons/gut/strutils.gd'):
	get: return Strutils.get_loaded()
	set(val): pass
static var Stubber = LazyLoader.new('res://addons/gut/stubber.gd'):
	get: return Stubber.get_loaded()
	set(val): pass
static var StubParams = LazyLoader.new('res://addons/gut/stub_params.gd'):
	get: return StubParams.get_loaded()
	set(val): pass
static var Summary = LazyLoader.new('res://addons/gut/summary.gd'):
	get: return Summary.get_loaded()
	set(val): pass
static var Test = LazyLoader.new('res://addons/gut/test.gd'):
	get: return Test.get_loaded()
	set(val): pass
static var TestCollector = LazyLoader.new('res://addons/gut/test_collector.gd'):
	get: return TestCollector.get_loaded()
	set(val): pass
static var ThingCounter = LazyLoader.new('res://addons/gut/thing_counter.gd'):
	get: return ThingCounter.get_loaded()
	set(val): pass
# --------------------------------

static var avail_fonts = ['AnonymousPro', 'CourierPrime', 'LobsterTwo', 'Default']

static var version_numbers = VersionNumbers.new(
	# gut_versrion (source of truth)
	'9.4.0',
	# required_godot_version
	'4.2.0'
)


static var warnings_at_start := { # WarningsManager dictionary
	exclude_addons = true
}

static var warnings_when_loading_test_scripts := { # WarningsManager dictionary
	enable = false
}


# ------------------------------------------------------------------------------
# Everything should get a logger through this.
#
# When running in test mode this will always return a new logger so that errors
# are not caused by getting bad warn/error/etc counts.
# ------------------------------------------------------------------------------
static var _test_mode = false
static var _lgr = null
static func get_logger():
	if(_test_mode):
		return GutLogger.new()
	else:
		if(_lgr == null):
			_lgr = GutLogger.new()
		return _lgr


static var _dyn_gdscript = DynamicGdScript.new()
static func create_script_from_source(source, override_path=null):
	var are_warnings_enabled = WarningsManager.are_warnings_enabled()
	WarningsManager.enable_warnings(false)

	var DynamicScript = _dyn_gdscript.create_script_from_source(source, override_path)
	if(typeof(DynamicScript) == TYPE_INT):
		var l = get_logger()
		l.error(str('Could not create script from source.  Error:  ', DynamicScript))
		l.info(str("Source Code:\n", add_line_numbers(source)))

	WarningsManager.enable_warnings(are_warnings_enabled)

	return DynamicScript


static func godot_version_string():
	return version_numbers.make_godot_version_string()


static func is_godot_version(expected):
	return VersionNumbers.VerNumTools.is_godot_version_eq(expected)


static func is_godot_version_gte(expected):
	return VersionNumbers.VerNumTools.is_godot_version_gte(expected)


const INSTALL_OK_TEXT = 'Everything checks out'
static func make_install_check_text(template_paths=DOUBLE_TEMPLATES, ver_nums=version_numbers):
	var text = INSTALL_OK_TEXT
	if(!FileAccess.file_exists(template_paths.FUNCTION) or
		!FileAccess.file_exists(template_paths.INIT) or
		!FileAccess.file_exists(template_paths.SCRIPT)):

		text = 'One or more GUT template files are missing.  If this is an exported project, you must include *.txt files in the export to run GUT.  If it is not an exported project then reinstall GUT.'
	elif(!ver_nums.is_godot_version_valid()):
		text = ver_nums.get_bad_version_text()

	return text


static func is_install_valid(template_paths=DOUBLE_TEMPLATES, ver_nums=version_numbers):
	return make_install_check_text(template_paths, ver_nums) == INSTALL_OK_TEXT


# ------------------------------------------------------------------------------
# Gets the root node without having to be in the tree and pushing out an error
# if we don't have a main loop ready to go yet.
# ------------------------------------------------------------------------------
# static func get_root_node():
# 	var main_loop = Engine.get_main_loop()
# 	if(main_loop != null):
# 		return main_loop.root
# 	else:
# 		push_error('No Main Loop Yet')
# 		return null


# ------------------------------------------------------------------------------
# Gets the value from an enum.
# - If passed an integer value as a string it will convert it to an int and
# 	processes the int value.
# - If the value is a float then it is converted to an int and then processes
#	the int value
# - If the value is an int, or was converted to an int, then the enum is checked
#	to see if it contains the value, if so then the value is returned.
#	Otherwise the default is returned.
# - If the value is a string then it is uppercased and all spaces are replaced
#	with underscores.  It then checks to see if enum contains a key of that
#	name.  If so then the value for that key is returned, otherwise the default
#	is returned.
#
# This description is longer than the code, you should have just read the code
# and the tests.
# ------------------------------------------------------------------------------
static func get_enum_value(thing, e, default=null):
	var to_return = default

	if(typeof(thing) == TYPE_STRING and str(thing.to_int()) == thing):
		thing = thing.to_int()
	elif(typeof(thing) == TYPE_FLOAT):
		thing = int(thing)

	if(typeof(thing) == TYPE_STRING):
		var converted = thing.to_upper().replace(' ', '_')
		if(e.keys().has(converted)):
			to_return = e[converted]
	else:
		if(e.values().has(thing)):
			to_return = thing

	return to_return


# ------------------------------------------------------------------------------
# return if_null if value is null otherwise return value
# ------------------------------------------------------------------------------
static func nvl(value, if_null):
	if(value == null):
		return if_null
	else:
		return value


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
static func pretty_print(dict, indent = '  '):
	print(JSON.stringify(dict, indent))


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
static func print_properties(props, thing, print_all_meta=false):
	for i in range(props.size()):
		var prop_name = props[i].name
		var prop_value = thing.get(props[i].name)
		var print_value = str(prop_value)
		if(print_value.length() > 100):
			print_value = print_value.substr(0, 97) + '...'
		elif(print_value == ''):
			print_value = 'EMPTY'

		print(prop_name, ' = ', print_value)
		if(print_all_meta):
			print('  ', props[i])



# ------------------------------------------------------------------------------
# Gets the value of the node_property 'script' from a PackedScene's root node.
# This does not assume the location of the root node in the PackedScene's node
# list.  This also does not assume the index of the 'script' node property in
# a nodes's property list.
# ------------------------------------------------------------------------------
static func get_scene_script_object(scene):
	var state = scene.get_state()
	var to_return = null
	var root_node_path = NodePath(".")
	var node_idx = 0

	while(node_idx < state.get_node_count() and to_return == null):
		if(state.get_node_path(node_idx) == root_node_path):
			for i in range(state.get_node_property_count(node_idx)):
				if(state.get_node_property_name(node_idx, i) == 'script'):
					to_return = state.get_node_property_value(node_idx, i)

		node_idx += 1

	return to_return


# ------------------------------------------------------------------------------
# returns true if the object has been freed, false if not
#
# From what i've read, the weakref approach should work.  It seems to work most
# of the time but sometimes it does not catch it.  The str comparison seems to
# fill in the gaps.  I've not seen any errors after adding that check.
# ------------------------------------------------------------------------------
static func is_freed(obj):
	var wr = weakref(obj)
	return !(wr.get_ref() and str(obj) != '<Freed Object>')


# ------------------------------------------------------------------------------
# Pretty self explanitory.
# ------------------------------------------------------------------------------
static func is_not_freed(obj):
	return !is_freed(obj)


# ------------------------------------------------------------------------------
# Checks if the passed in object is a GUT Double or Partial Double.
# ------------------------------------------------------------------------------
static func is_double(obj):
	var to_return = false
	if(typeof(obj) == TYPE_OBJECT and is_instance_valid(obj)):
		to_return = obj.has_method('__gutdbl_check_method__')
	return to_return


# ------------------------------------------------------------------------------
# Checks an object to see if it is a GDScriptNativeClass
# ------------------------------------------------------------------------------
static func is_native_class(thing):
	var it_is = false
	if(typeof(thing) == TYPE_OBJECT):
		it_is = str(thing).begins_with("<GDScriptNativeClass#")
	return it_is


# ------------------------------------------------------------------------------
# Checks if the passed in is an instance of a class
# ------------------------------------------------------------------------------
static func is_instance(obj):
	return typeof(obj) == TYPE_OBJECT and \
		!is_native_class(obj) and \
		!obj.has_method('new') and \
		!obj.has_method('instantiate')


# ------------------------------------------------------------------------------
# Checks if the passed in is a GDScript
# ------------------------------------------------------------------------------
static func is_gdscript(obj):
	return typeof(obj) == TYPE_OBJECT and str(obj).begins_with('<GDScript#')


# ------------------------------------------------------------------------------
# Checks if the passed in is an inner class
#
# Looks like the resource_path will be populated for gdscripts, and not populated
# for gdscripts inside a gdscript.
# ------------------------------------------------------------------------------
static func is_inner_class(obj):
	return is_gdscript(obj) and obj.resource_path == ''


# ------------------------------------------------------------------------------
# Returns an array of values by calling get(property) on each element in source
# ------------------------------------------------------------------------------
static func extract_property_from_array(source, property):
	var to_return = []
	for i in (source.size()):
		to_return.append(source[i].get(property))
	return to_return


# ------------------------------------------------------------------------------
# true if what is passed in is null or an empty string.
# ------------------------------------------------------------------------------
static func is_null_or_empty(text):
	return text == null or text == ''


# ------------------------------------------------------------------------------
# Get the name of a native class or null if the object passed in is not a
# native class.
# ------------------------------------------------------------------------------
static func get_native_class_name(thing):
	var to_return = null
	if(is_native_class(thing)):
		var newone = thing.new()
		to_return = newone.get_class()
		if(!newone is RefCounted):
			newone.free()
	return to_return


# ------------------------------------------------------------------------------
# Write a file.
# ------------------------------------------------------------------------------
static func write_file(path, content):
	var f = FileAccess.open(path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
	f = null;

	return FileAccess.get_open_error()


# ------------------------------------------------------------------------------
# Returns the text of a file or an empty string if the file could not be opened.
# ------------------------------------------------------------------------------
static func get_file_as_text(path):
	var to_return = ''
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	else:
		var err = FileAccess.get_open_error()
		_lgr.error(str('Could not open file ', path, '.  Error ', err))
	f = null
	return to_return


# ------------------------------------------------------------------------------
# Loops through an array of things and calls a method or checks a property on
# each element until it finds the returned value.  -1 is returned if not found
# or the index is returned if found.
# ------------------------------------------------------------------------------
static func search_array_idx(ar, prop_method, value):
	var found = false
	var idx = 0

	while(idx < ar.size() and !found):
		var item = ar[idx]
		var prop = item.get(prop_method)
		if(!(prop is Callable)):
			if(item.get(prop_method) == value):
				found = true
		elif(prop != null):
			var called_val = prop.call()
			if(called_val == value):
				found = true

		if(!found):
			idx += 1

	if(found):
		return idx
	else:
		return -1


# ------------------------------------------------------------------------------
# Loops through an array of things and calls a method or checks a property on
# each element until it finds the returned value.  The item in the array is
# returned or null if it is not found (this method originally came first).
# ------------------------------------------------------------------------------
static func search_array(ar, prop_method, value):
	var idx = search_array_idx(ar, prop_method, value)

	if(idx != -1):
		return ar[idx]
	else:
		return null


static func are_datatypes_same(got, expected):
	return !(typeof(got) != typeof(expected) and got != null and expected != null)


static func get_script_text(obj):
	return obj.get_script().get_source_code()


# func get_singleton_by_name(name):
# 	var source = str("var singleton = ", name)
# 	var script = GDScript.new()
# 	script.set_source_code(source)
# 	script.reload()
# 	return script.new().singleton


static func dec2bistr(decimal_value, max_bits = 31):
	var binary_string = ""
	var temp
	var count = max_bits

	while(count >= 0):
		temp = decimal_value >> count
		if(temp & 1):
			binary_string = binary_string + "1"
		else:
			binary_string = binary_string + "0"
		count -= 1

	return binary_string


static func add_line_numbers(contents):
	if(contents == null):
		return ''

	var to_return = ""
	var lines = contents.split("\n")
	var line_num = 1
	for line in lines:
		var line_str = str(line_num).lpad(6, ' ')
		to_return += str(line_str, ' |', line, "\n")
		line_num += 1
	return to_return


static func get_display_size():
	return Engine.get_main_loop().get_viewport().get_visible_rect()





# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################



=====================================
FILE: ./addons/gut/collected_test.gd
=====================================
# ------------------------------------------------------------------------------
# Used to keep track of info about each test ran.
# ------------------------------------------------------------------------------
# the name of the function
var name = ""

# flag to know if the name has been printed yet.  Used by the logger.
var has_printed_name = false

# the number of arguments the method has
var arg_count = 0

# the time it took to execute the test in seconds
var time_taken : float = 0

# The number of asserts in the test.  Converted to a property for backwards
# compatibility.  This now reflects the text sizes instead of being a value
# that can be altered externally.
var assert_count = 0 :
	get: return pass_texts.size() + fail_texts.size()
	set(val): pass

# Converted to propety for backwards compatibility.  This now cannot be set
# externally
var pending = false :
	get: return is_pending()
	set(val): pass

# the line number when the test fails
var line_number = -1

# Set internally by Gut using whatever reason Gut wants to use to set this.
# Gut will skip these marked true and the test will be listed as risky.
var should_skip = false  # -- Currently not used by GUT don't believe ^

var pass_texts = []
var fail_texts = []
var pending_texts = []
var orphans = 0

var was_run = false


func did_pass():
	return is_passing()


func add_fail(fail_text):
	fail_texts.append(fail_text)


func add_pending(pending_text):
	pending_texts.append(pending_text)


func add_pass(passing_text):
	pass_texts.append(passing_text)


# must have passed an assert and not have any other status to be passing
func is_passing():
	return pass_texts.size() > 0 and fail_texts.size() == 0 and pending_texts.size() == 0


# failing takes precedence over everything else, so any failures makes the
# test a failure.
func is_failing():
	return fail_texts.size() > 0


# test is only pending if pending was called and the test is not failing.
func is_pending():
	return pending_texts.size() > 0 and fail_texts.size() == 0


func is_risky():
	return should_skip or (was_run and !did_something())


func did_something():
	return is_passing() or is_failing() or is_pending()


func get_status_text():
	var to_return = GutUtils.TEST_STATUSES.NO_ASSERTS

	if(should_skip):
		to_return = GutUtils.TEST_STATUSES.SKIPPED
	elif(!was_run):
		to_return = GutUtils.TEST_STATUSES.NOT_RUN
	elif(pending_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.PENDING
	elif(fail_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.FAILED
	elif(pass_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.PASSED

	return to_return


# Deprecated
func get_status():
	return get_status_text()


func to_s():
	var pad = '     '
	var to_return = str(name, "[", get_status_text(), "]\n")

	for i in range(fail_texts.size()):
		to_return += str(pad, 'Fail:  ', fail_texts[i])
	for i in range(pending_texts.size()):
		to_return += str(pad, 'Pending:  ', pending_texts[i], "\n")
	for i in range(pass_texts.size()):
		to_return += str(pad, 'Pass:  ', pass_texts[i], "\n")
	return to_return




=====================================
FILE: ./addons/gut/script_parser.gd
=====================================
# These methods didn't have flags that would exclude them from being used
# in a double and they appear to break things if they are included.
const BLACKLIST = [
	'get_script',
	'has_method',
]


# ------------------------------------------------------------------------------
# Combins the meta for the method with additional information.
# * flag for whether the method is local
# * adds a 'default' property to all parameters that can be easily checked per
#   parameter
# ------------------------------------------------------------------------------
class ParsedMethod:
	const NO_DEFAULT = '__no__default__'

	var _meta = {}
	var meta = _meta :
		get: return _meta
		set(val): return;

	var is_local = false
	var _parameters = []

	func _init(metadata):
		_meta = metadata
		var start_default = _meta.args.size() - _meta.default_args.size()
		for i in range(_meta.args.size()):
			var arg = _meta.args[i]
			# Add a "default" property to the metadata so we don't have to do
			# weird default paramter position math again.
			if(i >= start_default):
				arg['default'] = _meta.default_args[start_default - i]
			else:
				arg['default'] = NO_DEFAULT
			_parameters.append(arg)


	func is_eligible_for_doubling():
		var has_bad_flag = _meta.flags & \
			(METHOD_FLAG_OBJECT_CORE | METHOD_FLAG_VIRTUAL | METHOD_FLAG_STATIC)
		return !has_bad_flag and BLACKLIST.find(_meta.name) == -1


	func is_accessor():
		return _meta.name.begins_with('@') and \
			(_meta.name.ends_with('_getter') or _meta.name.ends_with('_setter'))


	func to_s():
		var s = _meta.name + "("

		for i in range(_meta.args.size()):
			var arg = _meta.args[i]
			if(str(arg.default) != NO_DEFAULT):
				var val = str(arg.default)
				if(val == ''):
					val = '""'
				s += str(arg.name, ' = ', val)
			else:
				s += str(arg.name)

			if(i != _meta.args.size() -1):
				s += ', '

		s += ")"
		return s




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class ParsedScript:
	# All methods indexed by name.
	var _methods_by_name = {}

	var _script_path = null
	var script_path = _script_path :
		get: return _script_path
		set(val): return;

	var _subpath = null
	var subpath = null :
		get: return _subpath
		set(val): return;

	var _resource = null
	var resource = null :
		get: return _resource
		set(val): return;


	var _is_native = false
	var is_native = _is_native:
		get: return _is_native
		set(val): return;

	var _native_methods = {}
	var _native_class_name = ""



	func _init(script_or_inst, inner_class=null):
		var to_load = script_or_inst

		if(GutUtils.is_native_class(to_load)):
			_resource = to_load
			_is_native = true
			var inst = to_load.new()
			_native_class_name = inst.get_class()
			_native_methods = inst.get_method_list()
			if(!inst is RefCounted):
				inst.free()
		else:
			if(!script_or_inst is Resource):
				to_load = load(script_or_inst.get_script().get_path())

			_script_path = to_load.resource_path
			if(inner_class != null):
				_subpath = _find_subpath(to_load, inner_class)

			if(inner_class == null):
				_resource = to_load
			else:
				_resource = inner_class
				to_load = inner_class

		_parse_methods(to_load)


	func _print_flags(meta):
		print(str(meta.name, ':').rpad(30), str(meta.flags).rpad(4), ' = ', GutUtils.dec2bistr(meta.flags, 10))


	func _get_native_methods(base_type):
		var to_return = []
		if(base_type != null):
			var source = str('extends ', base_type)
			var inst = GutUtils.create_script_from_source(source).new()
			to_return = inst.get_method_list()
			if(! inst is RefCounted):
				inst.free()
		return to_return


	func _parse_methods(thing):
		var methods = []
		if(is_native):
			methods = _native_methods.duplicate()
		else:
			var base_type = thing.get_instance_base_type()
			methods = _get_native_methods(base_type)

		for m in methods:
			var parsed = ParsedMethod.new(m)
			_methods_by_name[m.name] = parsed
			# _init must always be included so that we can initialize
			# double_tools
			if(m.name == '_init'):
				parsed.is_local = true


		# This loop will overwrite all entries in _methods_by_name with the local
		# method object so there is only ever one listing for a function with
		# the right "is_local" flag.
		if(!is_native):
			methods = thing.get_script_method_list()
			for m in methods:
				var parsed_method = ParsedMethod.new(m)
				parsed_method.is_local = true
				_methods_by_name[m.name] = parsed_method


	func _find_subpath(parent_script, inner):
		var const_map = parent_script.get_script_constant_map()
		var consts = const_map.keys()
		var const_idx = 0
		var found = false
		var to_return = null

		while(const_idx < consts.size() and !found):
			var key = consts[const_idx]
			var const_val = const_map[key]
			if(typeof(const_val) == TYPE_OBJECT):
				if(const_val == inner):
					found = true
					to_return = key
				else:
					to_return = _find_subpath(const_val, inner)
					if(to_return != null):
						to_return = str(key, '.', to_return)
						found = true

			const_idx += 1

		return to_return


	func get_method(name):
		return _methods_by_name[name]


	func get_super_method(name):
		var to_return = get_method(name)
		if(to_return.is_local):
			to_return = null

		return to_return

	func get_local_method(name):
		var to_return = get_method(name)
		if(!to_return.is_local):
			to_return = null

		return to_return


	func get_sorted_method_names():
		var keys = _methods_by_name.keys()
		keys.sort()
		return keys


	func get_local_method_names():
		var names = []
		for method in _methods_by_name:
			if(_methods_by_name[method].is_local):
				names.append(method)

		return names


	func get_super_method_names():
		var names = []
		for method in _methods_by_name:
			if(!_methods_by_name[method].is_local):
				names.append(method)

		return names


	func get_local_methods():
		var to_return = []
		for key in _methods_by_name:
			var method = _methods_by_name[key]
			if(method.is_local):
				to_return.append(method)
		return to_return


	func get_super_methods():
		var to_return = []
		for key in _methods_by_name:
			var method = _methods_by_name[key]
			if(!method.is_local):
				to_return.append(method)
		return to_return


	func get_extends_text():
		var text = null
		if(is_native):
			text = str("extends ", _native_class_name)
		else:
			text = str("extends '", _script_path, "'")
			if(_subpath != null):
				text += '.' + _subpath
		return text


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
var scripts = {}

func _get_instance_id(thing):
	var inst_id = null

	if(GutUtils.is_native_class(thing)):
		var id_str = str(thing).replace("<", '').replace(">", '').split('#')[1]
		inst_id = id_str.to_int()
	elif(typeof(thing) == TYPE_STRING):
		if(FileAccess.file_exists(thing)):
			inst_id = load(thing).get_instance_id()
	else:
		inst_id = thing.get_instance_id()

	return inst_id


func parse(thing, inner_thing=null):
	var key = -1
	if(inner_thing == null):
		key = _get_instance_id(thing)
	else:
		key = _get_instance_id(inner_thing)

	var parsed = null

	if(key != null):
		if(scripts.has(key)):
			parsed = scripts[key]
		else:
			var obj = instance_from_id(_get_instance_id(thing))
			var inner = null
			if(inner_thing != null):
				inner = instance_from_id(_get_instance_id(inner_thing))

			if(obj is Resource or GutUtils.is_native_class(obj)):
				parsed = ParsedScript.new(obj, inner)
				scripts[key] = parsed

	return parsed



=====================================
FILE: ./addons/gut/strutils.gd
=====================================
class_name GutStringUtils

# Hash containing all the built in types in Godot.  This provides an English
# name for the types that corosponds with the type constants defined in the
# engine.
var types = {}

func _init_types_dictionary():
	types[TYPE_NIL] = 'NIL'
	types[TYPE_AABB] = 'AABB'
	types[TYPE_ARRAY] = 'ARRAY'
	types[TYPE_BASIS] = 'BASIS'
	types[TYPE_BOOL] = 'BOOL'
	types[TYPE_CALLABLE] = 'CALLABLE'
	types[TYPE_COLOR] = 'COLOR'
	types[TYPE_DICTIONARY] = 'DICTIONARY'
	types[TYPE_FLOAT] = 'FLOAT'
	types[TYPE_INT] = 'INT'
	types[TYPE_MAX] = 'MAX'
	types[TYPE_NODE_PATH] = 'NODE_PATH'
	types[TYPE_OBJECT] = 'OBJECT'
	types[TYPE_PACKED_BYTE_ARRAY] = 'PACKED_BYTE_ARRAY'
	types[TYPE_PACKED_COLOR_ARRAY] = 'PACKED_COLOR_ARRAY'
	types[TYPE_PACKED_FLOAT32_ARRAY] = 'PACKED_FLOAT32_ARRAY'
	types[TYPE_PACKED_FLOAT64_ARRAY] = 'PACKED_FLOAT64_ARRAY'
	types[TYPE_PACKED_INT32_ARRAY] = 'PACKED_INT32_ARRAY'
	types[TYPE_PACKED_INT64_ARRAY] = 'PACKED_INT64_ARRAY'
	types[TYPE_PACKED_STRING_ARRAY] = 'PACKED_STRING_ARRAY'
	types[TYPE_PACKED_VECTOR2_ARRAY] = 'PACKED_VECTOR2_ARRAY'
	types[TYPE_PACKED_VECTOR3_ARRAY] = 'PACKED_VECTOR3_ARRAY'
	types[TYPE_PLANE] = 'PLANE'
	types[TYPE_PROJECTION] = 'PROJECTION'
	types[TYPE_QUATERNION] = 'QUATERNION'
	types[TYPE_RECT2] = 'RECT2'
	types[TYPE_RECT2I] = 'RECT2I'
	types[TYPE_RID] = 'RID'
	types[TYPE_SIGNAL] = 'SIGNAL'
	types[TYPE_STRING_NAME] = 'STRING_NAME'
	types[TYPE_STRING] = 'STRING'
	types[TYPE_TRANSFORM2D] = 'TRANSFORM2D'
	types[TYPE_TRANSFORM3D] = 'TRANSFORM3D'
	types[TYPE_VECTOR2] = 'VECTOR2'
	types[TYPE_VECTOR2I] = 'VECTOR2I'
	types[TYPE_VECTOR3] = 'VECTOR3'
	types[TYPE_VECTOR3I] = 'VECTOR3I'
	types[TYPE_VECTOR4] = 'VECTOR4'
	types[TYPE_VECTOR4I] = 'VECTOR4I'

# Types to not be formatted when using _str
var _str_ignore_types = [
	TYPE_INT, TYPE_FLOAT, TYPE_STRING,
	TYPE_NIL, TYPE_BOOL
]

func _init():
	_init_types_dictionary()

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_filename(path):
	return path.split('/')[-1]

# ------------------------------------------------------------------------------
# Gets the filename of an object passed in.  This does not return the
# full path to the object, just the filename.
# ------------------------------------------------------------------------------
func _get_obj_filename(thing):
	var filename = null

	if(thing == null or
		GutUtils.is_native_class(thing) or
		!is_instance_valid(thing) or
		str(thing) == '<Object#null>' or
		typeof(thing) != TYPE_OBJECT or
		GutUtils.is_double(thing)):
		return

	if(thing.get_script() == null):
		if(thing is PackedScene):
			filename = _get_filename(thing.resource_path)
		else:
			# If it isn't a packed scene and it doesn't have a script then
			# we do nothing.  This just reads better.
			pass
	elif(!GutUtils.is_native_class(thing)):
		var dict = inst_to_dict(thing)
		filename = _get_filename(dict['@path'])
		if(str(dict['@subpath']) != ''):
			filename += str('/', dict['@subpath'])

	return filename

# ------------------------------------------------------------------------------
# Better object/thing to string conversion.  Includes extra details about
# whatever is passed in when it can/should.
# ------------------------------------------------------------------------------
func type2str(thing):
	var filename = _get_obj_filename(thing)
	var str_thing = str(thing)

	if(thing == null):
		# According to str there is a difference between null and an Object
		# that is somehow null.  To avoid getting '[Object:null]' as output
		# always set it to str(null) instead of str(thing).  A null object
		# will pass typeof(thing) == TYPE_OBJECT check so this has to be
		# before that.
		str_thing = str(null)
	elif(typeof(thing) == TYPE_FLOAT):
		if(!'.' in str_thing):
			str_thing += '.0'
	elif(typeof(thing) == TYPE_STRING):
		str_thing = str('"', thing, '"')
	elif(typeof(thing) in _str_ignore_types):
		# do nothing b/c we already have str(thing) in
		# to_return.  I think this just reads a little
		# better this way.
		pass
	elif(typeof(thing) == TYPE_OBJECT):
		if(GutUtils.is_native_class(thing)):
			str_thing = GutUtils.get_native_class_name(thing)
		elif(GutUtils.is_double(thing)):
			var double_path = _get_filename(thing.__gutdbl.thepath)
			if(thing.__gutdbl.subpath != ''):
				double_path += str('/', thing.__gutdbl.subpath)
			elif(thing.__gutdbl.from_singleton != ''):
				double_path = thing.__gutdbl.from_singleton + " Singleton"

			var double_type = "double"
			if(thing.__gutdbl.is_partial):
				double_type = "partial-double"

			str_thing += str("(", double_type, " of ", double_path, ")")

			filename = null
	elif(types.has(typeof(thing))):
		if(!str_thing.begins_with('(')):
			str_thing = '(' + str_thing + ')'
		str_thing = str(types[typeof(thing)], str_thing)

	if(filename != null):
		str_thing += str('(', filename, ')')
	return str_thing

# ------------------------------------------------------------------------------
# Returns the string truncated with an '...' in it.  Shows the start and last
# 10 chars.  If the string is  smaller than max_size the entire string is
# returned.  If max_size is -1 then truncation is skipped.
# ------------------------------------------------------------------------------
func truncate_string(src, max_size):
	var to_return = src
	if(src.length() > max_size - 10 and max_size != -1):
		to_return = str(src.substr(0, max_size - 10), '...',  src.substr(src.length() - 10, src.length()))
	return to_return


func _get_indent_text(times, pad):
	var to_return = ''
	for i in range(times):
		to_return += pad

	return to_return

func indent_text(text, times, pad):
	if(times == 0):
		return text

	var to_return = text
	var ending_newline = ''

	if(text.ends_with("\n")):
		ending_newline = "\n"
		to_return = to_return.left(to_return.length() -1)

	var padding = _get_indent_text(times, pad)
	to_return = to_return.replace("\n", "\n" + padding)
	to_return += ending_newline

	return padding + to_return


=====================================
FILE: ./addons/gut/gut_loader_the_scene.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://jt6wsefn0x54"]

[ext_resource type="Script" path="res://addons/gut/gut_loader_the_scene.gd" id="1_1j0og"]

[node name="Node" type="Node2D"]
script = ExtResource("1_1j0og")


=====================================
FILE: ./addons/gut/parameter_handler.gd
=====================================
var _params = null
var _call_count = 0
var _logger = null

func _init(params=null):
	_params = params
	_logger = GutUtils.get_logger()
	if(typeof(_params) != TYPE_ARRAY):
		_logger.error('You must pass an array to parameter_handler constructor.')
		_params = null


func next_parameters():
	_call_count += 1
	return _params[_call_count -1]

func get_current_parameters():
	return _params[_call_count]

func is_done():
	var done = true
	if(_params != null):
		done = _call_count == _params.size()
	return done

func get_logger():
	return _logger

func set_logger(logger):
	_logger = logger

func get_call_count():
	return _call_count

func get_parameter_count():
	return _params.size()


=====================================
FILE: ./addons/gut/GutScene.gd
=====================================
extends Node2D
# ##############################################################################
# This is a wrapper around the normal and compact gui controls and serves as
# the interface between gut.gd and the gui.  The GutRunner creates an instance
# of this and then this takes care of managing the different GUI controls.
# ##############################################################################
@onready var _normal_gui = $Normal
@onready var _compact_gui = $Compact

var gut = null :
	set(val):
		gut = val
		_set_gut(val)


func _ready():
	_normal_gui.switch_modes.connect(use_compact_mode.bind(true))
	_compact_gui.switch_modes.connect(use_compact_mode.bind(false))

	_normal_gui.set_title("GUT")
	_compact_gui.set_title("GUT")

	_normal_gui.align_right()
	_compact_gui.to_bottom_right()

	use_compact_mode(false)

	if(get_parent() == get_tree().root):
		_test_running_setup()

func _test_running_setup():
	set_font_size(100)
	_normal_gui.get_textbox().text = "hello world, how are you doing?"

# ------------------------
# Private
# ------------------------
func _set_gut(val):
	if(_normal_gui.get_gut() == val):
		return
	_normal_gui.set_gut(val)
	_compact_gui.set_gut(val)

	val.start_run.connect(_on_gut_start_run)
	val.end_run.connect(_on_gut_end_run)
	val.start_pause_before_teardown.connect(_on_gut_pause)
	val.end_pause_before_teardown.connect(_on_pause_end)

func _set_both_titles(text):
	_normal_gui.set_title(text)
	_compact_gui.set_title(text)


# ------------------------
# Events
# ------------------------
func _on_gut_start_run():
	_set_both_titles('Running')

func _on_gut_end_run():
	_set_both_titles('Finished')

func _on_gut_pause():
	_set_both_titles('-- Paused --')

func _on_pause_end():
	_set_both_titles('Running')


# ------------------------
# Public
# ------------------------
func get_textbox():
	return _normal_gui.get_textbox()


func set_font_size(new_size):
	var rtl = _normal_gui.get_textbox()

	rtl.set('theme_override_font_sizes/bold_italics_font_size', new_size)
	rtl.set('theme_override_font_sizes/bold_font_size', new_size)
	rtl.set('theme_override_font_sizes/italics_font_size', new_size)
	rtl.set('theme_override_font_sizes/normal_font_size', new_size)


func set_font(font_name):
	_set_all_fonts_in_rtl(_normal_gui.get_textbox(), font_name)


func _set_font(rtl, font_name, custom_name):
	if(font_name == null):
		rtl.remove_theme_font_override(custom_name)
	else:
		var dyn_font = FontFile.new()
		dyn_font.load_dynamic_font('res://addons/gut/fonts/' + font_name + '.ttf')
		rtl.add_theme_font_override(custom_name, dyn_font)


func _set_all_fonts_in_rtl(rtl, base_name):
	if(base_name == 'Default'):
		_set_font(rtl, null, 'normal_font')
		_set_font(rtl, null, 'bold_font')
		_set_font(rtl, null, 'italics_font')
		_set_font(rtl, null, 'bold_italics_font')
	else:
		_set_font(rtl, base_name + '-Regular', 'normal_font')
		_set_font(rtl, base_name + '-Bold', 'bold_font')
		_set_font(rtl, base_name + '-Italic', 'italics_font')
		_set_font(rtl, base_name + '-BoldItalic', 'bold_italics_font')


func set_default_font_color(color):
	_normal_gui.get_textbox().set('custom_colors/default_color', color)


func set_background_color(color):
	_normal_gui.set_bg_color(color)


func use_compact_mode(should=true):
	_compact_gui.visible = should
	_normal_gui.visible = !should


func set_opacity(val):
	_normal_gui.modulate.a = val
	_compact_gui.modulate.a = val

func set_title(text):
	_set_both_titles(text)


=====================================
FILE: ./addons/gut/awaiter.gd
=====================================
extends Node

signal timeout
signal wait_started

var _wait_time := 0.0
var _wait_process_frames := 0
var _wait_physics_frames := 0
var _signal_to_wait_on = null

var _predicate_method = null
var _waiting_for_predicate_to_be = null

var _predicate_time_between := 0.0
var _predicate_time_between_elpased := 0.0

var _did_last_wait_timeout = false
var did_last_wait_timeout = false :
	get: return _did_last_wait_timeout
	set(val): push_error("Cannot set did_last_wait_timeout")

var _elapsed_time := 0.0
var _elapsed_frames := 0

func _ready() -> void:
	get_tree().process_frame.connect(_on_tree_process_frame)
	get_tree().physics_frame.connect(_on_tree_physics_frame)


func _on_tree_process_frame():
	# Count frames here instead of in _process so that tree order never
	# makes a difference and the count/signaling happens outside of
	# _process being called.
	if(_wait_process_frames > 0):
		_elapsed_frames += 1
		if(_elapsed_frames > _wait_process_frames):
			_end_wait()


func _on_tree_physics_frame():
	# Count frames here instead of in _physics_process so that tree order never
	# makes a difference and the count/signaling happens outside of
	# _physics_process being called.
	if(_wait_physics_frames != 0):
		_elapsed_frames += 1
		if(_elapsed_frames > _wait_physics_frames):
			_end_wait()


func _physics_process(delta):
	if(_wait_time != 0.0):
		_elapsed_time += delta
		if(_elapsed_time >= _wait_time):
			_end_wait()

	if(_predicate_method != null):
		_predicate_time_between_elpased += delta
		if(_predicate_time_between_elpased >= _predicate_time_between):
			_predicate_time_between_elpased = 0.0
			var result = _predicate_method.call()
			if(_waiting_for_predicate_to_be == false):
				if(typeof(result) != TYPE_BOOL or result != true):
					_end_wait()
			else:
				if(typeof(result) == TYPE_BOOL and result == _waiting_for_predicate_to_be):
					_end_wait()


func _end_wait():
	# Check for time before checking for frames so that the extra frames added
	# when waiting on a signal do not cause a false negative for timing out.
	if(_wait_time > 0):
		_did_last_wait_timeout = _elapsed_time >= _wait_time
	elif(_wait_physics_frames > 0):
		_did_last_wait_timeout = _elapsed_frames >= _wait_physics_frames
	elif(_wait_process_frames > 0):
		_did_last_wait_timeout = _elapsed_frames >= _wait_process_frames

	if(_signal_to_wait_on != null and _signal_to_wait_on.is_connected(_signal_callback)):
		_signal_to_wait_on.disconnect(_signal_callback)

	_wait_process_frames = 0
	_wait_time = 0.0
	_wait_physics_frames = 0
	_signal_to_wait_on = null
	_predicate_method = null
	_elapsed_time = 0.0
	_elapsed_frames = 0
	timeout.emit()


const ARG_NOT_SET = '_*_argument_*_is_*_not_set_*_'
func _signal_callback(
		_arg1=ARG_NOT_SET, _arg2=ARG_NOT_SET, _arg3=ARG_NOT_SET,
		_arg4=ARG_NOT_SET, _arg5=ARG_NOT_SET, _arg6=ARG_NOT_SET,
		_arg7=ARG_NOT_SET, _arg8=ARG_NOT_SET, _arg9=ARG_NOT_SET):

	_signal_to_wait_on.disconnect(_signal_callback)
	# DO NOT _end_wait here.  For other parts of the test to get the signal that
	# was waited on, we have to wait for another frames.  For example, the
	# signal_watcher doesn't get the signal in time if we don't do this.
	_wait_process_frames = 1


func wait_seconds(x):
	_did_last_wait_timeout = false
	_wait_time = x
	wait_started.emit()


func wait_process_frames(x):
	_did_last_wait_timeout = false
	_wait_process_frames = x
	wait_started.emit()


func wait_physics_frames(x):
	_did_last_wait_timeout = false
	_wait_physics_frames = x
	wait_started.emit()


func wait_for_signal(the_signal, max_time):
	_did_last_wait_timeout = false
	the_signal.connect(_signal_callback)
	_signal_to_wait_on = the_signal
	_wait_time = max_time
	wait_started.emit()


func wait_until(predicate_function: Callable, max_time, time_between_calls:=0.0):
	_predicate_time_between = time_between_calls
	_predicate_method = predicate_function
	_wait_time = max_time

	_waiting_for_predicate_to_be = true
	_predicate_time_between_elpased = 0.0
	_did_last_wait_timeout = false

	wait_started.emit()


func wait_while(predicate_function: Callable, max_time, time_between_calls:=0.0):
	_predicate_time_between = time_between_calls
	_predicate_method = predicate_function
	_wait_time = max_time

	_waiting_for_predicate_to_be = false
	_predicate_time_between_elpased = 0.0
	_did_last_wait_timeout = false

	wait_started.emit()

func is_waiting():
	return _wait_time != 0.0 || _wait_physics_frames != 0


=====================================
FILE: ./addons/gut/autofree.gd
=====================================
# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Class used to keep track of objects to be freed and utilities to free them.
# ##############################################################################
var _to_free = []
var _to_queue_free = []

func add_free(thing):
	if(typeof(thing) == TYPE_OBJECT):
		if(!thing is RefCounted):
			_to_free.append(thing)

func add_queue_free(thing):
	_to_queue_free.append(thing)

func get_queue_free_count():
	return _to_queue_free.size()

func get_free_count():
	return _to_free.size()

func free_all():
	for i in range(_to_free.size()):
		if(is_instance_valid(_to_free[i])):
			_to_free[i].free()
	_to_free.clear()

	for i in range(_to_queue_free.size()):
		if(is_instance_valid(_to_queue_free[i])):
			_to_queue_free[i].queue_free()
	_to_queue_free.clear()


=====================================
FILE: ./addons/gut/gut.gd
=====================================
extends 'res://addons/gut/gut_to_move.gd'
class_name GutMain
## The GUT brains.
##
## Most of this class is for internal use only.  Features that can be used are
## have descriptions and can be accessed through the [member GutTest.gut] variable
## in your test scripts (extends [GutTest]).
## The wiki page for this class contains only the usable features.
## [br][br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br]
## @ignore-uncommented


# ---------------------------
# Constants
# ---------------------------
const LOG_LEVEL_FAIL_ONLY = 0
const LOG_LEVEL_TEST_AND_FAILURES = 1
const LOG_LEVEL_ALL_ASSERTS = 2
const WAITING_MESSAGE = '/# waiting #/'
const PAUSE_MESSAGE = '/# Pausing.  Press continue button...#/'
const COMPLETED = 'completed'

# ---------------------------
# Signals
# ---------------------------
signal start_pause_before_teardown
signal end_pause_before_teardown

signal start_run
signal end_run
signal start_script(test_script_obj)
signal end_script
signal start_test(test_name)
signal end_test


# ---------------------------
# Settings
#
# These are properties that are usually set before a run is started through
# gutconfig.
# ---------------------------

var _inner_class_name = ''
# When set, GUT will only run Inner-Test-Classes that contain this string.
var inner_class_name = _inner_class_name :
	get: return _inner_class_name
	set(val): _inner_class_name = val

var _ignore_pause_before_teardown = false
# For batch processing purposes, you may want to ignore any calls to
# pause_before_teardown that you forgot to remove_at.
var ignore_pause_before_teardown = _ignore_pause_before_teardown :
	get: return _ignore_pause_before_teardown
	set(val): _ignore_pause_before_teardown = val

var _log_level = 1
## The log detail level.  Valid values are 0 - 2.  Larger values do not matter.
var log_level = _log_level:
	get: return _log_level
	set(val): _set_log_level(val)

# TODO 4.0
# This appears to not be used anymore.  Going to wait for more tests to be
# ported before removing.
var _disable_strict_datatype_checks = false
var disable_strict_datatype_checks = false :
	get: return _disable_strict_datatype_checks
	set(val): _disable_strict_datatype_checks = val

var _export_path = ''
# Path to file that GUT will create which holds a list of all test scripts so
# that GUT can run tests when a project is exported.
var export_path = '' :
	get: return _export_path
	set(val): _export_path = val

var _include_subdirectories = false
# Setting this to true will make GUT search all subdirectories of any directory
# you have configured GUT to search for tests in.
var include_subdirectories = _include_subdirectories :
	get: return _include_subdirectories
	set(val): _include_subdirectories = val


var _double_strategy = GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY
# TODO rework what this is and then document it here.
var double_strategy = _double_strategy  :
	get: return _double_strategy
	set(val):
		if(GutUtils.DOUBLE_STRATEGY.values().has(val)):
			_double_strategy = val
			_doubler.set_strategy(double_strategy)
		else:
			_lgr.error(str("gut.gd:  invalid double_strategy ", val))

var _pre_run_script = ''
# Path to the script that will be run before all tests are run.  This script
# must extend GutHookScript
var pre_run_script = _pre_run_script :
	get: return _pre_run_script
	set(val): _pre_run_script = val

var _post_run_script = ''
# Path to the script that will run after all tests have run.  The script
# must extend GutHookScript
var post_run_script = _post_run_script :
	get: return _post_run_script
	set(val): _post_run_script = val

var _color_output = false
# Flag to color output at the command line and in the GUT GUI.
var color_output = false :
	get: return _color_output
	set(val):
		_color_output = val
		_lgr.disable_formatting(!_color_output)

var _junit_xml_file = ''
# The full path to where GUT should write a JUnit compliant XML file to which
# contains the results of all tests run.
var junit_xml_file = '' :
	get: return _junit_xml_file
	set(val): _junit_xml_file = val

var _junit_xml_timestamp = false
# When true and junit_xml_file is set, the file name will include a
# timestamp so that previous files are not overwritten.
var junit_xml_timestamp = false :
	get: return _junit_xml_timestamp
	set(val): _junit_xml_timestamp = val

# The minimum amout of time GUT will wait before pausing for 1 frame to allow
# the screen to paint.  GUT checkes after each test to see if enough time has
# passed.
var paint_after = .1:
	get: return paint_after
	set(val): paint_after = val

var _unit_test_name = ''
# When set GUT will only run tests that contain this string.
var unit_test_name = _unit_test_name :
	get: return _unit_test_name
	set(val): _unit_test_name = val

var _parameter_handler = null
# This is populated by test.gd each time a paramterized test is encountered
# for the first time.
# FOR INTERNAL USE ONLY
var parameter_handler = _parameter_handler :
	get: return _parameter_handler
	set(val):
		_parameter_handler = val
		_parameter_handler.set_logger(_lgr)

var _lgr = GutUtils.get_logger()
# Local reference for the common logger.
var logger = _lgr :
	get: return _lgr
	set(val):
		_lgr = val
		_lgr.set_gut(self)

var _add_children_to = self
# Sets the object that GUT will add test objects to as it creates them.  The
# default is self, but can be set to other objects so that GUT is not obscured
# by the objects added during tests.
var add_children_to = self :
	get: return _add_children_to
	set(val): _add_children_to = val


var _treat_error_as_failure = true
var treat_error_as_failure = _treat_error_as_failure:
	get: return _treat_error_as_failure
	set(val): _treat_error_as_failure = val

# ------------
# Read only
# ------------
var _test_collector = GutUtils.TestCollector.new()
func get_test_collector():
	return _test_collector

# var version = null :
func get_version():
	return GutUtils.version_numbers.gut_version

var _orphan_counter =  GutUtils.OrphanCounter.new()
func get_orphan_counter():
	return _orphan_counter

var _autofree = GutUtils.AutoFree.new()
func get_autofree():
	return _autofree

var _stubber = GutUtils.Stubber.new()
func get_stubber():
	return _stubber

var _doubler = GutUtils.Doubler.new()
func get_doubler():
	return _doubler

var _spy = GutUtils.Spy.new()
func get_spy():
	return _spy

var _is_running = false
func is_running():
	return _is_running


# ---------------------------
# Private
# ---------------------------
var  _should_print_versions = true # used to cut down on output in tests.
var _should_print_summary = true

var _file_prefix = 'test_'
var _inner_class_prefix = 'Test'

var _select_script = ''
var _last_paint_time = 0.0
var _strutils = GutUtils.Strutils.new()

# The instance that is created from _pre_run_script.  Accessible from
# get_pre_run_script_instance.  These are created at the start of the run
# and then referenced at the appropriate time.  This allows us to validate the
# scripts prior to running.
var _pre_run_script_instance = null
var _post_run_script_instance = null

var _script_name = null

# The instanced scripts.  This is populated as the scripts are run.
var _test_script_objects = []

var _waiting = false

# msecs ticks when run was started
var _start_time = 0.0

# Collected Test instance for the current test being run.
var _current_test = null
var _pause_before_teardown = false


# Used to cancel importing scripts if an error has occurred in the setup.  This
# prevents tests from being run if they were exported and ensures that the
# error displayed is seen since importing generates a lot of text.
#
# TODO this appears to only be checked and never set anywhere.  Verify that this
# was not broken somewhere and remove if no longer used.
var _cancel_import = false

# this is how long Gut will wait when there are items that must be queued free
# when a test completes (due to calls to add_child_autoqfree)
var _auto_queue_free_delay = .1

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _init():
	# When running tests for GUT itself, GutUtils has been setup to always return
	# a new logger so this does not set the gut instance on the base logger
	# when creating test instances of GUT.
	_lgr.set_gut(self) # HEY!  What about tests?  ^^^^^^^^^

	_doubler.set_stubber(_stubber)
	_doubler.set_spy(_spy)
	_doubler.set_gut(self)

	update_loggers()

# Public for tests that set the logger.  This makes it much easier to propigate
# test loggers.
func update_loggers():
	_doubler.set_logger(_lgr)
	_spy.set_logger(_lgr)
	_stubber.set_logger(_lgr)
	_test_collector.set_logger(_lgr)


# ------------------------------------------------------------------------------
# Initialize controls
# ------------------------------------------------------------------------------
func _ready():
	if(_should_print_versions):
		_lgr.log('---  GUT  ---')
		_lgr.info(str('using [', OS.get_user_data_dir(), '] for temporary output.'))

	if(_select_script != null):
		select_script(_select_script)

	_print_versions()

# ------------------------------------------------------------------------------
# Runs right before free is called.  Can't override `free`.
# ------------------------------------------------------------------------------
func _notification(what):
	if(what == NOTIFICATION_PREDELETE):
		for ts in _test_script_objects:
			if(is_instance_valid(ts)):
				ts.free()

		_test_script_objects = []


func _print_versions(send_all = true):
	if(!_should_print_versions):
		return

	var info = GutUtils.version_numbers.get_version_text()

	if(send_all):
		p(info)
	else:
		_lgr.get_printer('gui').send(info + "\n")




# ---------------------------
#
# Accessor code
#
# ---------------------------


# ------------------------------------------------------------------------------
# Set the log level.  Use one of the various LOG_LEVEL_* constants.
# ------------------------------------------------------------------------------
func _set_log_level(level):
	_log_level = max(level, 0)

	# Level 0 settings
	_lgr.set_less_test_names(level == 0)
	# Explicitly always enabled
	_lgr.set_type_enabled(_lgr.types.normal, true)
	_lgr.set_type_enabled(_lgr.types.error, true)
	_lgr.set_type_enabled(_lgr.types.pending, true)

	# Level 1 types
	_lgr.set_type_enabled(_lgr.types.warn, level > 0)
	_lgr.set_type_enabled(_lgr.types.deprecated, level > 0)

	# Level 2 types
	_lgr.set_type_enabled(_lgr.types.passed, level > 1)
	_lgr.set_type_enabled(_lgr.types.info, level > 1)
	_lgr.set_type_enabled(_lgr.types.debug, level > 1)

# ---------------------------
#
# Events
#
# ---------------------------
func end_teardown_pause():
	_pause_before_teardown = false
	_waiting = false
	end_pause_before_teardown.emit()

# ---------------------------
#
# Private
#
# ---------------------------
func _log_test_children_warning(test_script):
	if(!_lgr.is_type_enabled(_lgr.types.orphan)):
		return

	var kids = test_script.get_children()
	if(kids.size() > 1):
		var msg = ''
		if(_log_level == 2):
			msg = "Test script still has children when all tests finisehd.\n"
			for i in range(kids.size()):
				msg += str("  ", _strutils.type2str(kids[i]), "\n")
			msg += "You can use autofree, autoqfree, add_child_autofree, or add_child_autoqfree to automatically free objects."
		else:
			msg = str("Test script has ", kids.size(), " unfreed children.  Increase log level for more details.")

		_lgr.warn(msg)


func _log_end_run():
	if(_should_print_summary):
		var summary = GutUtils.Summary.new(self)
		summary.log_end_run()


func _validate_hook_script(path):
	var result = {
		valid = true,
		instance = null
	}

	# empty path is valid but will have a null instance
	if(path == ''):
		return result

	if(FileAccess.file_exists(path)):
		var inst = load(path).new()
		if(inst and inst is GutHookScript):
			result.instance = inst
			result.valid = true
		else:
			result.valid = false
			_lgr.error('The hook script [' + path + '] does not extend GutHookScript')
	else:
		result.valid = false
		_lgr.error('The hook script [' + path + '] does not exist.')

	return result


# ------------------------------------------------------------------------------
# Runs a hook script.  Script must exist, and must extend
# GutHookScript or addons/gut/hook_script.gd
# ------------------------------------------------------------------------------
func _run_hook_script(inst):
	if(inst != null):
		inst.gut = self
		await inst.run()
	return inst

# ------------------------------------------------------------------------------
# Initialize variables for each run of a single test script.
# ------------------------------------------------------------------------------
func _init_run():
	var valid = true
	_test_collector.set_test_class_prefix(_inner_class_prefix)
	_test_script_objects = []
	_current_test = null
	_is_running = true

	var pre_hook_result = _validate_hook_script(_pre_run_script)
	_pre_run_script_instance = pre_hook_result.instance
	var post_hook_result = _validate_hook_script(_post_run_script)
	_post_run_script_instance  = post_hook_result.instance

	valid = pre_hook_result.valid and  post_hook_result.valid

	return valid


# ------------------------------------------------------------------------------
# Print out run information and close out the run.
# ------------------------------------------------------------------------------
func _end_run():
	_log_end_run()
	_is_running = false

	await _run_hook_script(get_post_run_script_instance())
	_export_results()
	end_run.emit()


# ------------------------------------------------------------------------------
# Add additional export types here.
# ------------------------------------------------------------------------------
func _export_results():
	if(_junit_xml_file != ''):
		_export_junit_xml()

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _export_junit_xml():
	var exporter = GutUtils.JunitXmlExport.new()
	var output_file = _junit_xml_file

	if(_junit_xml_timestamp):
		var ext = "." + output_file.get_extension()
		output_file = output_file.replace(ext, str("_", Time.get_unix_time_from_system(), ext))

	var f_result = exporter.write_file(self, output_file)
	if(f_result == OK):
		p(str("Results saved to ", output_file))


# ------------------------------------------------------------------------------
# Print out the heading for a new script
# ------------------------------------------------------------------------------
func _print_script_heading(coll_script):
	if(_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
		_lgr.log(str("\n\n", coll_script.get_full_name()), _lgr.fmts.underline)


# ------------------------------------------------------------------------------
# Yes if the class name is null or the script's class name includes class_name
# ------------------------------------------------------------------------------
func _does_class_name_match(the_class_name, script_class_name):
	return (the_class_name == null or the_class_name == '') or \
		(script_class_name != null and str(script_class_name).findn(the_class_name) != -1)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _setup_script(test_script, collected_script):
	test_script.gut = self
	test_script.set_logger(_lgr)
	_add_children_to.add_child(test_script)
	_test_script_objects.append(test_script)

	if(!test_script._was_ready_called):
		test_script._do_ready_stuff()
		_lgr.warn(str("!!! YOU HAVE UPSET YOUR GUT !!!\n",
			"You have overridden _ready in [", collected_script.get_filename_and_inner(), "] ",
			"but it does not call super._ready().  New additions (or maybe old ",
			"by the time you see this) require that super._ready() is called.",
			"\n\n",
			"GUT is working around this infraction, but may not be able to in ",
			"the future.  GUT also reserves the right to decide it does not want ",
			"to work around it in the future.  ",
			"You should probably use before_all instead of _ready.  I can think ",
			"of a few reasons why you would want to use _ready but I won't list ",
			"them here because I think they are bad ideas.  I know they are bad ",
			"ideas because I did them.  Hence the warning.  This message is ",
			"intentially long so that it bothers you and you change your ways.\n\n",
			"Thank you for using GUT."))


# ------------------------------------------------------------------------------
# returns self so it can be integrated into the yield call.
# ------------------------------------------------------------------------------
func _wait_for_continue_button():
	p(PAUSE_MESSAGE, 0)
	_waiting = true
	return self


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_indexes_matching_script_name(script_name):
	var indexes = [] # empty runs all
	for i in range(_test_collector.scripts.size()):
		if(_test_collector.scripts[i].get_filename().find(script_name) != -1):
			indexes.append(i)
	return indexes


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_indexes_matching_path(path):
	var indexes = []
	for i in range(_test_collector.scripts.size()):
		if(_test_collector.scripts[i].path == path):
			indexes.append(i)
	return indexes


# ------------------------------------------------------------------------------
# Execute all calls of a parameterized test.
# ------------------------------------------------------------------------------
func _run_parameterized_test(test_script, test_name):
	await _run_test(test_script, test_name)

	if(_current_test.assert_count == 0 and !_current_test.pending):
		_lgr.risky('Test did not assert')

	if(_parameter_handler == null):
		_lgr.error(str('Parameterized test ', _current_test.name, ' did not call use_parameters for the default value of the parameter.'))
		_fail(str('Parameterized test ', _current_test.name, ' did not call use_parameters for the default value of the parameter.'))
	else:
		while(!_parameter_handler.is_done()):
			var cur_assert_count = _current_test.assert_count
			await _run_test(test_script, test_name)
			if(_current_test.assert_count == cur_assert_count and !_current_test.pending):
				_lgr.risky('Test did not assert')

	_parameter_handler = null


# ------------------------------------------------------------------------------
# Runs a single test given a test.gd instance and the name of the test to run.
# ------------------------------------------------------------------------------
func _run_test(script_inst, test_name):
	_lgr.log_test_name()
	_lgr.set_indent_level(1)
	_orphan_counter.add_counter('test')

	await script_inst.before_each()

	start_test.emit(test_name)

	await script_inst.call(test_name)

	# if the test called pause_before_teardown then await until
	# the continue button is pressed.
	if(_pause_before_teardown and !_ignore_pause_before_teardown):
		start_pause_before_teardown.emit()
		await _wait_for_continue_button().end_pause_before_teardown

	script_inst.clear_signal_watcher()

	# call each post-each-test method until teardown is removed.
	await script_inst.after_each()

	# Free up everything in the _autofree.  Yield for a bit if we
	# have anything with a queue_free so that they have time to
	# free and are not found by the orphan counter.
	var aqf_count = _autofree.get_queue_free_count()
	_autofree.free_all()
	if(aqf_count > 0):
		await get_tree().create_timer(_auto_queue_free_delay).timeout

	if(_log_level > 0):
		_orphan_counter.print_orphans('test', _lgr)

	_doubler.get_ignored_methods().clear()


# ------------------------------------------------------------------------------
# Calls after_all on the passed in test script and takes care of settings so all
# logger output appears indented and with a proper heading
#
# Calls both pre-all-tests methods until prerun_setup is removed
# ------------------------------------------------------------------------------
func _call_before_all(test_script, collected_script):
	var before_all_test_obj = GutUtils.CollectedTest.new()
	before_all_test_obj.has_printed_name = false
	before_all_test_obj.name = 'before_all'

	collected_script.setup_teardown_tests.append(before_all_test_obj)
	_current_test = before_all_test_obj

	_lgr.inc_indent()
	await test_script.before_all()
	# before all does not need to assert anything so only mark it as run if
	# some assert was done.
	before_all_test_obj.was_run = before_all_test_obj.did_something()

	_lgr.dec_indent()

	_current_test = null


# ------------------------------------------------------------------------------
# Calls after_all on the passed in test script and takes care of settings so all
# logger output appears indented and with a proper heading
#
# Calls both post-all-tests methods until postrun_teardown is removed.
# ------------------------------------------------------------------------------
func _call_after_all(test_script, collected_script):
	var after_all_test_obj = GutUtils.CollectedTest.new()
	after_all_test_obj.has_printed_name = false
	after_all_test_obj.name = 'after_all'

	collected_script.setup_teardown_tests.append(after_all_test_obj)
	_current_test = after_all_test_obj

	_lgr.inc_indent()
	await test_script.after_all()
	# after all does not need to assert anything so only mark it as run if
	# some assert was done.
	after_all_test_obj.was_run = after_all_test_obj.did_something()
	_lgr.dec_indent()

	_current_test = null


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _should_skip_script(test_script, collected_script):
	var skip_message = 'not skipped'
	var skip_value = test_script.get('skip_script')
	var should_skip = false

	if(skip_value == null):
		skip_value = await test_script.should_skip_script()
	else:
		_lgr.deprecated('Using the skip_script var has been deprecated.  Implement the new should_skip_script() method in your test instead.')

	if(skip_value != null):
		if(typeof(skip_value) == TYPE_BOOL):
			should_skip = skip_value
			if(skip_value):
				skip_message = 'script marked to skip'
		elif(typeof(skip_value) == TYPE_STRING):
			should_skip = true
			skip_message = skip_value

	if(should_skip):
		var msg = str('- [Script skipped]:  ', skip_message)
		_lgr.inc_indent()
		_lgr.log(msg, _lgr.fmts.yellow)
		_lgr.dec_indent()
		collected_script.skip_reason = skip_message
		collected_script.was_skipped = true

	return should_skip

# ------------------------------------------------------------------------------
# Run all tests in a script.  This is the core logic for running tests.
# ------------------------------------------------------------------------------
func _test_the_scripts(indexes=[]):
	_orphan_counter.add_counter('pre_run')

	_print_versions(false)
	var is_valid = _init_run()
	if(!is_valid):
		_lgr.error('Something went wrong and the run was aborted.')
		return

	await _run_hook_script(get_pre_run_script_instance())
	if(_pre_run_script_instance!= null and _pre_run_script_instance.should_abort()):
		_lgr.error('pre-run abort')
		end_run.emit()
		return

	start_run.emit()
	_start_time = Time.get_ticks_msec()
	_last_paint_time = _start_time

	var indexes_to_run = []
	if(indexes.size()==0):
		for i in range(_test_collector.scripts.size()):
			indexes_to_run.append(i)
	else:
		indexes_to_run = indexes


	# loop through scripts
	for test_indexes in range(indexes_to_run.size()):
		var coll_script = _test_collector.scripts[indexes_to_run[test_indexes]]
		_orphan_counter.add_counter('script')

		if(coll_script.tests.size() > 0):
			_lgr.set_indent_level(0)
			_print_script_heading(coll_script)

		if(!coll_script.is_loaded):
			break

		start_script.emit(coll_script)

		var test_script = coll_script.get_new()

		_setup_script(test_script, coll_script)
		_doubler.set_strategy(_double_strategy)

		# ----
		# SHORTCIRCUIT
		# skip_script logic
		if(await _should_skip_script(test_script, coll_script)):
			continue
		# ----

		# !!!
		# Hack so there isn't another indent to this monster of a method.  if
		# inner class is set and we do not have a match then empty the tests
		# for the current test.
		# !!!
		if(!_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
			coll_script.tests = []
		else:
			coll_script.was_run = true
			await _call_before_all(test_script, coll_script)

		# Each test in the script
		for i in range(coll_script.tests.size()):
			_stubber.clear()
			_spy.clear()
			_current_test = coll_script.tests[i]

			if((_unit_test_name != '' and _current_test.name.find(_unit_test_name) > -1) or
				(_unit_test_name == '')):

				var ticks_before := Time.get_ticks_usec()

				if(_current_test.arg_count > 1):
					_lgr.error(str('Parameterized test ', _current_test.name,
						' has too many parameters:  ', _current_test.arg_count, '.'))
				elif(_current_test.arg_count == 1):
					_current_test.was_run = true
					await _run_parameterized_test(test_script, _current_test.name)
				else:
					_current_test.was_run = true
					await _run_test(test_script, _current_test.name)

				if(!_current_test.did_something()):
					_lgr.risky(str(_current_test.name, ' did not assert'))

				_current_test.has_printed_name = false

				_current_test.time_taken = (Time.get_ticks_usec() - ticks_before) / 1000000.0

				end_test.emit()

				# After each test, check to see if we shoudl wait a frame to
				# paint based on how much time has elapsed since we last 'painted'
				if(paint_after > 0.0):
					var now = Time.get_ticks_msec()
					var time_since = (now - _last_paint_time) / 1000.0
					if(time_since > paint_after):
						_last_paint_time = now
						await get_tree().process_frame

		_current_test = null
		_lgr.dec_indent()
		_orphan_counter.print_orphans('script', _lgr)

		if(_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
			await _call_after_all(test_script, coll_script)

		_log_test_children_warning(test_script)
		# This might end up being very resource intensive if the scripts
		# don't clean up after themselves.  Might have to consolidate output
		# into some other structure and kill the script objects with
		# test_script.free() instead of remove_at child.
		_add_children_to.remove_child(test_script)

		_lgr.set_indent_level(0)
		if(test_script.get_assert_count() > 0):
			var script_sum = str(coll_script.get_passing_test_count(), '/', coll_script.get_ran_test_count(), ' passed.')
			_lgr.log(script_sum, _lgr.fmts.bold)

		end_script.emit()
		# END TEST SCRIPT LOOP

	_lgr.set_indent_level(0)
	# Give anything that is queued to be freed time to be freed before we count
	# the orphans.  Without this, the last test's awaiter won't be freed
	# yet, which messes with the orphans total.  There could also be objects
	# the user has queued to be freed as well.
	await get_tree().create_timer(.1).timeout
	_end_run()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _pass(text=''):
	if(_current_test):
		_current_test.add_pass(text)


# ------------------------------------------------------------------------------
# Returns an empty string or "(call #x) " if the current test being run has
# parameters.  The
# ------------------------------------------------------------------------------
func get_call_count_text():
	var to_return = ''
	if(_parameter_handler != null):
		# This uses get_call_count -1 because test.gd's use_parameters method
		# should have been called before we get to any calls for this method
		# just due to how use_parameters works.  There isn't a way to know
		# whether we are before or after that call.
		to_return = str('params[', _parameter_handler.get_call_count() -1, '] ')
	return to_return


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _fail(text=''):
	if(_current_test != null):
		var line_number = _extract_line_number(_current_test)
		var line_text = '  at line ' + str(line_number)
		p(line_text, LOG_LEVEL_FAIL_ONLY)
		# format for summary
		line_text =  "\n    " + line_text
		var call_count_text = get_call_count_text()
		_current_test.line_number = line_number
		_current_test.add_fail(call_count_text + text + line_text)


# ------------------------------------------------------------------------------
# This is "private" but is only used by the logger, it is not used internally.
# It was either, make this weird method or "do it the right way" with signals
# or some other crazy mechanism.
# ------------------------------------------------------------------------------
func _fail_for_error(err_text):
	if(_current_test != null and treat_error_as_failure):
		_fail(err_text)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _pending(text=''):
	if(_current_test):
		_current_test.add_pending(text)


# ------------------------------------------------------------------------------
# Extracts the line number from curren stacktrace by matching the test case name
# ------------------------------------------------------------------------------
func _extract_line_number(current_test):
	var line_number = -1
	# if stack trace available than extraxt the test case line number
	var stackTrace = get_stack()
	if(stackTrace!=null):
		for index in stackTrace.size():
			var line = stackTrace[index]
			var function = line.get("function")
			if function == current_test.name:
				line_number = line.get("line")
	return line_number


# ------------------------------------------------------------------------------
# Gets all the files in a directory and all subdirectories if include_subdirectories
# is true.  The files returned are all sorted by name.
# ------------------------------------------------------------------------------
func _get_files(path, prefix, suffix):
	var files = []
	var directories = []
	# ignore addons/gut per issue 294
	if(path == 'res://addons/gut'):
		return [];

	var d = DirAccess.open(path)
	d.include_hidden = false
	d.include_navigational = false

	# Traversing a directory is kinda odd.  You have to start the process of
	# listing the contents of a directory with list_dir_begin then use get_next
	# until it returns an empty string.  Then I guess you should end it.
	d.list_dir_begin()
	var fs_item = d.get_next()
	var full_path = ''
	while(fs_item != ''):
		full_path = path.path_join(fs_item)

		# MUST use FileAccess since d.file_exists returns false for exported
		# projects
		if(FileAccess.file_exists(full_path)):
			if(fs_item.begins_with(prefix) and fs_item.ends_with(suffix)):
				files.append(full_path)
		# MUST use DirAccess, d.dir_exists is false for exported projects.
		elif(include_subdirectories and DirAccess.dir_exists_absolute(full_path)):
			directories.append(full_path)

		fs_item = d.get_next()
	d.list_dir_end()

	for dir in range(directories.size()):
		var dir_files = _get_files(directories[dir], prefix, suffix)
		for i in range(dir_files.size()):
			files.append(dir_files[i])

	files.sort()
	return files


# ---------------------------
#
# public
#
# ---------------------------

func get_elapsed_time() -> float:
	var to_return = 0.0
	if(_start_time != 0.0):
		to_return = Time.get_ticks_msec() - _start_time
	to_return = to_return / 1000.0

	return to_return

# ------------------------------------------------------------------------------
# Conditionally prints the text to the console/results variable based on the
# current log level and what level is passed in.  Whenever currently in a test,
# the text will be indented under the test.  It can be further indented if
# desired.
#
# The first time output is generated when in a test, the test name will be
# printed.
# ------------------------------------------------------------------------------
func p(text, level=0):
	var str_text = str(text)

	if(level <= GutUtils.nvl(_log_level, 0)):
		_lgr.log(str_text)

# ---------------------------
#
# RUN TESTS/ADD SCRIPTS
#
# ---------------------------

# ------------------------------------------------------------------------------
# Runs all the scripts that were added using add_script
# ------------------------------------------------------------------------------
func test_scripts(_run_rest=false):
	if(_script_name != null and _script_name != ''):
		var indexes = _get_indexes_matching_script_name(_script_name)
		if(indexes == []):
			_lgr.error(str(
				"Could not find script matching '", _script_name, "'.\n",
				"Check your directory settings and Script Prefix/Suffix settings."))
			end_run.emit()
		else:
			_test_the_scripts(indexes)
	else:
		_test_the_scripts([])

# alias
func run_tests(run_rest=false):
	test_scripts(run_rest)


# ------------------------------------------------------------------------------
# Runs a single script passed in.
# ------------------------------------------------------------------------------
# func run_test_script(script):
# 	_test_collector.set_test_class_prefix(_inner_class_prefix)
# 	_test_collector.clear()
# 	_test_collector.add_script(script)
# 	_test_the_scripts()


# ------------------------------------------------------------------------------
# Adds a script to be run when test_scripts called.
# ------------------------------------------------------------------------------
func add_script(script):
	if(!Engine.is_editor_hint()):
		_test_collector.set_test_class_prefix(_inner_class_prefix)
		_test_collector.add_script(script)


# ------------------------------------------------------------------------------
# Add all scripts in the specified directory that start with the prefix and end
# with the suffix.  Does not look in sub directories.  Can be called multiple
# times.
# ------------------------------------------------------------------------------
func add_directory(path, prefix=_file_prefix, suffix=".gd"):
	# check for '' b/c the calls to addin the exported directories 1-6 will pass
	# '' if the field has not been populated.  This will cause res:// to be
	# processed which will include all files if include_subdirectories is true.
	if(path == '' or path == null):
		return

	var dir = DirAccess.open(path)
	if(dir == null):
		_lgr.error(str('The path [', path, '] does not exist.'))
	else:
		var files = _get_files(path, prefix, suffix)
		for i in range(files.size()):
			if(_script_name == null or _script_name == '' or \
					(_script_name != null and files[i].findn(_script_name) != -1)):
				add_script(files[i])


# ------------------------------------------------------------------------------
# This will try to find a script in the list of scripts to test that contains
# the specified script name.  It does not have to be a full match.  It will
# select the first matching occurrence so that this script will run when run_tests
# is called.  Works the same as the select_this_one option of add_script.
#
# returns whether it found a match or not
# ------------------------------------------------------------------------------
func select_script(script_name):
	_script_name = script_name
	_select_script = script_name


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func export_tests(path=_export_path):
	if(path == null):
		_lgr.error('You must pass a path or set the export_path before calling export_tests')
	else:
		var result = _test_collector.export_tests(path)
		if(result):
			_lgr.info(_test_collector.to_s())
			_lgr.info("Exported to " + path)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func import_tests(path=_export_path):
	if(!FileAccess.file_exists(path)):
		_lgr.error(str('Cannot import tests:  the path [', path, '] does not exist.'))
	else:
		_test_collector.clear()
		var result = _test_collector.import_tests(path)
		if(result):
			_lgr.info("\n" + _test_collector.to_s())
			_lgr.info("Imported from " + path)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func import_tests_if_none_found():
	if(!_cancel_import and _test_collector.scripts.size() == 0):
		import_tests()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func export_if_tests_found():
	if(_test_collector.scripts.size() > 0):
		export_tests()

# ---------------------------
#
# MISC
#
# ---------------------------


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func maximize():
	_lgr.deprecated('gut.maximize')


# ------------------------------------------------------------------------------
# Clears the text of the text box.  This resets all counters.
# ------------------------------------------------------------------------------
func clear_text():
	_lgr.deprecated('gut.clear_text')


# ------------------------------------------------------------------------------
# Get the number of tests that were ran
# ------------------------------------------------------------------------------
func get_test_count():
	return _test_collector.get_ran_test_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that were made
func get_assert_count():
	return _test_collector.get_assert_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that passed
func get_pass_count():
	return _test_collector.get_pass_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that failed
func get_fail_count():
	return _test_collector.get_fail_count()

# ------------------------------------------------------------------------------
## Get the number of tests flagged as pending
func get_pending_count():
	return _test_collector.get_pending_count()


# ------------------------------------------------------------------------------
# Call this method to make the test pause before teardown so that you can inspect
# anything that you have rendered to the screen.
# ------------------------------------------------------------------------------
func pause_before_teardown():
	_pause_before_teardown = true;


# ------------------------------------------------------------------------------
# Returns the script object instance that is currently being run.
# ------------------------------------------------------------------------------
func get_current_script_object():
	var to_return = null
	if(_test_script_objects.size() > 0):
		to_return = _test_script_objects[-1]
	return to_return


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_current_test_object():
	return _current_test


## Returns a summary.gd object that contains all the information about
## the run results.
func get_summary():
	return GutUtils.Summary.new(self)

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_pre_run_script_instance():
	return _pre_run_script_instance

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_post_run_script_instance():
	return _post_run_script_instance

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func show_orphans(should):
	_lgr.set_type_enabled(_lgr.types.orphan, should)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_logger():
	return _lgr


# ------------------------------------------------------------------------------
## Returns the number of test scripts.  Inner Test classes each count as a
## script.
func get_test_script_count():
	return _test_script_objects.size()




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/diff_tool.gd
=====================================
extends 'res://addons/gut/compare_result.gd'
const INDENT = '    '
enum {
	DEEP,
	SIMPLE
}

var _strutils = GutUtils.Strutils.new()
var _compare = GutUtils.Comparator.new()
var DiffTool = load('res://addons/gut/diff_tool.gd')

var _value_1 = null
var _value_2 = null
var _total_count = 0
var _diff_type = null
var _brackets = null
var _valid = true
var _desc_things = 'somethings'

# -------- comapre_result.gd "interface" ---------------------
func set_are_equal(val):
	_block_set('are_equal', val)

func get_are_equal():
	if(!_valid):
		return null
	else:
		return differences.size() == 0


func set_summary(val):
	_block_set('summary', val)

func get_summary():
	return summarize()

func get_different_count():
	return differences.size()

func  get_total_count():
	return _total_count

func get_short_summary():
	var text = str(_strutils.truncate_string(str(_value_1), 50),
		' ', _compare.get_compare_symbol(are_equal), ' ',
		_strutils.truncate_string(str(_value_2), 50))
	if(!are_equal):
		text += str('  ', get_different_count(), ' of ', get_total_count(),
			' ', _desc_things, ' do not match.')
	return text

func get_brackets():
	return _brackets
# -------- comapre_result.gd "interface" ---------------------


func _invalidate():
	_valid = false
	differences = null


func _init(v1,v2,diff_type=DEEP):
	_value_1 = v1
	_value_2 = v2
	_diff_type = diff_type
	_compare.set_should_compare_int_to_float(false)
	_find_differences(_value_1, _value_2)


func _find_differences(v1, v2):
	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) == TYPE_ARRAY):
			_brackets = {'open':'[', 'close':']'}
			_desc_things = 'indexes'
			_diff_array(v1, v2)
		elif(typeof(v2) == TYPE_DICTIONARY):
			_brackets = {'open':'{', 'close':'}'}
			_desc_things = 'keys'
			_diff_dictionary(v1, v2)
		else:
			_invalidate()
			GutUtils.get_logger().error('Only Arrays and Dictionaries are supported.')
	else:
		_invalidate()
		GutUtils.get_logger().error('Only Arrays and Dictionaries are supported.')


func _diff_array(a1, a2):
	_total_count = max(a1.size(), a2.size())
	for i in range(a1.size()):
		var result = null
		if(i < a2.size()):
			if(_diff_type == DEEP):
				result = _compare.deep(a1[i], a2[i])
			else:
				result = _compare.simple(a1[i], a2[i])
		else:
			result = _compare.simple(a1[i], _compare.MISSING, 'index')

		if(!result.are_equal):
			differences[i] = result

	if(a1.size() < a2.size()):
		for i in range(a1.size(), a2.size()):
			differences[i] = _compare.simple(_compare.MISSING, a2[i], 'index')


func _diff_dictionary(d1, d2):
	var d1_keys = d1.keys()
	var d2_keys = d2.keys()

	# Process all the keys in d1
	_total_count += d1_keys.size()
	for key in d1_keys:
		if(!d2.has(key)):
			differences[key] = _compare.simple(d1[key], _compare.MISSING, 'key')
		else:
			d2_keys.remove_at(d2_keys.find(key))

			var result = null
			if(_diff_type == DEEP):
				result = _compare.deep(d1[key], d2[key])
			else:
				result = _compare.simple(d1[key], d2[key])

			if(!result.are_equal):
				differences[key] = result

	# Process all the keys in d2 that didn't exist in d1
	_total_count += d2_keys.size()
	for i in range(d2_keys.size()):
		differences[d2_keys[i]] = _compare.simple(_compare.MISSING, d2[d2_keys[i]], 'key')


func summarize():
	var summary = ''

	if(are_equal):
		summary = get_short_summary()
	else:
		var formatter = load('res://addons/gut/diff_formatter.gd').new()
		formatter.set_max_to_display(max_differences)
		summary = formatter.make_it(self)

	return summary


func get_diff_type():
	return _diff_type


func get_value_1():
	return _value_1


func get_value_2():
	return _value_2


=====================================
FILE: ./addons/gut/UserFileViewer.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bsm7wtt1gie4v"]

[ext_resource type="Script" path="res://addons/gut/UserFileViewer.gd" id="1"]

[node name="UserFileViewer" type="Window"]
exclusive = true
script = ExtResource("1")

[node name="FileDialog" type="FileDialog" parent="."]
access = 1
show_hidden_files = true
__meta__ = {
"_edit_use_anchors_": false
}

[node name="TextDisplay" type="ColorRect" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_right = -10.0
offset_bottom = -65.0
color = Color(0.2, 0.188235, 0.188235, 1)

[node name="RichTextLabel" type="RichTextLabel" parent="TextDisplay"]
anchor_right = 1.0
anchor_bottom = 1.0
focus_mode = 2
text = "In publishing and graphic design, Lorem ipsum is a placeholder text commonly used to demonstrate the visual form of a document or a typeface without relying on meaningful content. Lorem ipsum may be used before final copy is available, but it may also be used to temporarily replace copy in a process called greeking, which allows designers to consider form without the meaning of the text influencing the design.

Lorem ipsum is typically a corrupted version of De finibus bonorum et malorum, a first-century BCE text by the Roman statesman and philosopher Cicero, with words altered, added, and removed to make it nonsensical, improper Latin.

Versions of the Lorem ipsum text have been used in typesetting at least since the 1960s, when it was popularized by advertisements for Letraset transfer sheets. Lorem ipsum was introduced to the digital world in the mid-1980s when Aldus employed it in graphic and word-processing templates for its desktop publishing program PageMaker. Other popular word processors including Pages and Microsoft Word have since adopted Lorem ipsum as well."
selection_enabled = true

[node name="OpenFile" type="Button" parent="."]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -158.0
offset_top = -50.0
offset_right = -84.0
offset_bottom = -30.0
text = "Open File"

[node name="Home" type="Button" parent="."]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -478.0
offset_top = -50.0
offset_right = -404.0
offset_bottom = -30.0
text = "Home"

[node name="Copy" type="Button" parent="."]
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 160.0
offset_top = -50.0
offset_right = 234.0
offset_bottom = -30.0
text = "Copy"

[node name="End" type="Button" parent="."]
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -318.0
offset_top = -50.0
offset_right = -244.0
offset_bottom = -30.0
text = "End"

[node name="Close" type="Button" parent="."]
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 10.0
offset_top = -50.0
offset_right = 80.0
offset_bottom = -30.0
text = "Close"

[connection signal="file_selected" from="FileDialog" to="." method="_on_FileDialog_file_selected"]
[connection signal="visibility_changed" from="FileDialog" to="." method="_on_file_dialog_visibility_changed"]
[connection signal="pressed" from="OpenFile" to="." method="_on_OpenFile_pressed"]
[connection signal="pressed" from="Home" to="." method="_on_Home_pressed"]
[connection signal="pressed" from="Copy" to="." method="_on_Copy_pressed"]
[connection signal="pressed" from="End" to="." method="_on_End_pressed"]
[connection signal="pressed" from="Close" to="." method="_on_Close_pressed"]


=====================================
FILE: ./addons/gut/hook_script.gd
=====================================
class_name GutHookScript
## This script is the base for custom scripts to be used in pre and post
## run hooks.
##
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br][br]
## Creating a hook script requires that you:[br]
##  - Inherit [code skip-lint]GutHookScript[/code][br]
##  - Implement a [code skip-lint]run()[/code] method[br]
##  - Configure the path in GUT (gutconfig aand/or editor) as the approparite hook (pre or post).[br]
##
## See [wiki]Hooks[/wiki]


## Class responsible for generating xml.  You could use this to generate XML
## yourself instead of using the built in GUT xml generation options.  See
## [addons/gut/junit_xml_export.gd]
var JunitXmlExport = load('res://addons/gut/junit_xml_export.gd')

## This is the instance of [GutMain] that is running the tests.  You can get
## information about the run from this object.  This is set by GUT when the
## script is instantiated.
var gut  = null

# the exit code to be used by gut_cmdln.  See set method.
var _exit_code = null

var _should_abort =  false

## Virtual method that will be called by GUT after instantiating this script.
## This is where you put all of your logic.
func run():
	gut.logger.error("Run method not overloaded.  Create a 'run()' method in your hook script to run your code.")


## Set the exit code when running from the command line.  If not set then the
## default exit code will be returned (0 when no tests fail, 1 when any tests
## fail).
func set_exit_code(code : int):
	_exit_code  = code

## Returns the exit code set with [code skip-lint]set_exit_code[/code]
func get_exit_code():
	return _exit_code

## Usable by pre-run script to cause the run to end AFTER the run() method
## finishes.  GUT will quit and post-run script will not be ran.
func abort():
	_should_abort = true

## Returns if [code skip-lint]abort[/code] was called.
func should_abort():
	return _should_abort


=====================================
FILE: ./addons/gut/cli/gut_cli.gd
=====================================
extends Node

var Optparse = load('res://addons/gut/cli/optparse.gd')
var Gut = load('res://addons/gut/gut.gd')
var GutRunner = load('res://addons/gut/gui/GutRunner.tscn')

# ------------------------------------------------------------------------------
# Helper class to resolve the various different places where an option can
# be set.  Using the get_value method will enforce the order of precedence of:
# 	1.  command line value
#	2.  config file value
#	3.  default value
#
# The idea is that you set the base_opts.  That will get you a copies of the
# hash with null values for the other types of values.  Lower precedented hashes
# will punch through null values of higher precedented hashes.
# ------------------------------------------------------------------------------
class OptionResolver:
	var base_opts = {}
	var cmd_opts = {}
	var config_opts = {}


	func get_value(key):
		return _nvl(cmd_opts[key], _nvl(config_opts[key], base_opts[key]))

	func set_base_opts(opts):
		base_opts = opts
		cmd_opts = _null_copy(opts)
		config_opts = _null_copy(opts)

	# creates a copy of a hash with all values null.
	func _null_copy(h):
		var new_hash = {}
		for key in h:
			new_hash[key] = null
		return new_hash

	func _nvl(a, b):
		if(a == null):
			return b
		else:
			return a

	func _string_it(h):
		var to_return = ''
		for key in h:
			to_return += str('(',key, ':', _nvl(h[key], 'NULL'), ')')
		return to_return

	func to_s():
		return str("base:\n", _string_it(base_opts), "\n", \
				"config:\n", _string_it(config_opts), "\n", \
				"cmd:\n", _string_it(cmd_opts), "\n", \
				"resolved:\n", _string_it(get_resolved_values()))

	func get_resolved_values():
		var to_return = {}
		for key in base_opts:
			to_return[key] = get_value(key)
		return to_return

	func to_s_verbose():
		var to_return = ''
		var resolved = get_resolved_values()
		for key in base_opts:
			to_return += str(key, "\n")
			to_return += str('  default: ', _nvl(base_opts[key], 'NULL'), "\n")
			to_return += str('  config:  ', _nvl(config_opts[key], ' --'), "\n")
			to_return += str('  cmd:     ', _nvl(cmd_opts[key], ' --'), "\n")
			to_return += str('  final:   ', _nvl(resolved[key], 'NULL'), "\n")

		return to_return

# ------------------------------------------------------------------------------
# Here starts the actual script that uses the Options class to kick off Gut
# and run your tests.
# ------------------------------------------------------------------------------
var _gut_config = load('res://addons/gut/gut_config.gd').new()

# array of command line options specified
var _final_opts = []


func setup_options(options, font_names):
	var opts = Optparse.new()
	opts.banner =\
"""
The GUT CLI
-----------
The default behavior for GUT is to load options from a res://.gutconfig.json if
it exists.  Any options specified on the command line will take precedence over
options specified in the gutconfig file.  You can specify a different gutconfig
file with the -gconfig option.

To generate a .gutconfig.json file you can use -gprint_gutconfig_sample
To see the effective values of a CLI command and a gutconfig use -gpo

Values for options can be supplied using:
    option=value    # no space around "="
    option value    # a space between option and value w/o =

Options whose values are lists/arrays can be specified multiple times:
	-gdir=a,b
	-gdir c,d
	-gdir e
	# results in -gdir equaling [a, b, c, d, e]
"""
	opts.add_heading("Test Config:")
	opts.add('-gdir', options.dirs, 'List of directories to search for test scripts in.')
	opts.add('-ginclude_subdirs', false, 'Flag to include all subdirectories specified with -gdir.')
	opts.add('-gtest', [], 'List of full paths to test scripts to run.')
	opts.add('-gprefix', options.prefix, 'Prefix used to find tests when specifying -gdir.  Default "[default]".')
	opts.add('-gsuffix', options.suffix, 'Test script suffix, including .gd extension.  Default "[default]".')
	opts.add('-gconfig', 'res://.gutconfig.json', 'The config file to load options from.  The default is [default].  Use "-gconfig=" to not use a config file.')
	opts.add('-gpre_run_script', '', 'pre-run hook script path')
	opts.add('-gpost_run_script', '', 'post-run hook script path')
	opts.add('-gerrors_do_not_cause_failure', false, 'When an internal GUT error occurs tests will fail.  With this option set, that does not happen.')
	opts.add('-gdouble_strategy', 'SCRIPT_ONLY', 'Default strategy to use when doubling.  Valid values are [INCLUDE_NATIVE, SCRIPT_ONLY].  Default "[default]"')

	opts.add_heading("Run Options:")
	opts.add('-gselect', '', 'All scripts that contain the specified string in their filename will be ran')
	opts.add('-ginner_class', '', 'Only run inner classes that contain the specified string in their name.')
	opts.add('-gunit_test_name', '', 'Any test that contains the specified text will be run, all others will be skipped.')
	opts.add('-gexit', false, 'Exit after running tests.  If not specified you have to manually close the window.')
	opts.add('-gexit_on_success', false, 'Only exit if zero tests fail.')
	opts.add('-gignore_pause', false, 'Ignores any calls to pause_before_teardown.')

	opts.add_heading("Display Settings:")
	opts.add('-glog', options.log_level, 'Log level [0-3].  Default [default]')
	opts.add('-ghide_orphans', false, 'Display orphan counts for tests and scripts.  Default [default].')
	opts.add('-gmaximize', false, 'Maximizes test runner window to fit the viewport.')
	opts.add('-gcompact_mode', false, 'The runner will be in compact mode.  This overrides -gmaximize.')
	opts.add('-gopacity', options.opacity, 'Set opacity of test runner window. Use range 0 - 100. 0 = transparent, 100 = opaque.')
	opts.add('-gdisable_colors', false, 'Disable command line colors.')
	opts.add('-gfont_name', options.font_name, str('Valid values are:  ', font_names, '.  Default "[default]"'))
	opts.add('-gfont_size', options.font_size, 'Font size, default "[default]"')
	opts.add('-gbackground_color', options.background_color, 'Background color as an html color, default "[default]"')
	opts.add('-gfont_color',options.font_color, 'Font color as an html color, default "[default]"')
	opts.add('-gpaint_after', options.paint_after, 'Delay before GUT will add a 1 frame pause to paint the screen/GUI.  default [default]')

	opts.add_heading("Result Export:")
	opts.add('-gjunit_xml_file', options.junit_xml_file, 'Export results of run to this file in the Junit XML format.')
	opts.add('-gjunit_xml_timestamp', options.junit_xml_timestamp, 'Include a timestamp in the -gjunit_xml_file, default [default]')

	opts.add_heading("Help:")
	opts.add('-gh', false, 'Print this help.  You did this to see this, so you probably understand.')
	opts.add('-gpo', false, 'Print option values from all sources and the value used.')
	opts.add('-gprint_gutconfig_sample', false, 'Print out json that can be used to make a gutconfig file.')

	return opts


# Parses options, applying them to the _tester or setting values
# in the options struct.
func extract_command_line_options(from, to):
	to.config_file = from.get_value_or_null('-gconfig')
	to.dirs = from.get_value_or_null('-gdir')
	to.disable_colors =  from.get_value_or_null('-gdisable_colors')
	to.double_strategy = from.get_value_or_null('-gdouble_strategy')
	to.ignore_pause = from.get_value_or_null('-gignore_pause')
	to.include_subdirs = from.get_value_or_null('-ginclude_subdirs')
	to.inner_class = from.get_value_or_null('-ginner_class')
	to.log_level = from.get_value_or_null('-glog')
	to.opacity = from.get_value_or_null('-gopacity')
	to.post_run_script = from.get_value_or_null('-gpost_run_script')
	to.pre_run_script = from.get_value_or_null('-gpre_run_script')
	to.prefix = from.get_value_or_null('-gprefix')
	to.selected = from.get_value_or_null('-gselect')
	to.should_exit = from.get_value_or_null('-gexit')
	to.should_exit_on_success = from.get_value_or_null('-gexit_on_success')
	to.should_maximize = from.get_value_or_null('-gmaximize')
	to.compact_mode = from.get_value_or_null('-gcompact_mode')
	to.hide_orphans = from.get_value_or_null('-ghide_orphans')
	to.suffix = from.get_value_or_null('-gsuffix')
	to.errors_do_not_cause_failure = from.get_value_or_null('-gerrors_do_not_cause_failure')
	to.tests = from.get_value_or_null('-gtest')
	to.unit_test_name = from.get_value_or_null('-gunit_test_name')

	to.font_size = from.get_value_or_null('-gfont_size')
	to.font_name = from.get_value_or_null('-gfont_name')
	to.background_color = from.get_value_or_null('-gbackground_color')
	to.font_color = from.get_value_or_null('-gfont_color')
	to.paint_after = from.get_value_or_null('-gpaint_after')

	to.junit_xml_file = from.get_value_or_null('-gjunit_xml_file')
	to.junit_xml_timestamp = from.get_value_or_null('-gjunit_xml_timestamp')



func _print_gutconfigs(values):
	var header = """Here is a sample of a full .gutconfig.json file.
You do not need to specify all values in your own file.  The values supplied in
this sample are what would be used if you ran gut w/o the -gprint_gutconfig_sample
option.   Option priority is:  command-line, .gutconfig, default)."""
	print("\n", header.replace("\n", ' '), "\n")
	var resolved = values

	# remove_at some options that don't make sense to be in config
	resolved.erase("config_file")
	resolved.erase("show_help")

	print(JSON.stringify(resolved, '  '))

	for key in resolved:
		resolved[key] = null

	print("\n\nAnd here's an empty config for you fill in what you want.")
	print(JSON.stringify(resolved, ' '))


func _run_tests(opt_resolver):
	_final_opts = opt_resolver.get_resolved_values();
	_gut_config.options = _final_opts

	var runner = GutRunner.instantiate()
	runner.set_gut_config(_gut_config)
	get_tree().root.add_child(runner)

	runner.run_tests()


# parse options and run Gut
func main():
	var opt_resolver = OptionResolver.new()
	opt_resolver.set_base_opts(_gut_config.default_options)

	var cli_opts = setup_options(_gut_config.default_options, _gut_config.valid_fonts)

	cli_opts.parse()
	var all_options_valid = cli_opts.unused.size() == 0
	extract_command_line_options(cli_opts, opt_resolver.cmd_opts)

	var config_path = opt_resolver.get_value('config_file')
	var load_result = 1
	# Checking for an empty config path allows us to not use a config file via
	# the -gconfig_file option since using "-gconfig_file=" or -gconfig_file=''"
	# will result in an empty string.
	if(config_path != ''):
		load_result = _gut_config.load_options_no_defaults(config_path)

	# SHORTCIRCUIT
	if(!all_options_valid):
		print('Unknown arguments:  ', cli_opts.unused)
		get_tree().quit(1)
	elif(load_result == -1):
		print('Invalid gutconfig ', load_result)
		get_tree().quit(1)
	else:
		opt_resolver.config_opts = _gut_config.options

		if(cli_opts.get_value('-gh')):
			print(GutUtils.version_numbers.get_version_text())
			cli_opts.print_help()
			get_tree().quit(0)
		elif(cli_opts.get_value('-gpo')):
			print('All config options and where they are specified.  ' +
				'The "final" value shows which value will actually be used ' +
				'based on order of precedence (default < .gutconfig < cmd line).' + "\n")
			print(opt_resolver.to_s_verbose())
			get_tree().quit(0)
		elif(cli_opts.get_value('-gprint_gutconfig_sample')):
			_print_gutconfigs(opt_resolver.get_resolved_values())
			get_tree().quit(0)
		else:
			_run_tests(opt_resolver)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/cli/change_project_warnings.gd
=====================================
extends SceneTree

var Optparse = load('res://addons/gut/cli/optparse.gd')
var WarningsManager = load("res://addons/gut/warnings_manager.gd")
const WARN_VALUE_PRINT_POSITION = 36

var godot_default_warnings = {
  "assert_always_false": 1,             "assert_always_true": 1,  			"confusable_identifier": 1,
  "confusable_local_declaration": 1,    "confusable_local_usage": 1,  		"constant_used_as_function": 1,
  "deprecated_keyword": 1,              "empty_file": 1,  					"enable": true,
  "exclude_addons": true, 				"function_used_as_property": 1,  	"get_node_default_without_onready": 2,
  "incompatible_ternary": 1,  			"inference_on_variant": 2,  		"inferred_declaration": 0,
  "int_as_enum_without_cast": 1,  		"int_as_enum_without_match": 1,  	"integer_division": 1,
  "narrowing_conversion": 1,  			"native_method_override": 2,  		"onready_with_export": 2,
  "property_used_as_function": 1,  		"redundant_await": 1,  				"redundant_static_unload": 1,
  "renamed_in_godot_4_hint": 1,  		"return_value_discarded": 0,  		"shadowed_global_identifier": 1,
  "shadowed_variable": 1,  				"shadowed_variable_base_class": 1,  "standalone_expression": 1,
  "standalone_ternary": 1,  			"static_called_on_instance": 1,  	"unassigned_variable": 1,
  "unassigned_variable_op_assign": 1,  	"unreachable_code": 1,  			"unreachable_pattern": 1,
  "unsafe_call_argument": 0,  			"unsafe_cast": 0,  					"unsafe_method_access": 0,
  "unsafe_property_access": 0,  		"unsafe_void_return": 1,  			"untyped_declaration": 0,
  "unused_local_constant": 1,  			"unused_parameter": 1,  			"unused_private_class_variable": 1,
  "unused_signal": 1,  					"unused_variable": 1
}

var gut_default_changes = {
  "exclude_addons": false, 				"redundant_await": 0,
}

var warning_settings = {}

func _setup_warning_settings():
	warning_settings["godot_default"] = godot_default_warnings
	warning_settings["current"] = WarningsManager.create_warnings_dictionary_from_project_settings()
	warning_settings["all_warn"] = WarningsManager.create_warn_all_warnings_dictionary()

	var gut_default = godot_default_warnings.duplicate()
	gut_default.merge(gut_default_changes, true)
	warning_settings["gut_default"] = gut_default


func _warn_value_to_s(value):
	var readable = str(value).capitalize()
	if(typeof(value) == TYPE_INT):
		readable = WarningsManager.WARNING_LOOKUP.get(value, str(readable, ' ???'))
		readable = readable.capitalize()
	return readable


func _human_readable(warnings):
	var to_return = ""
	for key in warnings:
		var readable = _warn_value_to_s(warnings[key])
		to_return += str(key.capitalize().rpad(35, ' '), readable, "\n")
	return to_return


func _dump_settings(which):
	if(warning_settings.has(which)):
		GutUtils.pretty_print(warning_settings[which])
	else:
		print("UNKNOWN print option ", which)


func _print_settings(which):
	if(warning_settings.has(which)):
		print(_human_readable(warning_settings[which]))
	else:
		print("UNKNOWN print option ", which)


func _apply_settings(which):
	if(!warning_settings.has(which)):
		print("UNKNOWN set option ", which)
		return

	var pre_settings = warning_settings["current"]
	var new_settings = warning_settings[which]

	if(new_settings == pre_settings):
		print("-- Settings are the same, no changes were made --")
		return

	WarningsManager.apply_warnings_dictionary(new_settings)
	ProjectSettings.save()
	print("-- Project Warning Settings have been updated --")
	print(_diff_changes_text(pre_settings))


func _diff_text(w1, w2, diff_col_pad=10):
	var to_return = ""
	for key in w1:
		var v1_text = _warn_value_to_s(w1[key])
		var v2_text = _warn_value_to_s(w2[key])
		var diff_text = v1_text
		var prefix = "  "

		if(v1_text != v2_text):
			var diff_prefix = " "
			if(w1[key] > w2[key]):
				diff_prefix = "-"
			else:
				diff_prefix = "+"
			prefix = "* "
			diff_text = str(v1_text.rpad(diff_col_pad, ' '), diff_prefix, v2_text)

		to_return += str(str(prefix, key.capitalize()).rpad(WARN_VALUE_PRINT_POSITION, ' '), diff_text, "\n")

	return to_return.rstrip("\n")


func _diff_changes_text(pre_settings):
	var orig_diff_text = _diff_text(
		pre_settings,
		WarningsManager.create_warnings_dictionary_from_project_settings(),
		0)
	# these next two lines are fragile and brute force...enjoy
	var diff_text = orig_diff_text.replace("-", " -> ")
	diff_text = diff_text.replace("+", " -> ")

	if(orig_diff_text == diff_text):
		diff_text += "\n-- No changes were made --"
	else:
		diff_text += "\nChanges will not be visible in Godot until it is restarted.\n"
		diff_text += "Even if it asks you to reload...Maybe.  Probably."

	return diff_text



func _diff(name_1, name_2):
	if(warning_settings.has(name_1) and warning_settings.has(name_2)):
		var c2_pad = name_1.length() + 2
		var heading = str(" ".repeat(WARN_VALUE_PRINT_POSITION), name_1.rpad(c2_pad, ' '), name_2, "\n")
		heading += str(
			" ".repeat(WARN_VALUE_PRINT_POSITION),
			"-".repeat(name_1.length()).rpad(c2_pad, " "),
			"-".repeat(name_2.length()),
			"\n")

		var text = _diff_text(warning_settings[name_1], warning_settings[name_2], c2_pad)

		print(heading)
		print(text)

		var diff_count = 0
		for line in text.split("\n"):
			if(!line.begins_with("  ")):
				diff_count += 1

		if(diff_count == 0):
			print('-- [', name_1, "] and [", name_2, "] are the same --")
		else:
			print('-- There are ', diff_count, ' differences between [', name_1, "] and [", name_2, "] --")
	else:
		print("One or more unknown Warning Level Names:, [", name_1, "] [", name_2, "]")


func _set_settings(nvps):
	var pre_settings = warning_settings["current"]
	for i in range(nvps.size()/2):
		var s_name = nvps[i * 2]
		var s_value = nvps[i * 2 + 1]
		if(godot_default_warnings.has(s_name)):
			var t = typeof(godot_default_warnings[s_name])
			if(t == TYPE_INT):
				s_value = s_value.to_int()
			elif(t == TYPE_BOOL):
				s_value = s_value.to_lower() == 'true'

			WarningsManager.set_project_setting_warning(s_name, s_value)
			ProjectSettings.save()
	print(_diff_changes_text(pre_settings))



func _setup_options():
	var opts = Optparse.new()
	opts.banner = """
	This script prints info about or sets the warning settings for the project.
	Each action requires one or more Warning Level Names.

	Warning Level Names:
	    * current        The current settings for the project.
	    * godot_default  The default settings for Godot.
	    * gut_default    The warning settings that is used when developing GUT.
	    * all_warn       Everything set to warn.
	""".dedent()

	opts.add('-h', false, 'Print this help')
	opts.add('-set', [], "Sets a single setting in the project settings and saves.\n" +
						 "Use -dump to see a list of setting names and values.\n" +
						 "Example: -set enabled,true -set unsafe_cast,2 -set unreachable_code,0")
	opts.add_heading(" Actions (require Warning Level Name)")
	opts.add('-diff', [], "Shows the difference between two Warning Level Names.\n" +
						  "Example:  -diff current,all_warn")
	opts.add('-dump', 'none', "Prints a dictionary of the warning values.")
	opts.add('-print', 'none', "Print human readable warning values.")
	opts.add('-apply', 'none', "Applys one of the Warning Level Names to the project settings.  You should restart after using this")

	return opts

func _print_help(opts):
	opts.print_help()



func _init():
	# Testing might set this flag but it should never be disabled for this tool
	# or it cannot save project settings, but says it did.  Sneakily use the
	# private property to get around this property being read-only.  Don't
	# try this at home.
	WarningsManager._disabled = false

	_setup_warning_settings()

	var opts = _setup_options()
	opts.parse()

	if(opts.unused.size() != 0):
		opts.print_help()
		print("Unknown arguments ", opts.unused)
	if(opts.values.h):
		opts.print_help()
	elif(opts.values.print != 'none'):
		_print_settings(opts.values.print)
	elif(opts.values.dump != 'none'):
		_dump_settings(opts.values.dump)
	elif(opts.values.apply != 'none'):
		_apply_settings(opts.values.apply )
	elif(opts.values.diff.size() == 2):
		_diff(opts.values.diff[0], opts.values.diff[1])
	elif(opts.values.set.size() % 2 == 0):
		_set_settings(opts.values.set)
	else:
		opts.print_help()
		print("You didn't specify any options or too many or not the right size or something invalid.  I don't know what you want to do.")

	quit()

=====================================
FILE: ./addons/gut/cli/optparse.gd
=====================================
## Parses command line arguments, as one might expect.
##
## Parses command line arguments with a bunch of options including generating
## text that displays all the arguments your script accepts.  This
## is included in the GUT ClassRef since it might be usable by others and is
## portable (everything it needs is in this one file).
## [br]
## This does alot, if you want to see it in action have a look at
##	[url=https://github.com/bitwes/Gut/blob/main/scratch/optparse_example.gd]scratch/optparse_example.gd[/url]
## [codeblock lang=text]
##
## Godot Argument Lists
## -------------------------
## There are two sets of command line arguments that Godot populates:
##	OS.get_cmdline_args
##	OS.get_cmdline_user_args.
##
## OS.get_cmdline_args contains any arguments that are not used by the engine
## itself.  This means options like --help and -d will never appear in this list
## since these are used by the engine.  The one exception is the -s option which
## is always included as the first entry and the script path as the second.
## Optparse ignores these values for argument processing but can be accessed
## with my_optparse.options.script_option.  This list does not contain any
## arguments that appear in OS.get_cmdline_user_args.
##
## OS.get_cmdline_user_args contains any arguments that appear on the command
## line AFTER " -- " or " ++ ".  This list CAN contain options that the engine
## would otherwise use, and are ignored completely by the engine.
##
## The parse method, by default, includes arguments from OS.get_cmdline_args and
## OS.get_cmdline_user_args.  You can optionally pass one of these to the parse
## method to limit which arguments are parsed.  You can also conjure up your own
## array of arguments and pass that to parse.
##
## See Godot's documentation for get_cmdline_args and get_cmdline_user_args for
## more information.
##
##
## Adding Options
## --------------
## Use the following to add options to be parsed.  These methods return the
## created Option instance.  See that class above for more info.  You can use
## the returned instance to get values, or use get_value/get_value_or_null.
##   add("--name", "default", "Description goes here")
##   add(["--name", "--aliases"], "default", "Description goes here")
##   add_required(["--name", "--aliases"], "default", "Description goes here")
##   add_positional("--name", "default", "Description goes here")
##   add_positional_required("--name", "default", "Description goes here")
##
## get_value will return the value of the option or the default if it was not
## set.  get_value_or_null will return the value of the option or null if it was
## not set.
##
## The Datatype for an option is determined from the default value supplied to
## the various add methods.  Supported types are
##   String
##   Int
##   Float
##   Array of strings
##   Boolean
##
##
## Value Parsing
## -------------
## optparse uses option_name_prefix to differentiate between option names and
## values.  Any argument that starts with this value will be treated as an
## argument name.  The default is "-".  Set this before calling parse if you want
## to change it.
##
## Values for options can be supplied on the command line with or without an "=":
##	option=value    # no space around "="
##	option value    # a space between option and value w/o =
## There is no way to escape "=" at this time.
##
## Array options can be specified multiple times and/or set from a comma delimited
## list.
##   -gdir=a,b
##   -gdir c,d
##   -gdir e
## Results in -gdir equaling [a, b, c, d, e].  There is no way to escape commas
## at this time.
##
## To specify an empty list via the command line follow the option with an equal
## sign
##   -gdir=
##
## Boolean options will have thier value set to !default when they are supplied
## on the command line.  Boolean options cannot have a value on the command line.
## They are either supplied or not.
##
## If a value is not an array and is specified multiple times on the command line
## then the last entry will be used as the value.
##
## Positional argument values are parsed after all named arguments are parsed.
## This means that other options can appear before, between, and after positional
## arguments.
##   --foo=bar positional_0_value --disabled --bar foo positional_1_value --a_flag
##
## Anything that is not used by named or positional arguments will appear in the
## unused property.  You can use this to detect unrecognized arguments or treat
## everything else provided as a list of things, or whatever you want.  You can
## use is_option on the elements of unused (or whatever you want really) to see
## if optparse would treat it as an option name.
##
## Use get_missing_required_options to get an array of Option with all required
## options that were not found when parsing.
##
## The parsed_args property holds the list of arguments that were parsed.
##
##
## Help Generation
## ---------------
## You can call get_help to generate help text, or you can just call print_help
## and this will print it for you.
##
## Set the banner property to any text you want to appear before the usage and
## options sections.
##
## Options are printed in the order they are added.  You can add a heading for
## different options sections with add_heading.
##   add("--asdf", 1, "This will have no heading")
##   add_heading("foo")
##   add("--foo", false, "This will have the foo heading")
##   add("--another_foo", 1.5, "This too.")
##   add_heading("This is after foo")
##   add("--bar", true, "You probably get it by now.")
##
## If you include "[default]" in the description of a option, then the help will
## substitue it with the default value.
## [/codeblock]


#-------------------------------------------------------------------------------
# Holds all the properties of a command line option
#
# value will return the default when it has not been set.
#-------------------------------------------------------------------------------
class Option:
	var _has_been_set = false
	var _value = null
	# REMEMBER that when this option is an array, you have to set the value
	# before you alter the contents of the array (append etc) or has_been_set
	# will return false and it might not be used right.  For example
	# get_value_or_null will return null when you've actually changed the value.
	var value = _value:
		get:
			return _value

		set(val):
			_has_been_set = true
			_value = val

	var option_name = ''
	var default = null
	var description = ''
	var required = false
	var aliases: Array[String] = []


	func _init(name,default_value,desc=''):
		option_name = name
		default = default_value
		description = desc
		_value = default


	func to_s(min_space=0):
		var line_indent = str("\n", " ".repeat(min_space + 1))
		var subbed_desc = description
		if not aliases.is_empty():
			subbed_desc += "\naliases: " + ", ".join(aliases)
		subbed_desc = subbed_desc.replace('[default]', str(default))
		subbed_desc = subbed_desc.replace("\n", line_indent)
		return str(option_name.rpad(min_space), ' ', subbed_desc)


	func has_been_set():
		return _has_been_set




#-------------------------------------------------------------------------------
# A struct for organizing options by a heading
#-------------------------------------------------------------------------------
class OptionHeading:
	var options = []
	var display = 'default'




#-------------------------------------------------------------------------------
# Organizes options by order, heading, position.  Also responsible for all
# help related text generation.
#-------------------------------------------------------------------------------
class Options:
	var options = []
	var positional = []
	var default_heading = OptionHeading.new()
	var script_option = Option.new('-s', '?', 'script option provided by Godot')

	var _options_by_name = {"--script": script_option, "-s": script_option}
	var _options_by_heading = [default_heading]
	var _cur_heading = default_heading


	func add_heading(display):
		var heading = OptionHeading.new()
		heading.display = display
		_cur_heading = heading
		_options_by_heading.append(heading)


	func add(option, aliases=null):
		options.append(option)
		_options_by_name[option.option_name] = option
		_cur_heading.options.append(option)

		if aliases != null:
			for a in aliases:
				_options_by_name[a] = option
			option.aliases.assign(aliases)


	func add_positional(option):
		positional.append(option)
		_options_by_name[option.option_name] = option


	func get_by_name(option_name):
		var found_param = null
		if(_options_by_name.has(option_name)):
			found_param = _options_by_name[option_name]

		return found_param


	func get_help_text():
		var longest = 0
		var text = ""
		for i in range(options.size()):
			if(options[i].option_name.length() > longest):
				longest = options[i].option_name.length()

		for heading in _options_by_heading:
			if(heading != default_heading):
				text += str("\n", heading.display, "\n")
			for option in heading.options:
				text += str('  ', option.to_s(longest + 2).replace("\n", "\n  "), "\n")

		return text


	func get_option_value_text():
		var text = ""
		var i = 0
		for option in positional:
			text += str(i, '.  ', option.option_name, ' = ', option.value)

			if(!option.has_been_set()):
				text += " (default)"
			text += "\n"
			i += 1

		for option in options:
			text += str(option.option_name, ' = ', option.value)

			if(!option.has_been_set()):
				text += " (default)"
			text += "\n"
		return text


	func print_option_values():
		print(get_option_value_text())


	func get_missing_required_options():
		var to_return = []
		for opt in options:
			if(opt.required and !opt.has_been_set()):
				to_return.append(opt)

		for opt in positional:
			if(opt.required and !opt.has_been_set()):
				to_return.append(opt)

		return to_return


	func get_usage_text():
		var pos_text = ""
		for opt in positional:
			pos_text += str("[", opt.description, "] ")

		if(pos_text != ""):
			pos_text += " [opts] "

		return "<path to godot> -s " + script_option.value + " [opts] " + pos_text




#-------------------------------------------------------------------------------
#
# optarse
#
#-------------------------------------------------------------------------------
## @ignore
var options := Options.new()
## Set the banner property to any text you want to appear before the usage and
## options sections when printing the options help.
var banner := ''
## optparse uses option_name_prefix to differentiate between option names and
## values.  Any argument that starts with this value will be treated as an
## argument name.  The default is "-".  Set this before calling parse if you want
## to change it.
var option_name_prefix := '-'
## @ignore
var unused = []
## @ignore
var parsed_args = []
## @ignore
var values: Dictionary = {}


func _populate_values_dictionary():
	for entry in options.options:
		var value_key = entry.option_name.lstrip('-')
		values[value_key] = entry.value

	for entry in options.positional:
		var value_key = entry.option_name.lstrip('-')
		values[value_key] = entry.value


func _convert_value_to_array(raw_value):
	var split = raw_value.split(',')
	# This is what an empty set looks like from the command line.  If we do
	# not do this then we will always get back [''] which is not what it
	# shoudl be.
	if(split.size() == 1 and split[0] == ''):
		split = []
	return split

# REMEMBER raw_value not used for bools.
func _set_option_value(option, raw_value):
	var t = typeof(option.default)
	# only set values that were specified at the command line so that
	# we can punch through default and config values correctly later.
	# Without this check, you can't tell the difference between the
	# defaults and what was specified, so you can't punch through
	# higher level options.
	if(t == TYPE_INT):
		option.value = int(raw_value)
	elif(t == TYPE_STRING):
		option.value = str(raw_value)
	elif(t == TYPE_ARRAY):
		var values = _convert_value_to_array(raw_value)
		if(!option.has_been_set()):
			option.value = []
		option.value.append_array(values)
	elif(t == TYPE_BOOL):
		option.value = !option.default
	elif(t == TYPE_FLOAT):
		option.value = float(raw_value)
	elif(t == TYPE_NIL):
		print(option.option_name + ' cannot be processed, it has a nil datatype')
	else:
		print(option.option_name + ' cannot be processed, it has unknown datatype:' + str(t))


func _parse_command_line_arguments(args):
	var parsed_opts = args.duplicate()
	var i = 0
	var positional_index = 0

	while i < parsed_opts.size():
		var opt  = ''
		var value = ''
		var entry = parsed_opts[i]

		if(is_option(entry)):
			if(entry.find('=') != -1):
				var parts = entry.split('=')
				opt = parts[0]
				value = parts[1]
				var the_option = options.get_by_name(opt)
				if(the_option != null):
					parsed_opts.remove_at(i)
					_set_option_value(the_option, value)
				else:
					i += 1
			else:
				var the_option = options.get_by_name(entry)
				if(the_option != null):
					parsed_opts.remove_at(i)
					if(typeof(the_option.default) == TYPE_BOOL):
						_set_option_value(the_option, null)
					elif(i < parsed_opts.size() and !is_option(parsed_opts[i])):
						value = parsed_opts[i]
						parsed_opts.remove_at(i)
						_set_option_value(the_option, value)
				else:
					i += 1
		else:
			if(positional_index < options.positional.size()):
				_set_option_value(options.positional[positional_index], entry)
				parsed_opts.remove_at(i)
				positional_index += 1
			else:
				i += 1

	# this is the leftovers that were not extracted.
	return parsed_opts


## Test if something is an existing argument. If [code]str(arg)[/code] begins
## with the [member option_name_prefix], it will considered true,
## otherwise it will be considered false.
func is_option(arg) -> bool:
	return str(arg).begins_with(option_name_prefix)


## Adds a command line option.
## If [param op_names] is a String, this is set as the argument's name.
## If [param op_names] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add(op_names, default, desc: String) -> Option:
	var op_name: String
	var aliases: Array[String] = []
	var new_op: Option = null

	if(typeof(op_names) == TYPE_STRING):
		op_name = op_names
	else:
		op_name = op_names[0]
		aliases.assign(op_names.slice(1))

	var bad_alias: int = aliases.map(
		func (a: String) -> bool: return options.get_by_name(a) != null
	).find(true)

	if(options.get_by_name(op_name) != null):
		push_error(str('Option [', op_name, '] already exists.'))
	elif bad_alias != -1:
		push_error(str('Option [', aliases[bad_alias], '] already exists.'))
	else:
		new_op = Option.new(op_name, default, desc)
		options.add(new_op, aliases)

	return new_op


## Adds a required command line option.
## Required options that have not been set may be collected after parsing
## by calling [method get_missing_required_options].
## If [param op_names] is a String, this is set as the argument's name.
## If [param op_names] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_required(op_names, default, desc: String) -> Option:
	var op := add(op_names, default, desc)
	if(op != null):
		op.required = true
	return op


## Adds a positional command line option.
## Positional options are parsed by their position in the list of arguments
## are are not assigned by name by the user.
## If [param op_name] is a String, this is set as the argument's name.
## If [param op_name] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_positional(op_name, default, desc: String) -> Option:
	var new_op = null
	if(options.get_by_name(op_name) != null):
		push_error(str('Positional option [', op_name, '] already exists.'))
	else:
		new_op = Option.new(op_name, default, desc)
		options.add_positional(new_op)
	return new_op


## Adds a required positional command line option.
## If [param op_name] is a String, this is set as the argument's name.
## Required options that have not been set may be collected after parsing
## by calling [method get_missing_required_options].
## Positional options are parsed by their position in the list of arguments
## are are not assigned by name by the user.
## If [param op_name] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_positional_required(op_name, default, desc: String) -> Option:
	var op = add_positional(op_name, default, desc)
	if(op != null):
		op.required = true
	return op


## Headings are used to separate logical groups of command line options
## when printing out options from the help menu.
## Headings are printed out between option descriptions in the order
## that [method add_heading] was called.
func add_heading(display_text: String) -> void:
	options.add_heading(display_text)


## Gets the value assigned to an option after parsing.
## [param name] can be the name of the option or an alias of it.
## [param name] specifies the option whose value you wish to query.
## If the option exists, the value assigned to it during parsing is returned.
## Otherwise, an error message is printed and [code]null[/code] is returned.
func get_value(name: String):
	var found_param: Option = options.get_by_name(name)

	if(found_param != null):
		return found_param.value
	else:
		push_error("COULD NOT FIND OPTION " + name)
		return null


## Gets the value assigned to an option after parsing,
## returning null if the option was not assigned instead of its default value.
## [param name] specifies the option whose value you wish to query.
## This can be useful when providing an order of precedence to your values.
## For example if
## [codeblock]
##     default value < config file < command line
## [/codeblock]
## then you do not want to get the default value for a command line option or
## it will overwrite the value in a config file.
func get_value_or_null(name: String):
	var found_param: Option = options.get_by_name(name)

	if(found_param != null and found_param.has_been_set()):
		return found_param.value
	else:
		return null


## Returns the help text for all defined options.
func get_help() -> String:
	var sep := '---------------------------------------------------------'

	var text := str(sep, "\n", banner, "\n\n")
	text += "Usage\n-----------\n"
	text += "  " + options.get_usage_text() + "\n\n"
	text += "\nOptions\n-----------\n"
	text += options.get_help_text()
	text += str(sep, "\n")
	return text


## Prints out the help text for all defined options.
func print_help() -> void:
	print(get_help())


## Parses a string for all options that have been set in this optparse.
## if [param cli_args] is passed as a String, then it is parsed.
## Otherwise if [param cli_args] is null,
## aruments passed to the Godot engine at startup are parsed.
## See the explanation at the top of addons/gut/cli/optparse.gd to understand
## which arguments this will have access to.
func parse(cli_args=null) -> void:
	parsed_args = cli_args

	if(parsed_args == null):
		parsed_args = OS.get_cmdline_args()
		parsed_args.append_array(OS.get_cmdline_user_args())

	unused = _parse_command_line_arguments(parsed_args)
	_populate_values_dictionary()


## Get all options that were required and were not set during parsing.
## The return value is an Array of Options.
func get_missing_required_options() -> Array:
	return options.get_missing_required_options()


# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

=====================================
FILE: ./addons/gut/test_collector.gd
=====================================
# ------------------------------------------------------------------------------
# This class handles calling out to the test parser and maintaining an array of
# collected_script.gd.  This is used for both calling the tests and tracking
# the results of each script and test's execution.
#
# This also handles exporting and importing tests.
# ------------------------------------------------------------------------------
var CollectedScript = GutUtils.CollectedScript
var CollectedTest = GutUtils.CollectedTest

var _test_prefix = 'test_'
var _test_class_prefix = 'Test'

var _lgr = GutUtils.get_logger()


# Array of CollectedScripts.
var scripts = []


func _does_inherit_from_test(thing):
	var base_script = thing.get_base_script()
	var to_return = false
	if(base_script != null):
		var base_path = base_script.get_path()
		if(base_path == 'res://addons/gut/test.gd'):
			to_return = true
		else:
			to_return = _does_inherit_from_test(base_script)
	return to_return


func _populate_tests(test_script):
	var script =  test_script.load_script()
	if(script == null):
		print('  !!! ', test_script.path, ' could not be loaded')
		return false

	test_script.is_loaded = true
	var methods = script.get_script_method_list()
	for i in range(methods.size()):
		var name = methods[i]['name']
		if(name.begins_with(_test_prefix)):
			var t = CollectedTest.new()
			t.name = name
			t.arg_count = methods[i]['args'].size()
			test_script.tests.append(t)


func _get_inner_test_class_names(loaded):
	var inner_classes = []
	var const_map = loaded.get_script_constant_map()
	for key in const_map:
		var thing = const_map[key]
		if(GutUtils.is_gdscript(thing)):
			if(key.begins_with(_test_class_prefix)):
				if(_does_inherit_from_test(thing)):
					inner_classes.append(key)
				else:
					_lgr.warn(str('Ignoring Inner Class ', key,
						' because it does not extend GutTest'))

			# This could go deeper and find inner classes within inner classes
			# but requires more experimentation.  Right now I'm keeping it at
			# one level since that is what the previous version did and there
			# has been no demand for deeper nesting.
			# _populate_inner_test_classes(thing)
	return inner_classes


func _parse_script(test_script):
	var inner_classes = []
	var scripts_found = []

	var loaded = GutUtils.WarningsManager.load_script_using_custom_warnings(
		test_script.path,
		GutUtils.warnings_when_loading_test_scripts)

	if(_does_inherit_from_test(loaded)):
		_populate_tests(test_script)
		scripts_found.append(test_script.path)
		inner_classes = _get_inner_test_class_names(loaded)
	else:
		return []

	for i in range(inner_classes.size()):
		var loaded_inner = loaded.get(inner_classes[i])
		if(_does_inherit_from_test(loaded_inner)):
			var ts = CollectedScript.new(_lgr)
			ts.path = test_script.path
			ts.inner_class_name = inner_classes[i]
			_populate_tests(ts)
			scripts.append(ts)
			scripts_found.append(test_script.path + '[' + inner_classes[i] +']')

	return scripts_found


# -----------------
# Public
# -----------------
func add_script(path):
	# SHORTCIRCUIT
	if(has_script(path)):
		return []

	# SHORTCIRCUIT
	if(!FileAccess.file_exists(path)):
		# This check was added so tests could create dynmaic scripts and add
		# them to be run through gut.  This helps cut down on creating test
		# scripts to be used in test/resources.
		if(ResourceLoader.has_cached(path)):
			_lgr.debug("Using cached version of " + path)
		else:
			_lgr.error('Could not find script:  ' + path)
			return

	var ts = CollectedScript.new(_lgr)
	ts.path = path
	# Append right away because if we don't test_doubler.gd.TestInitParameters
	# will HARD crash.  I couldn't figure out what was causing the issue but
	# appending right away, and then removing if it's not valid seems to fix
	# things.  It might have to do with the ordering of the test classes in
	# the test collecter.  I'm not really sure.
	scripts.append(ts)
	var parse_results = _parse_script(ts)

	if(parse_results.find(path) == -1):
		_lgr.warn(str('Ignoring script ', path, ' because it does not extend GutTest'))
		scripts.remove_at(scripts.find(ts))

	return parse_results


func clear():
	scripts.clear()


func has_script(path):
	var found = false
	var idx = 0
	while(idx < scripts.size() and !found):
		if(scripts[idx].get_full_name() == path):
			found = true
		else:
			idx += 1
	return found


func export_tests(path):
	var success = true
	var f = ConfigFile.new()
	for i in range(scripts.size()):
		scripts[i].export_to(f, str('CollectedScript-', i))
	var result = f.save(path)
	if(result != OK):
		_lgr.error(str('Could not save exported tests to [', path, '].  Error code:  ', result))
		success = false
	return success


func import_tests(path):
	var success = false
	var f = ConfigFile.new()
	var result = f.load(path)
	if(result != OK):
		_lgr.error(str('Could not load exported tests from [', path, '].  Error code:  ', result))
	else:
		var sections = f.get_sections()
		for key in sections:
			var ts = CollectedScript.new(_lgr)
			ts.import_from(f, key)
			_populate_tests(ts)
			scripts.append(ts)
		success = true
	return success


func get_script_named(name):
	return GutUtils.search_array(scripts, 'get_filename_and_inner', name)


func get_test_named(script_name, test_name):
	var s = get_script_named(script_name)
	if(s != null):
		return s.get_test_named(test_name)
	else:
		return null


func to_s():
	var to_return = ''
	for i in range(scripts.size()):
		to_return += scripts[i].to_s() + "\n"
	return to_return

# ---------------------
# Accessors
# ---------------------
func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


func get_test_prefix():
	return _test_prefix


func set_test_prefix(test_prefix):
	_test_prefix = test_prefix


func get_test_class_prefix():
	return _test_class_prefix


func set_test_class_prefix(test_class_prefix):
	_test_class_prefix = test_class_prefix


func get_scripts():
	return scripts


func get_ran_test_count():
	var count = 0
	for s in scripts:
		count += s.get_ran_test_count()
	return count


func get_ran_script_count():
	var count = 0
	for s in scripts:
		if(s.was_run):
			count += 1
	return count

func get_test_count():
	var count = 0
	for s in scripts:
		count += s.tests.size()
	return count


func get_assert_count():
	var count = 0
	for s in scripts:
		count += s.get_assert_count()
	return count


func get_pass_count():
	var count = 0
	for s in scripts:
		count += s.get_pass_count()
	return count


func get_fail_count():
	var count = 0
	for s in scripts:
		count += s.get_fail_count()
	return count


func get_pending_count():
	var count = 0
	for s in scripts:
		count += s.get_pending_count()
	return count



=====================================
FILE: ./addons/gut/gut_config.gd
=====================================
# ##############################################################################
#
# This holds all the configuratoin values for GUT.  It can load and save values
# to a json file.  It is also responsible for applying these settings to GUT.
#
# ##############################################################################
var valid_fonts = ['AnonymousPro', 'CourierPro', 'LobsterTwo', 'Default']

var default_options = {
	background_color = Color(.15, .15, .15, 1).to_html(),
	config_file = 'res://.gutconfig.json',
	# used by editor to handle enabled/disabled dirs.  All dirs configured go
	# here and only the enabled dirs go into dirs
	configured_dirs = [],
	dirs = [],
	disable_colors = false,
	# double strategy can be the name of the enum value, the enum value or
	# lowercase name with spaces:  0/SCRIPT_ONLY/script only
	# The GUI gut config expects the value to be the enum value and not a string
	# when saved.
	double_strategy = 'SCRIPT_ONLY',
	# named differently than gut option so we can use it as a flag in the cli
	errors_do_not_cause_failure = false,
	font_color = Color(.8, .8, .8, 1).to_html(),
	font_name = 'CourierPrime',
	font_size = 16,
	hide_orphans = false,
	ignore_pause = false,
	include_subdirs = false,
	inner_class = '',
	junit_xml_file = '',
	junit_xml_timestamp = false,
	log_level = 1,
	opacity = 100,
	paint_after = .1,
	post_run_script = '',
	pre_run_script = '',
	prefix = 'test_',
	selected = '',
	should_exit = false,
	should_exit_on_success = false,
	should_maximize = false,
	compact_mode = false,
	show_help = false,
	suffix = '.gd',
	tests = [],
	unit_test_name = '',

	gut_on_top = true,
}


var options = default_options.duplicate()
var logger = GutUtils.get_logger()

func _null_copy(h):
	var new_hash = {}
	for key in h:
		new_hash[key] = null
	return new_hash


func _load_options_from_config_file(file_path, into):
	if(!FileAccess.file_exists(file_path)):
		# Default files are ok to be missing.  Maybe this is too deep a place
		# to implement this, but here it is.
		if(file_path != 'res://.gutconfig.json' and file_path != GutUtils.EditorGlobals.editor_run_gut_config_path):
			logger.error(str('Config File "', file_path, '" does not exist.'))
			return -1
		else:
			return 1

	var f = FileAccess.open(file_path, FileAccess.READ)
	if(f == null):
		var result = FileAccess.get_open_error()
		logger.error(str("Could not load data ", file_path, ' ', result))
		return result

	var json = f.get_as_text()
	f = null # close file

	var test_json_conv = JSON.new()
	test_json_conv.parse(json)
	var results = test_json_conv.get_data()
	# SHORTCIRCUIT
	if(results == null):
		logger.error(str("Could not parse file:  ", file_path))
		return -1

	# Get all the options out of the config file using the option name.  The
	# options hash is now the default source of truth for the name of an option.
	_load_dict_into(results, into)

	return 1

func _load_dict_into(source, dest):
	for key in dest:
		if(source.has(key)):
			if(source[key] != null):
				if(typeof(source[key]) == TYPE_DICTIONARY):
					_load_dict_into(source[key], dest[key])
				else:
					dest[key] = source[key]


# Apply all the options specified to tester.  This is where the rubber meets
# the road.
func _apply_options(opts, gut):
	gut.include_subdirectories = opts.include_subdirs

	if(opts.inner_class != ''):
		gut.inner_class_name = opts.inner_class
	gut.log_level = opts.log_level
	gut.ignore_pause_before_teardown = opts.ignore_pause

	gut.select_script(opts.selected)

	for i in range(opts.dirs.size()):
		gut.add_directory(opts.dirs[i], opts.prefix, opts.suffix)

	for i in range(opts.tests.size()):
		gut.add_script(opts.tests[i])

	# Sometimes it is the index, sometimes it's a string.  This sets it regardless
	gut.double_strategy = GutUtils.get_enum_value(
		opts.double_strategy, GutUtils.DOUBLE_STRATEGY,
		GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY)

	gut.unit_test_name = opts.unit_test_name
	gut.pre_run_script = opts.pre_run_script
	gut.post_run_script = opts.post_run_script
	gut.color_output = !opts.disable_colors
	gut.show_orphans(!opts.hide_orphans)
	gut.junit_xml_file = opts.junit_xml_file
	gut.junit_xml_timestamp = opts.junit_xml_timestamp
	gut.paint_after = str(opts.paint_after).to_float()
	gut.treat_error_as_failure = !opts.errors_do_not_cause_failure

	return gut

# --------------------------
# Public
# --------------------------
func write_options(path):
	var content = JSON.stringify(options, ' ')

	var f = FileAccess.open(path, FileAccess.WRITE)
	var result = FileAccess.get_open_error()
	if(f != null):
		f.store_string(content)
		f = null # closes file
	else:
		logger.error(str("Could not open file ", path, ' ', result))
	return result


# consistent name
func save_file(path):
	write_options(path)


func load_options(path):
	return _load_options_from_config_file(path, options)


# consistent name
func load_file(path):
	return load_options(path)


func load_options_no_defaults(path):
	options = _null_copy(default_options)
	return _load_options_from_config_file(path, options)


func apply_options(gut):
	_apply_options(options, gut)




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/lazy_loader.gd
=====================================
@tool
# ------------------------------------------------------------------------------
# Static
# ------------------------------------------------------------------------------
static var usage_counter = load('res://addons/gut/thing_counter.gd').new()
static var WarningsManager = load('res://addons/gut/warnings_manager.gd')

static func load_all():
	for key in usage_counter.things:
		key.get_loaded()


static func print_usage():
	for key in usage_counter.things:
		print(key._path, '  (', usage_counter.things[key], ')')


# ------------------------------------------------------------------------------
# Class
# ------------------------------------------------------------------------------
var _loaded = null
var _path = null

func _init(path):
	_path = path
	usage_counter.add_thing_to_count(self)


func get_loaded():
	if(_loaded == null):
		_loaded = WarningsManager.load_script_ignoring_all_warnings(_path)
	usage_counter.add(self)
	return _loaded



=====================================
FILE: ./addons/gut/collected_script.gd
=====================================
# ------------------------------------------------------------------------------
# This holds all the meta information for a test script.  It contains the
# name of the inner class and an array of CollectedTests.  This does not parse
# anything, it just holds the data about parsed scripts and tests.  The
# TestCollector is responsible for populating this object.
#
# This class also facilitates all the exporting and importing of tests.
# ------------------------------------------------------------------------------
var CollectedTest = GutUtils.CollectedTest

var _lgr = null

# One entry per test found in the script.  Added externally by TestCollector
var tests = []
# One entry for before_all and after_all (maybe add before_each and after_each).
# These are added by Gut when running before_all and after_all for the script.
var setup_teardown_tests = []
var inner_class_name:StringName
var path:String


# Set externally by test_collector after it can verify that the script was
# actually loaded.  This could probably be changed to just hold the GutTest
# script that was loaded, cutting down on complexity elsewhere.
var is_loaded = false

# Set by Gut when it decides that a script should be skipped.
# Right now this is whenever the script has the variable skip_script declared.
# the value of skip_script is put into skip_reason.
var was_skipped = false
var skip_reason = ''
var was_run = false


var name = '' :
	get: return path
	set(val):pass


func _init(logger=null):
	_lgr = logger


func get_new():
	return load_script().new()


func load_script():
	var to_return = load(path)

	if(inner_class_name != null and inner_class_name != ''):
		# If we wanted to do inner classes in inner classses
		# then this would have to become some kind of loop or recursive
		# call to go all the way down the chain or this class would
		# have to change to hold onto the loaded class instead of
		# just path information.
		to_return = to_return.get(inner_class_name)

	return to_return

# script.gd.InnerClass
func get_filename_and_inner():
	var to_return = get_filename()
	if(inner_class_name != ''):
		to_return += '.' + String(inner_class_name)
	return to_return


# res://foo/bar.gd.FooBar
func get_full_name():
	var to_return = path
	if(inner_class_name != ''):
		to_return += '.' + String(inner_class_name)
	return to_return


func get_filename():
	return path.get_file()


func has_inner_class():
	return inner_class_name != ''


# Note:  although this no longer needs to export the inner_class names since
#        they are pulled from metadata now, it is easier to leave that in
#        so we don't have to cut the export down to unique script names.
func export_to(config_file, section):
	config_file.set_value(section, 'path', path)
	config_file.set_value(section, 'inner_class', inner_class_name)
	var names = []
	for i in range(tests.size()):
		names.append(tests[i].name)
	config_file.set_value(section, 'tests', names)


func _remap_path(source_path):
	var to_return = source_path
	if(!FileAccess.file_exists(source_path)):
		_lgr.debug('Checking for remap for:  ' + source_path)
		var remap_path = source_path.get_basename() + '.gd.remap'
		if(FileAccess.file_exists(remap_path)):
			var cf = ConfigFile.new()
			cf.load(remap_path)
			to_return = cf.get_value('remap', 'path')
		else:
			_lgr.warn('Could not find remap file ' + remap_path)
	return to_return


func import_from(config_file, section):
	path = config_file.get_value(section, 'path')
	path = _remap_path(path)
	# Null is an acceptable value, but you can't pass null as a default to
	# get_value since it thinks you didn't send a default...then it spits
	# out red text.  This works around that.
	var inner_name = config_file.get_value(section, 'inner_class', 'Placeholder')
	if(inner_name != 'Placeholder'):
		inner_class_name = inner_name
	else: # just being explicit
		inner_class_name = StringName("")


func get_test_named(test_name):
	return GutUtils.search_array(tests, 'name', test_name)


func get_ran_test_count():
	var count = 0
	for t in tests:
		if(t.was_run):
			count += 1
	return count


func get_assert_count():
	var count = 0
	for t in tests:
		count += t.pass_texts.size()
		count += t.fail_texts.size()
	for t in setup_teardown_tests:
		count += t.pass_texts.size()
		count += t.fail_texts.size()
	return count


func get_pass_count():
	var count = 0
	for t in tests:
		count += t.pass_texts.size()
	for t in setup_teardown_tests:
		count += t.pass_texts.size()
	return count


func get_fail_count():
	var count = 0
	for t in tests:
		count += t.fail_texts.size()
	for t in setup_teardown_tests:
		count += t.fail_texts.size()
	return count


func get_pending_count():
	var count = 0
	for t in tests:
		count += t.pending_texts.size()
	return count


func get_passing_test_count():
	var count = 0
	for t in tests:
		if(t.is_passing()):
			count += 1
	return count


func get_failing_test_count():
	var count = 0
	for t in tests:
		if(t.is_failing()):
			count += 1
	return count


func get_risky_count():
	var count = 0
	if(was_skipped):
		count = 1
	else:
		for t in tests:
			if(t.is_risky()):
				count += 1
	return count


func to_s():
	var to_return = path
	if(inner_class_name != null):
		to_return += str('.', inner_class_name)
	to_return += "\n"
	for i in range(tests.size()):
		to_return += str('  ', tests[i].to_s())
	return to_return


=====================================
FILE: ./addons/gut/inner_class_registry.gd
=====================================
var _registry = {}


func _create_reg_entry(base_path, subpath):
	var to_return = {
		"base_path":base_path,
		"subpath":subpath,
		"base_resource":load(base_path),
		"full_path":str("'", base_path, "'", subpath)
	}
	return to_return

func _register_inners(base_path, obj, prev_inner = ''):
	var const_map = obj.get_script_constant_map()
	var consts = const_map.keys()
	var const_idx = 0

	while(const_idx < consts.size()):
		var key = consts[const_idx]
		var thing = const_map[key]

		if(typeof(thing) == TYPE_OBJECT):
			var cur_inner = str(prev_inner, ".", key)
			_registry[thing] = _create_reg_entry(base_path, cur_inner)
			_register_inners(base_path, thing, cur_inner)

		const_idx += 1


func register(base_script):
	var base_path = base_script.resource_path
	_register_inners(base_path, base_script)


func get_extends_path(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].full_path
	else:
		return null

# returns the subpath for the inner class.  This includes the leading "." in
# the path.
func get_subpath(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].subpath
	else:
		return ''

func get_base_path(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].base_path


func has(inner_class):
	return _registry.has(inner_class)


func get_base_resource(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].base_resource


func to_s():
	var text = ""
	for key in _registry:
		text += str(key, ": ", _registry[key], "\n")
	return text


=====================================
FILE: ./addons/gut/junit_xml_export.gd
=====================================
## Creates an export of a test run in the JUnit XML format.
##
## More words needed?

var _exporter = GutUtils.ResultExporter.new()

## @ignore should be private I think
func indent(s, ind):
	var to_return = ind + s
	to_return = to_return.replace("\n", "\n" + ind)
	return to_return

# Wraps content in CDATA section because it may contain special characters
# e.g. str(null) becomes <null> and can break XML parsing.
func wrap_cdata(content):
	return "<![CDATA[" + str(content) + "]]>"

## @ignore should be private I think
func add_attr(name, value):
	return str(name, '="', value, '" ')


func _export_test_result(test):
	var to_return = ''

	# Right now the pending and failure messages won't fit in the message
	# attribute because they can span multiple lines and need to be escaped.
	if(test.status == 'pending'):
		var skip_tag = str("<skipped message=\"pending\">", wrap_cdata(test.pending[0]), "</skipped>")
		to_return += skip_tag
	elif(test.status == 'fail'):
		var fail_tag = str("<failure message=\"failed\">", wrap_cdata(test.failing[0]), "</failure>")
		to_return += fail_tag

	return to_return


func _export_tests(script_result, classname):
	var to_return = ""

	for key in script_result.keys():
		var test = script_result[key]
		var assert_count = test.passing.size() + test.failing.size()
		to_return += "<testcase "
		to_return += add_attr("name", key)
		to_return += add_attr("assertions", assert_count)
		to_return += add_attr("status", test.status)
		to_return += add_attr("classname", classname.replace("res://", ""))
		to_return += add_attr("time", test.time_taken)
		to_return += ">\n"

		to_return += _export_test_result(test)

		to_return += "</testcase>\n"

	return to_return


func _sum_test_time(script_result, classname)->float:
	var to_return := 0.0

	for key in script_result.keys():
		var test = script_result[key]
		to_return += test.time_taken

	return to_return


func _export_scripts(exp_results):
	var to_return = ""
	for key in exp_results.test_scripts.scripts.keys():
		var s = exp_results.test_scripts.scripts[key]
		to_return += "<testsuite "
		to_return += add_attr("name", key.replace("res://", ""))
		to_return += add_attr("tests", s.props.tests)
		to_return += add_attr("failures", s.props.failures)
		to_return += add_attr("skipped", s.props.pending)
		to_return += add_attr("time", _sum_test_time(s.tests, key) )
		to_return += ">\n"

		to_return += indent(_export_tests(s.tests, key), "    ")

		to_return += "</testsuite>\n"

	return to_return


## Takes in an instance of GutMain and returns a string of XML representing the
## results of the run.
func get_results_xml(gut):
	var exp_results = _exporter.get_results_dictionary(gut)
	var to_return = '<?xml version="1.0" encoding="UTF-8"?>' + "\n"
	to_return += '<testsuites '
	to_return += add_attr("name", 'GutTests')
	to_return += add_attr("failures", exp_results.test_scripts.props.failures)
	to_return += add_attr('tests', exp_results.test_scripts.props.tests)
	to_return += ">\n"

	to_return += indent(_export_scripts(exp_results), "  ")

	to_return += '</testsuites>'
	return to_return


## Takes in an instance of GutMain and writes the XML file to the specified
## path
func write_file(gut, path):
	var xml = get_results_xml(gut)

	var f_result = GutUtils.write_file(path, xml)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result



=====================================
FILE: ./addons/gut/comparator.gd
=====================================
var _strutils = GutUtils.Strutils.new()
var _max_length = 100
var _should_compare_int_to_float = true

const MISSING = '|__missing__gut__compare__value__|'


func _cannot_compare_text(v1, v2):
	return str('Cannot compare ', _strutils.types[typeof(v1)], ' with ',
		_strutils.types[typeof(v2)], '.')


func _make_missing_string(text):
	return '<missing ' + text + '>'


func _create_missing_result(v1, v2, text):
	var to_return = null
	var v1_str = format_value(v1)
	var v2_str = format_value(v2)

	if(typeof(v1) == TYPE_STRING and v1 == MISSING):
		v1_str = _make_missing_string(text)
		to_return = GutUtils.CompareResult.new()
	elif(typeof(v2) == TYPE_STRING and v2 == MISSING):
		v2_str = _make_missing_string(text)
		to_return = GutUtils.CompareResult.new()

	if(to_return != null):
		to_return.summary = str(v1_str, ' != ', v2_str)
		to_return.are_equal = false

	return to_return


func simple(v1, v2, missing_string=''):
	var missing_result = _create_missing_result(v1, v2, missing_string)
	if(missing_result != null):
		return missing_result

	var result = GutUtils.CompareResult.new()
	var cmp_str = null
	var extra = ''

	var tv1 = typeof(v1)
	var tv2 = typeof(v2)

	# print(tv1, '::', tv2, '   ', _strutils.types[tv1], '::', _strutils.types[tv2])
	if(_should_compare_int_to_float and [TYPE_INT, TYPE_FLOAT].has(tv1) and [TYPE_INT, TYPE_FLOAT].has(tv2)):
		result.are_equal = v1 == v2
	elif([TYPE_STRING, TYPE_STRING_NAME].has(tv1) and [TYPE_STRING, TYPE_STRING_NAME].has(tv2)):
		result.are_equal = v1 == v2
	elif(GutUtils.are_datatypes_same(v1, v2)):
		result.are_equal = v1 == v2

		if(typeof(v1) == TYPE_DICTIONARY or typeof(v1) == TYPE_ARRAY):
			var sub_result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
			result.summary = sub_result.get_short_summary()
			if(!sub_result.are_equal):
				extra = ".\n" + sub_result.get_short_summary()
	else:
		cmp_str = '!='
		result.are_equal = false
		extra = str('.  ', _cannot_compare_text(v1, v2))

	cmp_str = get_compare_symbol(result.are_equal)
	result.summary = str(format_value(v1), ' ', cmp_str, ' ', format_value(v2), extra)

	return result


func shallow(v1, v2):
	var result =  null
	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
		else:
			result = simple(v1, v2)
	else:
		result = simple(v1, v2)

	return result


func deep(v1, v2):
	var result =  null

	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
		else:
			result = simple(v1, v2)
	else:
		result = simple(v1, v2)

	return result


func format_value(val, max_val_length=_max_length):
	return _strutils.truncate_string(_strutils.type2str(val), max_val_length)


func compare(v1, v2, diff_type=GutUtils.DIFF.SIMPLE):
	var result = null
	if(diff_type == GutUtils.DIFF.SIMPLE):
		result = simple(v1, v2)
	elif(diff_type ==  GutUtils.DIFF.DEEP):
		result = deep(v1, v2)

	return result


func get_should_compare_int_to_float():
	return _should_compare_int_to_float


func set_should_compare_int_to_float(should_compare_int_float):
	_should_compare_int_to_float = should_compare_int_float


func get_compare_symbol(is_equal):
	if(is_equal):
		return '=='
	else:
		return '!='


=====================================
FILE: ./addons/gut/result_exporter.gd
=====================================
# ------------------------------------------------------------------------------
# Creates a structure that contains all the data about the results of running
# tests.  This was created to make an intermediate step organizing the result
# of a run and exporting it in a specific format.  This can also serve as a
# unofficial GUT export format.
# ------------------------------------------------------------------------------
var json = JSON.new()

func _export_tests(collected_script):
	var to_return = {}
	var tests = collected_script.tests
	for test in tests:
		if(test.get_status_text() != GutUtils.TEST_STATUSES.NOT_RUN):
			to_return[test.name] = {
				"status":test.get_status_text(),
				"passing":test.pass_texts,
				"failing":test.fail_texts,
				"pending":test.pending_texts,
				"orphans":test.orphans,
				"time_taken": test.time_taken
			}

	return to_return

# TODO
#	errors
func _export_scripts(collector):
	if(collector == null):
		return {}

	var scripts = {}

	for s in collector.scripts:
		var test_data = _export_tests(s)
		scripts[s.get_full_name()] = {
			'props':{
				"tests":test_data.keys().size(),
				"pending":s.get_pending_count(),
				"failures":s.get_fail_count(),
			},
			"tests":test_data
		}
	return scripts

func _make_results_dict():
	var result =  {
		'test_scripts':{
			"props":{
				"pending":0,
				"failures":0,
				"passing":0,
				"tests":0,
				"time":0,
				"orphans":0,
				"errors":0,
				"warnings":0
			},
			"scripts":[]
		}
	}
	return result


func get_results_dictionary(gut, include_scripts=true):
	var scripts = []

	if(include_scripts):
		scripts = _export_scripts(gut.get_test_collector())

	var result =  _make_results_dict()

	var totals = gut.get_summary().get_totals()

	var props = result.test_scripts.props
	props.pending = totals.pending
	props.failures = totals.failing
	props.passing = totals.passing_tests
	props.tests = totals.tests
	props.errors = gut.logger.get_errors().size()
	props.warnings = gut.logger.get_warnings().size()
	props.time =  gut.get_elapsed_time()
	props.orphans = gut.get_orphan_counter().get_orphans_since('pre_run')
	result.test_scripts.scripts = scripts

	return result


func write_json_file(gut, path):
	var dict = get_results_dictionary(gut)
	var json_text = JSON.stringify(dict, ' ')

	var f_result = GutUtils.write_file(path, json_text)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result



func write_summary_file(gut, path):
	var dict = get_results_dictionary(gut, false)
	var json_text = JSON.stringify(dict, ' ')

	var f_result = GutUtils.write_file(path, json_text)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result


=====================================
FILE: ./addons/gut/warnings_manager.gd
=====================================
const IGNORE = 0
const WARN = 1
const ERROR = 2


const WARNING_LOOKUP = {
	IGNORE : 'IGNORE',
	WARN : 'WARN',
	ERROR : 'ERROR'
}

const GDSCRIPT_WARNING = 'debug/gdscript/warnings/'


# ---------------------------------------
# Static
# ---------------------------------------
static var _static_init_called = false
# This is static and set in _static_init so that we can get the current settings as
# soon as possible.
static var _project_warnings : Dictionary = {}

static var _disabled = false
# should never be true, unless it is, but it shouldn't be.  Whatever it is, it
# should stay the same for the entire run.  Read only.
static var disabled = _disabled:
	get: return _disabled
	set(val):pass

static var project_warnings := {} :
	get:
		# somehow this gets called before _project_warnings is initialized when
		# loading a project in the editor.  It causes an error stating that
		# duplicate can't be called on nil.  It seems there might be an
		# implicit "get" call happening.  Using push_error I saw a message
		# in this method, but not one from _static_init upon loading the project
		if(_static_init_called):
			return _project_warnings.duplicate()
		else:
			return {}
	set(val): pass


static func _static_init():
	_project_warnings = create_warnings_dictionary_from_project_settings()
	_static_init_called = true
	if(disabled):
		print("""
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!! Warnings Manager has been disabled
		!!
		!! Do not push this up buddy
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		""".dedent())


static func are_warnings_enabled():
	return ProjectSettings.get(str(GDSCRIPT_WARNING, 'enable'))


## Turn all warnings on/off.  Use reset_warnings to restore the original value.
static func enable_warnings(should=true):
	if(disabled):
		return
	ProjectSettings.set(str(GDSCRIPT_WARNING, 'enable'), should)


## Turn on/off excluding addons.  Use reset_warnings to restore the original value.
static func exclude_addons(should=true):
	if(disabled):
		return
	ProjectSettings.set(str(GDSCRIPT_WARNING, 'exclude_addons'), should)


## Resets warning settings to what they are set to in Project Settings
static func reset_warnings():
	apply_warnings_dictionary(_project_warnings)



static func set_project_setting_warning(warning_name : String, value : Variant):
	if(disabled):
		return

	var property_name = str(GDSCRIPT_WARNING, warning_name)
	# This check will generate a warning if the setting does not exist
	if(property_name in ProjectSettings):
		ProjectSettings.set(property_name, value)


static func apply_warnings_dictionary(warning_values : Dictionary):
	if(disabled):
		return

	for key in warning_values:
		set_project_setting_warning(key, warning_values[key])


static func create_ignore_all_dictionary():
	return replace_warnings_values(project_warnings, -1, IGNORE)


static func create_warn_all_warnings_dictionary():
	return replace_warnings_values(project_warnings, -1, WARN)


static func replace_warnings_with_ignore(dict):
	return replace_warnings_values(dict, WARN, IGNORE)


static func replace_errors_with_warnings(dict):
	return replace_warnings_values(dict, ERROR, WARN)


static func replace_warnings_values(dict, replace_this, with_this):
	var to_return = dict.duplicate()
	for key in to_return:
		if(typeof(to_return[key]) == TYPE_INT and (replace_this == -1 or to_return[key] == replace_this)):
			to_return[key] = with_this
	return to_return


static func create_warnings_dictionary_from_project_settings() -> Dictionary :
	var props = ProjectSettings.get_property_list()
	var to_return = {}
	for i in props.size():
		if(props[i].name.begins_with(GDSCRIPT_WARNING)):
			var prop_name = props[i].name.replace(GDSCRIPT_WARNING, '')
			to_return[prop_name] = ProjectSettings.get(props[i].name)
	return to_return


static func print_warnings_dictionary(which : Dictionary):
	var is_valid = true
	for key in which:
		var value_str = str(which[key])
		if(_project_warnings.has(key)):
			if(typeof(which[key]) == TYPE_INT):
				if(WARNING_LOOKUP.has(which[key])):
					value_str = WARNING_LOOKUP[which[key]]
				else:
					push_warning(str(which[key], ' is not a valid value for ', key))
					is_valid = false
		else:
			push_warning(str(key, ' is not a valid warning setting'))
			is_valid = false
		var s = str(key, ' = ', value_str)
		print(s)
	return is_valid


static func load_script_ignoring_all_warnings(path : String) -> Variant:
	return load_script_using_custom_warnings(path, create_ignore_all_dictionary())


static func load_script_using_custom_warnings(path : String, warnings_dictionary : Dictionary) -> Variant:
	var current_warns = create_warnings_dictionary_from_project_settings()
	apply_warnings_dictionary(warnings_dictionary)
	var s = load(path)
	apply_warnings_dictionary(current_warns)

	return s


=====================================
FILE: ./addons/gut/one_to_many.gd
=====================================
# ------------------------------------------------------------------------------
# This datastructure represents a simple one-to-many relationship.  It manages
# a dictionary of value/array pairs.  It ignores duplicates of both the "one"
# and the "many".
# ------------------------------------------------------------------------------
var _items = {}

# return the size of _items or the size of an element in _items if "one" was
# specified.
func size(one=null):
	var to_return = 0
	if(one == null):
		to_return = _items.size()
	elif(_items.has(one)):
		to_return = _items[one].size()
	return to_return

# Add an element to "one" if it does not already exist
func add(one, many_item):
	if(_items.has(one) and !_items[one].has(many_item)):
		_items[one].append(many_item)
	else:
		_items[one] = [many_item]

func clear():
	_items.clear()

func has(one, many_item):
	var to_return = false
	if(_items.has(one)):
		to_return = _items[one].has(many_item)
	return to_return

func to_s():
	var to_return = ''
	for key in _items:
		to_return += str(key, ":  ", _items[key], "\n")
	return to_return


=====================================
FILE: ./addons/gut/compare_result.gd
=====================================
var _are_equal = false
var are_equal = false :
	get:
		return get_are_equal()
	set(val):
		set_are_equal(val)

var _summary = null
var summary = null :
	get:
		return get_summary()
	set(val):
		set_summary(val)

var _max_differences = 30
var max_differences = 30 :
	get:
		return get_max_differences()
	set(val):
		set_max_differences(val)

var _differences = {}
var differences :
	get:
		return get_differences()
	set(val):
		set_differences(val)

func _block_set(which, val):
	push_error(str('cannot set ', which, ', value [', val, '] ignored.'))

func _to_string():
	return str(get_summary()) # could be null, gotta str it.

func get_are_equal():
	return _are_equal

func set_are_equal(r_eq):
	_are_equal = r_eq

func get_summary():
	return _summary

func set_summary(smry):
	_summary = smry

func get_total_count():
	pass

func get_different_count():
	pass

func get_short_summary():
	return summary

func get_max_differences():
	return _max_differences

func set_max_differences(max_diff):
	_max_differences = max_diff

func get_differences():
	return _differences

func set_differences(diffs):
	_block_set('differences', diffs)

func get_brackets():
	return null



=====================================
FILE: ./addons/gut/input_sender.gd
=====================================
class_name GutInputSender
## The GutInputSender class.  It sends input to places.
##
## [br][br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url][br]
## See [wiki]Mocking-Input[/wiki] for examples.
## [br][br]
## This class can be used to send [code]InputEvent*[/code] events to various
## objects.  It also allows you to script out a series of inputs and play
## them back in real time.  You could use it to:[br]
##  - Verify that jump height depends on how long the jump button is pressed.[br]
##  - Double tap a direction performs a dash.[br]
##  - Down, Down-Forward, Forward + punch throws a fireball.[br]
## [br][br]
## And much much more.
## [br][br]
## As of 9.3.1 you can use [code skip-lint]GutInputSender[/code] instead of [code]InputSender[/code].  It's the same thing, but [code skip-lint]GutInputSender[/code] is a [code]class_name[/code] so you may have less warnings and auto-complete will work.
## [br][br]
## [b]Warning[/b][br]
## If you move the Godot window to a different monitor while tests are running it can cause input tests to fail.  [url=https://github.com/bitwes/Gut/issues/643]This issue[/url] has more details.



# Implemented InputEvent* convenience methods
# 	InputEventAction
# 	InputEventKey
# 	InputEventMouseButton
#	InputEventMouseMotion

# Yet to implement InputEvents
# 	InputEventJoypadButton
# 	InputEventJoypadMotion
# 	InputEventMagnifyGesture
# 	InputEventMIDI
# 	InputEventPanGesture
# 	InputEventScreenDrag
# 	InputEventScreenTouch



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class InputQueueItem:
	extends Node

	var events = []
	var time_delay = null
	var frame_delay = null
	var _waited_frames = 0
	var _is_ready = false
	var _delay_started = false

	signal event_ready

	# TODO should this be done in _physics_process instead or should it be
	# configurable?
	func _physics_process(delta):
		if(frame_delay > 0 and _delay_started):
			_waited_frames += 1
			if(_waited_frames >= frame_delay):
				event_ready.emit()

	func _init(t_delay,f_delay):
		time_delay = t_delay
		frame_delay = f_delay
		_is_ready = time_delay == 0 and frame_delay == 0

	func _on_time_timeout():
		_is_ready = true
		event_ready.emit()

	func _delay_timer(t):
		return Engine.get_main_loop().root.get_tree().create_timer(t)

	func is_ready():
		return _is_ready

	func start():
		_delay_started = true
		if(time_delay > 0):
			var t = _delay_timer(time_delay)
			t.connect("timeout",Callable(self,"_on_time_timeout"))




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class MouseDraw:
	extends Node2D

	var down_color = Color(1, 1, 1, .25)
	var up_color = Color(0, 0, 0, .25)
	var line_color = Color(1, 0, 0)
	var disabled = true :
		get : return disabled
		set(val) :
			disabled = val
			queue_redraw()

	var _draw_at = Vector2(0, 0)
	var _b1_down = false
	var _b2_down = false


	func draw_event(event):
		if(event is InputEventMouse):
			_draw_at = event.position
			if(event is InputEventMouseButton):
				if(event.button_index == MOUSE_BUTTON_LEFT):
					_b1_down = event.pressed
				elif(event.button_index == MOUSE_BUTTON_RIGHT):
					_b2_down = event.pressed
		queue_redraw()


	func _draw_cicled_cursor():
		var r = 10
		var b1_color = up_color
		var b2_color = up_color

		if(_b1_down):
			var pos = _draw_at - (Vector2(r * 1.5, 0))
			draw_arc(pos, r / 2, 0, 360, 180, b1_color)

		if(_b2_down):
			var pos = _draw_at + (Vector2(r * 1.5, 0))
			draw_arc(pos, r / 2, 0, 360, 180, b2_color)

		draw_arc(_draw_at, r, 0, 360, 360, line_color, 1)
		draw_line(_draw_at - Vector2(0, r), _draw_at + Vector2(0, r), line_color)
		draw_line(_draw_at - Vector2(r, 0), _draw_at + Vector2(r, 0), line_color)


	func _draw_square_cursor():
		var r = 10
		var b1_color = up_color
		var b2_color = up_color

		if(_b1_down):
			b1_color = down_color

		if(_b2_down):
			b2_color = down_color

		var blen = r * .75
		# left button rectangle
		draw_rect(Rect2(_draw_at - Vector2(blen, blen), Vector2(blen, blen * 2)), b1_color)
		# right button rectrangle
		draw_rect(Rect2(_draw_at - Vector2(0, blen), Vector2(blen, blen * 2)), b2_color)
		# Crosshair
		draw_line(_draw_at - Vector2(0, r), _draw_at + Vector2(0, r), line_color)
		draw_line(_draw_at - Vector2(r, 0), _draw_at + Vector2(r, 0), line_color)


	func _draw():
		if(disabled):
			return
		_draw_square_cursor()







# ##############################################################################
#
# ##############################################################################
## Local reference to the GutInputFactory static class
const INPUT_WARN = 'If using Input as a reciever it will not respond to *_down events until a *_up event is recieved.  Call the appropriate *_up event or use hold_for(...) to automatically release after some duration.'

var _lgr = GutUtils.get_logger()
var _receivers = []
var _input_queue = []
var _next_queue_item = null

# used by hold_for and echo.
var _last_event = null
# indexed by keycode, each entry contains a boolean value indicating the
# last emitted "pressed" value for that keycode.
var _pressed_keys = {}
var _pressed_actions = {}
var _pressed_mouse_buttons = {}

var _auto_flush_input = false
var _tree_items_parent = null
var _mouse_draw = null;

var _default_mouse_position = {
	position = Vector2(0, 0),
	global_position = Vector2(0, 0)
}

var _last_mouse_position = {
}

## Warp mouse when sending InputEventMouse* events
var mouse_warp = false
## Draw mouse position cross hairs.  Useful to see where the mouse is at
## when not using [member mouse_warp]
var draw_mouse = true

## Emitted when all events in the input queue have been sent.
signal idle


## Accepts a single optional receiver.
func _init(r=null):
	if(r != null):
		add_receiver(r)

	_last_mouse_position = _default_mouse_position.duplicate()
	_tree_items_parent = Node.new()
	Engine.get_main_loop().root.add_child(_tree_items_parent)

	_mouse_draw = MouseDraw.new()
	_tree_items_parent.add_child(_mouse_draw)
	_mouse_draw.disabled = false


func _notification(what):
	if(what == NOTIFICATION_PREDELETE):
		if(is_instance_valid(_tree_items_parent)):
			_tree_items_parent.queue_free()


func _add_queue_item(item):
	item.connect("event_ready", _on_queue_item_ready.bind(item))
	_next_queue_item = item
	_input_queue.append(item)
	_tree_items_parent.add_child(item)
	if(_input_queue.size() == 1):
		item.start()


func _handle_pressed_keys(event):
	if(event is InputEventKey):
		if((event.pressed and !event.echo) and is_key_pressed(event.keycode)):
			_lgr.warn(str("InputSender:  key_down called for ", event.as_text(), " when that key is already pressed.  ", INPUT_WARN))
		_pressed_keys[event.keycode] = event.pressed
	elif(event is InputEventAction):
		if(event.pressed and is_action_pressed(event.action)):
			_lgr.warn(str("InputSender:  action_down called for ", event.action, " when that action is already pressed.  ", INPUT_WARN))
		_pressed_actions[event.action] = event.pressed
	elif(event is InputEventMouseButton):
		if(event.pressed and is_mouse_button_pressed(event.button_index)):
			_lgr.warn(str("InputSender:  mouse_button_down called for ", event.button_index, " when that mouse button is already pressed.  ", INPUT_WARN))
		_pressed_mouse_buttons[event.button_index] = event


func _handle_mouse_position(event):
	if(event is InputEventMouse):
		_mouse_draw.disabled = !draw_mouse
		_mouse_draw.draw_event(event)
		if(mouse_warp):
			DisplayServer.warp_mouse(event.position)


func _send_event(event):
	_handle_mouse_position(event)
	_handle_pressed_keys(event)

	for r in _receivers:
		if(r == Input):
			Input.parse_input_event(event)
			if(event is InputEventAction):
				if(event.pressed):
					Input.action_press(event.action)
				else:
					Input.action_release(event.action)
			if(_auto_flush_input):
				Input.flush_buffered_events()
		else:
			if(r.has_method(&"_input")):
				r._input(event)

			if(r.has_signal(&"gui_input")):
				r.gui_input.emit(event)

			if(r.has_method(&"_gui_input")):
				r._gui_input(event)

			if(r.has_method(&"_unhandled_input")):
				r._unhandled_input(event)


func _send_or_record_event(event):
	_last_event = event
	if(_next_queue_item != null):
		_next_queue_item.events.append(event)
	else:
		_send_event(event)


func _set_last_mouse_positions(event : InputEventMouse):
	_last_mouse_position.position = event.position
	_last_mouse_position.global_position = event.global_position


func _apply_last_position_and_set_last_position(event, position, global_position):
	event.position = GutUtils.nvl(position, _last_mouse_position.position)
	event.global_position = GutUtils.nvl(
		global_position, _last_mouse_position.global_position)
	_set_last_mouse_positions(event)


func _new_defaulted_mouse_button_event(position, global_position):
	var event = InputEventMouseButton.new()
	_apply_last_position_and_set_last_position(event, position, global_position)
	return event


func _new_defaulted_mouse_motion_event(position, global_position):
	var event = InputEventMouseMotion.new()
	_apply_last_position_and_set_last_position(event, position, global_position)
	for key in _pressed_mouse_buttons:
		if(_pressed_mouse_buttons[key].pressed):
			event.button_mask += key
	return event


# ------------------------------
# Events
# ------------------------------
func _on_queue_item_ready(item):
	for event in item.events:
		_send_event(event)

	var done_event = _input_queue.pop_front()
	done_event.queue_free()

	if(_input_queue.size() == 0):
		_next_queue_item = null
		idle.emit()
	else:
		_input_queue[0].start()


# ------------------------------
# Public
# ------------------------------


## Add an object to receive input events.
func add_receiver(obj):
	_receivers.append(obj)


## Returns the receivers that have been added.
func get_receivers():
	return _receivers


## Returns true if the input queue has items to be processed, false if not.
func is_idle():
	return _input_queue.size() == 0

func is_key_pressed(which):
	var event = GutInputFactory.key_up(which)
	return _pressed_keys.has(event.keycode) and _pressed_keys[event.keycode]

func is_action_pressed(which):
	return _pressed_actions.has(which) and _pressed_actions[which]

func is_mouse_button_pressed(which):
	return _pressed_mouse_buttons.has(which) and _pressed_mouse_buttons[which].pressed


## Get the value of [method set_auto_flush_input].
func get_auto_flush_input():
	return _auto_flush_input


## Enable/Disable auto flushing of input.  When enabled the [GutInputSender]
## will call [code]Input.flush_buffered_events[/code] after each event is sent.
## See the "use_accumulated_input" section in [wiki]Mocking-Input[/wiki] for more
## information.
func set_auto_flush_input(val):
	_auto_flush_input = val


## Adds a delay between the last input queue item added and any queue item added
## next.  By default this will wait [param t] seconds.  You can specify a
## number of frames to wait by passing a string composed of a number and "f".
## For example [code]wait("5f")[/code] will wait 5 frames.
func wait(t):
	if(typeof(t) == TYPE_STRING):
		var suffix = t.substr(t.length() -1, 1)
		var val = t.rstrip('s').rstrip('f').to_float()

		if(suffix.to_lower() == 's'):
			wait_secs(val)
		elif(suffix.to_lower() == 'f'):
			wait_frames(val)
	else:
		wait_secs(t)

	return self


## Clears the input queue and any state such as the last event sent and any
## pressed actions/buttons.  Does not clear the list of receivers.
## [br][br]
## This should be done between each test when the [GutInputSender] is a class
## level variable so that state does not leak between tests.
func clear():
	_last_event = null
	_next_queue_item = null

	for item in _input_queue:
		item.free()
	_input_queue.clear()

	_pressed_keys.clear()
	_pressed_actions.clear()
	_pressed_mouse_buttons.clear()
	_last_mouse_position = _default_mouse_position.duplicate()


# ------------------------------
# Event methods
# ------------------------------

## Sends a [InputEventKey] event with [code]pressed = false[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
func key_up(which):
	var event = GutInputFactory.key_up(which)
	_send_or_record_event(event)
	return self


## Sends a [InputEventKey] event with [code]pressed = true[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
func key_down(which):
	var event = GutInputFactory.key_down(which)
	_send_or_record_event(event)
	return self


## Sends an echo [InputEventKey] event of the last key event.
func key_echo():
	if(_last_event != null and _last_event is InputEventKey):
		var new_key = _last_event.duplicate()
		new_key.echo = true
		_send_or_record_event(new_key)
	return self


## Sends a "action up" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
func action_up(which, strength=1.0):
	var event  = GutInputFactory.action_up(which, strength)
	_send_or_record_event(event)
	return self


## Sends a "action down" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
func action_down(which, strength=1.0):
	var event  = GutInputFactory.action_down(which, strength)
	_send_or_record_event(event)
	return self


## Sends a "button down" [InputEventMouseButton] for the left mouse button.
func mouse_left_button_down(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = true
	event.button_index = MOUSE_BUTTON_LEFT
	_send_or_record_event(event)
	return self


## Sends a "button up" [InputEventMouseButton] for the left mouse button.
func mouse_left_button_up(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = false
	event.button_index = MOUSE_BUTTON_LEFT
	_send_or_record_event(event)
	return self


## Sends a "double click" [InputEventMouseButton] for the left mouse button.
func mouse_double_click(position=null, global_position=null):
	var event = GutInputFactory.mouse_double_click(position, global_position)
	event.double_click = true
	_send_or_record_event(event)
	return self


## Sends a "button down" [InputEventMouseButton] for the right mouse button.
func mouse_right_button_down(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = true
	event.button_index = MOUSE_BUTTON_RIGHT
	_send_or_record_event(event)
	return self


## Sends a "button up" [InputEventMouseButton] for the right mouse button.
func mouse_right_button_up(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = false
	event.button_index = MOUSE_BUTTON_RIGHT
	_send_or_record_event(event)
	return self


## Sends a [InputEventMouseMotion] to move the mouse the specified positions.
func mouse_motion(position, global_position=null):
	var event = _new_defaulted_mouse_motion_event(position, global_position)
	_send_or_record_event(event)
	return self


## Sends a [InputEventMouseMotion] that moves the mouse [param offset]
## from the last [method mouse_motion] or [method mouse_set_position] call.
func mouse_relative_motion(offset, speed=Vector2(0, 0)):
	var last_event = _new_defaulted_mouse_motion_event(null, null)
	var event = GutInputFactory.mouse_relative_motion(offset, last_event, speed)
	_set_last_mouse_positions(event)
	_send_or_record_event(event)
	return self


## Sets the mouse's position.  This does not send an event.  This position will
## be used for the next call to [method mouse_relative_motion].
func mouse_set_position(position, global_position=null):
	var event = _new_defaulted_mouse_motion_event(position, global_position)
	return self


## Performs a left click at the given position.
func mouse_left_click_at(where, duration = '5f'):
	wait_frames(1)
	mouse_left_button_down(where)
	hold_for(duration)
	wait_frames(10)
	return self


## Create your own event and use this to send it to all receivers.
func send_event(event):
	_send_or_record_event(event)
	return self


## Releases all [InputEventKey], [InputEventAction], and [InputEventMouseButton]
## events that have passed through this instance.  These events could have been
## generated via the various [code]_down[/code] methods or passed to
## [method send_event].
## [br][br]
## This will send the "release" event ([code]pressed = false[/code]) to all
## receivers.  This should be done between each test when using `Input` as a
## receiver.
func release_all():
	for key in _pressed_keys:
		if(_pressed_keys[key]):
			_send_event(GutInputFactory.key_up(key))
	_pressed_keys.clear()

	for key in _pressed_actions:
		if(_pressed_actions[key]):
			_send_event(GutInputFactory.action_up(key))
	_pressed_actions.clear()

	for key in _pressed_mouse_buttons:
		var event = _pressed_mouse_buttons[key].duplicate()
		if(event.pressed):
			event.pressed = false
			_send_event(event)
	_pressed_mouse_buttons.clear()

	return self

## Same as [method wait] but only accepts a number of frames to wait.
func wait_frames(num_frames):
	var item = InputQueueItem.new(0, num_frames)
	_add_queue_item(item)
	return self


## Same as [method wait] but only accepts a number of seconds to wait.
func wait_secs(num_secs):
	var item = InputQueueItem.new(num_secs, 0)
	_add_queue_item(item)
	return self


## This is a special [method wait] that will emit the previous input queue item
## with [code]pressed = false[/code] after a delay.  If you pass a number then
## it will wait that many seconds.  You can also use the `"4f"` format to wait
## a specific number of frames.
## [br][br]
## For example [code]sender.action_down('jump').hold_for("10f")[/code] will
## cause two [InputEventAction] instances to be sent.  The "jump-down" event
## from [method action_down] and then a "jump-up" event after 10 frames.
func hold_for(duration):
	if(_last_event != null and _last_event.pressed):
		var next_event = _last_event.duplicate()
		next_event.pressed = false

		wait(duration)
		send_event(next_event)
	return self


## Same as [method hold_for] but specifically holds for a number of physics
## frames.
func hold_frames(duration:int):
	return hold_for(str(duration, 'f'))


## Same as [method hold_for] but specifically holds for a number of seconds.
func hold_seconds(duration:float):
	return hold_for(duration)


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Description
# -----------
# This class sends input to one or more recievers.  The receivers' _input,
# _unhandled_input, and _gui_input are called sending InputEvent* events.
# InputEvents can be sent via the helper methods or a custom made InputEvent
# can be sent via send_event(...)
#
# ##############################################################################


=====================================
FILE: ./addons/gut/gui/ResizeHandle.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bvrqqgjpyouse"]

[ext_resource type="Script" path="res://addons/gut/gui/ResizeHandle.gd" id="1_oi5ed"]

[node name="ResizeHandle" type="ColorRect"]
custom_minimum_size = Vector2(20, 20)
color = Color(1, 1, 1, 0)
script = ExtResource("1_oi5ed")


=====================================
FILE: ./addons/gut/gui/BottomPanelShortcuts.gd
=====================================
@tool
extends Window

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var default_path = GutEditorGlobals.editor_shortcuts_path

@onready var _ctrls = {
	run_all = $Layout/CRunAll/ShortcutButton,
	run_current_script = $Layout/CRunCurrentScript/ShortcutButton,
	run_current_inner = $Layout/CRunCurrentInner/ShortcutButton,
	run_current_test = $Layout/CRunCurrentTest/ShortcutButton,
	panel_button = $Layout/CPanelButton/ShortcutButton,
}

var _user_prefs = GutEditorGlobals.user_prefs

func _ready():
	for key in _ctrls:
		var sc_button = _ctrls[key]
		sc_button.connect('start_edit', _on_edit_start.bind(sc_button))
		sc_button.connect('end_edit', _on_edit_end)

	# show dialog when running scene from editor.
	if(get_parent() == get_tree().root):
		popup_centered()


func _cancel_all():
	_ctrls.run_all.cancel()
	_ctrls.run_current_script.cancel()
	_ctrls.run_current_inner.cancel()
	_ctrls.run_current_test.cancel()
	_ctrls.panel_button.cancel()

# ------------
# Events
# ------------
func _on_Hide_pressed():
	hide()


func _on_edit_start(which):
	for key in _ctrls:
		var sc_button = _ctrls[key]
		if(sc_button != which):
			sc_button.disable_set(true)
			sc_button.disable_clear(true)


func _on_edit_end():
	for key in _ctrls:
		var sc_button = _ctrls[key]
		sc_button.disable_set(false)
		sc_button.disable_clear(false)


func _on_popup_hide():
	_cancel_all()

# ------------
# Public
# ------------
func get_run_all():
	return _ctrls.run_all.get_shortcut()

func get_run_current_script():
	return _ctrls.run_current_script.get_shortcut()

func get_run_current_inner():
	return _ctrls.run_current_inner.get_shortcut()

func get_run_current_test():
	return _ctrls.run_current_test.get_shortcut()

func get_panel_button():
	return _ctrls.panel_button.get_shortcut()

func _set_pref_value(pref, button):
	pref.value = {shortcut = button.get_shortcut().events}


func save_shortcuts():
	save_shortcuts_to_file(default_path)


func save_shortcuts_to_editor_settings():
	_set_pref_value(_user_prefs.shortcut_run_all, _ctrls.run_all)
	_set_pref_value(_user_prefs.shortcut_run_current_script, _ctrls.run_current_script)
	_set_pref_value(_user_prefs.shortcut_run_current_inner, _ctrls.run_current_inner)
	_set_pref_value(_user_prefs.shortcut_run_current_test, _ctrls.run_current_test)
	_set_pref_value(_user_prefs.shortcut_panel_button, _ctrls.panel_button)

	_user_prefs.save_it()


func save_shortcuts_to_file(path):
	var f = ConfigFile.new()
	f.set_value('main', 'run_all', _ctrls.run_all.get_shortcut())
	f.set_value('main', 'run_current_script', _ctrls.run_current_script.get_shortcut())
	f.set_value('main', 'run_current_inner', _ctrls.run_current_inner.get_shortcut())
	f.set_value('main', 'run_current_test', _ctrls.run_current_test.get_shortcut())
	f.set_value('main', 'panel_button', _ctrls.panel_button.get_shortcut())
	f.save(path)


func _load_shortcut_from_pref(user_pref):
	var to_return = Shortcut.new()
	# value with be _user_prefs.EMPTY which is a string when the value
	# has not been set.
	if(typeof(user_pref.value) == TYPE_DICTIONARY):
		to_return.events.append(user_pref.value.shortcut[0])
		# to_return = user_pref.value
	return to_return


func load_shortcuts():
	load_shortcuts_from_file(default_path)


func load_shortcuts_from_editor_settings():
	var empty = Shortcut.new()

	_ctrls.run_all.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_all))
	_ctrls.run_current_script.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_current_script))
	_ctrls.run_current_inner.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_current_inner))
	_ctrls.run_current_test.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_current_test))
	_ctrls.panel_button.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_panel_button))


func load_shortcuts_from_file(path):
	var f = ConfigFile.new()
	var empty = Shortcut.new()

	f.load(path)
	_ctrls.run_all.set_shortcut(f.get_value('main', 'run_all', empty))
	_ctrls.run_current_script.set_shortcut(f.get_value('main', 'run_current_script', empty))
	_ctrls.run_current_inner.set_shortcut(f.get_value('main', 'run_current_inner', empty))
	_ctrls.run_current_test.set_shortcut(f.get_value('main', 'run_current_test', empty))
	_ctrls.panel_button.set_shortcut(f.get_value('main', 'panel_button', empty))


=====================================
FILE: ./addons/gut/gui/GutSceneTheme.tres
=====================================
[gd_resource type="Theme" load_steps=2 format=3 uid="uid://cstkhwkpajvqu"]

[ext_resource type="FontFile" uid="uid://c6c7gnx36opr0" path="res://addons/gut/fonts/AnonymousPro-Regular.ttf" id="1_df57p"]

[resource]
default_font = ExtResource("1_df57p")
Label/fonts/font = ExtResource("1_df57p")


=====================================
FILE: ./addons/gut/gui/GutControl.gd
=====================================
@tool
extends Control

const RUNNER_JSON_PATH = 'res://.gut_editor_config.json'

var GutConfig = load('res://addons/gut/gut_config.gd')
var GutRunnerScene = load('res://addons/gut/gui/GutRunner.tscn')
var GutConfigGui = load('res://addons/gut/gui/gut_config_gui.gd')

var _config = GutConfig.new()
var _config_gui = null
var _gut_runner = GutRunnerScene.instantiate()
var _has_connected = false
var _tree_root : TreeItem = null

var _script_icon = load('res://addons/gut/images/Script.svg')
var _folder_icon = load('res://addons/gut/images/Folder.svg')

var _tree_scripts = {}
var _tree_directories = {}

const TREE_SCRIPT = 'Script'
const TREE_DIR = 'Directory'

@onready var _ctrls = {
	run_tests_button = $VBox/Buttons/RunTests,
	run_selected = $VBox/Buttons/RunSelected,
	test_tree = $VBox/Tabs/Tests,
	settings_vbox = $VBox/Tabs/SettingsScroll/Settings,
	tabs = $VBox/Tabs,
	bg = $Bg
}

@export var bg_color : Color = Color(.36, .36, .36) :
	get: return bg_color
	set(val):
		bg_color = val
		if(is_inside_tree()):
			$Bg.color = bg_color


func _ready():
	if Engine.is_editor_hint():
		return

	$Bg.color = bg_color
	_ctrls.tabs.set_tab_title(0, 'Tests')
	_ctrls.tabs.set_tab_title(1, 'Settings')

	_config_gui = GutConfigGui.new(_ctrls.settings_vbox)

	_ctrls.test_tree.hide_root = true
	add_child(_gut_runner)

	# TODO This might not need to be called deferred after changing GutUtils to
	# an all static class.
	call_deferred('_post_ready')


func _draw():
	if Engine.is_editor_hint():
		return

	var gut = _gut_runner.get_gut()
	if(!gut.is_running()):
		var r = Rect2(Vector2(0, 0), get_rect().size)
		draw_rect(r, Color.BLACK, false, 2)


func _post_ready():
	var gut = _gut_runner.get_gut()
	gut.start_run.connect(_on_gut_run_started)
	gut.end_run.connect(_on_gut_run_ended)
	_refresh_tree_and_settings()


func _set_meta_for_script_tree_item(item, script, test=null):
	var meta = {
		type = TREE_SCRIPT,
		script = script.path,
		inner_class = script.inner_class_name,
		test = ''
	}

	if(test != null):
		meta.test = test.name

	item.set_metadata(0, meta)


func _set_meta_for_directory_tree_item(item, path, temp_item):
	var meta = {
		type = TREE_DIR,
		path = path,
		temp_item = temp_item
	}
	item.set_metadata(0, meta)


func _get_script_tree_item(script, parent_item):
	if(!_tree_scripts.has(script.path)):
		var item = _ctrls.test_tree.create_item(parent_item)
		item.set_text(0, script.path.get_file())
		item.set_icon(0, _script_icon)
		_tree_scripts[script.path] = item
		_set_meta_for_script_tree_item(item, script)

	return _tree_scripts[script.path]


func _get_directory_tree_item(path):
	var parent = _tree_root
	if(!_tree_directories.has(path)):

		var item : TreeItem = null
		if(parent != _tree_root):
			item = parent.create_child(0)
		else:
			item = parent.create_child()

		_tree_directories[path] = item
		item.collapsed = false
		item.set_text(0, path)
		item.set_icon(0, _folder_icon)
		item.set_icon_modulate(0, Color.ROYAL_BLUE)
		# temp_item is used in calls with move_before since you must use
		# move_before or move_after to reparent tree items. This ensures that
		# there is an item on all directories.  These are deleted later.
		var temp_item = item.create_child()
		temp_item.set_text(0, '<temp>')

		_set_meta_for_directory_tree_item(item, path, temp_item)

	return _tree_directories[path]


func _find_dir_item_to_move_before(path):
	var max_matching_len = 0
	var best_parent = null

	# Go through all the directory items finding the one that has the longest
	# path that contains our path.
	for key in _tree_directories.keys():
		if(path != key and path.begins_with(key) and key.length() > max_matching_len):
				max_matching_len = key.length()
				best_parent = _tree_directories[key]

	var to_return = null
	if(best_parent != null):
		to_return = best_parent.get_metadata(0).temp_item
	return to_return


func _reorder_dir_items():
	var the_keys = _tree_directories.keys()
	the_keys.sort()
	for key in _tree_directories.keys():
		var to_move = _tree_directories[key]
		to_move.collapsed = false
		var move_before = _find_dir_item_to_move_before(key)
		if(move_before != null):
			to_move.move_before(move_before)
			var new_text = key.substr(move_before.get_parent().get_metadata(0).path.length())
			to_move.set_text(0, new_text)


func _remove_dir_temp_items():
	for key in _tree_directories.keys():
		var item = _tree_directories[key].get_metadata(0).temp_item
		_tree_directories[key].remove_child(item)


func _add_dir_and_script_tree_items():
	var tree : Tree = _ctrls.test_tree
	tree.clear()
	_tree_root = _ctrls.test_tree.create_item()

	var scripts = _gut_runner.get_gut().get_test_collector().scripts
	for script in scripts:
		var dir_item = _get_directory_tree_item(script.path.get_base_dir())
		var item = _get_script_tree_item(script, dir_item)

		if(script.inner_class_name != ''):
			var inner_item = tree.create_item(item)
			inner_item.set_text(0, script.inner_class_name)
			_set_meta_for_script_tree_item(inner_item, script)
			item = inner_item

		for test in script.tests:
			var test_item = tree.create_item(item)
			test_item.set_text(0, test.name)
			_set_meta_for_script_tree_item(test_item, script, test)


func _populate_tree():
	_add_dir_and_script_tree_items()
	_tree_root.set_collapsed_recursive(true)
	_tree_root.set_collapsed(false)
	_reorder_dir_items()
	_remove_dir_temp_items()


func _refresh_tree_and_settings():
	_config.apply_options(_gut_runner.get_gut())
	_gut_runner.set_gut_config(_config)
	_populate_tree()

# ---------------------------
# Events
# ---------------------------
func _on_gut_run_started():
	_ctrls.run_tests_button.disabled = true
	_ctrls.run_selected.visible = false
	_ctrls.tabs.visible = false
	_ctrls.bg.visible = false
	_ctrls.run_tests_button.text = 'Running'
	queue_redraw()


func _on_gut_run_ended():
	_ctrls.run_tests_button.disabled = false
	_ctrls.run_selected.visible = true
	_ctrls.tabs.visible = true
	_ctrls.bg.visible = true
	_ctrls.run_tests_button.text = 'Run All'
	queue_redraw()


func _on_run_tests_pressed():
	run_all()


func _on_run_selected_pressed():
	run_selected()


func _on_tests_item_activated():
	run_selected()

# ---------------------------
# Public
# ---------------------------
func get_gut():
	return _gut_runner.get_gut()


func get_config():
	return _config


func run_all():
	_config.options.selected = ''
	_config.options.inner_class_name = ''
	_config.options.unit_test_name = ''
	run_tests()


func run_tests(options = null):
	if(options == null):
		_config.options = _config_gui.get_options(_config.options)
	else:
		_config.options = options

	_gut_runner.get_gut().get_test_collector().clear()
	_gut_runner.set_gut_config(_config)
	_gut_runner.run_tests()


func run_selected():
	var sel_item = _ctrls.test_tree.get_selected()
	if(sel_item == null):
		return

	var options = _config_gui.get_options(_config.options)
	var meta = sel_item.get_metadata(0)
	if(meta.type == TREE_SCRIPT):
		options.selected = meta.script.get_file()
		options.inner_class_name = meta.inner_class
		options.unit_test_name = meta.test
	elif(meta.type == TREE_DIR):
		options.dirs = [meta.path]
		options.include_subdirectories = true
		options.selected = ''
		options.inner_class_name = ''
		options.unit_test_name = ''

	run_tests(options)


func load_config_file(path):
	_config.load_options(path)
	_config.options.selected = ''
	_config.options.inner_class_name = ''
	_config.options.unit_test_name = ''
	_config_gui.load_file(path)


# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/gui/RunResults.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://4gyyn12um08h"]

[ext_resource type="Script" path="res://addons/gut/gui/RunResults.gd" id="1"]
[ext_resource type="PackedScene" uid="uid://dls5r5f6157nq" path="res://addons/gut/gui/ResultsTree.tscn" id="2_o808v"]

[sub_resource type="Image" id="Image_abbh7"]
data = {
"data": PackedByteArray(255, 255, 255, 0, 255, 255, 255, 0, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 131, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 131, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 131, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 128, 128, 4, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 231, 255, 93, 93, 55, 255, 97, 97, 58, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 93, 93, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 97, 97, 42, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 98, 98, 47, 255, 97, 97, 42, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 93, 93, 233, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 94, 94, 46, 255, 93, 93, 236, 255, 93, 93, 233, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 93, 93, 252, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0),
"format": "RGBA8",
"height": 16,
"mipmaps": false,
"width": 16
}

[sub_resource type="ImageTexture" id="ImageTexture_x655i"]
image = SubResource("Image_abbh7")

[node name="RunResults" type="Control"]
custom_minimum_size = Vector2(345, 0)
layout_mode = 3
anchors_preset = 0
offset_right = 709.0
offset_bottom = 321.0
script = ExtResource("1")

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="Toolbar" type="HBoxContainer" parent="VBox"]
layout_mode = 2
size_flags_horizontal = 0

[node name="Expand" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
icon = SubResource("ImageTexture_x655i")

[node name="Collapse" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
icon = SubResource("ImageTexture_x655i")

[node name="Sep" type="ColorRect" parent="VBox/Toolbar"]
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="LblAll" type="Label" parent="VBox/Toolbar"]
layout_mode = 2
text = "All:"

[node name="ExpandAll" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
icon = SubResource("ImageTexture_x655i")

[node name="CollapseAll" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
icon = SubResource("ImageTexture_x655i")

[node name="Sep2" type="ColorRect" parent="VBox/Toolbar"]
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="HidePassing" type="CheckBox" parent="VBox/Toolbar"]
layout_mode = 2
size_flags_horizontal = 4
text = "Passing"

[node name="Sep3" type="ColorRect" parent="VBox/Toolbar"]
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="LblSync" type="Label" parent="VBox/Toolbar"]
layout_mode = 2
text = "Sync:"

[node name="ShowScript" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
toggle_mode = true
button_pressed = true
icon = SubResource("ImageTexture_x655i")

[node name="ScrollOutput" type="Button" parent="VBox/Toolbar"]
layout_mode = 2
toggle_mode = true
button_pressed = true
icon = SubResource("ImageTexture_x655i")

[node name="Output" type="Panel" parent="VBox"]
self_modulate = Color(1, 1, 1, 0.541176)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Scroll" type="ScrollContainer" parent="VBox/Output"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Tree" parent="VBox/Output/Scroll" instance=ExtResource("2_o808v")]
layout_mode = 2

[node name="FontSampler" type="Label" parent="."]
visible = false
layout_mode = 0
offset_right = 40.0
offset_bottom = 14.0
text = "000 of 000 passed"

[connection signal="pressed" from="VBox/Toolbar/Expand" to="." method="_on_Expand_pressed"]
[connection signal="pressed" from="VBox/Toolbar/Collapse" to="." method="_on_Collapse_pressed"]
[connection signal="pressed" from="VBox/Toolbar/ExpandAll" to="." method="_on_ExpandAll_pressed"]
[connection signal="pressed" from="VBox/Toolbar/CollapseAll" to="." method="_on_CollapseAll_pressed"]
[connection signal="pressed" from="VBox/Toolbar/HidePassing" to="." method="_on_Hide_Passing_pressed"]


=====================================
FILE: ./addons/gut/gui/ResultsTree.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dls5r5f6157nq"]

[ext_resource type="Script" path="res://addons/gut/gui/ResultsTree.gd" id="1_b4uub"]

[node name="ResultsTree" type="VBoxContainer"]
custom_minimum_size = Vector2(10, 10)
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = -70.0
offset_bottom = -104.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1_b4uub")

[node name="Tree" type="Tree" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
columns = 2
hide_root = true

[node name="TextOverlay" type="Label" parent="Tree"]
visible = false
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2


=====================================
FILE: ./addons/gut/gui/OutputText.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://bqmo4dj64c7yl"]

[ext_resource type="Script" path="res://addons/gut/gui/OutputText.gd" id="1"]
[ext_resource type="FontFile" uid="uid://bnh0lslf4yh87" path="res://addons/gut/fonts/CourierPrime-Regular.ttf" id="2_huwnh"]

[sub_resource type="Image" id="Image_j74eb"]
data = {
"data": PackedByteArray(255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 93, 93, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0),
"format": "RGBA8",
"height": 16,
"mipmaps": false,
"width": 16
}

[sub_resource type="ImageTexture" id="ImageTexture_42opa"]
image = SubResource("Image_j74eb")

[sub_resource type="CodeHighlighter" id="CodeHighlighter_v57hd"]
number_color = Color(1, 1, 1, 1)
symbol_color = Color(1, 1, 1, 1)
function_color = Color(1, 1, 1, 1)
member_variable_color = Color(1, 1, 1, 1)
keyword_colors = {
"ERROR": Color(1, 0, 0, 1),
"Failed": Color(1, 0, 0, 1),
"Orphans": Color(1, 1, 0, 1),
"Passed": Color(0, 1, 0, 1),
"Pending": Color(1, 1, 0, 1),
"WARNING": Color(1, 1, 0, 1)
}

[node name="OutputText" type="VBoxContainer"]
offset_right = 862.0
offset_bottom = 523.0
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1")

[node name="Toolbar" type="HBoxContainer" parent="."]
layout_mode = 2
size_flags_horizontal = 3

[node name="ShowSearch" type="Button" parent="Toolbar"]
layout_mode = 2
tooltip_text = "Search"
toggle_mode = true
icon = SubResource("ImageTexture_42opa")

[node name="ShowSettings" type="Button" parent="Toolbar"]
layout_mode = 2
tooltip_text = "Settings"
toggle_mode = true
text = "..."

[node name="CenterContainer" type="CenterContainer" parent="Toolbar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LblPosition" type="Label" parent="Toolbar"]
layout_mode = 2

[node name="CopyButton" type="Button" parent="Toolbar"]
layout_mode = 2
text = " Copy "

[node name="ClearButton" type="Button" parent="Toolbar"]
layout_mode = 2
text = "  Clear  "

[node name="Settings" type="HBoxContainer" parent="."]
visible = false
layout_mode = 2

[node name="WordWrap" type="Button" parent="Settings"]
layout_mode = 2
tooltip_text = "Word Wrap"
toggle_mode = true
icon = SubResource("ImageTexture_42opa")

[node name="UseColors" type="Button" parent="Settings"]
layout_mode = 2
tooltip_text = "Colorized Text"
toggle_mode = true
button_pressed = true
icon = SubResource("ImageTexture_42opa")

[node name="Output" type="TextEdit" parent="."]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
theme_override_fonts/font = ExtResource("2_huwnh")
theme_override_font_sizes/font_size = 30
deselect_on_focus_loss_enabled = false
virtual_keyboard_enabled = false
middle_mouse_paste_enabled = false
scroll_smooth = true
syntax_highlighter = SubResource("CodeHighlighter_v57hd")
highlight_all_occurrences = true
highlight_current_line = true

[node name="Search" type="HBoxContainer" parent="."]
visible = false
layout_mode = 2

[node name="SearchTerm" type="LineEdit" parent="Search"]
layout_mode = 2
size_flags_horizontal = 3

[node name="SearchNext" type="Button" parent="Search"]
layout_mode = 2
text = "Next"

[node name="SearchPrev" type="Button" parent="Search"]
layout_mode = 2
text = "Prev"

[connection signal="pressed" from="Toolbar/ShowSearch" to="." method="_on_ShowSearch_pressed"]
[connection signal="pressed" from="Toolbar/ShowSettings" to="." method="_on_settings_pressed"]
[connection signal="pressed" from="Toolbar/CopyButton" to="." method="_on_CopyButton_pressed"]
[connection signal="pressed" from="Toolbar/ClearButton" to="." method="_on_ClearButton_pressed"]
[connection signal="pressed" from="Settings/WordWrap" to="." method="_on_WordWrap_pressed"]
[connection signal="pressed" from="Settings/UseColors" to="." method="_on_UseColors_pressed"]
[connection signal="focus_entered" from="Search/SearchTerm" to="." method="_on_SearchTerm_focus_entered"]
[connection signal="gui_input" from="Search/SearchTerm" to="." method="_on_SearchTerm_gui_input"]
[connection signal="text_changed" from="Search/SearchTerm" to="." method="_on_SearchTerm_text_changed"]
[connection signal="text_submitted" from="Search/SearchTerm" to="." method="_on_SearchTerm_text_entered"]
[connection signal="pressed" from="Search/SearchNext" to="." method="_on_SearchNext_pressed"]
[connection signal="pressed" from="Search/SearchPrev" to="." method="_on_SearchPrev_pressed"]


=====================================
FILE: ./addons/gut/gui/GutRunner.gd
=====================================
# ##############################################################################
# This class joins together GUT, GUT Gui, GutConfig and is THE way to kick off a
# run of a test suite.
#
# This creates its own instance of gut.gd that it manages.  You can set the
# gut.gd instance if you need to for testing.
#
# Set gut_config to an instance of a configured gut_config.gd instance prior to
# running tests.
#
# This will create a GUI and wire it up and apply gut_config.gd options.
#
# Running tests:  Call run_tests
# ##############################################################################
extends Node2D

const EXIT_OK = 0
const EXIT_ERROR = 1

var Gut = load('res://addons/gut/gut.gd')
var ResultExporter = load('res://addons/gut/result_exporter.gd')
var GutConfig = load('res://addons/gut/gut_config.gd')

var runner_json_path = null
var result_bbcode_path = null
var result_json_path = null

var lgr = GutUtils.get_logger()
var gut_config = null

var _hid_gut = null;
# Lazy loaded gut instance.  Settable for testing purposes.
var gut = _hid_gut :
	get:
		if(_hid_gut == null):
			_hid_gut = Gut.new()
		return _hid_gut
	set(val):
		_hid_gut = val

var _wrote_results = false
var _ran_from_editor = false

@onready var _gut_layer = $GutLayer
@onready var _gui = $GutLayer/GutScene


func _ready():
	GutUtils.WarningsManager.apply_warnings_dictionary(
		GutUtils.warnings_at_start)


func _exit_tree():
	if(!_wrote_results and _ran_from_editor):
		_write_results_for_gut_panel()


func _setup_gui(show_gui):
	if(show_gui):
		_gui.gut = gut
		var printer = gut.logger.get_printer('gui')
		printer.set_textbox(_gui.get_textbox())
	else:
		gut.logger.disable_printer('gui', true)
		_gui.visible = false

	var opts = gut_config.options
	_gui.set_font_size(opts.font_size)
	_gui.set_font(opts.font_name)
	if(opts.font_color != null and opts.font_color.is_valid_html_color()):
		_gui.set_default_font_color(Color(opts.font_color))
	if(opts.background_color != null and opts.background_color.is_valid_html_color()):
		_gui.set_background_color(Color(opts.background_color))

	_gui.set_opacity(min(1.0, float(opts.opacity) / 100))
	_gui.use_compact_mode(opts.compact_mode)


func _write_results_for_gut_panel():
	var content = _gui.get_textbox().get_parsed_text() #_gut.logger.get_gui_bbcode()
	var f = FileAccess.open(result_bbcode_path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
		f = null # closes file
	else:
		push_error('Could not save bbcode, result = ', FileAccess.get_open_error())

	var exporter = ResultExporter.new()
	# TODO this should be checked and _wrote_results should maybe not be set, or
	# maybe we do not care.  Whichever, it should be clear.
	var _f_result = exporter.write_json_file(gut, result_json_path)
	_wrote_results = true


func _handle_quit(should_exit, should_exit_on_success, override_exit_code=EXIT_OK):
	var quitting_time = should_exit or \
		(should_exit_on_success and gut.get_fail_count() == 0)

	if(!quitting_time):
		if(should_exit_on_success):
			lgr.log("There are failing tests, exit manually.")
		_gui.use_compact_mode(false)
		return

	# For some reason, tests fail asserting that quit was called with 0 if we
	# do not do this, but everything is defaulted so I don't know why it gets
	# null.
	var exit_code = GutUtils.nvl(override_exit_code, EXIT_OK)

	if(gut.get_fail_count() > 0):
		exit_code = EXIT_ERROR

	# Overwrite the exit code with the post_script's exit code if it is set
	var post_hook_inst = gut.get_post_run_script_instance()
	if(post_hook_inst != null and post_hook_inst.get_exit_code() != null):
		exit_code = post_hook_inst.get_exit_code()

	quit(exit_code)


func _end_run(override_exit_code=EXIT_OK):
	if(_ran_from_editor):
		_write_results_for_gut_panel()

	_handle_quit(gut_config.options.should_exit,
		gut_config.options.should_exit_on_success,
		override_exit_code)


# -------------
# Events
# -------------
func _on_tests_finished():
	_end_run()


# -------------
# Public
# -------------
# For internal use only, but still public.  Consider it "protected" and you
# don't have my permission to call this, unless "you" is "me".
func run_from_editor():
	_ran_from_editor = true
	var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
	runner_json_path = GutUtils.nvl(runner_json_path, GutEditorGlobals.editor_run_gut_config_path)
	result_bbcode_path = GutUtils.nvl(result_bbcode_path, GutEditorGlobals.editor_run_bbcode_results_path)
	result_json_path = GutUtils.nvl(result_json_path, GutEditorGlobals.editor_run_json_results_path)

	if(gut_config == null):
		gut_config = GutConfig.new()
		gut_config.load_options(runner_json_path)

	call_deferred('run_tests')


func run_tests(show_gui=true):
	_setup_gui(show_gui)

	if(gut_config.options.dirs.size() + gut_config.options.tests.size() == 0):
		var err_text = "You do not have any directories configured, so GUT doesn't know where to find the tests.  Tell GUT where to find the tests and GUT shall run the tests."
		lgr.error(err_text)
		push_error(err_text)
		_end_run(EXIT_ERROR)
		return

	var install_check_text = GutUtils.make_install_check_text()
	if(install_check_text != GutUtils.INSTALL_OK_TEXT):
		print("\n\n", GutUtils.version_numbers.get_version_text())
		lgr.error(install_check_text)
		push_error(install_check_text)
		_end_run(EXIT_ERROR)
		return

	gut.add_children_to = self
	if(gut.get_parent() == null):
		if(gut_config.options.gut_on_top):
			_gut_layer.add_child(gut)
		else:
			add_child(gut)

	gut.end_run.connect(_on_tests_finished)

	gut_config.apply_options(gut)
	var run_rest_of_scripts = gut_config.options.unit_test_name == ''

	gut.test_scripts(run_rest_of_scripts)


func set_gut_config(which):
	gut_config = which


# for backwards compatibility
func get_gut():
	return gut


func quit(exit_code):
	# Sometimes quitting takes a few seconds.  This gives some indicator
	# of what is going on.
	_gui.set_title("Exiting")
	await get_tree().process_frame

	lgr.info(str('Exiting with code ', exit_code))
	get_tree().quit(exit_code)




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/gui/RunAtCursor.gd
=====================================
@tool
extends Control


var ScriptTextEditors = load('res://addons/gut/gui/script_text_editor_controls.gd')

@onready var _ctrls = {
	btn_script = $HBox/BtnRunScript,
	btn_inner = $HBox/BtnRunInnerClass,
	btn_method = $HBox/BtnRunMethod,
	lbl_none = $HBox/LblNoneSelected,
	arrow_1 = $HBox/Arrow1,
	arrow_2 = $HBox/Arrow2
}

var _editors = null
var _cur_editor = null
var _last_line = -1
var _cur_script_path = null
var _last_info = {
	script = null,
	inner_class = null,
	test_method = null
}


signal run_tests(what)


func _ready():
	_ctrls.lbl_none.visible = true
	_ctrls.btn_script.visible = false
	_ctrls.btn_inner.visible = false
	_ctrls.btn_method.visible = false
	_ctrls.arrow_1.visible = false
	_ctrls.arrow_2.visible = false

# ----------------
# Private
# ----------------
func _set_editor(which):
	_last_line = -1
	if(_cur_editor != null and _cur_editor.get_ref()):
		# _cur_editor.get_ref().disconnect('cursor_changed',Callable(self,'_on_cursor_changed'))
		_cur_editor.get_ref().caret_changed.disconnect(_on_cursor_changed)

	if(which != null):
		_cur_editor = weakref(which)
		which.caret_changed.connect(_on_cursor_changed.bind(which))
		# which.connect('cursor_changed',Callable(self,'_on_cursor_changed'),[which])

		_last_line = which.get_caret_line()
		_last_info = _editors.get_line_info()
		_update_buttons(_last_info)


func _update_buttons(info):
	_ctrls.lbl_none.visible = _cur_script_path == null
	_ctrls.btn_script.visible = _cur_script_path != null

	_ctrls.btn_inner.visible = info.inner_class != null
	_ctrls.arrow_1.visible = info.inner_class != null
	_ctrls.btn_inner.text = str(info.inner_class)
	_ctrls.btn_inner.tooltip_text = str("Run all tests in Inner-Test-Class ", info.inner_class)

	_ctrls.btn_method.visible = info.test_method != null
	_ctrls.arrow_2.visible = info.test_method != null
	_ctrls.btn_method.text = str(info.test_method)
	_ctrls.btn_method.tooltip_text = str("Run test ", info.test_method)

	# The button's new size won't take effect until the next frame.
	# This appears to be what was causing the button to not be clickable the
	# first time.
	call_deferred("_update_size")

func _update_size():
	custom_minimum_size.x = _ctrls.btn_method.size.x + _ctrls.btn_method.position.x

# ----------------
# Events
# ----------------
func _on_cursor_changed(which):
	if(which.get_caret_line() != _last_line):
		_last_line = which.get_caret_line()
		_last_info = _editors.get_line_info()
		_update_buttons(_last_info)


func _on_BtnRunScript_pressed():
	var info = _last_info.duplicate()
	info.script = _cur_script_path.get_file()
	info.inner_class = null
	info.test_method = null
	emit_signal("run_tests", info)


func _on_BtnRunInnerClass_pressed():
	var info = _last_info.duplicate()
	info.script = _cur_script_path.get_file()
	info.test_method = null
	emit_signal("run_tests", info)


func _on_BtnRunMethod_pressed():
	var info = _last_info.duplicate()
	info.script = _cur_script_path.get_file()
	emit_signal("run_tests", info)


# ----------------
# Public
# ----------------
func set_script_text_editors(value):
	_editors = value


func activate_for_script(path):
	_ctrls.btn_script.visible = true
	_ctrls.btn_script.text = path.get_file()
	_ctrls.btn_script.tooltip_text = str("Run all tests in script ", path)
	_cur_script_path = path
	_editors.refresh()
	# We have to wait a beat for the visibility to change on
	# the editors, otherwise we always get the first one.
	await get_tree().process_frame
	_set_editor(_editors.get_current_text_edit())


func get_script_button():
	return _ctrls.btn_script


func get_inner_button():
	return _ctrls.btn_inner


func get_test_button():
	return _ctrls.btn_method


# not used, thought was configurable but it's just the script prefix
func set_method_prefix(value):
	_editors.set_method_prefix(value)


# not used, thought was configurable but it's just the script prefix
func set_inner_class_prefix(value):
	_editors.set_inner_class_prefix(value)


# Mashed this function in here b/c it has _editors.  Probably should be
# somewhere else (possibly in script_text_editor_controls).
func search_current_editor_for_text(txt):
	var te = _editors.get_current_text_edit()
	var result = te.search(txt, 0, 0, 0)
	var to_return = -1

	return to_return


=====================================
FILE: ./addons/gut/gui/GutRunner.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://bqy3ikt6vu4b5"]

[ext_resource type="Script" path="res://addons/gut/gui/GutRunner.gd" id="1"]
[ext_resource type="PackedScene" uid="uid://m28heqtswbuq" path="res://addons/gut/GutScene.tscn" id="2_6ruxb"]

[node name="GutRunner" type="Node2D"]
script = ExtResource("1")

[node name="GutLayer" type="CanvasLayer" parent="."]
layer = 128

[node name="GutScene" parent="GutLayer" instance=ExtResource("2_6ruxb")]


=====================================
FILE: ./addons/gut/gui/ResultsTree.gd
=====================================
@tool
extends Control

var _show_orphans = true
var show_orphans = true :
	get: return _show_orphans
	set(val): _show_orphans = val


var _hide_passing = true
var hide_passing = true :
	get: return _hide_passing
	set(val): _hide_passing = val


var _icons = {
	red = load('res://addons/gut/images/red.png'),
	green = load('res://addons/gut/images/green.png'),
	yellow = load('res://addons/gut/images/yellow.png'),
}
const _col_1_bg_color = Color(0, 0, 0, .1)
var _max_icon_width = 10
var _root : TreeItem

@onready var _ctrls = {
	tree = $Tree,
	lbl_overlay = $Tree/TextOverlay
}


signal item_selected(script_path, inner_class, test_name, line_number)
# -------------------
# Private
# -------------------
func _ready():
	_root = _ctrls.tree.create_item()
	_root = _ctrls.tree.create_item()
	_ctrls.tree.set_hide_root(true)
	_ctrls.tree.columns = 2
	_ctrls.tree.set_column_expand(0, true)
	_ctrls.tree.set_column_expand(1, false)
	_ctrls.tree.set_column_clip_content(0, true)

	$Tree.item_selected.connect(_on_tree_item_selected)

	if(get_parent() == get_tree().root):
		_test_running_setup()

func _test_running_setup():
	load_json_file('user://.gut_editor.json')


func _on_tree_item_selected():
	var item = _ctrls.tree.get_selected()
	var item_meta = item.get_metadata(0)
	var item_type = null

	# Only select the left side of the tree item, cause I like that better.
	# you can still click the right, but only the left gets highlighted.
	if(item.is_selected(1)):
		item.deselect(1)
		item.select(0)

	if(item_meta == null):
		return
	else:
		item_type = item_meta.type

	var script_path = '';
	var line = -1;
	var test_name = ''
	var inner_class = ''

	if(item_type == 'test'):
		var s_item = item.get_parent()
		script_path = s_item.get_metadata(0)['path']
		inner_class = s_item.get_metadata(0)['inner_class']
		line = -1
		test_name = item.get_text(0)
	elif(item_type == 'assert'):
		var s_item = item.get_parent().get_parent()
		script_path = s_item.get_metadata(0)['path']
		inner_class = s_item.get_metadata(0)['inner_class']
		line = _get_line_number_from_assert_msg(item.get_text(0))
		test_name = item.get_parent().get_text(0)
	elif(item_type == 'script'):
		script_path = item.get_metadata(0)['path']
		if(item.get_parent() != _root):
			inner_class = item.get_text(0)
		line = -1
		test_name = ''
	else:
		return

	item_selected.emit(script_path, inner_class, test_name, line)


func _get_line_number_from_assert_msg(msg):
	var line = -1
	if(msg.find('at line') > 0):
		line = msg.split("at line")[-1].split(" ")[-1].to_int()
	return line


func _get_path_and_inner_class_name_from_test_path(path):
	var to_return = {
		path = '',
		inner_class = ''
	}

	to_return.path = path
	if !path.ends_with('.gd'):
		var loc = path.find('.gd')
		to_return.inner_class = path.split('.')[-1]
		to_return.path = path.substr(0, loc + 3)
	return to_return


func _find_script_item_with_path(path):
	var items = _root.get_children()
	var to_return = null

	var idx = 0
	while(idx < items.size() and to_return == null):
		var item = items[idx]
		if(item.get_metadata(0).path == path):
			to_return = item
		else:
			idx += 1

	return to_return


func _add_script_tree_item(script_path, script_json):
	var path_info = _get_path_and_inner_class_name_from_test_path(script_path)
	var item_text = script_path
	var parent = _root

	if(path_info.inner_class != ''):
		parent = _find_script_item_with_path(path_info.path)
		item_text = path_info.inner_class
		if(parent == null):
			parent = _add_script_tree_item(path_info.path, {})

		parent.get_metadata(0).inner_tests += script_json['props']['tests']
		parent.get_metadata(0).inner_passing += script_json['props']['tests']
		parent.get_metadata(0).inner_passing -= script_json['props']['failures']
		parent.get_metadata(0).inner_passing -= script_json['props']['pending']

		var total_text = str("All ", parent.get_metadata(0).inner_tests, " passed")
		if(parent.get_metadata(0).inner_passing != parent.get_metadata(0).inner_tests):
			total_text = str(parent.get_metadata(0).inner_passing, '/', parent.get_metadata(0).inner_tests, ' passed.')
		parent.set_text(1, total_text)

	var item = _ctrls.tree.create_item(parent)
	item.set_text(0, item_text)
	var meta = {
		"type":"script",
		"path":path_info.path,
		"inner_class":path_info.inner_class,
		"json":script_json,
		"inner_passing":0,
		"inner_tests":0
	}
	item.set_metadata(0, meta)
	item.set_custom_bg_color(1, _col_1_bg_color)

	return item


func _add_assert_item(text, icon, parent_item):
	# print('        * adding assert')
	var assert_item = _ctrls.tree.create_item(parent_item)
	assert_item.set_icon_max_width(0, _max_icon_width)
	assert_item.set_text(0, text)
	assert_item.set_metadata(0, {"type":"assert"})
	assert_item.set_icon(0, icon)
	assert_item.set_custom_bg_color(1, _col_1_bg_color)

	return assert_item


func _add_test_tree_item(test_name, test_json, script_item):
	# print('    * adding test ', test_name)
	var no_orphans_to_show = !_show_orphans or (_show_orphans and test_json.orphans == 0)
	if(_hide_passing and test_json['status'] == 'pass' and no_orphans_to_show):
		return

	var item = _ctrls.tree.create_item(script_item)
	var status = test_json['status']
	var meta = {"type":"test", "json":test_json}

	item.set_text(0, test_name)
	item.set_text(1, status)
	item.set_text_alignment(1, HORIZONTAL_ALIGNMENT_RIGHT)
	item.set_custom_bg_color(1, _col_1_bg_color)

	item.set_metadata(0, meta)
	item.set_icon_max_width(0, _max_icon_width)

	var orphan_text = 'orphans'
	if(test_json.orphans == 1):
		orphan_text = 'orphan'
	orphan_text = str(test_json.orphans, ' ', orphan_text)

	if(status == 'pass' and no_orphans_to_show):
		item.set_icon(0, _icons.green)
	elif(status == 'pass' and !no_orphans_to_show):
		item.set_icon(0, _icons.yellow)
		item.set_text(1, orphan_text)
	elif(status == 'fail'):
		item.set_icon(0, _icons.red)
	else:
		item.set_icon(0, _icons.yellow)

	if(!_hide_passing):
		for passing in test_json.passing:
			_add_assert_item('pass: ' + passing, _icons.green, item)

	for failure in test_json.failing:
		_add_assert_item("fail:  " + failure.replace("\n", ''), _icons.red, item)

	for pending in test_json.pending:
		_add_assert_item("pending:  " + pending.replace("\n", ''), _icons.yellow, item)

	if(status != 'pass' and !no_orphans_to_show):
		_add_assert_item(orphan_text, _icons.yellow, item)

	return item


func _add_script_to_tree(key, script_json):
	var tests = script_json['tests']
	var test_keys = tests.keys()
	var s_item = _add_script_tree_item(key, script_json)
	var bad_count = 0

	for test_key in test_keys:
		var t_item = _add_test_tree_item(test_key, tests[test_key], s_item)
		if(tests[test_key].status != 'pass'):
			bad_count += 1
		elif(t_item != null):
			t_item.collapsed = true

	if(s_item.get_children().size() == 0):
		s_item.free()
	else:
		var total_text = str('All ', test_keys.size(), ' passed')
		if(bad_count == 0):
			s_item.collapsed = true
		else:
			total_text = str(test_keys.size() - bad_count, '/', test_keys.size(), ' passed')
		s_item.set_text(1, total_text)


func _free_childless_scripts():
	var items = _root.get_children()
	for item in items:
		var next_item = item.get_next()
		if(item.get_children().size() == 0):
			item.free()
		item = next_item


func _show_all_passed():
	if(_root.get_children().size() == 0):
		add_centered_text('Everything passed!')


func _load_result_tree(j):
	var scripts = j['test_scripts']['scripts']
	var script_keys = scripts.keys()
	# if we made it here, the json is valid and we did something, otherwise the
	# 'nothing to see here' should be visible.
	clear_centered_text()

	var add_count = 0
	for key in script_keys:
		if(scripts[key]['props']['tests'] > 0):
			add_count += 1
			_add_script_to_tree(key, scripts[key])

	_free_childless_scripts()
	if(add_count == 0):
		add_centered_text('Nothing was run')
	else:
		_show_all_passed()


# -------------------
# Public
# -------------------
func load_json_file(path):
	var file = FileAccess.open(path, FileAccess.READ)
	var text = ''
	if(file != null):
		text = file.get_as_text()

	if(text != ''):
		var test_json_conv = JSON.new()
		var result = test_json_conv.parse(text)
		if(result != OK):
			add_centered_text(str(path, " has invalid json in it \n",
				'Error ', result, "@", test_json_conv.get_error_line(), "\n",
				test_json_conv.get_error_message()))
			return

		var data = test_json_conv.get_data()
		load_json_results(data)
	else:
		add_centered_text(str(path, ' was empty or does not exist.'))


func load_json_results(j):
	clear()
	_load_result_tree(j)


func clear():
	_ctrls.tree.clear()
	_root = _ctrls.tree.create_item()


func set_summary_min_width(width):
	_ctrls.tree.set_column_custom_minimum_width(1, width)


func add_centered_text(t):
	_ctrls.lbl_overlay.visible = true
	_ctrls.lbl_overlay.text = t


func clear_centered_text():
	_ctrls.lbl_overlay.visible = false
	_ctrls.lbl_overlay.text = ''


func collapse_all():
	set_collapsed_on_all(_root, true)


func expand_all():
	set_collapsed_on_all(_root, false)


func set_collapsed_on_all(item, value):
	item.set_collapsed_recursive(value)
	if(item == _root and value):
		item.set_collapsed(false)


func get_selected():
	return _ctrls.tree.get_selected()


=====================================
FILE: ./addons/gut/gui/GutBottomPanel.gd
=====================================
@tool
extends Control

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var TestScript = load('res://addons/gut/test.gd')
var GutConfigGui = load('res://addons/gut/gui/gut_config_gui.gd')
var ScriptTextEditors = load('res://addons/gut/gui/script_text_editor_controls.gd')


var _interface = null;
var _is_running = false;
var _gut_config = load('res://addons/gut/gut_config.gd').new()
var _gut_config_gui = null
var _gut_plugin = null
var _light_color = Color(0, 0, 0, .5)
var _panel_button = null
var _last_selected_path = null
var _user_prefs = null


@onready var _ctrls = {
	output = $layout/RSplit/CResults/TabBar/OutputText.get_rich_text_edit(),
	output_ctrl = $layout/RSplit/CResults/TabBar/OutputText,
	run_button = $layout/ControlBar/RunAll,
	shortcuts_button = $layout/ControlBar/Shortcuts,

	settings_button = $layout/ControlBar/Settings,
	run_results_button = $layout/ControlBar/RunResultsBtn,
	output_button = $layout/ControlBar/OutputBtn,

	settings = $layout/RSplit/sc/Settings,
	shortcut_dialog = $BottomPanelShortcuts,
	light = $layout/RSplit/CResults/ControlBar/Light3D,
	results = {
		bar = $layout/RSplit/CResults/ControlBar,
		passing = $layout/RSplit/CResults/ControlBar/Passing/value,
		failing = $layout/RSplit/CResults/ControlBar/Failing/value,
		pending = $layout/RSplit/CResults/ControlBar/Pending/value,
		errors = $layout/RSplit/CResults/ControlBar/Errors/value,
		warnings = $layout/RSplit/CResults/ControlBar/Warnings/value,
		orphans = $layout/RSplit/CResults/ControlBar/Orphans/value
	},
	run_at_cursor = $layout/ControlBar/RunAtCursor,
	run_results = $layout/RSplit/CResults/TabBar/RunResults
}

func _init():
	pass


func _ready():
	GutEditorGlobals.create_temp_directory()

	_user_prefs = GutEditorGlobals.user_prefs
	_gut_config_gui = GutConfigGui.new(_ctrls.settings)

	_ctrls.results.bar.connect('draw', _on_results_bar_draw.bind(_ctrls.results.bar))
	hide_settings(!_ctrls.settings_button.button_pressed)

	_gut_config.load_options(GutEditorGlobals.editor_run_gut_config_path)
	_gut_config_gui.set_options(_gut_config.options)
	_apply_options_to_controls()

	_ctrls.shortcuts_button.icon = get_theme_icon('Shortcut', 'EditorIcons')
	_ctrls.settings_button.icon = get_theme_icon('Tools', 'EditorIcons')
	_ctrls.run_results_button.icon = get_theme_icon('AnimationTrackGroup', 'EditorIcons') # Tree
	_ctrls.output_button.icon = get_theme_icon('Font', 'EditorIcons')

	_ctrls.run_results.set_output_control(_ctrls.output_ctrl)

	var check_import = load('res://addons/gut/images/red.png')
	if(check_import == null):
		_ctrls.run_results.add_centered_text("GUT got some new images that are not imported yet.  Please restart Godot.")
		print('GUT got some new images that are not imported yet.  Please restart Godot.')
	else:
		_ctrls.run_results.add_centered_text("Let's run some tests!")


func _apply_options_to_controls():
	hide_settings(_user_prefs.hide_settings.value)
	hide_result_tree(_user_prefs.hide_result_tree.value)
	hide_output_text(_user_prefs.hide_output_text.value)
	_ctrls.run_results.set_show_orphans(!_gut_config.options.hide_orphans)


func _process(delta):
	if(_is_running):
		if(!_interface.is_playing_scene()):
			_is_running = false
			_ctrls.output_ctrl.add_text("\ndone")
			load_result_output()
			_gut_plugin.make_bottom_panel_item_visible(self)

# ---------------
# Private
# ---------------

func load_shortcuts():
	_ctrls.shortcut_dialog.load_shortcuts()
	_apply_shortcuts()


func _is_test_script(script):
	var from = script.get_base_script()
	while(from and from.resource_path != 'res://addons/gut/test.gd'):
		from = from.get_base_script()

	return from != null


func _show_errors(errs):
	_ctrls.output_ctrl.clear()
	var text = "Cannot run tests, you have a configuration error:\n"
	for e in errs:
		text += str('*  ', e, "\n")
	text += "Check your settings ----->"
	_ctrls.output_ctrl.add_text(text)
	hide_output_text(false)
	hide_settings(false)


func _save_config():
	_user_prefs.hide_settings.value = !_ctrls.settings_button.button_pressed
	_user_prefs.hide_result_tree.value = !_ctrls.run_results_button.button_pressed
	_user_prefs.hide_output_text.value = !_ctrls.output_button.button_pressed
	_user_prefs.save_it()

	_gut_config.options = _gut_config_gui.get_options(_gut_config.options)
	var w_result = _gut_config.write_options(GutEditorGlobals.editor_run_gut_config_path)
	if(w_result != OK):
		push_error(str('Could not write options to ', GutEditorGlobals.editor_run_gut_config_path, ': ', w_result))
	else:
		_gut_config_gui.mark_saved()


func _run_tests():
	GutEditorGlobals.create_temp_directory()

	var issues = _gut_config_gui.get_config_issues()
	if(issues.size() > 0):
		_show_errors(issues)
		return

	write_file(GutEditorGlobals.editor_run_bbcode_results_path, 'Run in progress')
	_save_config()
	_apply_options_to_controls()

	_ctrls.output_ctrl.clear()
	_ctrls.run_results.clear()
	_ctrls.run_results.add_centered_text('Running...')

	_interface.play_custom_scene('res://addons/gut/gui/run_from_editor.tscn')
	_is_running = true
	_ctrls.output_ctrl.add_text('Running...')


func _apply_shortcuts():
	_ctrls.run_button.shortcut = _ctrls.shortcut_dialog.get_run_all()

	_ctrls.run_at_cursor.get_script_button().shortcut = \
		_ctrls.shortcut_dialog.get_run_current_script()
	_ctrls.run_at_cursor.get_inner_button().shortcut = \
		_ctrls.shortcut_dialog.get_run_current_inner()
	_ctrls.run_at_cursor.get_test_button().shortcut = \
		_ctrls.shortcut_dialog.get_run_current_test()

	_panel_button.shortcut = _ctrls.shortcut_dialog.get_panel_button()


func _run_all():
	_gut_config.options.selected = null
	_gut_config.options.inner_class = null
	_gut_config.options.unit_test_name = null

	_run_tests()


# ---------------
# Events
# ---------------
func _on_results_bar_draw(bar):
	bar.draw_rect(Rect2(Vector2(0, 0), bar.size), Color(0, 0, 0, .2))


func _on_Light_draw():
	var l = _ctrls.light
	l.draw_circle(Vector2(l.size.x / 2, l.size.y / 2), l.size.x / 2, _light_color)


func _on_editor_script_changed(script):
	if(script):
		set_current_script(script)


func _on_RunAll_pressed():
	_run_all()


func _on_Shortcuts_pressed():
	_ctrls.shortcut_dialog.popup_centered()

func _on_bottom_panel_shortcuts_visibility_changed():
	_apply_shortcuts()
	_ctrls.shortcut_dialog.save_shortcuts()

func _on_RunAtCursor_run_tests(what):
	_gut_config.options.selected = what.script
	_gut_config.options.inner_class = what.inner_class
	_gut_config.options.unit_test_name = what.test_method

	_run_tests()


func _on_Settings_pressed():
	hide_settings(!_ctrls.settings_button.button_pressed)
	_save_config()


func _on_OutputBtn_pressed():
	hide_output_text(!_ctrls.output_button.button_pressed)
	_save_config()


func _on_RunResultsBtn_pressed():
	hide_result_tree(! _ctrls.run_results_button.button_pressed)
	_save_config()


# Currently not used, but will be when I figure out how to put
# colors into the text results
func _on_UseColors_pressed():
	pass

# ---------------
# Public
# ---------------
func hide_result_tree(should):
	_ctrls.run_results.visible = !should
	_ctrls.run_results_button.button_pressed = !should


func hide_settings(should):
	var s_scroll = _ctrls.settings.get_parent()
	s_scroll.visible = !should

	# collapse only collapses the first control, so we move
	# settings around to be the collapsed one
	if(should):
		s_scroll.get_parent().move_child(s_scroll, 0)
	else:
		s_scroll.get_parent().move_child(s_scroll, 1)

	$layout/RSplit.collapsed = should
	_ctrls.settings_button.button_pressed = !should


func hide_output_text(should):
	$layout/RSplit/CResults/TabBar/OutputText.visible = !should
	_ctrls.output_button.button_pressed = !should


func load_result_output():
	_ctrls.output_ctrl.load_file(GutEditorGlobals.editor_run_bbcode_results_path)

	var summary = get_file_as_text(GutEditorGlobals.editor_run_json_results_path)
	var test_json_conv = JSON.new()
	if (test_json_conv.parse(summary) != OK):
		return
	var results = test_json_conv.get_data()

	_ctrls.run_results.load_json_results(results)

	var summary_json = results['test_scripts']['props']
	_ctrls.results.passing.text = str(summary_json.passing)
	_ctrls.results.passing.get_parent().visible = true

	_ctrls.results.failing.text = str(summary_json.failures)
	_ctrls.results.failing.get_parent().visible = true

	_ctrls.results.pending.text = str(summary_json.pending)
	_ctrls.results.pending.get_parent().visible = _ctrls.results.pending.text != '0'

	_ctrls.results.errors.text = str(summary_json.errors)
	_ctrls.results.errors.get_parent().visible = _ctrls.results.errors.text != '0'

	_ctrls.results.warnings.text = str(summary_json.warnings)
	_ctrls.results.warnings.get_parent().visible = _ctrls.results.warnings.text != '0'

	_ctrls.results.orphans.text = str(summary_json.orphans)
	_ctrls.results.orphans.get_parent().visible = _ctrls.results.orphans.text != '0' and !_gut_config.options.hide_orphans

	if(summary_json.tests == 0):
		_light_color = Color(1, 0, 0, .75)
	elif(summary_json.failures != 0):
		_light_color = Color(1, 0, 0, .75)
	elif(summary_json.pending != 0):
		_light_color = Color(1, 1, 0, .75)
	else:
		_light_color = Color(0, 1, 0, .75)
	_ctrls.light.visible = true
	_ctrls.light.queue_redraw()


func set_current_script(script):
	if(script):
		if(_is_test_script(script)):
			var file = script.resource_path.get_file()
			_last_selected_path = script.resource_path.get_file()
			_ctrls.run_at_cursor.activate_for_script(script.resource_path)


func set_interface(value):
	_interface = value
	_interface.get_script_editor().connect("editor_script_changed",Callable(self,'_on_editor_script_changed'))

	var ste = ScriptTextEditors.new(_interface.get_script_editor())
	_ctrls.run_results.set_interface(_interface)
	_ctrls.run_results.set_script_text_editors(ste)
	_ctrls.run_at_cursor.set_script_text_editors(ste)
	set_current_script(_interface.get_script_editor().get_current_script())


func set_plugin(value):
	_gut_plugin = value


func set_panel_button(value):
	_panel_button = value

# ------------------------------------------------------------------------------
# Write a file.
# ------------------------------------------------------------------------------
func write_file(path, content):
	var f = FileAccess.open(path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
	f = null;

	return FileAccess.get_open_error()


# ------------------------------------------------------------------------------
# Returns the text of a file or an empty string if the file could not be opened.
# ------------------------------------------------------------------------------
func get_file_as_text(path):
	var to_return = ''
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	f = null
	return to_return


# ------------------------------------------------------------------------------
# return if_null if value is null otherwise return value
# ------------------------------------------------------------------------------
func nvl(value, if_null):
	if(value == null):
		return if_null
	else:
		return value


=====================================
FILE: ./addons/gut/gui/ShortcutButton.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://sfb1fw8j6ufu"]

[ext_resource type="Script" path="res://addons/gut/gui/ShortcutButton.gd" id="1"]

[node name="ShortcutButton" type="Control"]
custom_minimum_size = Vector2(210, 30)
layout_mode = 3
anchor_right = 0.123
anchor_bottom = 0.04
offset_right = 68.304
offset_bottom = 6.08
script = ExtResource("1")

[node name="Layout" type="HBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="lblShortcut" type="Label" parent="Layout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 7
text = "<None>"
horizontal_alignment = 2

[node name="CenterContainer" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(10, 0)
layout_mode = 2

[node name="SetButton" type="Button" parent="Layout"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Set"

[node name="SaveButton" type="Button" parent="Layout"]
visible = false
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Save"

[node name="CancelButton" type="Button" parent="Layout"]
visible = false
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Cancel"

[node name="ClearButton" type="Button" parent="Layout"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
text = "Clear"

[connection signal="pressed" from="Layout/SetButton" to="." method="_on_SetButton_pressed"]
[connection signal="pressed" from="Layout/SaveButton" to="." method="_on_SaveButton_pressed"]
[connection signal="pressed" from="Layout/CancelButton" to="." method="_on_CancelButton_pressed"]
[connection signal="pressed" from="Layout/ClearButton" to="." method="_on_ClearButton_pressed"]


=====================================
FILE: ./addons/gut/gui/panel_controls.gd
=====================================
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class BaseGutPanelControl:
	extends HBoxContainer
	var label = Label.new()
	var _lbl_unsaved = Label.new()
	var _lbl_invalid = Label.new()

	var value = null:
		get: return get_value()
		set(val): set_value(val)

	signal changed

	func _init(title, val, hint=""):
		size_flags_horizontal = SIZE_EXPAND_FILL
		mouse_filter = MOUSE_FILTER_PASS

		label.size_flags_horizontal = label.SIZE_EXPAND_FILL
		label.mouse_filter = label.MOUSE_FILTER_STOP
		add_child(label)

		_lbl_unsaved.text = '*'
		_lbl_unsaved.visible = false
		add_child(_lbl_unsaved)

		_lbl_invalid.text = '!'
		_lbl_invalid.visible = false
		add_child(_lbl_invalid)

		label.text = title
		label.tooltip_text = hint


	func mark_unsaved(is_it=true):
		_lbl_unsaved.visible = is_it


	func mark_invalid(is_it):
		_lbl_invalid.visible = is_it

	# -- Virtual --
	#
	# value_ctrl (all should declare the value_ctrl)
	#
	func set_value(value):
		pass

	func get_value():
		pass


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class NumberControl:
	extends BaseGutPanelControl

	var value_ctrl = SpinBox.new()

	func _init(title, val, v_min, v_max, hint=""):
		super._init(title, val, hint)

		value_ctrl.value = val
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.min_value = v_min
		value_ctrl.max_value = v_max
		value_ctrl.value_changed.connect(_on_value_changed)
		value_ctrl.select_all_on_focus = true
		add_child(value_ctrl)

	func _on_value_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.value

	func set_value(val):
		value_ctrl.value = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class StringControl:
	extends BaseGutPanelControl

	var value_ctrl = LineEdit.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.text = val
		value_ctrl.text_changed.connect(_on_text_changed)
		value_ctrl.select_all_on_focus = true
		add_child(value_ctrl)

	func _on_text_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class BooleanControl:
	extends BaseGutPanelControl

	var value_ctrl = CheckBox.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		value_ctrl.button_pressed = val
		value_ctrl.toggled.connect(_on_button_toggled)
		add_child(value_ctrl)

	func _on_button_toggled(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.button_pressed

	func set_value(val):
		value_ctrl.button_pressed = val


# ------------------------------------------------------------------------------
# value is "selected" and is gettable and settable
# text is the text value of the selected item, it is gettable only
# ------------------------------------------------------------------------------
class SelectControl:
	extends BaseGutPanelControl

	var value_ctrl = OptionButton.new()

	var text = '' :
		get: return value_ctrl.get_item_text(value_ctrl.selected)
		set(val): pass

	func _init(title, val, choices, hint=""):
		super._init(title, val, hint)

		var select_idx = 0
		for i in range(choices.size()):
			value_ctrl.add_item(choices[i])
			if(val == choices[i]):
				select_idx = i
		value_ctrl.selected = select_idx
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.item_selected.connect(_on_item_selected)
		add_child(value_ctrl)

	func _on_item_selected(idx):
		changed.emit()

	func get_value():
		return value_ctrl.selected

	func set_value(val):
		value_ctrl.selected = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class ColorControl:
	extends BaseGutPanelControl

	var value_ctrl = ColorPickerButton.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.color = val
		add_child(value_ctrl)

	func get_value():
		return value_ctrl.color

	func set_value(val):
		value_ctrl.color = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class DirectoryControl:
	extends BaseGutPanelControl

	var value_ctrl := LineEdit.new()
	var dialog := FileDialog.new()
	var enabled_button = CheckButton.new()

	var _btn_dir := Button.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		label.size_flags_horizontal = Control.SIZE_SHRINK_BEGIN

		_btn_dir.text = '...'
		_btn_dir.pressed.connect(_on_dir_button_pressed)

		value_ctrl.text = val
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.select_all_on_focus = true
		value_ctrl.text_changed.connect(_on_value_changed)

		dialog.file_mode = dialog.FILE_MODE_OPEN_DIR
		dialog.unresizable = false
		dialog.dir_selected.connect(_on_selected)
		dialog.file_selected.connect(_on_selected)

		enabled_button.button_pressed = true
		enabled_button.visible = false

		add_child(enabled_button)
		add_child(value_ctrl)
		add_child(_btn_dir)
		add_child(dialog)

	func _update_display():
		var is_empty = value_ctrl.text == ''
		enabled_button.button_pressed = !is_empty
		enabled_button.disabled = is_empty


	func _ready():
		if(Engine.is_editor_hint()):
			dialog.size = Vector2(1000, 700)
		else:
			dialog.size = Vector2(500, 350)
		_update_display()

	func _on_value_changed(new_text):
		_update_display()

	func _on_selected(path):
		value_ctrl.text = path
		_update_display()

	func _on_dir_button_pressed():
		dialog.current_dir = value_ctrl.text
		dialog.popup_centered()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val


# ------------------------------------------------------------------------------
# Features:
# 	Buttons to pick res://, user://, or anywhere on the OS.
# ------------------------------------------------------------------------------
class FileDialogSuperPlus:
	extends FileDialog

	var show_diretory_types = true :
		set(val) :
			show_diretory_types = val
			_update_display()

	var show_res = true :
		set(val) :
			show_res = val
			_update_display()

	var show_user = true :
		set(val) :
			show_user = val
			_update_display()

	var show_os = true :
		set(val) :
			show_os = val
			_update_display()

	var _dir_type_hbox = null
	var _btn_res = null
	var _btn_user = null
	var _btn_os = null

	func _ready():
		_init_controls()
		_update_display()


	func _init_controls():
		_dir_type_hbox = HBoxContainer.new()

		_btn_res = Button.new()
		_btn_user = Button.new()
		_btn_os = Button.new()
		var spacer1 = CenterContainer.new()
		spacer1.size_flags_horizontal = spacer1.SIZE_EXPAND_FILL
		var spacer2 = spacer1.duplicate()

		_dir_type_hbox.add_child(spacer1)
		_dir_type_hbox.add_child(_btn_res)
		_dir_type_hbox.add_child(_btn_user)
		_dir_type_hbox.add_child(_btn_os)
		_dir_type_hbox.add_child(spacer2)

		_btn_res.text = 'res://'
		_btn_user.text = 'user://'
		_btn_os.text = '  OS  '

		get_vbox().add_child(_dir_type_hbox)
		get_vbox().move_child(_dir_type_hbox, 0)

		_btn_res.pressed.connect(func(): access = ACCESS_RESOURCES)
		_btn_user.pressed.connect(func(): access = ACCESS_USERDATA)
		_btn_os.pressed.connect(func(): access = ACCESS_FILESYSTEM)


	func _update_display():
		if(is_inside_tree()):
			_dir_type_hbox.visible = show_diretory_types
			_btn_res.visible = show_res
			_btn_user.visible = show_user
			_btn_os.visible = show_os


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class SaveLoadControl:
	extends BaseGutPanelControl

	var btn_load = Button.new()
	var btn_save = Button.new()

	var dlg_load := FileDialogSuperPlus.new()
	var dlg_save := FileDialogSuperPlus.new()

	signal save_path_chosen(path)
	signal load_path_chosen(path)

	func _init(title, val, hint):
		super._init(title, val, hint)

		btn_load.text = "Load"
		btn_load.custom_minimum_size.x = 100
		btn_load.pressed.connect(_on_load_pressed)
		add_child(btn_load)

		btn_save.text = "Save As"
		btn_save.custom_minimum_size.x = 100
		btn_save.pressed.connect(_on_save_pressed)
		add_child(btn_save)

		dlg_load.file_mode = dlg_load.FILE_MODE_OPEN_FILE
		dlg_load.unresizable = false
		dlg_load.dir_selected.connect(_on_load_selected)
		dlg_load.file_selected.connect(_on_load_selected)
		add_child(dlg_load)

		dlg_save.file_mode = dlg_save.FILE_MODE_SAVE_FILE
		dlg_save.unresizable = false
		dlg_save.dir_selected.connect(_on_save_selected)
		dlg_save.file_selected.connect(_on_save_selected)
		add_child(dlg_save)


	func _ready():
		if(Engine.is_editor_hint()):
			dlg_load.size = Vector2(1000, 700)
			dlg_save.size = Vector2(1000, 700)
		else:
			dlg_load.size = Vector2(500, 350)
			dlg_save.size = Vector2(500, 350)

	func _on_load_selected(path):
		load_path_chosen.emit(path)

	func _on_save_selected(path):
		save_path_chosen.emit(path)

	func _on_load_pressed():
		dlg_load.popup_centered()

	func _on_save_pressed():
		dlg_save.popup_centered()

# ------------------------------------------------------------------------------
# This one was never used in gut_config_gui...but I put some work into it and
# I'm a sucker for that kinda thing.  Delete this when you get tired of looking
# at it.
# ------------------------------------------------------------------------------
# class Vector2Ctrl:
# 	extends VBoxContainer

# 	var value = Vector2(-1, -1) :
# 		get:
# 			return get_value()
# 		set(val):
# 			set_value(val)
# 	var disabled = false :
# 		get:
# 			return get_disabled()
# 		set(val):
# 			set_disabled(val)
# 	var x_spin = SpinBox.new()
# 	var y_spin = SpinBox.new()

# 	func _init():
# 		add_child(_make_one('x:  ', x_spin))
# 		add_child(_make_one('y:  ', y_spin))

# 	func _make_one(txt, spinner):
# 		var hbox = HBoxContainer.new()
# 		var lbl = Label.new()
# 		lbl.text = txt
# 		hbox.add_child(lbl)
# 		hbox.add_child(spinner)
# 		spinner.min_value = -1
# 		spinner.max_value = 10000
# 		spinner.size_flags_horizontal = spinner.SIZE_EXPAND_FILL
# 		return hbox

# 	func set_value(v):
# 		if(v != null):
# 			x_spin.value = v[0]
# 			y_spin.value = v[1]

# 	# Returns array instead of vector2 b/c that is what is stored in
# 	# in the dictionary and what is expected everywhere else.
# 	func get_value():
# 		return [x_spin.value, y_spin.value]

# 	func set_disabled(should):
# 		get_parent().visible = !should
# 		x_spin.visible = !should
# 		y_spin.visible = !should

# 	func get_disabled():
# 		pass


=====================================
FILE: ./addons/gut/gui/run_from_editor.gd
=====================================
# ------------------------------------------------------------------------------
# This is the entry point when running tests from the editor.
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
extends Node2D

var GutLoader : Object

func _init() -> void:
	GutLoader = load("res://addons/gut/gut_loader.gd")


@warning_ignore("unsafe_method_access")
func _ready() -> void:
	var runner : Node = load("res://addons/gut/gui/GutRunner.tscn").instantiate()
	add_child(runner)
	runner.run_from_editor()
	GutLoader.restore_ignore_addons()


=====================================
FILE: ./addons/gut/gui/Settings.tscn
=====================================
[gd_scene format=3 uid="uid://cvvvtsah38l0e"]

[node name="Settings" type="VBoxContainer"]
offset_right = 388.0
offset_bottom = 586.0
size_flags_horizontal = 3
size_flags_vertical = 3


=====================================
FILE: ./addons/gut/gui/gut_user_preferences.gd
=====================================
class GutEditorPref:
	var gut_pref_prefix = 'gut/'
	var pname = '__not_set__'
	var default = null
	var value = '__not_set__'
	var _settings = null

	func _init(n, d, s):
		pname = n
		default = d
		_settings = s
		load_it()

	func _prefstr():
		var to_return = str(gut_pref_prefix, pname)
		return to_return

	func save_it():
		_settings.set_setting(_prefstr(), value)

	func load_it():
		if(_settings.has_setting(_prefstr())):
			value = _settings.get_setting(_prefstr())
		else:
			value = default

	func erase():
		_settings.erase(_prefstr())


const EMPTY = '-- NOT_SET --'

# -- Editor ONLY Settings --
var output_font_name = null
var output_font_size = null
var hide_result_tree = null
var hide_output_text = null
var hide_settings = null
var use_colors = null	# ? might be output panel

# var shortcut_run_all = null
# var shortcut_run_current_script = null
# var shortcut_run_current_inner = null
# var shortcut_run_current_test = null
# var shortcut_panel_button = null


func _init(editor_settings):
	output_font_name = GutEditorPref.new('output_font_name', 'CourierPrime', editor_settings)
	output_font_size = GutEditorPref.new('output_font_size', 30, editor_settings)
	hide_result_tree = GutEditorPref.new('hide_result_tree', false, editor_settings)
	hide_output_text = GutEditorPref.new('hide_output_text', false, editor_settings)
	hide_settings = GutEditorPref.new('hide_settings', false, editor_settings)
	use_colors = GutEditorPref.new('use_colors', true, editor_settings)

	# shortcut_run_all = GutEditorPref.new('shortcut_run_all', EMPTY, editor_settings)
	# shortcut_run_current_script = GutEditorPref.new('shortcut_run_current_script', EMPTY, editor_settings)
	# shortcut_run_current_inner = GutEditorPref.new('shortcut_run_current_inner', EMPTY, editor_settings)
	# shortcut_run_current_test = GutEditorPref.new('shortcut_run_current_test', EMPTY, editor_settings)
	# shortcut_panel_button = GutEditorPref.new('shortcut_panel_button', EMPTY, editor_settings)

func save_it():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.save_it()


func load_it():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.load_it()


func erase_all():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.erase()

=====================================
FILE: ./addons/gut/gui/GutBottomPanel.tscn
=====================================
[gd_scene load_steps=10 format=3 uid="uid://b3bostcslstem"]

[ext_resource type="Script" path="res://addons/gut/gui/GutBottomPanel.gd" id="1"]
[ext_resource type="PackedScene" uid="uid://bsk32dh41b4gs" path="res://addons/gut/gui/BottomPanelShortcuts.tscn" id="2"]
[ext_resource type="PackedScene" uid="uid://0yunjxtaa8iw" path="res://addons/gut/gui/RunAtCursor.tscn" id="3"]
[ext_resource type="Texture2D" uid="uid://cr6tvdv0ve6cv" path="res://addons/gut/gui/play.png" id="4"]
[ext_resource type="PackedScene" uid="uid://4gyyn12um08h" path="res://addons/gut/gui/RunResults.tscn" id="5"]
[ext_resource type="PackedScene" uid="uid://bqmo4dj64c7yl" path="res://addons/gut/gui/OutputText.tscn" id="6"]

[sub_resource type="Shortcut" id="9"]

[sub_resource type="Image" id="Image_4maas"]
data = {
"data": PackedByteArray(255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 94, 94, 127, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 231, 255, 94, 94, 54, 255, 94, 94, 57, 255, 93, 93, 233, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 93, 93, 41, 255, 255, 255, 0, 255, 255, 255, 0, 255, 97, 97, 42, 255, 93, 93, 233, 255, 93, 93, 232, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 44, 255, 255, 255, 0, 255, 97, 97, 42, 255, 97, 97, 42, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 96, 96, 45, 255, 93, 93, 235, 255, 94, 94, 234, 255, 95, 95, 43, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 93, 93, 235, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 233, 255, 95, 95, 59, 255, 96, 96, 61, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 93, 93, 255, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0, 255, 255, 255, 0),
"format": "RGBA8",
"height": 16,
"mipmaps": false,
"width": 16
}

[sub_resource type="ImageTexture" id="ImageTexture_umaha"]
image = SubResource("Image_4maas")

[node name="GutBottomPanel" type="Control"]
custom_minimum_size = Vector2(250, 250)
layout_mode = 3
anchor_left = -0.0025866
anchor_top = -0.00176575
anchor_right = 0.997413
anchor_bottom = 0.998234
offset_left = 2.64868
offset_top = 1.05945
offset_right = 2.64862
offset_bottom = 1.05945
script = ExtResource("1")

[node name="layout" type="VBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0

[node name="ControlBar" type="HBoxContainer" parent="layout"]
layout_mode = 2

[node name="RunAll" type="Button" parent="layout/ControlBar"]
layout_mode = 2
size_flags_vertical = 11
shortcut = SubResource("9")
text = "Run All"
icon = ExtResource("4")

[node name="Label" type="Label" parent="layout/ControlBar"]
layout_mode = 2
mouse_filter = 1
text = "Current:  "

[node name="RunAtCursor" parent="layout/ControlBar" instance=ExtResource("3")]
layout_mode = 2

[node name="CenterContainer2" type="CenterContainer" parent="layout/ControlBar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Sep1" type="ColorRect" parent="layout/ControlBar"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="RunResultsBtn" type="Button" parent="layout/ControlBar"]
layout_mode = 2
toggle_mode = true
icon = SubResource("ImageTexture_umaha")

[node name="OutputBtn" type="Button" parent="layout/ControlBar"]
layout_mode = 2
toggle_mode = true
icon = SubResource("ImageTexture_umaha")

[node name="Settings" type="Button" parent="layout/ControlBar"]
layout_mode = 2
toggle_mode = true
icon = SubResource("ImageTexture_umaha")

[node name="Sep2" type="ColorRect" parent="layout/ControlBar"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="Shortcuts" type="Button" parent="layout/ControlBar"]
layout_mode = 2
size_flags_vertical = 11
icon = SubResource("ImageTexture_umaha")

[node name="RSplit" type="HSplitContainer" parent="layout"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
collapsed = true

[node name="sc" type="ScrollContainer" parent="layout/RSplit"]
visible = false
custom_minimum_size = Vector2(500, 2.08165e-12)
layout_mode = 2
size_flags_vertical = 3

[node name="Settings" type="VBoxContainer" parent="layout/RSplit/sc"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="CResults" type="VBoxContainer" parent="layout/RSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ControlBar" type="HBoxContainer" parent="layout/RSplit/CResults"]
layout_mode = 2

[node name="Sep2" type="ColorRect" parent="layout/RSplit/CResults/ControlBar"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="Light3D" type="Control" parent="layout/RSplit/CResults/ControlBar"]
custom_minimum_size = Vector2(30, 30)
layout_mode = 2

[node name="Passing" type="HBoxContainer" parent="layout/RSplit/CResults/ControlBar"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/RSplit/CResults/ControlBar/Passing"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/RSplit/CResults/ControlBar/Passing"]
layout_mode = 2
text = "Passing"

[node name="value" type="Label" parent="layout/RSplit/CResults/ControlBar/Passing"]
layout_mode = 2
text = "---"

[node name="Failing" type="HBoxContainer" parent="layout/RSplit/CResults/ControlBar"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/RSplit/CResults/ControlBar/Failing"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/RSplit/CResults/ControlBar/Failing"]
layout_mode = 2
text = "Failing"

[node name="value" type="Label" parent="layout/RSplit/CResults/ControlBar/Failing"]
layout_mode = 2
text = "---"

[node name="Pending" type="HBoxContainer" parent="layout/RSplit/CResults/ControlBar"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/RSplit/CResults/ControlBar/Pending"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/RSplit/CResults/ControlBar/Pending"]
layout_mode = 2
text = "Pending"

[node name="value" type="Label" parent="layout/RSplit/CResults/ControlBar/Pending"]
layout_mode = 2
text = "---"

[node name="Orphans" type="HBoxContainer" parent="layout/RSplit/CResults/ControlBar"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/RSplit/CResults/ControlBar/Orphans"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/RSplit/CResults/ControlBar/Orphans"]
layout_mode = 2
text = "Orphans"

[node name="value" type="Label" parent="layout/RSplit/CResults/ControlBar/Orphans"]
layout_mode = 2
text = "---"

[node name="Errors" type="HBoxContainer" parent="layout/RSplit/CResults/ControlBar"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/RSplit/CResults/ControlBar/Errors"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/RSplit/CResults/ControlBar/Errors"]
layout_mode = 2
text = "Errors"

[node name="value" type="Label" parent="layout/RSplit/CResults/ControlBar/Errors"]
layout_mode = 2
text = "---"

[node name="Warnings" type="HBoxContainer" parent="layout/RSplit/CResults/ControlBar"]
visible = false
layout_mode = 2

[node name="Sep" type="ColorRect" parent="layout/RSplit/CResults/ControlBar/Warnings"]
custom_minimum_size = Vector2(1, 2.08165e-12)
layout_mode = 2

[node name="label" type="Label" parent="layout/RSplit/CResults/ControlBar/Warnings"]
layout_mode = 2
text = "Warnings"

[node name="value" type="Label" parent="layout/RSplit/CResults/ControlBar/Warnings"]
layout_mode = 2
text = "---"

[node name="CenterContainer" type="CenterContainer" parent="layout/RSplit/CResults/ControlBar"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TabBar" type="HSplitContainer" parent="layout/RSplit/CResults"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="RunResults" parent="layout/RSplit/CResults/TabBar" instance=ExtResource("5")]
visible = false
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="OutputText" parent="layout/RSplit/CResults/TabBar" instance=ExtResource("6")]
visible = false
layout_mode = 2

[node name="BottomPanelShortcuts" parent="." instance=ExtResource("2")]
visible = false

[connection signal="pressed" from="layout/ControlBar/RunAll" to="." method="_on_RunAll_pressed"]
[connection signal="run_tests" from="layout/ControlBar/RunAtCursor" to="." method="_on_RunAtCursor_run_tests"]
[connection signal="pressed" from="layout/ControlBar/RunResultsBtn" to="." method="_on_RunResultsBtn_pressed"]
[connection signal="pressed" from="layout/ControlBar/OutputBtn" to="." method="_on_OutputBtn_pressed"]
[connection signal="pressed" from="layout/ControlBar/Settings" to="." method="_on_Settings_pressed"]
[connection signal="pressed" from="layout/ControlBar/Shortcuts" to="." method="_on_Shortcuts_pressed"]
[connection signal="draw" from="layout/RSplit/CResults/ControlBar/Light3D" to="." method="_on_Light_draw"]
[connection signal="visibility_changed" from="BottomPanelShortcuts" to="." method="_on_bottom_panel_shortcuts_visibility_changed"]


=====================================
FILE: ./addons/gut/gui/script_text_editor_controls.gd
=====================================
# Holds weakrefs to a ScriptTextEditor and related children nodes
# that might be useful.  Though the CodeEdit is really the only one, but
# since the tree may change, the first TextEdit under a CodeTextEditor is
# the one we use...so we hold a ref to the CodeTextEditor too.
class ScriptEditorControlRef:
	var _text_edit = null
	var _script_editor = null
	var _code_editor = null

	func _init(script_edit):
		_script_editor = weakref(script_edit)
		_populate_controls()
		# print("_script_editor = ", script_edit, ' vis = ', is_visible())


	func _populate_controls():
		# who knows if the tree will change so get the first instance of each
		# type of control we care about.  Chances are there won't be more than
		# one of these in the future, but their position in the tree may change.
		_code_editor = weakref(_get_first_child_named('CodeTextEditor', _script_editor.get_ref()))
		_text_edit = weakref(_get_first_child_named("CodeEdit", _code_editor.get_ref()))


	func _get_first_child_named(obj_name, parent_obj):
		if(parent_obj == null):
			return null

		var kids = parent_obj.get_children()
		var index = 0
		var to_return = null

		while(index < kids.size() and to_return == null):
			if(str(kids[index]).find(str("<", obj_name)) != -1):
				to_return = kids[index]
			else:
				to_return = _get_first_child_named(obj_name, kids[index])
				if(to_return == null):
					index += 1

		return to_return


	func get_script_text_edit():
		return _script_editor.get_ref()


	func get_text_edit():
		# ScriptTextEditors that are loaded when the project is opened
		# do not have their children populated yet.  So if we may have to
		# _populate_controls again if we don't have one.
		if(_text_edit == null):
			_populate_controls()
		return _text_edit.get_ref()


	func get_script_editor():
		return _script_editor


	func is_visible():
		var to_return = false
		if(_script_editor.get_ref()):
			to_return = _script_editor.get_ref().visible
		return to_return

# ##############################################################################
#
# ##############################################################################

# Used to make searching for the controls easier and faster.
var _script_editors_parent = null
# reference the ScriptEditor instance
var _script_editor = null
# Array of ScriptEditorControlRef containing all the opened ScriptTextEditors
# and related controls at the time of the last refresh.
var _script_editor_controls = []

var _method_prefix = 'test_'
var _inner_class_prefix = 'Test'

func _init(script_edit):
	_script_editor = script_edit
	refresh()


func _is_script_editor(obj):
	return str(obj).find('<ScriptTextEditor') != -1


# Find the first ScriptTextEditor and then get its parent.  Done this way
# because who knows if the parent object will change.  This is somewhat
# future proofed.
func _find_script_editors_parent():
	var _first_editor = _get_first_child_of_type_name("ScriptTextEditor", _script_editor)
	if(_first_editor != null):
		_script_editors_parent = _first_editor.get_parent()


func _populate_editors():
	if(_script_editors_parent == null):
		return

	_script_editor_controls.clear()
	for child in _script_editors_parent.get_children():
		if(_is_script_editor(child)):
			var ref = ScriptEditorControlRef.new(child)
			_script_editor_controls.append(ref)

# Yes, this is the same as the one above but with a different name.  This was
# easier than trying to find a place where it could be used by both.
func _get_first_child_of_type_name(obj_name, parent_obj):
	if(parent_obj == null):
		# print('aborting search for ', obj_name, ' parent is null')
		return null

	var kids = parent_obj.get_children()
	var index = 0
	var to_return = null

	var search_for = str("<", obj_name)
	# print('searching for ', search_for, ' in ', parent_obj, ' kids ', kids.size())
	while(index < kids.size() and to_return == null):
		var this_one = str(kids[index])
		# print(search_for, ' :: ', this_one)
		if(this_one.find(search_for) != -1):
			to_return = kids[index]
		else:
			to_return = _get_first_child_of_type_name(obj_name, kids[index])
			if(to_return == null):
				index += 1

	return to_return


func _get_func_name_from_line(text):
	text = text.strip_edges()
	var left = text.split("(")[0]
	var func_name = left.split(" ")[1]
	return func_name


func _get_class_name_from_line(text):
	text = text.strip_edges()
	var right = text.split(" ")[1]
	var the_name = right.rstrip(":")
	return the_name

func refresh():
	if(_script_editors_parent == null):
		_find_script_editors_parent()
		# print("script editors parent = ", _script_editors_parent)

	if(_script_editors_parent != null):
		_populate_editors()

	# print("script editor controls = ", _script_editor_controls)


func get_current_text_edit():
	var cur_script_editor = null
	var idx = 0

	while(idx < _script_editor_controls.size() and cur_script_editor == null):
		if(_script_editor_controls[idx].is_visible()):
			cur_script_editor = _script_editor_controls[idx]
		else:
			idx += 1

	var to_return = null
	if(cur_script_editor != null):
		to_return = cur_script_editor.get_text_edit()

	return to_return


func get_script_editor_controls():
	var to_return = []
	for ctrl_ref in _script_editor_controls:
		to_return.append(ctrl_ref.get_script_text_edit())

	return to_return


func get_line_info():
	var editor = get_current_text_edit()
	if(editor == null):
		return

	var info = {
		script = null,
		inner_class = null,
		test_method = null
	}

	var line = editor.get_caret_line()
	var done_func = false
	var done_inner = false
	while(line > 0 and (!done_func or !done_inner)):
		if(editor.can_fold_line(line)):
			var text = editor.get_line(line)
			var strip_text = text.strip_edges(true, false) # only left

			if(!done_func and strip_text.begins_with("func ")):
				var func_name = _get_func_name_from_line(text)
				if(func_name.begins_with(_method_prefix)):
					info.test_method = func_name
				done_func = true
				# If the func line is left justified then there won't be any
				# inner classes above it.
				if(strip_text == text):
					done_inner = true

			if(!done_inner and strip_text.begins_with("class")):
				var inner_name = _get_class_name_from_line(text)
				if(inner_name.begins_with(_inner_class_prefix)):
					info.inner_class = inner_name
					done_inner = true
					# if we found an inner class then we are already past
					# any test the cursor could be in.
					done_func = true
		line -= 1

	return info


func get_method_prefix():
	return _method_prefix


func set_method_prefix(method_prefix):
	_method_prefix = method_prefix


func get_inner_class_prefix():
	return _inner_class_prefix


func set_inner_class_prefix(inner_class_prefix):
	_inner_class_prefix = inner_class_prefix


=====================================
FILE: ./addons/gut/gui/ResizeHandle.gd
=====================================
@tool
extends ColorRect
# #############################################################################
# Resize Handle control.  Place onto a control.  Set the orientation, then
# set the control that this should resize.  Then you can resize the control
# by dragging this thing around.  It's pretty neat.
# #############################################################################
enum ORIENTATION {
	LEFT,
	RIGHT
}

@export var orientation := ORIENTATION.RIGHT :
	get: return orientation
	set(val):
		orientation = val
		queue_redraw()
@export var resize_control : Control = null
@export var vertical_resize := true

var _line_width = .5
var _line_color = Color(.4, .4, .4)
var _active_line_color = Color(.3, .3, .3)
var _invalid_line_color = Color(1, 0, 0)

var _line_space = 3
var _num_lines = 8

var _mouse_down = false
# Called when the node enters the scene tree for the first time.


func _draw():
	var c = _line_color
	if(resize_control == null):
		c = _invalid_line_color
	elif(_mouse_down):
		c = _active_line_color

	if(orientation == ORIENTATION.LEFT):
		_draw_resize_handle_left(c)
	else:
		_draw_resize_handle_right(c)


func _gui_input(event):
	if(resize_control == null):
		return

	if(orientation == ORIENTATION.LEFT):
		_handle_left_input(event)
	else:
		_handle_right_input(event)


# Draw the lines in the corner to show where you can
# drag to resize the dialog
func _draw_resize_handle_right(draw_color):
	var br = size

	for i in range(_num_lines):
		var start = br - Vector2(i * _line_space, 0)
		var end = br - Vector2(0, i * _line_space)
		draw_line(start, end, draw_color, _line_width, true)


func _draw_resize_handle_left(draw_color):
	var bl = Vector2(0, size.y)

	for i in range(_num_lines):
		var start = bl + Vector2(i * _line_space, 0)
		var end = bl -  Vector2(0, i * _line_space)
		draw_line(start, end, draw_color, _line_width, true)


func _handle_right_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_mouse_down and
			event.global_position.x > 0 and
			event.global_position.y < DisplayServer.window_get_size().y):

			if(vertical_resize):
				resize_control.size.y += event.relative.y
			resize_control.size.x += event.relative.x
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_mouse_down = event.pressed
			queue_redraw()


func _handle_left_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_mouse_down and
			event.global_position.x > 0 and
			event.global_position.y < DisplayServer.window_get_size().y):

			var start_size = resize_control.size
			resize_control.size.x -= event.relative.x
			if(resize_control.size.x != start_size.x):
				resize_control.global_position.x += event.relative.x

			if(vertical_resize):
				resize_control.size.y += event.relative.y
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_mouse_down = event.pressed
			queue_redraw()


=====================================
FILE: ./addons/gut/gui/MinGui.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://cnqqdfsn80ise"]

[ext_resource type="Theme" uid="uid://cstkhwkpajvqu" path="res://addons/gut/gui/GutSceneTheme.tres" id="1_farmq"]
[ext_resource type="FontFile" uid="uid://bnh0lslf4yh87" path="res://addons/gut/fonts/CourierPrime-Regular.ttf" id="2_a2e2l"]
[ext_resource type="Script" path="res://addons/gut/gui/gut_gui.gd" id="2_eokrf"]
[ext_resource type="PackedScene" uid="uid://bvrqqgjpyouse" path="res://addons/gut/gui/ResizeHandle.tscn" id="4_xrhva"]

[node name="Min" type="Panel"]
clip_contents = true
custom_minimum_size = Vector2(280, 145)
offset_right = 280.0
offset_bottom = 145.0
theme = ExtResource("1_farmq")
script = ExtResource("2_eokrf")

[node name="MainBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="TitleBar" type="Panel" parent="MainBox"]
custom_minimum_size = Vector2(0, 25)
layout_mode = 2

[node name="TitleBox" type="HBoxContainer" parent="MainBox/TitleBar"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = 2.0
offset_bottom = 3.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="Spacer1" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
text = "Title"

[node name="Spacer2" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TimeLabel" type="Label" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
text = "0.000s"

[node name="Body" type="HBoxContainer" parent="MainBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="LeftMargin" type="CenterContainer" parent="MainBox/Body"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="BodyRows" type="VBoxContainer" parent="MainBox/Body"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ProgressBars" type="HBoxContainer" parent="MainBox/Body/BodyRows"]
layout_mode = 2
size_flags_horizontal = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/Body/BodyRows/ProgressBars"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer"]
layout_mode = 2
text = "T:"

[node name="ProgressTest" type="ProgressBar" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
size_flags_horizontal = 3
value = 25.0

[node name="HBoxContainer2" type="HBoxContainer" parent="MainBox/Body/BodyRows/ProgressBars"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Label" type="Label" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer2"]
layout_mode = 2
text = "S:"

[node name="ProgressScript" type="ProgressBar" parent="MainBox/Body/BodyRows/ProgressBars/HBoxContainer2"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
size_flags_horizontal = 3
value = 75.0

[node name="PathDisplay" type="VBoxContainer" parent="MainBox/Body/BodyRows"]
clip_contents = true
layout_mode = 2
size_flags_vertical = 3

[node name="Path" type="Label" parent="MainBox/Body/BodyRows/PathDisplay"]
layout_mode = 2
theme_override_fonts/font = ExtResource("2_a2e2l")
theme_override_font_sizes/font_size = 14
text = "res://test/integration/whatever"
clip_text = true
text_overrun_behavior = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/Body/BodyRows/PathDisplay"]
clip_contents = true
layout_mode = 2

[node name="S3" type="CenterContainer" parent="MainBox/Body/BodyRows/PathDisplay/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="File" type="Label" parent="MainBox/Body/BodyRows/PathDisplay/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = ExtResource("2_a2e2l")
theme_override_font_sizes/font_size = 14
text = "test_this_thing.gd"
text_overrun_behavior = 3

[node name="Footer" type="HBoxContainer" parent="MainBox/Body/BodyRows"]
layout_mode = 2

[node name="HandleLeft" parent="MainBox/Body/BodyRows/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_xrhva")]
layout_mode = 2
orientation = 0
resize_control = NodePath("../../../../..")
vertical_resize = false

[node name="SwitchModes" type="Button" parent="MainBox/Body/BodyRows/Footer"]
layout_mode = 2
text = "Expand"

[node name="CenterContainer" type="CenterContainer" parent="MainBox/Body/BodyRows/Footer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Continue" type="Button" parent="MainBox/Body/BodyRows/Footer"]
layout_mode = 2
text = "Continue
"

[node name="HandleRight" parent="MainBox/Body/BodyRows/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_xrhva")]
layout_mode = 2
resize_control = NodePath("../../../../..")
vertical_resize = false

[node name="RightMargin" type="CenterContainer" parent="MainBox/Body"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="CenterContainer" type="CenterContainer" parent="MainBox"]
custom_minimum_size = Vector2(2.08165e-12, 2)
layout_mode = 2


=====================================
FILE: ./addons/gut/gui/gut_config_gui.gd
=====================================
var PanelControls = load("res://addons/gut/gui/panel_controls.gd")
var GutConfig = load('res://addons/gut/gut_config.gd')

const DIRS_TO_LIST = 6

var _base_container = null
# All the various PanelControls indexed by thier gut_config keys.
var _cfg_ctrls = {}

# specific titles that we need to do stuff with
var _titles = {
	dirs = null
}
# All titles so we can free them when we want.
var _all_titles = []


func _init(cont):
	_base_container = cont


func _add_title(text):
	var row = PanelControls.BaseGutPanelControl.new(text, text)
	_base_container.add_child(row)
	row.connect('draw', _on_title_cell_draw.bind(row))
	_all_titles.append(row)
	return row

func _add_ctrl(key, ctrl):
	_cfg_ctrls[key] = ctrl
	_base_container.add_child(ctrl)


func _add_number(key, value, disp_text, v_min, v_max, hint=''):
	var ctrl = PanelControls.NumberControl.new(disp_text, value, v_min, v_max, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_select(key, value, values, disp_text, hint=''):
	var ctrl = PanelControls.SelectControl.new(disp_text, value, values, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_value(key, value, disp_text, hint=''):
	var ctrl = PanelControls.StringControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_boolean(key, value, disp_text, hint=''):
	var ctrl = PanelControls.BooleanControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_directory(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	ctrl.dialog.title = disp_text
	return ctrl


func _add_file(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	ctrl.dialog.file_mode = ctrl.dialog.FILE_MODE_OPEN_FILE
	ctrl.dialog.title = disp_text
	return ctrl


func _add_save_file_anywhere(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	ctrl.dialog.file_mode = ctrl.dialog.FILE_MODE_SAVE_FILE
	ctrl.dialog.access = ctrl.dialog.ACCESS_FILESYSTEM
	ctrl.dialog.title = disp_text
	return ctrl


func _add_color(key, value, disp_text, hint=''):
	var ctrl = PanelControls.ColorControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_save_load():
	var ctrl = PanelControls.SaveLoadControl.new('Config', '', '')
	_base_container.add_child(ctrl)

	ctrl.save_path_chosen.connect(_on_save_path_chosen)
	ctrl.load_path_chosen.connect(_on_load_path_chosen)

	_cfg_ctrls['save_load'] = ctrl
	return ctrl

# ------------------
# Events
# ------------------
func _on_title_cell_draw(which):
	which.draw_rect(Rect2(Vector2(0, 0), which.size), Color(0, 0, 0, .15))


func _on_save_path_chosen(path):
	save_file(path)


func _on_load_path_chosen(path):
	load_file.bind(path).call_deferred()

# ------------------
# Public
# ------------------
func get_config_issues():
	var to_return = []
	var has_directory = false

	for i in range(DIRS_TO_LIST):
		var key = str('directory_', i)
		var path = _cfg_ctrls[key].value
		if(path != null and path != ''):
			has_directory = true
			if(!DirAccess.dir_exists_absolute(path)):
				_cfg_ctrls[key].mark_invalid(true)
				to_return.append(str('Test directory ', path, ' does not exist.'))
			else:
				_cfg_ctrls[key].mark_invalid(false)
		else:
			_cfg_ctrls[key].mark_invalid(false)

	if(!has_directory):
		to_return.append('You do not have any directories set.')
		_titles.dirs.mark_invalid(true)
	else:
		_titles.dirs.mark_invalid(false)

	if(!_cfg_ctrls.suffix.value.ends_with('.gd')):
		_cfg_ctrls.suffix.mark_invalid(true)
		to_return.append("Script suffix must end in '.gd'")
	else:
		_cfg_ctrls.suffix.mark_invalid(false)

	return to_return


func clear():
	for key in _cfg_ctrls:
		_cfg_ctrls[key].free()

	_cfg_ctrls.clear()

	for entry in _all_titles:
		entry.free()

	_all_titles.clear()


func save_file(path):
	var gcfg = GutConfig.new()
	gcfg.options = get_options({})
	gcfg.save_file(path)



func load_file(path):
	var gcfg = GutConfig.new()
	gcfg.load_options(path)
	clear()
	set_options(gcfg.options)


# --------------
# SUPER dumb but VERY fun hack to hide settings.  The various _add methods will
# return what they add.  If you want to hide it, just assign the result to this.
# YES, I could have just put .visible at the end, but I didn't think of that
# until just now, and this was fun, non-permanent and the .visible at the end
# isn't as obvious as hide_this =
#
# Also, we can't just skip adding the controls because other things are looking
# for them and things start to blow up if you don't add them.
var hide_this = null :
	set(val):
		val.visible = false

# --------------

func set_options(opts):
	var options = opts.duplicate()

	# _add_title('Save/Load')
	_add_save_load()

	_add_title("Settings")
	_add_number("log_level", options.log_level, "Log Level", 0, 3,
		"Detail level for log messages.\n" + \
		"\t0: Errors and failures only.\n" + \
		"\t1: Adds all test names + warnings + info\n" + \
		"\t2: Shows all asserts\n" + \
		"\t3: Adds more stuff probably, maybe not.")
	_add_boolean('ignore_pause', options.ignore_pause, 'Ignore Pause',
		"Ignore calls to pause_before_teardown")
	_add_boolean('hide_orphans', options.hide_orphans, 'Hide Orphans',
		'Do not display orphan counts in output.')
	_add_boolean('should_exit', options.should_exit, 'Exit on Finish',
		"Exit when tests finished.")
	_add_boolean('should_exit_on_success', options.should_exit_on_success, 'Exit on Success',
		"Exit if there are no failures.  Does nothing if 'Exit on Finish' is enabled.")
	_add_select('double_strategy', 'Script Only', ['Include Native', 'Script Only'], 'Double Strategy',
		'"Include Native" will include native methods in Doubles.  "Script Only" will not.  ' + "\n" + \
		'The native method override warning is disabled when creating Doubles.' + "\n" + \
		'This is the default, you can override this at the script level or when creating doubles.')
	_cfg_ctrls.double_strategy.value = GutUtils.get_enum_value(
		options.double_strategy, GutUtils.DOUBLE_STRATEGY, GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY)
	_add_boolean('errors_cause_failure', !options.errors_do_not_cause_failure, 'Errors cause failures.',
		"When GUT generates an error (not an engine error) it causes tests to fail.")


	_add_title('Runner Appearance')
	hide_this = _add_boolean("gut_on_top", options.gut_on_top, "On Top",
		"The GUT Runner appears above children added during tests.")
	_add_number('opacity', options.opacity, 'Opacity', 0, 100,
		"The opacity of GUT when tests are running.")
	hide_this = _add_boolean('should_maximize', options.should_maximize, 'Maximize',
		"Maximize GUT when tests are being run.")
	_add_boolean('compact_mode', options.compact_mode, 'Compact Mode',
		'The runner will be in compact mode.  This overrides Maximize.')
	_add_select('font_name', options.font_name, GutUtils.avail_fonts, 'Font',
		"The font to use for text output in the Gut Runner.")
	_add_number('font_size', options.font_size, 'Font Size', 5, 100,
		"The font size for text output in the Gut Runner.")
	hide_this = _add_color('font_color', options.font_color, 'Font Color',
		"The font color for text output in the Gut Runner.")
	_add_color('background_color', options.background_color, 'Background Color',
		"The background color for text output in the Gut Runner.")
	_add_boolean('disable_colors', options.disable_colors, 'Disable Formatting',
		'Disable formatting and colors used in the Runner.  Does not affect panel output.')


	_titles.dirs = _add_title('Test Directories')
	_add_boolean('include_subdirs', options.include_subdirs, 'Include Subdirs',
		"Include subdirectories of the directories configured below.")

	var dirs_to_load = options.configured_dirs
	if(options.dirs.size() > dirs_to_load.size()):
		dirs_to_load = options.dirs

	for i in range(DIRS_TO_LIST):
		var value = ''
		if(dirs_to_load.size() > i):
			value = dirs_to_load[i]

		var test_dir = _add_directory(str('directory_', i), value, str(i))
		test_dir.enabled_button.visible = true
		test_dir.enabled_button.button_pressed = options.dirs.has(value)


	_add_title("XML Output")
	_add_save_file_anywhere("junit_xml_file", options.junit_xml_file, "Output Path",
		"Path3D and filename where GUT should create a JUnit compliant XML file.  " +
		"This file will contain the results of the last test run.  To avoid " +
		"overriding the file use Include Timestamp.")
	_add_boolean("junit_xml_timestamp", options.junit_xml_timestamp, "Include Timestamp",
		"Include a timestamp in the filename so that each run gets its own xml file.")


	_add_title('Hooks')
	_add_file('pre_run_script', options.pre_run_script, 'Pre-Run Hook',
		'This script will be run by GUT before any tests are run.')
	_add_file('post_run_script', options.post_run_script, 'Post-Run Hook',
		'This script will be run by GUT after all tests are run.')


	_add_title('Misc')
	_add_value('prefix', options.prefix, 'Script Prefix',
		"The filename prefix for all test scripts.")
	_add_value('suffix', options.suffix, 'Script Suffix',
		"Script suffix, including .gd extension.  For example '_foo.gd'.")
	_add_number('paint_after', options.paint_after, 'Paint After', 0.0, 1.0,
		"How long GUT will wait before pausing for 1 frame to paint the screen.  0 is never.")

	# since _add_number doesn't set step property, it will default to a step of
	# 1 and cast values to int.  Give it a .5 step and re-set the value.
	_cfg_ctrls.paint_after.value_ctrl.step = .05
	_cfg_ctrls.paint_after.value = options.paint_after



func get_options(base_opts):
	var to_return = base_opts.duplicate()

	# Settings
	to_return.log_level = _cfg_ctrls.log_level.value
	to_return.ignore_pause = _cfg_ctrls.ignore_pause.value
	to_return.hide_orphans = _cfg_ctrls.hide_orphans.value
	to_return.should_exit = _cfg_ctrls.should_exit.value
	to_return.should_exit_on_success = _cfg_ctrls.should_exit_on_success.value
	to_return.double_strategy = _cfg_ctrls.double_strategy.value
	to_return.errors_do_not_cause_failure = !_cfg_ctrls.errors_cause_failure.value


	# Runner Appearance
	to_return.font_name = _cfg_ctrls.font_name.text
	to_return.font_size = _cfg_ctrls.font_size.value
	to_return.should_maximize = _cfg_ctrls.should_maximize.value
	to_return.compact_mode = _cfg_ctrls.compact_mode.value
	to_return.opacity = _cfg_ctrls.opacity.value
	to_return.background_color = _cfg_ctrls.background_color.value.to_html()
	to_return.font_color = _cfg_ctrls.font_color.value.to_html()
	to_return.disable_colors = _cfg_ctrls.disable_colors.value
	to_return.gut_on_top = _cfg_ctrls.gut_on_top.value
	to_return.paint_after = _cfg_ctrls.paint_after.value


	# Directories
	to_return.include_subdirs = _cfg_ctrls.include_subdirs.value
	var dirs = []
	var configured_dirs = []
	for i in range(DIRS_TO_LIST):
		var key = str('directory_', i)
		var ctrl = _cfg_ctrls[key]
		if(ctrl.value != '' and ctrl.value != null):
			configured_dirs.append(ctrl.value)
			if(ctrl.enabled_button.button_pressed):
				dirs.append(ctrl.value)
	to_return.dirs = dirs
	to_return.configured_dirs = configured_dirs

	# XML Output
	to_return.junit_xml_file = _cfg_ctrls.junit_xml_file.value
	to_return.junit_xml_timestamp = _cfg_ctrls.junit_xml_timestamp.value

	# Hooks
	to_return.pre_run_script = _cfg_ctrls.pre_run_script.value
	to_return.post_run_script = _cfg_ctrls.post_run_script.value

	# Misc
	to_return.prefix = _cfg_ctrls.prefix.value
	to_return.suffix = _cfg_ctrls.suffix.value

	return to_return


func mark_saved():
	for key in _cfg_ctrls:
		_cfg_ctrls[key].mark_unsaved(false)


=====================================
FILE: ./addons/gut/gui/RunResults.gd
=====================================
@tool
extends Control

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

var _interface = null
var _font = null
var _font_size = null
var _editors = null # script_text_editor_controls.gd
var _output_control = null

@onready var _ctrls = {
	tree = $VBox/Output/Scroll/Tree,
	toolbar = {
		toolbar = $VBox/Toolbar,
		collapse = $VBox/Toolbar/Collapse,
		collapse_all = $VBox/Toolbar/CollapseAll,
		expand = $VBox/Toolbar/Expand,
		expand_all = $VBox/Toolbar/ExpandAll,
		hide_passing = $VBox/Toolbar/HidePassing,
		show_script = $VBox/Toolbar/ShowScript,
		scroll_output = $VBox/Toolbar/ScrollOutput
	}
}

func _ready():
	var f = null
	if ($FontSampler.get_label_settings() == null) :
		f = get_theme_default_font()
	else :
		f = $FontSampler.get_label_settings().font
	var s_size = f.get_string_size("000 of 000 passed")
	_ctrls.tree.set_summary_min_width(s_size.x)

	_set_toolbutton_icon(_ctrls.toolbar.collapse, 'CollapseTree', 'c')
	_set_toolbutton_icon(_ctrls.toolbar.collapse_all, 'CollapseTree', 'c')
	_set_toolbutton_icon(_ctrls.toolbar.expand, 'ExpandTree', 'e')
	_set_toolbutton_icon(_ctrls.toolbar.expand_all, 'ExpandTree', 'e')
	_set_toolbutton_icon(_ctrls.toolbar.show_script, 'Script', 'ss')
	_set_toolbutton_icon(_ctrls.toolbar.scroll_output, 'Font', 'so')

	_ctrls.tree.hide_passing = true
	_ctrls.toolbar.hide_passing.button_pressed = false
	_ctrls.tree.show_orphans = true
	_ctrls.tree.item_selected.connect(_on_item_selected)

	if(get_parent() == get_tree().root):
		_test_running_setup()

	call_deferred('_update_min_width')


func _test_running_setup():
	_ctrls.tree.hide_passing = true
	_ctrls.tree.show_orphans = true

	_ctrls.toolbar.hide_passing.text = '[hp]'
	_ctrls.tree.load_json_file(GutEditorGlobals.editor_run_json_results_path)


func _set_toolbutton_icon(btn, icon_name, text):
	if(Engine.is_editor_hint()):
		btn.icon = get_theme_icon(icon_name, 'EditorIcons')
	else:
		btn.text = str('[', text, ']')


func _update_min_width():
	custom_minimum_size.x = _ctrls.toolbar.toolbar.size.x


func _open_script_in_editor(path, line_number):
	if(_interface == null):
		print('Too soon, wait a bit and try again.')
		return

	var r = load(path)
	if(line_number != null and line_number != -1):
		_interface.edit_script(r, line_number)
	else:
		_interface.edit_script(r)

	if(_ctrls.toolbar.show_script.pressed):
		_interface.set_main_screen_editor('Script')


# starts at beginning of text edit and searches for each search term, moving
# through the text as it goes; ensuring that, when done, it found the first
# occurance of the last srting that happend after the first occurance of
# each string before it.  (Generic way of searching for a method name in an
# inner class that may have be a duplicate of a method name in a different
# inner class)
func _get_line_number_for_seq_search(search_strings, te):
	if(te == null):
		print("No Text editor to get line number for")
		return 0;

	var result = null
	var line = Vector2i(0, 0)
	var s_flags = 0

	var i = 0
	var string_found = true
	while(i < search_strings.size() and string_found):
		result = te.search(search_strings[i], s_flags, line.y, line.x)
		if(result.x != -1):
			line = result
		else:
			string_found = false
		i += 1

	return line.y


func _goto_code(path, line, method_name='', inner_class =''):
	if(_interface == null):
		print('going to ', [path, line, method_name, inner_class])
		return

	_open_script_in_editor(path, line)
	if(line == -1):
		var search_strings = []
		if(inner_class != ''):
			search_strings.append(inner_class)

		if(method_name != ''):
			search_strings.append(method_name)

		await get_tree().process_frame
		line = _get_line_number_for_seq_search(search_strings, _editors.get_current_text_edit())
		if(line != null and line != -1):
			_interface.get_script_editor().goto_line(line)


func _goto_output(path, method_name, inner_class):
	if(_output_control == null):
		return

	var search_strings = [path]

	if(inner_class != ''):
		search_strings.append(inner_class)

	if(method_name != ''):
		search_strings.append(method_name)

	var line = _get_line_number_for_seq_search(search_strings, _output_control.get_rich_text_edit())
	if(line != null and line != -1):
		_output_control.scroll_to_line(line)




# --------------
# Events
# --------------
func _on_Collapse_pressed():
	collapse_selected()


func _on_Expand_pressed():
	expand_selected()


func _on_CollapseAll_pressed():
	collapse_all()


func _on_ExpandAll_pressed():
	expand_all()


func _on_Hide_Passing_pressed():
	_ctrls.tree.hide_passing = !_ctrls.toolbar.hide_passing.button_pressed
	_ctrls.tree.load_json_file(GutEditorGlobals.editor_run_json_results_path)


func _on_item_selected(script_path, inner_class, test_name, line):
	if(_ctrls.toolbar.show_script.button_pressed):
		_goto_code(script_path, line, test_name, inner_class)
	if(_ctrls.toolbar.scroll_output.button_pressed):
		_goto_output(script_path, test_name, inner_class)




# --------------
# Public
# --------------
func add_centered_text(t):
	_ctrls.tree.add_centered_text(t)


func clear_centered_text():
	_ctrls.tree.clear_centered_text()


func clear():
	_ctrls.tree.clear()
	clear_centered_text()


func set_interface(which):
	_interface = which


func set_script_text_editors(value):
	_editors = value


func collapse_all():
	_ctrls.tree.collapse_all()


func expand_all():
	_ctrls.tree.expand_all()


func collapse_selected():
	var item = _ctrls.tree.get_selected()
	if(item != null):
		_ctrls.tree.set_collapsed_on_all(item, true)


func expand_selected():
	var item = _ctrls.tree.get_selected()
	if(item != null):
		_ctrls.tree.set_collapsed_on_all(item, false)


func set_show_orphans(should):
	_ctrls.tree.show_orphans = should


func set_font(font_name, size):
	pass
#	var dyn_font = FontFile.new()
#	var font_data = FontFile.new()
#	font_data.font_path = 'res://addons/gut/fonts/' + font_name + '-Regular.ttf'
#	font_data.antialiased = true
#	dyn_font.font_data = font_data
#
#	_font = dyn_font
#	_font.size = size
#	_font_size = size


func set_output_control(value):
	_output_control = value


func load_json_results(j):
	_ctrls.tree.load_json_results(j)


=====================================
FILE: ./addons/gut/gui/OutputText.gd
=====================================
@tool
extends VBoxContainer

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var PanelControls = load('res://addons/gut/gui/panel_controls.gd')

# ##############################################################################
# Keeps search results from the TextEdit
# ##############################################################################
class TextEditSearcher:
	var te : TextEdit
	var _last_term = ''
	var _last_pos = Vector2(-1, -1)
	var _ignore_caret_change = false

	func set_text_edit(which):
		te = which
		te.caret_changed.connect(_on_caret_changed)


	func _on_caret_changed():
		if(_ignore_caret_change):
			_ignore_caret_change = false
		else:
			_last_pos = _get_caret();


	func _get_caret():
		return Vector2(te.get_caret_column(), te.get_caret_line())


	func _set_caret_and_sel(pos, len):
		te.set_caret_line(pos.y)
		te.set_caret_column(pos.x)
		if(len > 0):
			te.select(pos.y, pos.x, pos.y, pos.x + len)


	func _find(term, search_flags):
		var pos = _get_caret()
		if(term == _last_term):
			if(search_flags == 0):
				pos = _last_pos
				pos.x += 1
			else:
				pos = _last_pos
				pos.x -= 1

		var result = te.search(term, search_flags, pos.y, pos.x)
#		print('searching from ', pos, ' for "', term, '" = ', result)
		if(result.y != -1):
			_ignore_caret_change = true
			_set_caret_and_sel(result, term.length())
			_last_pos = result

		_last_term = term

	func find_next(term):
		_find(term, 0)

	func find_prev(term):
		_find(term, te.SEARCH_BACKWARDS)


# ##############################################################################
# Start OutputText control code
# ##############################################################################
@onready var _ctrls = {
	output = $Output,
	settings_bar = $Settings,
	use_colors = $Settings/UseColors,
	word_wrap = $Settings/WordWrap,

	copy_button = $Toolbar/CopyButton,
	clear_button = $Toolbar/ClearButton,
	show_search = $Toolbar/ShowSearch,
	caret_position = $Toolbar/LblPosition,

	search_bar = {
		bar = $Search,
		search_term = $Search/SearchTerm,
	}
}

var _sr = TextEditSearcher.new()
var _highlighter : CodeHighlighter
var _font_name = null
var _user_prefs = GutEditorGlobals.user_prefs
var _font_name_pctrl = null
var _font_size_pctrl = null

# Automatically used when running the OutputText scene from the editor.  Changes
# to this method only affect test-running the control through the editor.
func _test_running_setup():
	_ctrls.use_colors.text = 'use colors'
	_ctrls.show_search.text = 'search'
	_ctrls.word_wrap.text = 'ww'

	set_all_fonts("CourierPrime")
	set_font_size(30)

	_ctrls.output.queue_redraw()
	load_file('user://.gut_editor.bbcode')
	await get_tree().process_frame

	show_search(true)
	_ctrls.output.set_caret_line(0)
	_ctrls.output.scroll_vertical = 0
	_ctrls.output.caret_changed.connect(_on_caret_changed)


func _ready():
	_sr.set_text_edit(_ctrls.output)
	_ctrls.use_colors.icon = get_theme_icon('RichTextEffect', 'EditorIcons')
	_ctrls.show_search.icon = get_theme_icon('Search', 'EditorIcons')
	_ctrls.word_wrap.icon = get_theme_icon('Loop', 'EditorIcons')

	_setup_colors()
	_ctrls.use_colors.button_pressed = true
	_use_highlighting(true)

	if(get_parent() == get_tree().root):
		_test_running_setup()

	_ctrls.settings_bar.visible = false
	_add_other_ctrls()


func _add_other_ctrls():
	var fname = 'CourierNew'
	if(_user_prefs != null):
		fname = _user_prefs.output_font_name.value
	_font_name_pctrl = PanelControls.SelectControl.new('Font', fname, GutUtils.avail_fonts,
		"The font, you know, for the text below.  Change it, see what it does.")
	_font_name_pctrl.changed.connect(_on_font_name_changed)
	_font_name_pctrl.label.size_flags_horizontal = SIZE_SHRINK_BEGIN
	_ctrls.settings_bar.add_child(_font_name_pctrl)
	set_all_fonts(fname)

	var fsize = 30
	if(_user_prefs != null):
		fsize = _user_prefs.output_font_size.value
	_font_size_pctrl = PanelControls.NumberControl.new('Font Size', fsize , 5, 100,
		"The size of 'The Font'.")
	_font_size_pctrl.changed.connect(_on_font_size_changed)
	_font_size_pctrl.label.size_flags_horizontal = SIZE_SHRINK_BEGIN
	_ctrls.settings_bar.add_child(_font_size_pctrl)
	set_font_size(fsize)


# ------------------
# Private
# ------------------

# Call this after changes in colors and the like to get them to apply.  reloads
# the text of the output control.
func _refresh_output():
	var orig_pos = _ctrls.output.scroll_vertical
	var text = _ctrls.output.text

	_ctrls.output.text = text
	_ctrls.output.scroll_vertical = orig_pos


func _create_highlighter(default_color=Color(1, 1, 1, 1)):
	var to_return = CodeHighlighter.new()

	to_return.function_color = default_color
	to_return.number_color = default_color
	to_return.symbol_color = default_color
	to_return.member_variable_color = default_color

	var keywords = [
		['Failed', Color.RED],
		['Passed', Color.GREEN],
		['Pending', Color.YELLOW],
		['Orphans', Color.YELLOW],
		['WARNING', Color.YELLOW],
		['ERROR', Color.RED]
	]

	for keyword in keywords:
		to_return.add_keyword_color(keyword[0], keyword[1])

	return to_return


func _setup_colors():
	_ctrls.output.clear()

	var f_color = null
	if (_ctrls.output.theme == null) :
		f_color = get_theme_color("font_color")
	else :
		f_color = _ctrls.output.theme.font_color

	_highlighter = _create_highlighter()
	_ctrls.output.queue_redraw()



func _use_highlighting(should):
	if(should):
		_ctrls.output.syntax_highlighter = _highlighter
	else:
		_ctrls.output.syntax_highlighter = null
	_refresh_output()

# ------------------
# Events
# ------------------
func _on_caret_changed():
	var txt = str("line:",_ctrls.output.get_caret_line(), ' col:', _ctrls.output.get_caret_column())
	_ctrls.caret_position.text = str(txt)

func _on_font_size_changed():
	set_font_size(_font_size_pctrl.value)
	if(_user_prefs != null):
		_user_prefs.output_font_size.value = _font_size_pctrl.value
		_user_prefs.output_font_size.save_it()

func _on_font_name_changed():
	set_all_fonts(_font_name_pctrl.text)
	if(_user_prefs != null):
		_user_prefs.output_font_name.value = _font_name_pctrl.text
		_user_prefs.output_font_name.save_it()

func _on_CopyButton_pressed():
	copy_to_clipboard()

func _on_UseColors_pressed():
	_use_highlighting(_ctrls.use_colors.button_pressed)

func _on_ClearButton_pressed():
	clear()

func _on_ShowSearch_pressed():
	show_search(_ctrls.show_search.button_pressed)

func _on_SearchTerm_focus_entered():
	_ctrls.search_bar.search_term.call_deferred('select_all')

func _on_SearchNext_pressed():
	_sr.find_next(_ctrls.search_bar.search_term.text)

func _on_SearchPrev_pressed():
	_sr.find_prev(_ctrls.search_bar.search_term.text)

func _on_SearchTerm_text_changed(new_text):
	if(new_text == ''):
		_ctrls.output.deselect()
	else:
		_sr.find_next(new_text)

func _on_SearchTerm_text_entered(new_text):
	if(Input.is_physical_key_pressed(KEY_SHIFT)):
		_sr.find_prev(new_text)
	else:
		_sr.find_next(new_text)

func _on_SearchTerm_gui_input(event):
	if(event is InputEventKey and !event.pressed and event.keycode == KEY_ESCAPE):
		show_search(false)

func _on_WordWrap_pressed():
	if(_ctrls.word_wrap.button_pressed):
		_ctrls.output.wrap_mode = TextEdit.LINE_WRAPPING_BOUNDARY
	else:
		_ctrls.output.wrap_mode = TextEdit.LINE_WRAPPING_NONE

	_ctrls.output.queue_redraw()

func _on_settings_pressed():
	_ctrls.settings_bar.visible = $Toolbar/ShowSettings.button_pressed

# ------------------
# Public
# ------------------
func show_search(should):
	_ctrls.search_bar.bar.visible = should
	if(should):
		_ctrls.search_bar.search_term.grab_focus()
		_ctrls.search_bar.search_term.select_all()
	_ctrls.show_search.button_pressed = should


func search(text, start_pos, highlight=true):
	return _sr.find_next(text)


func copy_to_clipboard():
	var selected = _ctrls.output.get_selected_text()
	if(selected != ''):
		DisplayServer.clipboard_set(selected)
	else:
		DisplayServer.clipboard_set(_ctrls.output.text)


func clear():
	_ctrls.output.text = ''


func _set_font(font_name, custom_name):
	var rtl = _ctrls.output
	if(font_name == null):
		rtl.remove_theme_font_override(custom_name)
	else:
		var dyn_font = FontFile.new()
		dyn_font.load_dynamic_font('res://addons/gut/fonts/' + font_name + '.ttf')
		rtl.add_theme_font_override(custom_name, dyn_font)


func set_all_fonts(base_name):
	_font_name = GutUtils.nvl(base_name, 'Default')

	if(base_name == 'Default'):
		_set_font(null, 'font')
		_set_font(null, 'normal_font')
		_set_font(null, 'bold_font')
		_set_font(null, 'italics_font')
		_set_font(null, 'bold_italics_font')
	else:
		_set_font(base_name + '-Regular', 'font')
		_set_font(base_name + '-Regular', 'normal_font')
		_set_font(base_name + '-Bold', 'bold_font')
		_set_font(base_name + '-Italic', 'italics_font')
		_set_font(base_name + '-BoldItalic', 'bold_italics_font')


func set_font_size(new_size):
	_ctrls.output.set("theme_override_font_sizes/font_size", new_size)


func set_use_colors(value):
	pass


func get_use_colors():
	return false;


func get_rich_text_edit():
	return _ctrls.output


func load_file(path):
	var f = FileAccess.open(path, FileAccess.READ)
	if(f == null):
		return

	var t = f.get_as_text()
	f = null # closes file
	_ctrls.output.text = t
	_ctrls.output.scroll_vertical = _ctrls.output.get_line_count()
	_ctrls.output.set_deferred('scroll_vertical', _ctrls.output.get_line_count())


func add_text(text):
	if(is_inside_tree()):
		_ctrls.output.text += text


func scroll_to_line(line):
	_ctrls.output.scroll_vertical = line
	_ctrls.output.set_caret_line(line)


=====================================
FILE: ./addons/gut/gui/GutControl.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://4jb53yqktyfg"]

[ext_resource type="Script" path="res://addons/gut/gui/GutControl.gd" id="1_eprql"]

[node name="GutControl" type="Control"]
layout_mode = 3
anchors_preset = 0
offset_right = 295.0
offset_bottom = 419.0
script = ExtResource("1_eprql")

[node name="Bg" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.36, 0.36, 0.36, 1)

[node name="VBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Tabs" type="TabContainer" parent="VBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="Tests" type="Tree" parent="VBox/Tabs"]
layout_mode = 2
size_flags_vertical = 3
hide_root = true

[node name="SettingsScroll" type="ScrollContainer" parent="VBox/Tabs"]
visible = false
layout_mode = 2
size_flags_vertical = 3

[node name="Settings" type="VBoxContainer" parent="VBox/Tabs/SettingsScroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Buttons" type="HBoxContainer" parent="VBox"]
layout_mode = 2

[node name="RunTests" type="Button" parent="VBox/Buttons"]
layout_mode = 2
size_flags_horizontal = 3
text = "Run All"

[node name="RunSelected" type="Button" parent="VBox/Buttons"]
layout_mode = 2
size_flags_horizontal = 3
text = "Run Selected"

[connection signal="item_activated" from="VBox/Tabs/Tests" to="." method="_on_tests_item_activated"]
[connection signal="pressed" from="VBox/Buttons/RunTests" to="." method="_on_run_tests_pressed"]
[connection signal="pressed" from="VBox/Buttons/RunSelected" to="." method="_on_run_selected_pressed"]


=====================================
FILE: ./addons/gut/gui/RunAtCursor.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://0yunjxtaa8iw"]

[ext_resource type="Script" path="res://addons/gut/gui/RunAtCursor.gd" id="1"]
[ext_resource type="Texture2D" uid="uid://cr6tvdv0ve6cv" path="res://addons/gut/gui/play.png" id="2"]
[ext_resource type="Texture2D" uid="uid://6wra5rxmfsrl" path="res://addons/gut/gui/arrow.png" id="3"]

[node name="RunAtCursor" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 1.0
offset_bottom = -527.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
script = ExtResource("1")

[node name="HBox" type="HBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="LblNoneSelected" type="Label" parent="HBox"]
layout_mode = 2
text = "<None>"

[node name="BtnRunScript" type="Button" parent="HBox"]
visible = false
layout_mode = 2
text = "<script>"
icon = ExtResource("2")

[node name="Arrow1" type="TextureButton" parent="HBox"]
visible = false
custom_minimum_size = Vector2(24, 0)
layout_mode = 2
texture_normal = ExtResource("3")
stretch_mode = 3

[node name="BtnRunInnerClass" type="Button" parent="HBox"]
visible = false
layout_mode = 2
text = "<inner class>"
icon = ExtResource("2")

[node name="Arrow2" type="TextureButton" parent="HBox"]
visible = false
custom_minimum_size = Vector2(24, 0)
layout_mode = 2
texture_normal = ExtResource("3")
stretch_mode = 3

[node name="BtnRunMethod" type="Button" parent="HBox"]
visible = false
layout_mode = 2
text = "<method>"
icon = ExtResource("2")

[connection signal="pressed" from="HBox/BtnRunScript" to="." method="_on_BtnRunScript_pressed"]
[connection signal="pressed" from="HBox/BtnRunInnerClass" to="." method="_on_BtnRunInnerClass_pressed"]
[connection signal="pressed" from="HBox/BtnRunMethod" to="." method="_on_BtnRunMethod_pressed"]


=====================================
FILE: ./addons/gut/gui/BottomPanelShortcuts.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://bsk32dh41b4gs"]

[ext_resource type="PackedScene" uid="uid://sfb1fw8j6ufu" path="res://addons/gut/gui/ShortcutButton.tscn" id="1"]
[ext_resource type="Script" path="res://addons/gut/gui/BottomPanelShortcuts.gd" id="2"]

[node name="BottomPanelShortcuts" type="Popup"]
title = "Shortcuts"
size = Vector2i(500, 350)
visible = true
exclusive = true
unresizable = false
borderless = false
script = ExtResource("2")

[node name="Layout" type="VBoxContainer" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 5.0
offset_right = -5.0
offset_bottom = 2.0

[node name="TopPad" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2

[node name="Label2" type="Label" parent="Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
text = "Always Active"

[node name="ColorRect" type="ColorRect" parent="Layout/Label2"]
show_behind_parent = true
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
color = Color(0, 0, 0, 0.196078)

[node name="CPanelButton" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Layout/CPanelButton"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Show/Hide GUT Panel"

[node name="ShortcutButton" parent="Layout/CPanelButton" instance=ExtResource("1")]
layout_mode = 2
size_flags_horizontal = 3

[node name="GutPanelPad" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2

[node name="Label" type="Label" parent="Layout"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2
text = "Only Active When GUT Panel Shown"

[node name="ColorRect2" type="ColorRect" parent="Layout/Label"]
show_behind_parent = true
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
color = Color(0, 0, 0, 0.196078)

[node name="TopPad2" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2

[node name="CRunAll" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Layout/CRunAll"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run All"

[node name="ShortcutButton" parent="Layout/CRunAll" instance=ExtResource("1")]
layout_mode = 2
size_flags_horizontal = 3

[node name="CRunCurrentScript" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Layout/CRunCurrentScript"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run Current Script"

[node name="ShortcutButton" parent="Layout/CRunCurrentScript" instance=ExtResource("1")]
layout_mode = 2
size_flags_horizontal = 3

[node name="CRunCurrentInner" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Layout/CRunCurrentInner"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run Current Inner Class"

[node name="ShortcutButton" parent="Layout/CRunCurrentInner" instance=ExtResource("1")]
layout_mode = 2
size_flags_horizontal = 3

[node name="CRunCurrentTest" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="Label" type="Label" parent="Layout/CRunCurrentTest"]
custom_minimum_size = Vector2(50, 0)
layout_mode = 2
size_flags_vertical = 7
text = "Run Current Test"

[node name="ShortcutButton" parent="Layout/CRunCurrentTest" instance=ExtResource("1")]
layout_mode = 2
size_flags_horizontal = 3

[node name="CenterContainer2" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="ShiftDisclaimer" type="Label" parent="Layout"]
layout_mode = 2
text = "\"Shift\" cannot be the only modifier for a shortcut."

[node name="HBoxContainer" type="HBoxContainer" parent="Layout"]
layout_mode = 2

[node name="CenterContainer" type="CenterContainer" parent="Layout/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Hide" type="Button" parent="Layout/HBoxContainer"]
custom_minimum_size = Vector2(60, 30)
layout_mode = 2
text = "Close"

[node name="BottomPad" type="CenterContainer" parent="Layout"]
custom_minimum_size = Vector2(0, 10)
layout_mode = 2
size_flags_horizontal = 3

[connection signal="popup_hide" from="." to="." method="_on_popup_hide"]
[connection signal="pressed" from="Layout/HBoxContainer/Hide" to="." method="_on_Hide_pressed"]


=====================================
FILE: ./addons/gut/gui/NormalGui.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://duxblir3vu8x7"]

[ext_resource type="Theme" uid="uid://cstkhwkpajvqu" path="res://addons/gut/gui/GutSceneTheme.tres" id="1_5hlsm"]
[ext_resource type="Script" path="res://addons/gut/gui/gut_gui.gd" id="2_fue6q"]
[ext_resource type="FontFile" uid="uid://bnh0lslf4yh87" path="res://addons/gut/fonts/CourierPrime-Regular.ttf" id="2_u5uc1"]
[ext_resource type="PackedScene" uid="uid://bvrqqgjpyouse" path="res://addons/gut/gui/ResizeHandle.tscn" id="4_2r8a8"]

[node name="Large" type="Panel"]
custom_minimum_size = Vector2(500, 150)
offset_right = 632.0
offset_bottom = 260.0
theme = ExtResource("1_5hlsm")
script = ExtResource("2_fue6q")

[node name="MainBox" type="VBoxContainer" parent="."]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="TitleBar" type="Panel" parent="MainBox"]
custom_minimum_size = Vector2(0, 25)
layout_mode = 2

[node name="TitleBox" type="HBoxContainer" parent="MainBox/TitleBar"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = 2.0
offset_bottom = 3.0
grow_horizontal = 2
grow_vertical = 2
metadata/_edit_layout_mode = 1

[node name="Spacer1" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Title" type="Label" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
text = "Title"

[node name="Spacer2" type="CenterContainer" parent="MainBox/TitleBar/TitleBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="TimeLabel" type="Label" parent="MainBox/TitleBar/TitleBox"]
custom_minimum_size = Vector2(90, 0)
layout_mode = 2
text = "999.999s"

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="VBoxContainer" type="VBoxContainer" parent="MainBox/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="OutputBG" type="ColorRect" parent="MainBox/HBoxContainer/VBoxContainer"]
layout_mode = 2
size_flags_vertical = 3
color = Color(0.0745098, 0.0705882, 0.0784314, 1)
metadata/_edit_layout_mode = 1

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG"]
layout_mode = 0
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="S2" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="TestOutput" type="RichTextLabel" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
focus_mode = 2
bbcode_enabled = true
scroll_following = true
autowrap_mode = 0
selection_enabled = true

[node name="S1" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/OutputBG/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="ControlBox" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer"]
layout_mode = 2

[node name="S1" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="ProgressBars" type="VBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
custom_minimum_size = Vector2(2.08165e-12, 2.08165e-12)
layout_mode = 2

[node name="TestBox" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars"]
layout_mode = 2

[node name="Label" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/TestBox"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
size_flags_horizontal = 3
text = "Tests"

[node name="ProgressTest" type="ProgressBar" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/TestBox"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
value = 25.0

[node name="ScriptBox" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars"]
layout_mode = 2

[node name="Label" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/ScriptBox"]
custom_minimum_size = Vector2(60, 0)
layout_mode = 2
size_flags_horizontal = 3
text = "Scripts"

[node name="ProgressScript" type="ProgressBar" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/ProgressBars/ScriptBox"]
custom_minimum_size = Vector2(100, 0)
layout_mode = 2
value = 75.0

[node name="PathDisplay" type="VBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Path" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay"]
layout_mode = 2
size_flags_vertical = 6
theme_override_fonts/font = ExtResource("2_u5uc1")
theme_override_font_sizes/font_size = 14
text = "res://test/integration/whatever"
text_overrun_behavior = 3

[node name="HBoxContainer" type="HBoxContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay"]
layout_mode = 2
size_flags_vertical = 3

[node name="S3" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay/HBoxContainer"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="File" type="Label" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox/PathDisplay/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_fonts/font = ExtResource("2_u5uc1")
theme_override_font_sizes/font_size = 14
text = "test_this_thing.gd"
text_overrun_behavior = 3

[node name="Spacer1" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
visible = false
layout_mode = 2
size_flags_horizontal = 10

[node name="Continue" type="Button" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
layout_mode = 2
size_flags_vertical = 4
text = "Continue
"

[node name="S3" type="CenterContainer" parent="MainBox/HBoxContainer/VBoxContainer/ControlBox"]
custom_minimum_size = Vector2(5, 0)
layout_mode = 2

[node name="BottomPad" type="CenterContainer" parent="MainBox"]
custom_minimum_size = Vector2(0, 5)
layout_mode = 2

[node name="Footer" type="HBoxContainer" parent="MainBox"]
layout_mode = 2

[node name="SidePad1" type="CenterContainer" parent="MainBox/Footer"]
custom_minimum_size = Vector2(2, 2.08165e-12)
layout_mode = 2

[node name="ResizeHandle3" parent="MainBox/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_2r8a8")]
custom_minimum_size = Vector2(25, 25)
layout_mode = 2
orientation = 0
resize_control = NodePath("../../..")

[node name="SwitchModes" type="Button" parent="MainBox/Footer"]
layout_mode = 2
text = "Compact
"

[node name="CenterContainer" type="CenterContainer" parent="MainBox/Footer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ResizeHandle2" parent="MainBox/Footer" node_paths=PackedStringArray("resize_control") instance=ExtResource("4_2r8a8")]
custom_minimum_size = Vector2(25, 25)
layout_mode = 2
resize_control = NodePath("../../..")

[node name="SidePad2" type="CenterContainer" parent="MainBox/Footer"]
custom_minimum_size = Vector2(2, 2.08165e-12)
layout_mode = 2

[node name="BottomPad2" type="CenterContainer" parent="MainBox"]
custom_minimum_size = Vector2(2.08165e-12, 2)
layout_mode = 2


=====================================
FILE: ./addons/gut/gui/gut_gui.gd
=====================================
extends Control
# ##############################################################################
# This is the decoupled GUI for gut.gd
#
# This is a "generic" interface between a GUI and gut.gd.  It assumes there are
# certain controls with specific names.  It will then interact with those
# controls based on signals emitted from gut.gd in order to give the user
# feedback about the progress of the test run and the results.
#
# Optional controls are marked as such in the _ctrls dictionary.  The names
# of the controls can be found in _populate_ctrls.
# ##############################################################################
var _gut = null

var _ctrls = {
	btn_continue = null,
	path_dir = null,
	path_file = null,
	prog_script = null,
	prog_test = null,
	rtl = null,                 # optional
	rtl_bg = null,              # required if rtl exists
	switch_modes = null,
	time_label = null,
	title = null,
	title_bar = null,
}

var _title_mouse = {
	down = false
}


signal switch_modes()

var _max_position = Vector2(100, 100)

func _ready():
	_populate_ctrls()

	_ctrls.btn_continue.visible = false
	_ctrls.btn_continue.pressed.connect(_on_continue_pressed)
	_ctrls.switch_modes.pressed.connect(_on_switch_modes_pressed)
	_ctrls.title_bar.gui_input.connect(_on_title_bar_input)

	_ctrls.prog_script.value = 0
	_ctrls.prog_test.value = 0
	_ctrls.path_dir.text = ''
	_ctrls.path_file.text = ''
	_ctrls.time_label.text = ''

	_max_position = get_display_size() - Vector2(30, _ctrls.title_bar.size.y)


func _process(_delta):
	if(_gut != null and _gut.is_running()):
		set_elapsed_time(_gut.get_elapsed_time())


# ------------------
# Private
# ------------------
func get_display_size():
	return get_viewport().get_visible_rect().size


func _populate_ctrls():
	# Brute force, but flexible.  This allows for all the controls to exist
	# anywhere, and as long as they all have the right name, they will be
	# found.
	_ctrls.btn_continue = _get_first_child_named('Continue', self)
	_ctrls.path_dir = _get_first_child_named('Path', self)
	_ctrls.path_file = _get_first_child_named('File', self)
	_ctrls.prog_script = _get_first_child_named('ProgressScript', self)
	_ctrls.prog_test = _get_first_child_named('ProgressTest', self)
	_ctrls.rtl = _get_first_child_named('TestOutput', self)
	_ctrls.rtl_bg = _get_first_child_named('OutputBG', self)
	_ctrls.switch_modes = _get_first_child_named("SwitchModes", self)
	_ctrls.time_label = _get_first_child_named('TimeLabel', self)
	_ctrls.title = _get_first_child_named("Title", self)
	_ctrls.title_bar = _get_first_child_named("TitleBar", self)


func _get_first_child_named(obj_name, parent_obj):
	if(parent_obj == null):
		return null

	var kids = parent_obj.get_children()
	var index = 0
	var to_return = null

	while(index < kids.size() and to_return == null):
		if(str(kids[index]).find(str(obj_name, ':')) != -1):
			to_return = kids[index]
		else:
			to_return = _get_first_child_named(obj_name, kids[index])
			if(to_return == null):
				index += 1

	return to_return



# ------------------
# Events
# ------------------
func _on_title_bar_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_title_mouse.down):
			position += event.relative
			position.x = clamp(position.x, 0, _max_position.x)
			position.y = clamp(position.y, 0, _max_position.y)
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_title_mouse.down = event.pressed


func _on_continue_pressed():
	_gut.end_teardown_pause()


func _on_gut_start_run():
	if(_ctrls.rtl != null):
		_ctrls.rtl.clear()
	set_num_scripts(_gut.get_test_collector().scripts.size())


func _on_gut_end_run():
	_ctrls.prog_test.value = _ctrls.prog_test.max_value
	_ctrls.prog_script.value = _ctrls.prog_script.max_value


func _on_gut_start_script(script_obj):
	next_script(script_obj.get_full_name(), script_obj.tests.size())


func _on_gut_end_script():
	pass


func _on_gut_start_test(test_name):
	next_test(test_name)


func _on_gut_end_test():
	pass


func _on_gut_start_pause():
	pause_before_teardown()


func _on_gut_end_pause():
	_ctrls.btn_continue.visible = false


func _on_switch_modes_pressed():
	switch_modes.emit()

# ------------------
# Public
# ------------------
func set_num_scripts(val):
	_ctrls.prog_script.value = 0
	_ctrls.prog_script.max_value = val


func next_script(path, num_tests):
	_ctrls.prog_script.value += 1
	_ctrls.prog_test.value = 0
	_ctrls.prog_test.max_value = num_tests

	_ctrls.path_dir.text = path.get_base_dir()
	_ctrls.path_file.text = path.get_file()


func next_test(__test_name):
	_ctrls.prog_test.value += 1


func pause_before_teardown():
	_ctrls.btn_continue.visible = true


func set_gut(g):
	if(_gut == g):
		return
	_gut = g
	g.start_run.connect(_on_gut_start_run)
	g.end_run.connect(_on_gut_end_run)

	g.start_script.connect(_on_gut_start_script)
	g.end_script.connect(_on_gut_end_script)

	g.start_test.connect(_on_gut_start_test)
	g.end_test.connect(_on_gut_end_test)

	g.start_pause_before_teardown.connect(_on_gut_start_pause)
	g.end_pause_before_teardown.connect(_on_gut_end_pause)

func get_gut():
	return _gut

func get_textbox():
	return _ctrls.rtl

func set_elapsed_time(t):
	_ctrls.time_label.text = str("%6.1f" % t, 's')


func set_bg_color(c):
	_ctrls.rtl_bg.color = c


func set_title(text):
	_ctrls.title.text = text


func to_top_left():
	self.position = Vector2(5, 5)


func to_bottom_right():
	var win_size = get_display_size()
	self.position = win_size - Vector2(self.size) - Vector2(5, 5)


func align_right():
	var win_size = get_display_size()
	self.position.x = win_size.x - self.size.x -5
	self.position.y = 5
	self.size.y = win_size.y - 10


=====================================
FILE: ./addons/gut/gui/ShortcutButton.gd
=====================================
@tool
extends Control


@onready var _ctrls = {
	shortcut_label = $Layout/lblShortcut,
	set_button = $Layout/SetButton,
	save_button = $Layout/SaveButton,
	cancel_button = $Layout/CancelButton,
	clear_button = $Layout/ClearButton
}

signal changed
signal start_edit
signal end_edit

const NO_SHORTCUT = '<None>'

var _source_event = InputEventKey.new()
var _pre_edit_event = null
var _key_disp = NO_SHORTCUT
var _editing = false

var _modifier_keys = [KEY_ALT, KEY_CTRL, KEY_META, KEY_SHIFT]

# Called when the node enters the scene tree for the first time.
func _ready():
	set_process_unhandled_key_input(false)


func _display_shortcut():
	if(_key_disp == ''):
		_key_disp = NO_SHORTCUT
	_ctrls.shortcut_label.text = _key_disp


func _is_shift_only_modifier():
	return _source_event.shift_pressed and \
		!(_source_event.alt_pressed or \
			_source_event.ctrl_pressed or \
			_source_event.meta_pressed) \
		and !_is_modifier(_source_event.keycode)


func _has_modifier(event):
	return event.alt_pressed or event.ctrl_pressed or \
		event.meta_pressed or event.shift_pressed


func _is_modifier(keycode):
	return _modifier_keys.has(keycode)


func _edit_mode(should):
	_editing = should
	set_process_unhandled_key_input(should)
	_ctrls.set_button.visible = !should
	_ctrls.save_button.visible = should
	_ctrls.save_button.disabled = should
	_ctrls.cancel_button.visible = should
	_ctrls.clear_button.visible = !should

	if(should and to_s() == ''):
		_ctrls.shortcut_label.text = 'press buttons'
	else:
		_ctrls.shortcut_label.text = to_s()

	if(should):
		emit_signal("start_edit")
	else:
		emit_signal("end_edit")

# ---------------
# Events
# ---------------
func _unhandled_key_input(event):
	if(event is InputEventKey):
		if(event.pressed):
			if(_has_modifier(event) and !_is_modifier(event.get_keycode_with_modifiers())):
				_source_event = event
				_key_disp = OS.get_keycode_string(event.get_keycode_with_modifiers())
			else:
				_source_event = InputEventKey.new()
				_key_disp = NO_SHORTCUT
			_display_shortcut()
			_ctrls.save_button.disabled = !is_valid()


func _on_SetButton_pressed():
	_pre_edit_event = _source_event.duplicate(true)
	_edit_mode(true)


func _on_SaveButton_pressed():
	_edit_mode(false)
	_pre_edit_event = null
	emit_signal('changed')


func _on_CancelButton_pressed():
	cancel()


func _on_ClearButton_pressed():
	clear_shortcut()

# ---------------
# Public
# ---------------
func to_s():
	return OS.get_keycode_string(_source_event.get_keycode_with_modifiers())


func is_valid():
	return _has_modifier(_source_event) and !_is_shift_only_modifier()


func get_shortcut():
	var to_return = Shortcut.new()
	to_return.events.append(_source_event)
	return to_return


func set_shortcut(sc):
	if(sc == null or sc.events == null || sc.events.size() <= 0):
		clear_shortcut()
	else:
		_source_event = sc.events[0]
		_key_disp = to_s()
		_display_shortcut()


func clear_shortcut():
	_source_event = InputEventKey.new()
	_key_disp = NO_SHORTCUT
	_display_shortcut()


func disable_set(should):
	_ctrls.set_button.disabled = should


func disable_clear(should):
	_ctrls.clear_button.disabled = should
	
	
func cancel():
	if(_editing):
		_edit_mode(false)
		_source_event = _pre_edit_event
		_key_disp = to_s()
		_display_shortcut()


=====================================
FILE: ./addons/gut/gui/editor_globals.gd
=====================================
@tool

static var GutUserPreferences = load("res://addons/gut/gui/gut_user_preferences.gd")
static var temp_directory = 'user://gut_temp_directory'

static var editor_run_gut_config_path = 'gut_editor_config.json':
	# This avoids having to use path_join wherever we want to reference this
	# path.  The value is not supposed to change.  Could it be a constant
	# instead?  Probably, but I didn't like repeating the directory part.
	# Do I like that this is a bit witty.  Absolutely.
	get: return temp_directory.path_join(editor_run_gut_config_path)
	# Should this print a message or something instead?  Probably, but then I'd
	# be repeating even more code than if this was just a constant.  So I didn't,
	# even though I wanted to make the message a easter eggish fun message.
	# I didn't, so this dumb comment will have to serve as the easter eggish fun.
	set(v):
		print("Be sure to document your code.  Never trust comments.")


static var editor_run_bbcode_results_path = 'gut_editor.bbcode':
	get: return temp_directory.path_join(editor_run_bbcode_results_path)
	set(v): pass


static var editor_run_json_results_path = 'gut_editor.json':
	get: return temp_directory.path_join(editor_run_json_results_path)
	set(v): pass


static var editor_shortcuts_path = 'gut_editor_shortcuts.cfg' :
	get: return temp_directory.path_join(editor_shortcuts_path)
	set(v): pass


static var _user_prefs = null
static var user_prefs = _user_prefs :
	# workaround not being able to reference EditorInterface when not in
	# the editor.  This shouldn't be referenced by anything not in the
	# editor.
	get:
		if(_user_prefs == null and Engine.is_editor_hint()):
			_user_prefs = GutUserPreferences.new(EditorInterface.get_editor_settings())
		return _user_prefs


static func create_temp_directory():
	DirAccess.make_dir_recursive_absolute(temp_directory)



=====================================
FILE: ./addons/gut/gui/run_from_editor.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bgj3fm5d8yvjw"]

[ext_resource type="Script" path="res://addons/gut/gui/run_from_editor.gd" id="1_53pap"]

[node name="RunFromEditor" type="Node2D"]
script = ExtResource("1_53pap")


=====================================
FILE: ./addons/gut/signal_watcher.gd
=====================================
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

# Some arbitrary string that should never show up by accident.  If it does, then
# shame on  you.
const ARG_NOT_SET = '_*_argument_*_is_*_not_set_*_'

# This hash holds the objects that are being watched, the signals that are being
# watched, and an array of arrays that contains arguments that were passed
# each time the signal was emitted.
#
# For example:
#	_watched_signals => {
#		ref1 => {
#			'signal1' => [[], [], []],
#			'signal2' => [[p1, p2]],
#			'signal3' => [[p1]]
#		},
#		ref2 => {
#			'some_signal' => [],
#			'other_signal' => [[p1, p2, p3], [p1, p2, p3], [p1, p2, p3]]
#		}
#	}
#
# In this sample:
#	- signal1 on the ref1 object was emitted 3 times and each time, zero
#	parameters were passed.
#	- signal3 on ref1 was emitted once and passed a single parameter
#	- some_signal on ref2 was never emitted.
#	- other_signal on ref2 was emitted 3 times, each time with 3 parameters.
var _watched_signals = {}
var _lgr = GutUtils.get_logger()

func _add_watched_signal(obj, name):
	# SHORTCIRCUIT - ignore dupes
	if(_watched_signals.has(obj) and _watched_signals[obj].has(name)):
		return

	if(!_watched_signals.has(obj)):
		_watched_signals[obj] = {name:[]}
	else:
		_watched_signals[obj][name] = []
	obj.connect(name,Callable(self,'_on_watched_signal').bind(obj,name))

# This handles all the signals that are watched.  It supports up to 9 parameters
# which could be emitted by the signal and the two parameters used when it is
# connected via watch_signal.  I chose 9 since you can only specify up to 9
# parameters when dynamically calling a method via call (per the Godot
# documentation, i.e. some_object.call('some_method', 1, 2, 3...)).
#
# Based on the documentation of emit_signal, it appears you can only pass up
# to 4 parameters when firing a signal.  I haven't verified this, but this should
# future proof this some if the value ever grows.
func _on_watched_signal(arg1=ARG_NOT_SET, arg2=ARG_NOT_SET, arg3=ARG_NOT_SET, \
						arg4=ARG_NOT_SET, arg5=ARG_NOT_SET, arg6=ARG_NOT_SET, \
						arg7=ARG_NOT_SET, arg8=ARG_NOT_SET, arg9=ARG_NOT_SET, \
						arg10=ARG_NOT_SET, arg11=ARG_NOT_SET):
	var args = [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11]

	# strip off any unused vars.
	var idx = args.size() -1
	while(str(args[idx]) == ARG_NOT_SET):
		args.remove_at(idx)
		idx -= 1

	# retrieve object and signal name from the array and remove_at them.  These
	# will always be at the end since they are added when the connect happens.
	var signal_name = args[args.size() -1]
	args.pop_back()
	var object = args[args.size() -1]
	args.pop_back()

	if(_watched_signals.has(object)):
		_watched_signals[object][signal_name].append(args)
	else:
		_lgr.error(str("signal_watcher._on_watched_signal:  Got signal for unwatched object:  ", object, '::', signal_name))

# This parameter stuff should go into test.gd not here.  This thing works
# just fine the way it is.
func _obj_name_pair(obj_or_signal, signal_name=null):
	var to_return = {
		'object' : obj_or_signal,
		'signal_name' : signal_name
	}
	if(obj_or_signal is Signal):
		to_return.object =  obj_or_signal.get_object()
		to_return.signal_name = obj_or_signal.get_name()

	return to_return


func does_object_have_signal(object, signal_name):
	var signals = object.get_signal_list()
	for i in range(signals.size()):
		if(signals[i]['name'] == signal_name):
			return true
	return false

func watch_signals(object):
	var signals = object.get_signal_list()
	for i in range(signals.size()):
		_add_watched_signal(object, signals[i]['name'])

func watch_signal(object, signal_name):
	var did = false
	if(does_object_have_signal(object, signal_name)):
		_add_watched_signal(object, signal_name)
		did = true
	else:
		GutUtils.get_logger().warn(str(object, ' does not have signal ', signal_name))
	return did

func get_emit_count(object, signal_name):
	var to_return = -1
	if(is_watching(object, signal_name)):
		to_return = _watched_signals[object][signal_name].size()
	return to_return

func did_emit(object, signal_name=null):
	var vals = _obj_name_pair(object, signal_name)
	var did = false
	if(is_watching(vals.object, vals.signal_name)):
		did = get_emit_count(vals.object, vals.signal_name) != 0
	return did

func print_object_signals(object):
	var list = object.get_signal_list()
	for i in range(list.size()):
		print(list[i].name, "\n  ", list[i])

func get_signal_parameters(object, signal_name, index=-1):
	var params = null
	if(is_watching(object, signal_name)):
		var all_params = _watched_signals[object][signal_name]
		if(all_params.size() > 0):
			if(index == -1):
				index = all_params.size() -1
			params = all_params[index]
	return params

func is_watching_object(object):
	return _watched_signals.has(object)

func is_watching(object, signal_name):
	return _watched_signals.has(object) and _watched_signals[object].has(signal_name)

func clear():
	for obj in _watched_signals:
		if(GutUtils.is_not_freed(obj)):
			for signal_name in _watched_signals[obj]:
				obj.disconnect(signal_name, Callable(self,'_on_watched_signal'))
	_watched_signals.clear()

# Returns a list of all the signal names that were emitted by the object.
# If the object is not being watched then an empty list is returned.
func get_signals_emitted(obj):
	var emitted = []
	if(is_watching_object(obj)):
		for signal_name in _watched_signals[obj]:
			if(_watched_signals[obj][signal_name].size() > 0):
				emitted.append(signal_name)

	return emitted


func get_signal_summary(obj):
	var emitted = {}
	if(is_watching_object(obj)):
		for signal_name in _watched_signals[obj]:
			if(_watched_signals[obj][signal_name].size() > 0):
				# maybe this could return parameters if any were sent.  should
				# have an empty list if no parameters were ever sent to the
				# signal.  Or this all just gets moved into print_signal_summary
				# since this wouldn't be that useful without more data in the
				# summary.
				var entry = {
					emit_count = get_emit_count(obj, signal_name)
				}
				emitted[signal_name] = entry

	return emitted


func print_signal_summary(obj):
	if(!is_watching_object(obj)):
		var msg = str('Not watching signals for ', obj)
		GutUtils.get_logger().warn(msg)
		return

	var summary = get_signal_summary(obj)
	print(obj, '::Signals')
	var sorted = summary.keys()
	sorted.sort()
	for key in sorted:
		print(' -  ', key, ' x ', summary[key].emit_count)


=====================================
FILE: ./addons/gut/gut_to_move.gd
=====================================
# Temporary base script for gut.gd to hold the things to be remvoed and added
# to some utility somewhere.
extends Node

# ------------------------------------------------------------------------------
# deletes all files in a given directory
# ------------------------------------------------------------------------------
func directory_delete_files(path):
	var d = DirAccess.open(path)

	# SHORTCIRCUIT
	if(d == null):
		return

	# Traversing a directory is kinda odd.  You have to start the process of listing
	# the contents of a directory with list_dir_begin then use get_next until it
	# returns an empty string.  Then I guess you should end it.
	d.list_dir_begin() # TODOGODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547
	var thing = d.get_next() # could be a dir or a file or something else maybe?
	var full_path = ''
	while(thing != ''):
		full_path = path + "/" + thing
		# file_exists returns fasle for directories
		if(d.file_exists(full_path)):
			d.remove(full_path)
		thing = d.get_next()

	d.list_dir_end()

# ------------------------------------------------------------------------------
# deletes the file at the specified path
# ------------------------------------------------------------------------------
func file_delete(path):
	var d = DirAccess.open(path.get_base_dir())
	if(d != null):
		d.remove(path)

# ------------------------------------------------------------------------------
# Checks to see if the passed in file has any data in it.
# ------------------------------------------------------------------------------
func is_file_empty(path):
	var f = FileAccess.open(path, FileAccess.READ)
	var result = FileAccess.get_open_error()
	var empty = true
	if(result == OK):
		empty = f.get_length() == 0
	f = null
	return empty

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_file_as_text(path):
	return GutUtils.get_file_as_text(path)

# ------------------------------------------------------------------------------
# Creates an empty file at the specified path
# ------------------------------------------------------------------------------
func file_touch(path):
	FileAccess.open(path, FileAccess.WRITE)

# ------------------------------------------------------------------------------
# Simulate a number of frames by calling '_process' and '_physics_process' (if
# the methods exist) on an object and all of its descendents. The specified frame
# time, 'delta', will be passed to each simulated call.
#
# NOTE: Objects can disable their processing methods using 'set_process(false)' and
# 'set_physics_process(false)'. This is reflected in the 'Object' methods
# 'is_processing()' and 'is_physics_processing()', respectively. To make 'simulate'
# respect this status, for example if you are testing an object which toggles
# processing, pass 'check_is_processing' as 'true'.
# ------------------------------------------------------------------------------
func simulate(obj, times, delta, check_is_processing: bool = false):
	for _i in range(times):
		if (
			obj.has_method("_process")
			and (
				not check_is_processing
				or obj.is_processing()
			)
		):
			obj._process(delta)
		if(
			obj.has_method("_physics_process")
			and (
				not check_is_processing
				or obj.is_physics_processing()
			)
		):
			obj._physics_process(delta)

		for kid in obj.get_children():
			simulate(kid, 1, delta, check_is_processing)


=====================================
FILE: ./addons/gut/UserFileViewer.gd
=====================================
extends Window

@onready var rtl = $TextDisplay/RichTextLabel

func _get_file_as_text(path):
	var to_return = null
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	else:
		to_return = str('ERROR:  Could not open file.  Error code ', FileAccess.get_open_error())
	return to_return

func _ready():
	rtl.clear()

func _on_OpenFile_pressed():
	$FileDialog.popup_centered()

func _on_FileDialog_file_selected(path):
	show_file(path)

func _on_Close_pressed():
	self.hide()

func show_file(path):
	var text = _get_file_as_text(path)
	if(text == ''):
		text = '<Empty File>'
	rtl.set_text(text)
	self.window_title = path

func show_open():
	self.popup_centered()
	$FileDialog.popup_centered()

func get_rich_text_label():
	return $TextDisplay/RichTextLabel

func _on_Home_pressed():
	rtl.scroll_to_line(0)

func _on_End_pressed():
	rtl.scroll_to_line(rtl.get_line_count() -1)

func _on_Copy_pressed():
	return
	# OS.clipboard = rtl.text

func _on_file_dialog_visibility_changed():
	if rtl.text.length() == 0 and not $FileDialog.visible:
		self.hide()


=====================================
FILE: ./addons/gut/stub_params.gd
=====================================

var _lgr = GutUtils.get_logger()
var logger = _lgr :
	get: return _lgr
	set(val): _lgr = val

var return_val = null
var stub_target = null
# the parameter values to match method call on.
var parameters = null
var stub_method = null
var call_super = false
var call_this = null
# Whether this is a stub for default parameter values as they are defined in
# the script, and not an overridden default value.
var is_script_default = false

# -- Paramter Override --
# Parmater overrides are stored in here along with all the other stub info
# so that you can chain stubbing parameter overrides along with all the
# other stubbing.  This adds some complexity to the logic that tries to
# find the correct stub for a call by a double.  Since an instance of this
# class could be just a parameter override, or it could have been chained
# we have to have _paramter_override_only so that we know when to tell the
# difference.
var parameter_count = -1
var parameter_defaults = null
# Anything that would make this stub not just an override of paramters
# must set this flag to false.  This must be private bc the actual logic
# to determine if this stub is only an override is more complicated.
var _parameter_override_only = true
# --

const NOT_SET = '|_1_this_is_not_set_1_|'

func _init(target=null, method=null, _subpath=null):
	stub_target = target
	stub_method = method

	if(typeof(target) == TYPE_CALLABLE):
		stub_target = target.get_object()
		stub_method = target.get_method()
		parameters = target.get_bound_arguments()
		if(parameters.size() == 0):
			parameters = null
	elif(typeof(target) == TYPE_STRING):
		if(target.is_absolute_path()):
			stub_target = load(str(target))
		else:
			_lgr.warn(str(target, ' is not a valid path'))

	if(stub_target is PackedScene):
		stub_target = GutUtils.get_scene_script_object(stub_target)

	# this is used internally to stub default parameters for everything that is
	# doubled...or something.  Look for stub_defaults_from_meta for usage.  This
	# behavior is not to be used by end users.
	if(typeof(method) == TYPE_DICTIONARY):
		_load_defaults_from_metadata(method)


func _load_defaults_from_metadata(meta):
	stub_method = meta.name
	var values = meta.default_args.duplicate()
	while (values.size() < meta.args.size()):
		values.push_front(null)

	param_defaults(values)


func to_return(val):
	if(stub_method == '_init'):
		_lgr.error("You cannot stub _init to do nothing.  Super's _init is always called.")
	else:
		return_val = val
		call_super = false
		_parameter_override_only = false
	return self


func to_do_nothing():
	to_return(null)
	return self


func to_call_super():
	call_super = true
	_parameter_override_only = false
	return self


func to_call(callable : Callable):
	call_this = callable
	return self


func when_passed(p1=NOT_SET,p2=NOT_SET,p3=NOT_SET,p4=NOT_SET,p5=NOT_SET,p6=NOT_SET,p7=NOT_SET,p8=NOT_SET,p9=NOT_SET,p10=NOT_SET):
	parameters = [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10]
	var idx = 0
	while(idx < parameters.size()):
		if(str(parameters[idx]) == NOT_SET):
			parameters.remove_at(idx)
		else:
			idx += 1
	return self


func param_count(x):
	parameter_count = x
	return self


func param_defaults(values):
	parameter_count = values.size()
	parameter_defaults = values
	return self


func has_param_override():
	return parameter_count != -1


func is_param_override_only():
	var ret_val = false
	if(has_param_override()):
		ret_val = _parameter_override_only
	return ret_val


func to_s():
	var base_string = str(stub_target, '.', stub_method)

	if(has_param_override()):
		base_string += str(' (param count override=', parameter_count, ' defaults=', parameter_defaults)
		if(is_param_override_only()):
			base_string += " ONLY"
		if(is_script_default):
			base_string += " script default"
		base_string += ') '

	if(call_super):
		base_string += " to call SUPER"

	if(call_this != null):
		base_string += str(" to call ", call_this)

	if(parameters != null):
		base_string += str(' with params (', parameters, ') returns ', return_val)
	else:
		base_string += str(' returns ', return_val)

	return base_string


=====================================
FILE: ./addons/gut/method_maker.gd
=====================================
class CallParameters:
	var p_name = null
	var default = null

	func _init(n,d):
		p_name = n
		default = d


# ------------------------------------------------------------------------------
# This class will generate method declaration lines based on method meta
# data.  It will create defaults that match the method data.
#
# --------------------
# function meta data
# --------------------
# name:
# flags:
# args: [{
# 	(class_name:),
# 	(hint:0),
# 	(hint_string:),
# 	(name:),
# 	(type:4),
# 	(usage:7)
# }]
# default_args []

var _lgr = GutUtils.get_logger()
var default_vararg_arg_count = 10
const PARAM_PREFIX = 'p_'

# ------------------------------------------------------
# _supported_defaults
#
# This array contains all the data types that are supported for default values.
# If a value is supported it will contain either an empty string or a prefix
# that should be used when setting the parameter default value.
# For example int, real, bool do not need anything func(p1=1, p2=2.2, p3=false)
# but things like Vectors and Colors do since only the parameters to create a
# new Vector or Color are included in the metadata.
# ------------------------------------------------------
	# TYPE_NIL = 0 — Variable is of type nil (only applied for null).
	# TYPE_BOOL = 1 — Variable is of type bool.
	# TYPE_INT = 2 — Variable is of type int.
	# TYPE_FLOAT = 3 — Variable is of type float/real.
	# TYPE_STRING = 4 — Variable is of type String.
	# TYPE_VECTOR2 = 5 — Variable is of type Vector2.
	# TYPE_RECT2 = 6 — Variable is of type Rect2.
	# TYPE_VECTOR3 = 7 — Variable is of type Vector3.
	# TYPE_COLOR = 14 — Variable is of type Color.
	# TYPE_OBJECT = 17 — Variable is of type Object.
	# TYPE_DICTIONARY = 18 — Variable is of type Dictionary.
	# TYPE_ARRAY = 19 — Variable is of type Array.
	# TYPE_PACKED_VECTOR2_ARRAY = 24 — Variable is of type PackedVector2Array.
	# TYPE_TRANSFORM3D = 13 — Variable is of type Transform3D.
	# TYPE_TRANSFORM2D = 8 — Variable is of type Transform2D.
	# TYPE_RID = 16 — Variable is of type RID.
	# TYPE_PACKED_INT32_ARRAY = 21 — Variable is of type PackedInt32Array.
	# TYPE_PACKED_FLOAT32_ARRAY = 22 — Variable is of type PackedFloat32Array.
	# TYPE_PACKED_STRING_ARRAY = 23 — Variable is of type PackedStringArray.


# TYPE_PLANE = 9 — Variable is of type Plane.
# TYPE_QUATERNION = 10 — Variable is of type Quaternion.
# TYPE_AABB = 11 — Variable is of type AABB.
# TYPE_BASIS = 12 — Variable is of type Basis.
# TYPE_NODE_PATH = 15 — Variable is of type NodePath.
# TYPE_PACKED_BYTE_ARRAY = 20 — Variable is of type PackedByteArray.
# TYPE_PACKED_VECTOR3_ARRAY = 25 — Variable is of type PackedVector3Array.
# TYPE_PACKED_COLOR_ARRAY = 26 — Variable is of type PackedColorArray.
# TYPE_MAX = 27 — Marker for end of type constants.
# ------------------------------------------------------
var _supported_defaults = []

func _init():
	for _i in range(TYPE_MAX):
		_supported_defaults.append(null)

	# These types do not require a prefix for defaults
	_supported_defaults[TYPE_NIL] = ''
	_supported_defaults[TYPE_BOOL] = ''
	_supported_defaults[TYPE_INT] = ''
	_supported_defaults[TYPE_FLOAT] = ''
	_supported_defaults[TYPE_OBJECT] = ''
	_supported_defaults[TYPE_ARRAY] = ''
	_supported_defaults[TYPE_STRING] = ''
	_supported_defaults[TYPE_STRING_NAME] = ''
	_supported_defaults[TYPE_DICTIONARY] = ''
	_supported_defaults[TYPE_PACKED_VECTOR2_ARRAY] = ''
	_supported_defaults[TYPE_RID] = ''

	# These require a prefix for whatever default is provided
	_supported_defaults[TYPE_VECTOR2] = 'Vector2'
	_supported_defaults[TYPE_VECTOR2I] = 'Vector2i'
	_supported_defaults[TYPE_RECT2] = 'Rect2'
	_supported_defaults[TYPE_RECT2I] = 'Rect2i'
	_supported_defaults[TYPE_VECTOR3] = 'Vector3'
	_supported_defaults[TYPE_COLOR] = 'Color'
	_supported_defaults[TYPE_TRANSFORM2D] = 'Transform2D'
	_supported_defaults[TYPE_TRANSFORM3D] = 'Transform3D'
	_supported_defaults[TYPE_PACKED_INT32_ARRAY] = 'PackedInt32Array'
	_supported_defaults[TYPE_PACKED_FLOAT32_ARRAY] = 'PackedFloat32Array'
	_supported_defaults[TYPE_PACKED_STRING_ARRAY] = 'PackedStringArray'

# ###############
# Private
# ###############
var _func_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/function_template.txt')
var _init_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/init_template.txt')

func _is_supported_default(type_flag):
	return type_flag >= 0 and type_flag < _supported_defaults.size() and _supported_defaults[type_flag] != null


func _make_stub_default(method, index):
	return str('__gutdbl.default_val("', method, '",', index, ')')


func _make_arg_array(method_meta, override_size):
	var to_return = []

	var has_unsupported_defaults = false

	for i in range(method_meta.args.size()):
		var pname = method_meta.args[i].name
		var dflt_text = _make_stub_default(method_meta.name, i)
		to_return.append(CallParameters.new(PARAM_PREFIX + pname, dflt_text))

	var extra_params = GutUtils.nvl(override_size, 0)
	if(extra_params == 0):
		if(method_meta.flags & METHOD_FLAG_VARARG):
			extra_params = default_vararg_arg_count

	# Add in extra parameters from stub settings.
	if(extra_params > 0):
		for i in range(method_meta.args.size(), extra_params):
			var pname = str(PARAM_PREFIX, 'arg', i)
			var dflt_text = _make_stub_default(method_meta.name, i)
			to_return.append(CallParameters.new(pname, dflt_text))

	return [has_unsupported_defaults, to_return];


# Creates a list of parameters with defaults of null unless a default value is
# found in the metadata.  If a default is found in the meta then it is used if
# it is one we know how support.
#
# If a default is found that we don't know how to handle then this method will
# return null.
func _get_arg_text(arg_array):
	var text = ''

	for i in range(arg_array.size()):
		text += str(arg_array[i].p_name, '=', arg_array[i].default)
		if(i != arg_array.size() -1):
			text += ', '

	return text


# creates a call to the function in meta in the super's class.
func _get_super_call_text(method_name, args):
	var params = ''
	for i in range(args.size()):
		params += args[i].p_name
		if(i != args.size() -1):
			params += ', '

	return str('await super(', params, ')')


func _get_spy_call_parameters_text(args):
	var called_with = 'null'

	if(args.size() > 0):
		called_with = '['
		for i in range(args.size()):
			called_with += args[i].p_name
			if(i < args.size() - 1):
				called_with += ', '
		called_with += ']'

	return called_with


# ###############
# Public
# ###############

func _get_init_text(meta, args, method_params, param_array):
	var text = null

	var decleration = str('func ', meta.name, '(', method_params, ')')
	var super_params = ''
	if(args.size() > 0):
		for i in range(args.size()):
			super_params += args[i].p_name
			if(i != args.size() -1):
				super_params += ', '

	text = _init_text.format({
		"func_decleration":decleration,
		"super_params":super_params,
		"param_array":param_array,
		"method_name":meta.name,
	})

	return text


# Creates a delceration for a function based off of function metadata.  All
# types whose defaults are supported will have their values.  If a datatype
# is not supported and the parameter has a default, a warning message will be
# printed and the declaration will return null.
func get_function_text(meta, override_size=null):
	var method_params = ''
	var text = null
	var result = _make_arg_array(meta, override_size)
	var has_unsupported = result[0]
	var args = result[1]
	var vararg_warning = ""

	var param_array = _get_spy_call_parameters_text(args)
	if(has_unsupported):
		# This will cause a runtime error.  This is the most convenient way to
		# to stop running before the error gets more obscure.  _make_arg_array
		# generates a gut error when unsupported defaults are found.
		method_params = null
	else:
		method_params = _get_arg_text(args);

	if(param_array == 'null'):
		param_array = '[]'

	if(meta.flags & METHOD_FLAG_VARARG and override_size == null):
		vararg_warning = "__gutdbl.vararg_warning()\n\t"

	if(method_params != null):
		if(meta.name == '_init'):
			text =  _get_init_text(meta, args, method_params, param_array)
		else:
			var decleration = str('func ', meta.name, '(', method_params, '):')
			text = _func_text.format({
				"func_decleration":decleration,
				"method_name":meta.name,
				"param_array":param_array,
				"super_call":_get_super_call_text(meta.name, args),
				"vararg_warning":vararg_warning,
			})

	return text


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


=====================================
FILE: ./addons/gut/spy.gd
=====================================
# {
#   instance_id_or_path1:{
#       method1:[ [p1, p2], [p1, p2] ],
#       method2:[ [p1, p2], [p1, p2] ]
#   },
#   instance_id_or_path1:{
#       method1:[ [p1, p2], [p1, p2] ],
#       method2:[ [p1, p2], [p1, p2] ]
#   },
# }
var _calls = {}
var _lgr = GutUtils.get_logger()
var _compare = GutUtils.Comparator.new()

func _find_parameters(call_params, params_to_find):
	var found = false
	var idx = 0
	while(idx < call_params.size() and !found):
		var result = _compare.deep(call_params[idx], params_to_find)
		if(result.are_equal):
			found = true
		else:
			idx += 1
	return found


func _get_params_as_string(params):
	var to_return = ''
	if(params == null):
		return ''

	for i in range(params.size()):
		if(params[i] == null):
			to_return += 'null'
		else:
			if(typeof(params[i]) == TYPE_STRING):
				to_return += str('"', params[i], '"')
			else:
				to_return += str(params[i])
		if(i != params.size() -1):
			to_return += ', '
	return to_return


func add_call(variant, method_name, parameters=null):
	if(!_calls.has(variant)):
		_calls[variant] = {}

	if(!_calls[variant].has(method_name)):
		_calls[variant][method_name] = []

	_calls[variant][method_name].append(parameters)


func was_called(variant, method_name, parameters=null):
	var to_return = false
	if(_calls.has(variant) and _calls[variant].has(method_name)):
		if(parameters):
			to_return = _find_parameters(_calls[variant][method_name], parameters)
		else:
			to_return = true
	return to_return


func get_call_parameters(variant, method_name, index=-1):
	var to_return = null
	var get_index = -1

	if(_calls.has(variant) and _calls[variant].has(method_name)):
		var call_size = _calls[variant][method_name].size()
		if(index == -1):
			# get the most recent call by default
			get_index =  call_size -1
		else:
			get_index = index

		if(get_index < call_size):
			to_return = _calls[variant][method_name][get_index]
		else:
			_lgr.error(str('Specified index ', index, ' is outside range of the number of registered calls:  ', call_size))

	return to_return


func call_count(instance, method_name, parameters=null):
	var to_return = 0

	if(was_called(instance, method_name)):
		if(parameters):
			for i in range(_calls[instance][method_name].size()):
				if(_calls[instance][method_name][i] == parameters):
					to_return += 1
		else:
			to_return = _calls[instance][method_name].size()
	return to_return


func clear():
	_calls = {}


func get_call_list_as_string(instance):
	var to_return = ''
	if(_calls.has(instance)):
		for method in _calls[instance]:
			for i in range(_calls[instance][method].size()):
				to_return += str(method, '(', _get_params_as_string(_calls[instance][method][i]), ")\n")
	return to_return


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


=====================================
FILE: ./addons/gut/gut_cmdln.gd
=====================================
# ------------------------------------------------------------------------------
# Description
# -----------
# Entry point for the command line interface.  The actual logic for GUT's CLI
# is in addons/gut/cli/gut_cli.gd.
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
extends SceneTree

var VersionConversion = load("res://addons/gut/version_conversion.gd")

@warning_ignore("unsafe_method_access")
@warning_ignore("inferred_declaration")
func _init() -> void:
	if(VersionConversion.error_if_not_all_classes_imported()):
		quit(0)
		return

	var max_iter := 20
	var iter := 0

	var Loader : Object = load("res://addons/gut/gut_loader.gd")

	# Not seen this wait more than 1.
	while(Engine.get_main_loop() == null and iter < max_iter):
		await create_timer(.01).timeout
		iter += 1

	if(Engine.get_main_loop() == null):
		push_error('Main loop did not start in time.')
		quit(0)
		return

	var cli : Node = load('res://addons/gut/cli/gut_cli.gd').new()
	get_root().add_child(cli)

	Loader.restore_ignore_addons()
	cli.main()




# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/test.gd
=====================================
class_name GutTest
extends Node
## This is the base class for your GUT test scripts.[br]
## [br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br]
## Simple Example
## [codeblock]
##    extends GutTest
##
##    func before_all():
##        gut.p("before_all called"
##
##    func before_each():
##        gut.p("before_each called")
##
##    func after_each():
##        gut.p("after_each called")
##
##    func after_all():
##        gut.p("after_all called")
##
##    func test_assert_eq_letters():
##        assert_eq("asdf", "asdf", "Should pass")
##
##    func test_assert_eq_number_not_equal():
##        assert_eq(1, 2, "Should fail.  1 != 2")
## [/codeblock]


# Normalizes p1 and p2 into object/signal_name/signal_ref(sig).  Additional
# parameters are optional and will be placed into the others array.  This
# class is used in refactoring signal methods to accept a reference to the
# signal instead an object and the signal name.
class SignalAssertParameters:
	var object = null
	var signal_name = null
	var sig = null
	var others := []

	func _init(p1, p2, p3=null, p4=null, p5=null, p6=null):
		others = [p3, p4, p5, p6]
		if(p1 is Signal):
			object = p1.get_object()
			signal_name = p1.get_name()
			others.push_front(p2)
			sig = p1
		else:
			object = p1
			signal_name = p2
			sig = object.get(signal_name)


const EDITOR_PROPERTY = PROPERTY_USAGE_SCRIPT_VARIABLE | PROPERTY_USAGE_DEFAULT
const VARIABLE_PROPERTY = PROPERTY_USAGE_SCRIPT_VARIABLE
# Convenience copy of GutUtils.DOUBLE_STRATEGY
var DOUBLE_STRATEGY = GutUtils.DOUBLE_STRATEGY

## Reference to [addons/gut/parameter_factory.gd] script.
var ParameterFactory = GutUtils.ParameterFactory
## @ignore
var CompareResult = GutUtils.CompareResult
## Reference to [GutInputFactory] class that was originally used to reference
## the Input Factory before the class_name was introduced.
var InputFactory = GutInputFactory
## Reference to [GutInputSender].  This was the way you got to the [GutInputSender]
## before it was given a [code]class_name[/code]
var InputSender = GutUtils.InputSender

# Need a reference to the instance that is running the tests.  This
# is set by the gut class when it runs the test script.
var gut: GutMain = null


var _compare = GutUtils.Comparator.new()
var _disable_strict_datatype_checks = false
# Holds all the text for a test's fail/pass.  This is used for testing purposes
# to see the text of a failed sub-test in test_test.gd
var _fail_pass_text = []
# Summary counts for the test.
var _summary = {
	asserts = 0,
	passed = 0,
	failed = 0,
	tests = 0,
	pending = 0
}
# This is used to watch signals so we can make assertions about them.
var _signal_watcher = load('res://addons/gut/signal_watcher.gd').new()
var _lgr = GutUtils.get_logger()
var _strutils = GutUtils.Strutils.new()
var _awaiter = null
var _was_ready_called = false

# I haven't decided if we should be using _ready or not.  Right now gut.gd will
# call this if _ready was not called (because it was overridden without a super
# call).  Maybe gut.gd should just call _do_ready_stuff (after we rename it to
# something better).  I'm leaving all this as it is until it bothers me more.
func _do_ready_stuff():
	_awaiter = GutUtils.Awaiter.new()
	add_child(_awaiter)
	_was_ready_called = true


func _ready():
	_do_ready_stuff()


func _notification(what):
	# Tests are never expected to re-enter the tree.  Tests are removed from the
	# tree after they are run.
	if(what == NOTIFICATION_EXIT_TREE):
		_awaiter.queue_free()


#region Private
# ----------------


func _str(thing):
	return _strutils.type2str(thing)


func _str_precision(value, precision):
	var to_return = _str(value)
	var format = str('%.', precision, 'f')
	if(typeof(value) == TYPE_FLOAT):
		to_return = format % value
	elif(typeof(value) == TYPE_VECTOR2):
		to_return = str('VECTOR2(', format % value.x, ', ', format %value.y, ')')
	elif(typeof(value) == TYPE_VECTOR3):
		to_return = str('VECTOR3(', format % value.x, ', ', format %value.y, ', ', format % value.z, ')')

	return to_return


# Fail an assertion.  Causes test and script to fail as well.
func _fail(text):
	_summary.asserts += 1
	_summary.failed += 1
	_fail_pass_text.append('failed:  ' + text)
	if(gut):
		_lgr.failed(gut.get_call_count_text() + text)
		gut._fail(text)


# Pass an assertion.
func _pass(text):
	_summary.asserts += 1
	_summary.passed += 1
	_fail_pass_text.append('passed:  ' + text)
	if(gut):
		_lgr.passed(text)
		gut._pass(text)


# Checks if the datatypes passed in match.  If they do not then this will cause
# a fail to occur.  If they match then TRUE is returned, FALSE if not.  This is
# used in all the assertions that compare values.
func _do_datatypes_match__fail_if_not(got, expected, text):
	var did_pass = true

	if(!_disable_strict_datatype_checks):
		var got_type = typeof(got)
		var expect_type = typeof(expected)
		if(got_type != expect_type and got != null and expected != null):
			# If we have a mismatch between float and int (types 2 and 3) then
			# print out a warning but do not fail.
			if([2, 3].has(got_type) and [2, 3].has(expect_type)):
				_lgr.warn(str('Warn:  Float/Int comparison.  Got ', _strutils.types[got_type],
					' but expected ', _strutils.types[expect_type]))
			elif([TYPE_STRING, TYPE_STRING_NAME].has(got_type) and [TYPE_STRING, TYPE_STRING_NAME].has(expect_type)):
				pass
			else:
				_fail('Cannot compare ' + _strutils.types[got_type] + '[' + _str(got) + '] to ' + \
					_strutils.types[expect_type] + '[' + _str(expected) + '].  ' + text)
				did_pass = false

	return did_pass


# Create a string that lists all the methods that were called on an spied
# instance.
func _get_desc_of_calls_to_instance(inst):
	var BULLET = '  * '
	var calls = gut.get_spy().get_call_list_as_string(inst)
	# indent all the calls
	calls = BULLET + calls.replace("\n", "\n" + BULLET)
	# remove_at trailing newline and bullet
	calls = calls.substr(0, calls.length() - BULLET.length() - 1)
	return "Calls made on " + str(inst) + "\n" + calls



# Signal assertion helper.  Do not call directly, use _can_make_signal_assertions
func _fail_if_does_not_have_signal(object, signal_name):
	var did_fail = false
	if(!_signal_watcher.does_object_have_signal(object, signal_name)):
		_fail(str('Object ', object, ' does not have the signal [', signal_name, ']'))
		did_fail = true
	return did_fail


# Signal assertion helper.  Do not call directly, use _can_make_signal_assertions
func _fail_if_not_watching(object):
	var did_fail = false
	if(!_signal_watcher.is_watching_object(object)):
		_fail(str('Cannot make signal assertions because the object ', object, \
				' is not being watched.  Call watch_signals(some_object) to be able to make assertions about signals.'))
		did_fail = true
	return did_fail


# Returns text that contains original text and a list of all the signals that
# were emitted for the passed in object.
func _get_fail_msg_including_emitted_signals(text, object):
	return str(text," (Signals emitted: ", _signal_watcher.get_signals_emitted(object), ")")


# This validates that parameters is an array and generates a specific error
# and a failure with a specific message
func _fail_if_parameters_not_array(parameters):
	var invalid = parameters != null and typeof(parameters) != TYPE_ARRAY
	if(invalid):
		_lgr.error('The "parameters" parameter must be an array of expected parameter values.')
		_fail('Cannot compare parameter values because an array was not passed.')
	return invalid


# A bunch of common checkes used when validating a double/method pair.  If
# everything is ok then an empty string is returned, otherwise the message
# is returned.
func _get_bad_double_or_method_message(inst, method_name, what_you_cant_do):
	var to_return = ''

	if(!GutUtils.is_double(inst)):
		to_return = str("An instance of a Double was expected, you passed:  ", _str(inst))
	elif(!inst.has_method(method_name)):
		to_return = str("You cannot ", what_you_cant_do, " [", method_name, "] because the method does not exist.  ",
			"This can happen if the method is virtual and not overloaded (i.e. _ready) ",
			"or you have mistyped the name of the method.")
	elif(!inst.__gutdbl_values.doubled_methods.has(method_name)):
		to_return = str("You cannot ", what_you_cant_do, " [", method_name, "] because ",
			_str(inst), ' does not overload it or it was ignored with ',
			'ignore_method_when_doubling.  See Doubling ',
			'Strategy in the wiki for details on including non-overloaded ',
			'methods in a double.')

	return to_return


func _fail_if_not_double_or_does_not_have_method(inst, method_name):
	var to_return = OK

	var msg = _get_bad_double_or_method_message(inst, method_name, 'spy on')
	if(msg != ''):
		_fail(msg)
		to_return = ERR_INVALID_DATA

	return to_return


func _create_obj_from_type(type):
	var obj = null
	if type.is_class("PackedScene"):
		obj = type.instantiate()
		add_child(obj)
	else:
		obj = type.new()
	return obj


# Converts a Callabe passed through inst or inst/method_name/parameters into a
# hash so that methods that interact with Spy can accept both more easily.
func _convert_spy_args(inst, method_name, parameters):
	var to_return = {
		'object':inst,
		'method_name':method_name,
		'arguments':parameters,
		'invalid_message':'ok'
	}

	if(inst is Callable):
		if(parameters != null):
			to_return.invalid_message =\
				"3rd parameter to assert_called not supported when using a Callable."
		elif(method_name != null):
			to_return.invalid_message =\
				"2nd parameter to assert_called not supported when using a Callable."
		else:
			if(inst.get_bound_arguments_count() > 0):
				to_return.arguments = inst.get_bound_arguments()
			to_return.method_name = inst.get_method()
			to_return.object = inst.get_object()

	return to_return


func _get_typeof_string(the_type):
	var to_return = ""
	if(_strutils.types.has(the_type)):
		to_return += str(the_type, '(',  _strutils.types[the_type], ')')
	else:
		to_return += str(the_type)
	return to_return


# Validates the singleton_name is a string and exists.  Errors when conditions
# are not met.  Returns true/false if singleton_name is valid or not.
func _validate_singleton_name(singleton_name):
	var is_valid = true
	if(typeof(singleton_name) != TYPE_STRING):
		_lgr.error("double_singleton requires a Godot singleton name, you passed " + _str(singleton_name))
		is_valid = false
	# Sometimes they have underscores in front of them, sometimes they do not.
	# The doubler is smart enought of ind the right thing, so this has to be
	# that smart as well.
	elif(!ClassDB.class_exists(singleton_name) and !ClassDB.class_exists('_' + singleton_name)):
		var txt = str("The singleton [", singleton_name, "] could not be found.  ",
					"Check the GlobalScope page for a list of singletons.")
		_lgr.error(txt)
		is_valid = false
	return is_valid


# Checks the object for 'get_' and 'set_' methods for the specified property.
# If found a warning is generated.
func _warn_for_public_accessors(obj, property_name):
	var public_accessors = []
	var accessor_names = [
		str('get_', property_name),
		str('is_', property_name),
		str('set_', property_name)
	]

	for acc in accessor_names:
		if(obj.has_method(acc)):
			public_accessors.append(acc)

	if(public_accessors.size() > 0):
		_lgr.warn (str('Public accessors ', public_accessors, ' found for property ', property_name))


func _smart_double(thing, double_strat, partial):
	var override_strat = GutUtils.nvl(double_strat, gut.get_doubler().get_strategy())
	var to_return = null

	if(thing is PackedScene):
		if(partial):
			to_return =  gut.get_doubler().partial_double_scene(thing, override_strat)
		else:
			to_return =  gut.get_doubler().double_scene(thing, override_strat)

	elif(GutUtils.is_native_class(thing)):
		if(partial):
			to_return = gut.get_doubler().partial_double_gdnative(thing)
		else:
			to_return = gut.get_doubler().double_gdnative(thing)

	elif(thing is GDScript):
		if(partial):
			to_return = gut.get_doubler().partial_double(thing, override_strat)
		else:
			to_return = gut.get_doubler().double(thing, override_strat)

	return to_return


# This is here to aid in the transition to the new doubling sytnax.  Once this
# has been established it could be removed.  We must keep the is_instance check
# going forward though.
func _are_double_parameters_valid(thing, p2, p3):
	var bad_msg = ""
	if(p3 != null or typeof(p2) == TYPE_STRING):
		bad_msg += "Doubling using a subpath is not supported.  Call register_inner_class and then pass the Inner Class to double().\n"

	if(typeof(thing) == TYPE_STRING):
		bad_msg += "Doubling using the path to a script or scene is no longer supported.  Load the script or scene and pass that to double instead.\n"

	if(GutUtils.is_instance(thing)):
		bad_msg += "double requires a script, you passed an instance:  " + _str(thing)

	if(bad_msg != ""):
		_lgr.error(bad_msg)

	return bad_msg == ""

# ----------------
#endregion
#region Virtual Methods
# ----------------

## Virtual Method.  This is run after the script has been prepped for execution, but before `before_all` is executed.  If you implement this method and return `true` or a `String` (the string is displayed in the log) then GUT will stop executing the script and mark it as risky.  You might want to do this because:
## - You are porting tests from 3.x to 4.x and you don't want to comment everything out.[br]
## - Skipping tests that should not be run when in `headless` mode such as input testing that does not work in headless.[br]
## [codeblock]
##    func should_skip_script():
##        if DisplayServer.get_name() == "headless":
##            return "Skip Input tests when running headless"
## [/codeblock]
## - If you have tests that would normally cause the debugger to break on an error, you can skip the script if the debugger is enabled so that the run is not interrupted.[br]
## [codeblock]
##    func should_skip_script():
##        return EngineDebugger.is_active()
## [/codeblock]
func should_skip_script():
	return false


## Virtual method.  Run once before anything else in the test script is run.
func before_all():
	pass


## Virtual method.  Run before each test is executed
func before_each():
	pass

## Virtual method.  Run after each test is executed.
func after_each():
	pass


## Virtual method.  Run after all tests have been run.
func after_all():
	pass

# ----------------
#endregion
#region Misc Public
# ----------------
## Mark the current test as pending.
func pending(text=""):
	_summary.pending += 1
	if(gut):
		_lgr.pending(text)
		gut._pending(text)


## Returns true if the test is passing as of the time of this call.  False if not.
func is_passing():
	if(gut.get_current_test_object() != null and
		!['before_all', 'after_all'].has(gut.get_current_test_object().name)):
		return gut.get_current_test_object().is_passing() and \
			gut.get_current_test_object().assert_count > 0
	else:
		_lgr.error('No current test object found.  is_passing must be called inside a test.')
		return null


## Returns true if the test is failing as of the time of this call.  False if not.
func is_failing():
	if(gut.get_current_test_object() != null and
		!['before_all', 'after_all'].has(gut.get_current_test_object().name)):

		return gut.get_current_test_object().is_failing()
	else:
		_lgr.error('No current test object found.  is_failing must be called inside a test.')
		return null


## Marks the test as passing.  Does not override any failing asserts or calls to
## fail_test.  Same as a passing assert.
func pass_test(text):
	_pass(text)


## Marks the test as failing.  Same as a failing assert.
func fail_test(text):
	_fail(text)

## @internal
func clear_signal_watcher():
	_signal_watcher.clear()


## Returns the current double strategy.
func get_double_strategy():
	return gut.get_doubler().get_strategy()


## Sets the double strategy for all tests in the script.  This should usually
## be done in [method before_all].  The double strtegy can be set per
## run/script/double.  See [wiki]Double-Strategy[/wiki]
func set_double_strategy(double_strategy):
	gut.get_doubler().set_strategy(double_strategy)


## This method will cause Gut to pause before it moves on to the next test.
## This is useful for debugging, for instance if you want to investigate the
## screen or anything else after a test has finished executing.
## [br]
## Sometimes you get lazy, and you don't remove calls to
## [code skip-lint]pause_before_teardown[/code] after you are done with them.  You can
## tell GUT to ignore calls to this method through the panel or
## the command line.  Setting this in your `.gutconfig.json` file is recommended
## for CI/CD Pipelines.
func pause_before_teardown():
	gut.pause_before_teardown()


## @internal
func get_logger():
	return _lgr

## @internal
func set_logger(logger):
	_lgr = logger


## This must be called in order to make assertions based on signals being
## emitted.  __Right now, this only supports signals that are emitted with 9 or
## less parameters.__  This can be extended but nine seemed like enough for now.
## The Godot documentation suggests that the limit is four but in my testing
## I found you can pass more.
## [br]
## This must be called in each test in which you want to make signal based
## assertions in.  You can call it multiple times with different objects.
## You should not call it multiple times with the same object in the same test.
## The objects that are watched are cleared after each test (specifically right
## before `teardown` is called).  Under the covers, Gut will connect to all the
## signals an object has and it will track each time they fire.  You can then
## use the following asserts and methods to verify things are acting correct.
func watch_signals(object):
	_signal_watcher.watch_signals(object)


## This will return the number of times a signal was fired.  This gives you
## the freedom to make more complicated assertions if the spirit moves you.
## This will return -1 if the signal was not fired or the object was not being
## watched, or if the object does not have the signal.
## [br][br]
## Accepts either the object and the signal name or the signal.
func get_signal_emit_count(p1, p2=null):
	var sp = SignalAssertParameters.new(p1, p2)
	return _signal_watcher.get_emit_count(sp.object, sp.signal_name)


## If you need to inspect the parameters in order to make more complicate assertions, then this will give you access to
## the parameters of any watched signal.  This works the same way that
## [code skip-lint]assert_signal_emitted_with_parameters[/code] does.  It takes an object, signal name, and an optional
## index.  If the index is not specified then the parameters from the most recent emission will be returned.  If the
## object is not being watched, the signal was not fired, or the object does not have the signal then `null` will be
## returned.
##
## [br][br]
## [b]Signatures:[/b][br]
## - get_signal_parameters([param p1]:Signal, [param p2]:parameter-index (optional))[br]
## - get_signal_parameters([param p1]:object, [param p2]:signal name, [param p3]:parameter-index (optional)) [br]
## [br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_get_signal_parameters():
##     var obj = SignalObject.new()
##     watch_signals(obj)
##     obj.some_signal.emit(1, 2, 3)
##     obj.some_signal.emit('a', 'b', 'c')
##
##     # -- Passing --
##     # passes because get_signal_parameters returns the most recent emission
##     # by default
##     assert_eq(get_signal_parameters(obj, 'some_signal'), ['a', 'b', 'c'])
##     assert_eq(get_signal_parameters(obj.some_signal), ['a', 'b', 'c'])
##
##     assert_eq(get_signal_parameters(obj, 'some_signal', 0), [1, 2, 3])
##     assert_eq(get_signal_parameters(obj.some_signal, 0), [1, 2, 3])
##
##     # if the signal was not fired null is returned
##     assert_null(get_signal_parameters(obj, 'other_signal'))
##     # if the signal does not exist or isn't being watched null is returned
##     assert_null(get_signal_parameters(obj, 'signal_dne'))
##
##     # -- Failing --
##     assert_eq(get_signal_parameters(obj, 'some_signal'), [1, 2, 3])
##     assert_eq(get_signal_parameters(obj.some_signal, 0), ['a', 'b', 'c'])
## [/codeblock]
func get_signal_parameters(p1, p2=null, p3=-1):
	var sp := SignalAssertParameters.new(p1, GutUtils.nvl(p2, -1), p3)
	return _signal_watcher.get_signal_parameters(sp.object, sp.signal_name, sp.others[0])


## Get the parameters for a method call to a doubled object.  By default it will
## return the most recent call.  You can optionally specify an index for which
## call you want to get the parameters for.
##
## Can be called using a Callable for the first parameter instead of specifying
## an object and method name.  When you do this, the seoncd parameter is used
## as the index.
##
## Returns:
## * an array of parameter values if a call the method was found
## * null when a call to the method was not found or the index specified was
##   invalid.
func get_call_parameters(object, method_name_or_index = -1, idx=-1):
	var to_return = null
	var index = idx
	if(object is Callable):
		index = method_name_or_index
		method_name_or_index = null
	var converted = _convert_spy_args(object, method_name_or_index, null)

	if(GutUtils.is_double(converted.object)):
		to_return = gut.get_spy().get_call_parameters(
			converted.object, converted.method_name, index)
	else:
		_lgr.error('You must pass a doulbed object to get_call_parameters.')

	return to_return


## Returns the call count for a method with optional paramter matching.
##
## Can be called with a Callable instead of an object, method_name, and
## parameters.  Bound arguments will be used to match call arguments.
func get_call_count(object, method_name=null, parameters=null):
	var converted = _convert_spy_args(object, method_name, parameters)
	return gut.get_spy().call_count(converted.object, converted.method_name, converted.arguments)


## Simulate a number of frames by calling '_process' and '_physics_process' (if
## the methods exist) on an object and all of its descendents. The specified frame
## time, 'delta', will be passed to each simulated call.
##
## NOTE: Objects can disable their processing methods using 'set_process(false)' and
## 'set_physics_process(false)'. This is reflected in the 'Object' methods
## 'is_processing()' and 'is_physics_processing()', respectively. To make 'simulate'
## respect this status, for example if you are testing an object which toggles
## processing, pass 'check_is_processing' as 'true'.
func simulate(obj, times, delta, check_is_processing: bool = false):
	gut.simulate(obj, times, delta, check_is_processing)


# ------------------------------------------------------------------------------
## Replace the node at base_node.get_node(path) with with_this.  All references
## to the node via $ and get_node(...) will now return with_this.  with_this will
## get all the groups that the node that was replaced had.
## [br]
## The node that was replaced is queued to be freed.
## [br]
## TODO see replace_by method, this could simplify the logic here.
# ------------------------------------------------------------------------------
func replace_node(base_node, path_or_node, with_this):
	var path = path_or_node

	if(typeof(path_or_node) != TYPE_STRING):
		# This will cause an engine error if it fails.  It always returns a
		# NodePath, even if it fails.  Checking the name count is the only way
		# I found to check if it found something or not (after it worked I
		# didn't look any farther).
		path = base_node.get_path_to(path_or_node)
		if(path.get_name_count() == 0):
			_lgr.error('You passed an object that base_node does not have.  Cannot replace node.')
			return

	if(!base_node.has_node(path)):
		_lgr.error(str('Could not find node at path [', path, ']'))
		return

	var to_replace = base_node.get_node(path)
	var parent = to_replace.get_parent()
	var replace_name = to_replace.get_name()

	parent.remove_child(to_replace)
	parent.add_child(with_this)
	with_this.set_name(replace_name)
	with_this.set_owner(parent)

	var groups = to_replace.get_groups()
	for i in range(groups.size()):
		with_this.add_to_group(groups[i])

	to_replace.queue_free()


## Use this as the default value for the first parameter to a test to create
## a parameterized test.  See also the ParameterFactory and Parameterized Tests.
## [br][br]
## [b]Example[/b]
## [codeblock]
##    func test_with_parameters(p = use_parameters([1, 2, 3])):
## [/codeblock]
func use_parameters(params):
	var ph = gut.parameter_handler
	if(ph == null):
		ph = GutUtils.ParameterHandler.new(params)
		gut.parameter_handler = ph

	# DO NOT use gut.gd's get_call_count_text here since it decrements the
	# get_call_count value.  This method increments the call count in its
	# return statement.
	var output = str('- params[', ph.get_call_count(), ']','(', ph.get_current_parameters(), ')')
	gut.p(output, gut.LOG_LEVEL_TEST_AND_FAILURES)

	return ph.next_parameters()


## @internal
## When used as the default for a test method parameter, it will cause the test
## to be run x times.
##
## I Hacked this together to test a method that was occassionally failing due to
## timing issues.  I don't think it's a great idea, but you be the judge.  If
## you find a good use for it, let me know and I'll make it a legit member
## of the api.
func run_x_times(x):
	var ph = gut.parameter_handler
	if(ph == null):
		_lgr.warn(
			str("This test uses run_x_times and you really should not be ",
			"using it.  I don't think it's a good thing, but I did find it ",
			"temporarily useful so I left it in here and didn't document it.  ",
			"Well, you found it, might as well open up an issue and let me ",
			"know why you're doing this."))
		var params = []
		for i in range(x):
			params.append(i)

		ph = GutUtils.ParameterHandler.new(params)
		gut.parameter_handler = ph
	return ph.next_parameters()


## Checks the passed in version string (x.x.x) against the engine version to see
## if the engine version is less than the expected version.  If it is then the
## test is mareked as passed (for a lack of anything better to do).  The result
## of the check is returned.
## [br][br]
## [b]Example[/b]
## [codeblock]
##    if(skip_if_godot_version_lt('3.5.0')):
##        return
## [/codeblock]
func skip_if_godot_version_lt(expected):
	var should_skip = !GutUtils.is_godot_version_gte(expected)
	if(should_skip):
		_pass(str('Skipping: ', GutUtils.godot_version_string(), ' is less than ', expected))
	return should_skip


## Checks if the passed in version matches the engine version.  The passed in
## version can contain just the major, major.minor or major.minor.path.  If
## the version is not the same then the test is marked as passed.  The result of
## the check is returned.
## [br][br]
## [b]Example[/b]
## [codeblock]
##     if(skip_if_godot_version_ne('3.4')):
##        return
## [/codeblock]
func skip_if_godot_version_ne(expected):
	var should_skip = !GutUtils.is_godot_version(expected)
	if(should_skip):
		_pass(str('Skipping: ', GutUtils.godot_version_string(), ' is not ', expected))
	return should_skip


## Registers all the inner classes in a script with the doubler.  This is required
## before you can double any inner class.
func register_inner_classes(base_script):
	gut.get_doubler().inner_class_registry.register(base_script)


## Peforms a deep compare on both values, a CompareResult instnace is returned.
## The optional max_differences paramter sets the max_differences to be displayed.
func compare_deep(v1, v2, max_differences=null):
	var result = _compare.deep(v1, v2)
	if(max_differences != null):
		result.max_differences = max_differences
	return result


# ----------------
#endregion
#region Asserts
# ----------------

## Asserts that the expected value equals the value got.
## assert got == expected and prints optional text.  See [wiki]Comparing-Things[/wiki]
## for information about comparing dictionaries and arrays.
## [br]
## See also: [method assert_ne], [method assert_same], [method assert_not_same]
## [codeblock]
##    var one = 1
##    var node1 = Node.new()
##    var node2 = node1
##
##    # Passing
##    assert_eq(one, 1, 'one should equal one')
##    assert_eq('racecar', 'racecar')
##    assert_eq(node2, node1)
##    assert_eq([1, 2, 3], [1, 2, 3])
##    var d1_pass = {'a':1}
##    var d2_pass = d1_pass
##    assert_eq(d1_pass, d2_pass)
##
##    # Failing
##    assert_eq(1, 2) # FAIL
##    assert_eq('hello', 'world')
##    assert_eq(self, node1)
##    assert_eq([1, 'two', 3], [1, 2, 3, 4])
##    assert_eq({'a':1}, {'a':1})
## [/codeblock]
func assert_eq(got, expected, text=""):

	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		var disp = "[" + _str(got) + "] expected to equal [" + _str(expected) + "]:  " + text
		var result = null

		result = _compare.simple(got, expected)

		if(typeof(got) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			disp = str(result.summary, '  ', text)
			_lgr.info('Array/Dictionary compared by value.  Use assert_same to compare references.  Use assert_eq_deep to see diff when failing.')

		if(result.are_equal):
			_pass(disp)
		else:
			_fail(disp)


## asserts got != expected and prints optional text.  See
## [wiki]Comparing-Things[/wiki] for information about comparing dictionaries
## and arrays.
##[br]
## See also: [method assert_eq], [method assert_same], [method assert_not_same]
## [codeblock]
##    var two = 2
##    var node1 = Node.new()
##
##    # Passing
##    assert_ne(two, 1, 'Two should not equal one.')
##    assert_ne('hello', 'world')
##    assert_ne(self, node1)
##
##    # Failing
##    assert_ne(two, 2)
##    assert_ne('one', 'one')
##    assert_ne('2', 2)
## [/codeblock]
func assert_ne(got, not_expected, text=""):
	if(_do_datatypes_match__fail_if_not(got, not_expected, text)):
		var disp = "[" + _str(got) + "] expected to not equal [" + _str(not_expected) + "]:  " + text
		var result = null

		result = _compare.simple(got, not_expected)

		if(typeof(got) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			disp = str(result.summary, '  ', text)
			_lgr.info('Array/Dictionary compared by value.  Use assert_not_same to compare references.  Use assert_ne_deep to see diff.')

		if(result.are_equal):
			_fail(disp)
		else:
			_pass(disp)


## Asserts that [param got] is within the range of [param expected] +/- [param error_interval].
## The upper and lower bounds are included in the check.  Verified to work with
## integers, floats, and Vector2.  Should work with anything that can be
## added/subtracted.
##
## [codeblock]
##    # Passing
##    assert_almost_eq(0, 1, 1, '0 within range of 1 +/- 1')
##    assert_almost_eq(2, 1, 1, '2 within range of 1 +/- 1')
##    assert_almost_eq(1.2, 1.0, .5, '1.2 within range of 1 +/- .5')
##    assert_almost_eq(.5, 1.0, .5, '.5 within range of 1 +/- .5')
##    assert_almost_eq(Vector2(.5, 1.5), Vector2(1.0, 1.0), Vector2(.5, .5))
##    assert_almost_eq(Vector2(.5, 1.5), Vector2(1.0, 1.0), Vector2(.25, .25))
##
##    # Failing
##    assert_almost_eq(1, 3, 1, '1 outside range of 3 +/- 1')
##    assert_almost_eq(2.6, 3.0, .2, '2.6 outside range of 3 +/- .2')
## [/codeblock]
func assert_almost_eq(got, expected, error_interval, text=''):
	var disp = "[" + _str_precision(got, 20) + "] expected to equal [" + _str(expected) + "] +/- [" + str(error_interval) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text) and _do_datatypes_match__fail_if_not(got, error_interval, text)):
		if not _is_almost_eq(got, expected, error_interval):
			_fail(disp)
		else:
			_pass(disp)


## This is the inverse of [method assert_almost_eq].  This will pass if [param got] is
## outside the range of [param not_expected] +/- [param error_interval].
func assert_almost_ne(got, not_expected, error_interval, text=''):
	var disp = "[" + _str_precision(got, 20) + "] expected to not equal [" + _str(not_expected) + "] +/- [" + str(error_interval) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, not_expected, text) and _do_datatypes_match__fail_if_not(got, error_interval, text)):
		if _is_almost_eq(got, not_expected, error_interval):
			_fail(disp)
		else:
			_pass(disp)

# ------------------------------------------------------------------------------
# Helper function compares a value against a expected and a +/- range.  Compares
# all components of Vector2, Vector3, and Vector4 as well.
# ------------------------------------------------------------------------------
func _is_almost_eq(got, expected, error_interval) -> bool:
	var result = false
	var upper = expected + error_interval
	var lower = expected - error_interval

	if typeof(got) in [TYPE_VECTOR2, TYPE_VECTOR3, TYPE_VECTOR4]:
		result = got.clamp(lower, upper) == got
	else:
		result = got >= (lower) and got <= (upper)

	return(result)

## assserts got > expected
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_gt(bigger, smaller, 'Bigger should be greater than smaller')
##    assert_gt('b', 'a')
##    assert_gt('a', 'A')
##    assert_gt(1.1, 1)
##
##    # Failing
##    assert_gt('a', 'a')
##    assert_gt(1.0, 1)
##    assert_gt(smaller, bigger)
## [/codeblock]
func assert_gt(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be > than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got > expected):
			_pass(disp)
		else:
			_fail(disp)


## Asserts got is greater than or equal to expected.
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_gte(bigger, smaller, 'Bigger should be greater than or equal to smaller')
##    assert_gte('b', 'a')
##    assert_gte('a', 'A')
##    assert_gte(1.1, 1)
##    assert_gte('a', 'a')
##
##    # Failing
##    assert_gte(0.9, 1.0)
##    assert_gte(smaller, bigger)
## [/codeblock]
func assert_gte(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be >= than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got >= expected):
			_pass(disp)
		else:
			_fail(disp)

## Asserts [param got] is less than [param expected]
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_lt(smaller, bigger, 'Smaller should be less than bigger')
##    assert_lt('a', 'b')
##    assert_lt(99, 100)
##
##    # Failing
##    assert_lt('z', 'x')
##    assert_lt(-5, -5)
## [/codeblock]
func assert_lt(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be < than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got < expected):
			_pass(disp)
		else:
			_fail(disp)


## Asserts got is less than or equal to expected
func assert_lte(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be <= than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got <= expected):
			_pass(disp)
		else:
			_fail(disp)


## asserts that got is true.  Does not assert truthiness, only boolean values
## will pass.
func assert_true(got, text=""):
	if(typeof(got) == TYPE_BOOL):
		if(got):
			_pass(text)
		else:
			_fail(text)
	else:
		var msg = str("Cannot convert ", _strutils.type2str(got), " to boolean")
		_fail(msg)


## Asserts that got is false.  Does not assert truthiness, only boolean values
## will pass.
func assert_false(got, text=""):
	if(typeof(got) == TYPE_BOOL):
		if(got):
			_fail(text)
		else:
			_pass(text)
	else:
		var msg = str("Cannot convert ", _strutils.type2str(got), " to boolean")
		_fail(msg)


## Asserts value is between (inclusive) the two expected values.[br]
## got >= expect_low and <= expect_high
## [codeblock]
##    # Passing
##    assert_between(5, 0, 10, 'Five should be between 0 and 10')
##    assert_between(10, 0, 10)
##    assert_between(0, 0, 10)
##    assert_between(2.25, 2, 4.0)
##
##    # Failing
##    assert_between('a', 'b', 'c')
##    assert_between(1, 5, 10)
## [/codeblock]
func assert_between(got, expect_low, expect_high, text=""):
	var disp = "[" + _str_precision(got, 20) + "] expected to be between [" + _str(expect_low) + "] and [" + str(expect_high) + "]:  " + text

	if(_do_datatypes_match__fail_if_not(got, expect_low, text) and _do_datatypes_match__fail_if_not(got, expect_high, text)):
		if(expect_low > expect_high):
			disp = "INVALID range.  [" + str(expect_low) + "] is not less than [" + str(expect_high) + "]"
			_fail(disp)
		else:
			if(got < expect_low or got > expect_high):
				_fail(disp)
			else:
				_pass(disp)


## Asserts value is not between (exclusive) the two expected values.[br]
## asserts that got <= expect_low or got >=  expect_high.
## [codeblock]
##    # Passing
##    assert_not_between(1, 5, 10)
##    assert_not_between('a', 'b', 'd')
##    assert_not_between('d', 'b', 'd')
##    assert_not_between(10, 0, 10)
##    assert_not_between(-2, -2, 10)
##
##    # Failing
##    assert_not_between(5, 0, 10, 'Five shouldnt be between 0 and 10')
##    assert_not_between(0.25, -2.0, 4.0)
## [/codeblock]
func assert_not_between(got, expect_low, expect_high, text=""):
	var disp = "[" + _str_precision(got, 20) + "] expected not to be between [" + _str(expect_low) + "] and [" + str(expect_high) + "]:  " + text

	if(_do_datatypes_match__fail_if_not(got, expect_low, text) and _do_datatypes_match__fail_if_not(got, expect_high, text)):
		if(expect_low > expect_high):
			disp = "INVALID range.  [" + str(expect_low) + "] is not less than [" + str(expect_high) + "]"
			_fail(disp)
		else:
			if(got > expect_low and got < expect_high):
				_fail(disp)
			else:
				_pass(disp)


## Uses the 'has' method of the object passed in to determine if it contains
## the passed in element.
## [codeblock]
##    var an_array = [1, 2, 3, 'four', 'five']
##    var a_hash = { 'one':1, 'two':2, '3':'three'}
##
##    # Passing
##    assert_has(an_array, 'four') # PASS
##    assert_has(an_array, 2) # PASS
##    # the hash's has method checks indexes not values
##    assert_has(a_hash, 'one') # PASS
##    assert_has(a_hash, '3') # PASS
##
##    # Failing
##    assert_has(an_array, 5) # FAIL
##    assert_has(an_array, self) # FAIL
##    assert_has(a_hash, 3) # FAIL
##    assert_has(a_hash, 'three') # FAIL
## [/codeblock]
func assert_has(obj, element, text=""):
	var disp = str('Expected [', _str(obj), '] to contain value:  [', _str(element), ']:  ', text)
	if(obj.has(element)):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of assert_has.
func assert_does_not_have(obj, element, text=""):
	var disp = str('Expected [', _str(obj), '] to NOT contain value:  [', _str(element), ']:  ', text)
	if(obj.has(element)):
		_fail(disp)
	else:
		_pass(disp)


## asserts a file exists at the specified path
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_exists():
##        # Passing
##        assert_file_exists('res://addons/gut/gut.gd')
##        assert_file_exists('user://some_test_file')
##
##        # Failing
##        assert_file_exists('user://file_does_not.exist')
##        assert_file_exists('res://some_dir/another_dir/file_does_not.exist')
## [/codeblock]
func assert_file_exists(file_path):
	var disp = 'expected [' + file_path + '] to exist.'
	if(FileAccess.file_exists(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## asserts a file does not exist at the specified path
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_does_not_exist():
##        # Passing
##        assert_file_does_not_exist('user://file_does_not.exist')
##        assert_file_does_not_exist('res://some_dir/another_dir/file_does_not.exist')
##
##        # Failing
##        assert_file_does_not_exist('res://addons/gut/gut.gd')
## [/codeblock]
func assert_file_does_not_exist(file_path):
	var disp = 'expected [' + file_path + '] to NOT exist'
	if(!FileAccess.file_exists(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## asserts the specified file is empty
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_empty():
##        # Passing
##        assert_file_empty('user://some_test_file')
##
##        # Failing
##        assert_file_empty('res://addons/gut/gut.gd')
## [/codeblock]
func assert_file_empty(file_path):
	var disp = 'expected [' + file_path + '] to be empty'
	if(FileAccess.file_exists(file_path) and gut.is_file_empty(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts the specified file is not empty
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_not_empty():
##        # Passing
##        assert_file_not_empty('res://addons/gut/gut.gd') # PASS
##
##        # Failing
##        assert_file_not_empty('user://some_test_file') # FAIL
## [/codeblock]
func assert_file_not_empty(file_path):
	var disp = 'expected [' + file_path + '] to contain data'
	if(!gut.is_file_empty(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts that the passed in object has a method named [param method].
func assert_has_method(obj, method, text=''):
	var disp = _str(obj) + ' should have method: ' + method
	if(text != ''):
		disp = _str(obj) + ' ' + text
	assert_true(obj.has_method(method), disp)


## This is meant to make testing public get/set methods for a member variable.  This was originally created for early Godot 3.x setter and getter methods.  See [method assert_property] for verifying Godot 4.x accessors.  This makes multiple assertions to verify:
## [br]
## [li]The object has a method called [code]get_<PROPERTY_NAME>[/code][/li]
## [li]The object has a method called [code]set_<PROPERTY_NAME>[/code][/li]
## [li]The method [code]get_<PROPERTY_NAME>[/code] returns the expected default value when first called.[/li]
## [li]Once you set the property, the [code]get_<PROPERTY_NAME>[/code] returns the new value.[/li]
## [br]
func assert_accessors(obj, property, default, set_to):
	var fail_count = _summary.failed
	var get_func = 'get_' + property
	var set_func = 'set_' + property

	if(obj.has_method('is_' + property)):
		get_func = 'is_' + property

	assert_has_method(obj, get_func, 'should have getter starting with get_ or is_')
	assert_has_method(obj, set_func)
	# SHORT CIRCUIT
	if(_summary.failed > fail_count):
		return
	assert_eq(obj.call(get_func), default, 'It should have the expected default value.')
	obj.call(set_func, set_to)
	assert_eq(obj.call(get_func), set_to, 'The set value should have been returned.')


# Property search helper.  Used to retrieve Dictionary of specified property
# from passed object. Returns null if not found.
# If provided, property_usage constrains the type of property returned by
# passing either:
# EDITOR_PROPERTY for properties defined as: export var some_value: int
# VARIABLE_PROPERTY for properties defined as: var another_value
func _find_object_property(obj, property_name, property_usage=null):
	var result = null
	var found = false
	var properties = obj.get_property_list()

	while !found and !properties.is_empty():
		var property = properties.pop_back()
		if property['name'] == property_name:
			if property_usage == null or property['usage'] == property_usage:
				result = property
				found = true
	return result


## Asserts that [param obj] exports a property with the name
## [param property_name] and a type of [param type].  The [param type] must be
## one of the various Godot built-in [code]TYPE_[/code] constants.
## [codeblock]
##    class ExportClass:
##        export var some_number = 5
##        export(PackedScene) var some_scene
##        var some_variable = 1
##
##    func test_assert_exports():
##        var obj = ExportClass.new()
##
##        # Passing
##        assert_exports(obj, "some_number", TYPE_INT)
##        assert_exports(obj, "some_scene", TYPE_OBJECT)
##
##        # Failing
##        assert_exports(obj, 'some_number', TYPE_VECTOR2)
##        assert_exports(obj, 'some_scene', TYPE_AABB)
##        assert_exports(obj, 'some_variable', TYPE_INT)
## [/codeblock]
func assert_exports(obj, property_name, type):
	var disp = 'expected %s to have editor property [%s]' % [_str(obj), property_name]
	var property = _find_object_property(obj, property_name, EDITOR_PROPERTY)
	if property != null:
		disp += ' of type [%s]. Got type [%s].' % [_strutils.types[type], _strutils.types[property['type']]]
		if property['type'] == type:
			_pass(disp)
		else:
			_fail(disp)
	else:
		_fail(disp)


# Signal assertion helper.
#
# Verifies that the object and signal are valid for making signal assertions.
# This will fail with specific messages that indicate why they are not valid.
# This returns true/false to indicate if the object and signal are valid.
func _can_make_signal_assertions(object, signal_name):
	return !(_fail_if_not_watching(object) or _fail_if_does_not_have_signal(object, signal_name))


# Check if an object is connected to a signal on another object. Returns True
# if it is and false otherwise
func _is_connected(signaler_obj, connect_to_obj, signal_name, method_name=""):
	if(method_name != ""):
		return signaler_obj.is_connected(signal_name,Callable(connect_to_obj,method_name))
	else:
		var connections = signaler_obj.get_signal_connection_list(signal_name)
		for conn in connections:
			if(conn['signal'].get_name() == signal_name and conn['callable'].get_object() == connect_to_obj):
				return true
		return false


## Asserts that `signaler_obj` is connected to `connect_to_obj` on signal `signal_name`.  The method that is connected is optional.  If `method_name` is supplied then this will pass only if the signal is connected to the  method.  If it is not provided then any connection to the signal will cause a pass.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_connected([param p1]:Signal, [param p2]:connected-object)[br]
## - assert_connected([param p1]:Signal, [param p2]:connected-method)[br]
## - assert_connected([param p1]:object, [param p2]:connected-object, [param p3]:signal-name, [param p4]: connected-method-name <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class Signaler:
##     signal the_signal
##
## class Connector:
##     func connect_this():
##         pass
##     func  other_method():
##         pass
##
## func test_assert_connected():
##     var signaler = Signaler.new()
##     var connector  = Connector.new()
##     signaler.the_signal.connect(connector.connect_this)
##
##     # Passing
##     assert_connected(signaler.the_signal, connector.connect_this)
##     assert_connected(signaler.the_signal, connector)
##     assert_connected(signaler, connector, 'the_signal')
##     assert_connected(signaler, connector, 'the_signal', 'connect_this')
##
##     # Failing
##     assert_connected(signaler.the_signal, connector.other_method)
##
##     var foo = Connector.new()
##     assert_connected(signaler,  connector, 'the_signal', 'other_method')
##     assert_connected(signaler, connector, 'other_signal')
##     assert_connected(signaler, foo, 'the_signal')
## [/codeblock]
func assert_connected(p1, p2, p3=null, p4=""):
	var sp := SignalAssertParameters.new(p1, p3)
	var connect_to_obj = p2
	var method_name = p4

	if(connect_to_obj is  Callable):
		method_name = connect_to_obj.get_method()
		connect_to_obj = connect_to_obj.get_object()

	var method_disp = ''
	if (method_name != ""):
		method_disp = str(' using method: [', method_name, '] ')
	var disp = str('Expected object ', _str(sp.object),\
		' to be connected to signal: [', sp.signal_name, '] on ',\
		_str(connect_to_obj), method_disp)
	if(_is_connected(sp.object, connect_to_obj, sp.signal_name, method_name)):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of [method assert_connected].  See [method assert_connected] for parameter syntax.
## [br]
## This will fail with specific messages if the target object is connected to the specified signal on the source object.
func assert_not_connected(p1, p2, p3=null, p4=""):
	var sp := SignalAssertParameters.new(p1, p3)
	var connect_to_obj = p2
	var method_name = p4

	if(connect_to_obj is  Callable):
		method_name = connect_to_obj.get_method()
		connect_to_obj = connect_to_obj.get_object()

	var method_disp = ''
	if (method_name != ""):
		method_disp = str(' using method: [', method_name, '] ')
	var disp = str('Expected object ', _str(sp.object),\
		' to not be connected to signal: [', sp.signal_name, '] on ',\
		_str(sp.object), method_disp)
	if(_is_connected(sp.object, connect_to_obj, sp.signal_name, method_name)):
		_fail(disp)
	else:
		_pass(disp)


## Assert that the specified object emitted the named signal.  You must call
## [method watch_signals] and pass it the object that you are making assertions about.
## This will fail if the object is not being watched or if the object does not
## have the specified signal.  Since this will fail if the signal does not
## exist, you can often skip using [method assert_has_signal].
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emitted([param p1]:Signal, [param p2]: text <optional>)[br]
## - assert_signal_emitted([param p1]:object, [param p2]:signal-name, [param p3]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_assert_signal_emitted():
##     var obj = SignalObject.new()
##
##     watch_signals(obj)
##     obj.emit_signal('some_signal')
##
##     ## Passing
##     assert_signal_emitted(obj, 'some_signal')
##     assert_signal_emitted(obj.some_signal)
##
##     ## Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emitted(obj, 'signal_does_not_exist')
##     # Fails because the object passed is not being watched
##     assert_signal_emitted(SignalObject.new(), 'some_signal')
##     # Fails because the signal was not emitted
##     assert_signal_emitted(obj, 'other_signal')
##     assert_signal_emitted(obj.other_signal)
## [/codeblock]
func assert_signal_emitted(p1, p2='', p3=""):
	var sp := SignalAssertParameters.new(p1, p2, p3)
	var disp = str('Expected object ', _str(sp.object), ' to have emitted signal [', sp.signal_name, ']:  ', sp.others[0])
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			_pass(disp)
		else:
			_fail(_get_fail_msg_including_emitted_signals(disp, sp.object))


## This works opposite of `assert_signal_emitted`.  This will fail if the object
## is not being watched or if the object does not have the signal.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_not_emitted([param p1]:Signal, [param p2]: text <optional>)[br]
## - assert_signal_not_emitted([param p1]:object, [param p2]:signal-name, [param p3]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
##    class SignalObject:
##        signal some_signal
##        signal other_signal
##
##    func test_assert_signal_not_emitted():
##        var obj = SignalObject.new()
##
##        watch_signals(obj)
##        obj.emit_signal('some_signal')
##
##        # Passing
##        assert_signal_not_emitted(obj, 'other_signal')
##        assert_signal_not_emitted(obj.other_signal)
##
##        # Failing
##        # Fails with specific message that the object does not have the signal
##        assert_signal_not_emitted(obj, 'signal_does_not_exist')
##        # Fails because the object passed is not being watched
##        assert_signal_not_emitted(SignalObject.new(), 'some_signal')
##        # Fails because the signal was emitted
##        assert_signal_not_emitted(obj, 'some_signal')
## [/codeblock]
func assert_signal_not_emitted(p1, p2='', p3=''):
	var sp := SignalAssertParameters.new(p1, p2, p3)
	var disp = str('Expected object ', _str(sp.object), ' to NOT emit signal [', sp.signal_name, ']:  ', sp.others[0])
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			_fail(disp)
		else:
			_pass(disp)


## Asserts that a signal was fired with the specified parameters.  The expected
## parameters should be passed in as an array.  An optional index can be passed
## when a signal has fired more than once.  The default is to retrieve the most
## recent emission of the signal.
## [br]
## This will fail with specific messages if the object is not being watched or
## the object does not have the specified signal
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emitted_with_parameters([param p1]:Signal, [param p2]:expected-parameters, [param p3]: index <optional>)[br]
## - assert_signal_emitted_with_parameters([param p1]:object, [param p2]:signal-name, [param p3]:expected-parameters, [param p4]: index <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
## func test_assert_signal_emitted_with_parameters():
##     var obj = SignalObject.new()
##
##     watch_signals(obj)
##     # emit the signal 3 times to illustrate how the index works in
##     # assert_signal_emitted_with_parameters
##     obj.emit_signal('some_signal', 1, 2, 3)
##     obj.emit_signal('some_signal', 'a', 'b', 'c')
##     obj.emit_signal('some_signal', 'one', 'two', 'three')
##
##     # Passing
##     # Passes b/c the default parameters to check are the last emission of
##     # the signal
##     assert_signal_emitted_with_parameters(obj, 'some_signal', ['one', 'two', 'three'])
##     assert_signal_emitted_with_parameters(obj.some_signal, ['one', 'two', 'three'])
##
##     # Passes because the parameters match the specified emission based on index.
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3], 0)
##     assert_signal_emitted_with_parameters(obj.some_signal, [1, 2, 3], 0)
##
##     # Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emitted_with_parameters(obj, 'signal_does_not_exist', [])
##     # Fails because the object passed is not being watched
##     assert_signal_emitted_with_parameters(SignalObject.new(), 'some_signal', [])
##     # Fails because parameters do not match latest emission
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3])
##     # Fails because the parameters for the specified index do not match
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3], 1)
## [/codeblock]
func assert_signal_emitted_with_parameters(p1, p2, p3=-1, p4=-1):
	var sp := SignalAssertParameters.new(p1, p2, p3, p4)
	var parameters = sp.others[0]
	var index = sp.others[1]

	if(typeof(parameters) != TYPE_ARRAY):
		_lgr.error("The expected parameters must be wrapped in an array, you passed:  " + _str(parameters))
		_fail("Bad Parameters")
		return

	var disp = str('Expected object ', _str(sp.object), ' to emit signal [', sp.signal_name, '] with parameters ', parameters, ', got ')
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			var parms_got = _signal_watcher.get_signal_parameters(sp.object, sp.signal_name, index)
			var diff_result = _compare.deep(parameters, parms_got)
			if(diff_result.are_equal):
				_pass(str(disp, parms_got))
			else:
				_fail(str('Expected object ', _str(sp.object), ' to emit signal [', sp.signal_name, '] with parameters ', diff_result.summarize()))
		else:
			var text = str('Object ', sp.object, ' did not emit signal [', sp.signal_name, ']')
			_fail(_get_fail_msg_including_emitted_signals(text, sp.object))


## Asserts that a signal fired a specific number of times.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emit_count([param p1]:Signal, [param p2]:expected-count, [param p3]: text <optional>)[br]
## - assert_signal_emit_count([param p1]:object, [param p2]:signal-name, [param p3]:expected-count, [param p4]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_assert_signal_emit_count():
##     var obj_a = SignalObject.new()
##     var obj_b = SignalObject.new()
##
##     watch_signals(obj_a)
##     watch_signals(obj_b)
##
##     obj_a.emit_signal('some_signal')
##     obj_a.emit_signal('some_signal')
##
##     obj_b.emit_signal('some_signal')
##     obj_b.emit_signal('other_signal')
##
##     # Passing
##     assert_signal_emit_count(obj_a, 'some_signal', 2, 'passes')
##     assert_signal_emit_count(obj_a.some_signal, 2, 'passes')
##
##     assert_signal_emit_count(obj_a, 'other_signal', 0)
##     assert_signal_emit_count(obj_a.other_signal, 0)
##
##     assert_signal_emit_count(obj_b, 'other_signal', 1)
##
##     # Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emit_count(obj_a, 'signal_does_not_exist', 99)
##     # Fails because the object passed is not being watched
##     assert_signal_emit_count(SignalObject.new(), 'some_signal', 99)
##     # The following fail for obvious reasons
##     assert_signal_emit_count(obj_a, 'some_signal', 0)
##     assert_signal_emit_count(obj_b, 'other_signal', 283)
## [/codeblock]
func assert_signal_emit_count(p1, p2, p3=0, p4=""):
	var sp := SignalAssertParameters.new(p1, p2, p3, p4)
	var times = sp.others[0]
	var text = sp.others[1]

	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		var count = _signal_watcher.get_emit_count(sp.object, sp.signal_name)
		var disp = str('Expected the signal [', sp.signal_name, '] emit count of [', count, '] to equal [', times, ']: ', text)
		if(count== times):
			_pass(disp)
		else:
			_fail(_get_fail_msg_including_emitted_signals(disp, sp.object))


## Asserts the passed in object has a signal with the specified name.  It
## should be noted that all the asserts that verify a signal was/wasn't emitted
## will first check that the object has the signal being asserted against.  If
## it does not, a specific failure message will be given.  This means you can
## usually skip the step of specifically verifying that the object has a signal
## and move on to making sure it emits the signal correctly.
## [codeblock]
##    class SignalObject:
##        signal some_signal
##        signal other_signal
##
##    func test_assert_has_signal():
##        var obj = SignalObject.new()
##
##        ## Passing
##        assert_has_signal(obj, 'some_signal')
##        assert_has_signal(obj, 'other_signal')
##
##        ## Failing
##        assert_has_signal(obj, 'not_a real SIGNAL')
##        assert_has_signal(obj, 'yea, this one doesnt exist either')
##        # Fails because the signal is not a user signal.  Node2D does have the
##        # specified signal but it can't be checked this way.  It could be watched
##        # and asserted that it fired though.
##        assert_has_signal(Node2D.new(), 'exit_tree')
## [/codeblock]
func assert_has_signal(object, signal_name, text=""):
	var disp = str('Expected object ', _str(object), ' to have signal [', signal_name, ']:  ', text)
	if(_signal_watcher.does_object_have_signal(object, signal_name)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts that [param object] extends [param a_class].  object must be an instance of an
## object.  It cannot be any of the built in classes like Array or Int or Float.
## [param a_class] must be a class, it can be loaded via load, a GDNative class such as
## Node or Label or anything else.
## [codeblock]
##    # Passing
##    assert_is(Node2D.new(), Node2D)
##    assert_is(Label.new(), CanvasItem)
##    assert_is(SubClass.new(), BaseClass)
##    # Since this is a test script that inherits from test.gd, so
##    # this passes.  It's not obvious w/o seeing the whole script
##    # so I'm telling you.  You'll just have to trust me.
##    assert_is(self, load('res://addons/gut/test.gd'))
##
##    var Gut = load('res://addons/gut/gut.gd')
##    var a_gut = Gut.new()
##    assert_is(a_gut, Gut)
##
##    # Failing
##    assert_is(Node2D.new(), Node2D.new())
##    assert_is(BaseClass.new(), SubClass)
##    assert_is('a', 'b')
##    assert_is([], Node)
## [/codeblock]
func assert_is(object, a_class, text=''):
	var disp  = ''#var disp = str('Expected [', _str(object), '] to be type of [', a_class, ']: ', text)
	var bad_param_2 = 'Parameter 2 must be a Class (like Node2D or Label).  You passed '

	if(typeof(object) != TYPE_OBJECT):
		_fail(str('Parameter 1 must be an instance of an object.  You passed:  ', _str(object)))
	elif(typeof(a_class) != TYPE_OBJECT):
		_fail(str(bad_param_2, _str(a_class)))
	else:
		var a_str = _str(a_class)
		disp = str('Expected [', _str(object), '] to extend [', a_str, ']: ', text)
		if(!GutUtils.is_native_class(a_class) and !GutUtils.is_gdscript(a_class)):
			_fail(str(bad_param_2, a_str))
		else:
			if(is_instance_of(object, a_class)):
				_pass(disp)
			else:
				_fail(disp)


## Asserts that [param object] is the the [param type] specified.  [param type]
## should be one of the Godot [code]TYPE_[/code] constants.
## [codeblock]
##    # Passing
##    var c = Color(1, 1, 1, 1)
##    gr.test.assert_typeof(c, TYPE_COLOR)
##    assert_pass(gr.test)
##
##    # Failing
##    gr.test.assert_typeof('some string', TYPE_INT)
##    assert_fail(gr.test)
## [/codeblock]
func assert_typeof(object, type, text=''):
	var disp = str('Expected [typeof(', object, ') = ')
	disp += _get_typeof_string(typeof(object))
	disp += '] to equal ['
	disp += _get_typeof_string(type) +  ']'
	disp += '.  ' + text
	if(typeof(object) == type):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of [method assert_typeof]
func assert_not_typeof(object, type, text=''):
	var disp = str('Expected [typeof(', object, ') = ')
	disp += _get_typeof_string(typeof(object))
	disp += '] to not equal ['
	disp += _get_typeof_string(type) +  ']'
	disp += '.  ' + text
	if(typeof(object) != type):
		_pass(disp)
	else:
		_fail(disp)


## Assert that `text` contains `search`.  Can perform case insensitive search
## by passing false for `match_case`.
## [codeblock]
##    # Passing
##    assert_string_contains('abc 123', 'a')
##    assert_string_contains('abc 123', 'BC', false)
##    assert_string_contains('abc 123', '3')
##
##    # Failing
##    assert_string_contains('abc 123', 'A')
##    assert_string_contains('abc 123', 'BC')
##    assert_string_contains('abc 123', '012')
## [/codeblock]
func assert_string_contains(text, search, match_case=true):
	const empty_search = 'Expected text and search strings to be non-empty. You passed %s and %s.'
	const non_strings = 'Expected text and search to both be strings.  You passed %s and %s.'
	var disp = 'Expected \'%s\' to contain \'%s\', match_case=%s' % [text, search, match_case]
	if(typeof(text) != TYPE_STRING or typeof(search) != TYPE_STRING):
		_fail(non_strings % [_str(text), _str(search)])
	elif(text == '' or search == ''):
		_fail(empty_search % [_str(text), _str(search)])
	elif(match_case):
		if(text.find(search) == -1):
			_fail(disp)
		else:
			_pass(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == -1):
			_fail(disp)
		else:
			_pass(disp)


## Assert that text starts with search.  Can perform case insensitive check
## by passing false for match_case
## [codeblock]
##    # Passing
##    assert_string_starts_with('abc 123', 'a')
##    assert_string_starts_with('abc 123', 'ABC', false)
##    assert_string_starts_with('abc 123', 'abc 123')
##
##    ## Failing
##    assert_string_starts_with('abc 123', 'z')
##    assert_string_starts_with('abc 123', 'ABC')
##    assert_string_starts_with('abc 123', 'abc 1234')
## [/codeblock]
func assert_string_starts_with(text, search, match_case=true):
	var empty_search = 'Expected text and search strings to be non-empty. You passed \'%s\' and \'%s\'.'
	var disp = 'Expected \'%s\' to start with \'%s\', match_case=%s' % [text, search, match_case]
	if(text == '' or search == ''):
		_fail(empty_search % [text, search])
	elif(match_case):
		if(text.find(search) == 0):
			_pass(disp)
		else:
			_fail(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == 0):
			_pass(disp)
		else:
			_fail(disp)


## Assert that [param text] ends with [param search].  Can perform case insensitive check by passing false for [param match_case]
## [codeblock]
##    ## Passing
##    assert_string_ends_with('abc 123', '123')
##    assert_string_ends_with('abc 123', 'C 123', false)
##    assert_string_ends_with('abc 123', 'abc 123')
##
##    ## Failing
##    assert_string_ends_with('abc 123', '1234')
##    assert_string_ends_with('abc 123', 'C 123')
##    assert_string_ends_with('abc 123', 'nope')
## [/codeblock]
func assert_string_ends_with(text, search, match_case=true):
	var empty_search = 'Expected text and search strings to be non-empty. You passed \'%s\' and \'%s\'.'
	var disp = 'Expected \'%s\' to end with \'%s\', match_case=%s' % [text, search, match_case]
	var required_index = len(text) - len(search)
	if(text == '' or search == ''):
		_fail(empty_search % [text, search])
	elif(match_case):
		if(text.find(search) == required_index):
			_pass(disp)
		else:
			_fail(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == required_index):
			_pass(disp)
		else:
			_fail(disp)


# ------------------------------------------------------------------------------
## Assert that a method was called on an instance of a doubled class.  If
## parameters are supplied then the params passed in when called must match.
##
## Can be called with a Callabe instead of specifying the object, method_name,
## and parameters.  The Callable's object must be a double.  Bound arguments
## will be used to match calls based on values passed to the method.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    var my_double = double(Foobar).new()
##    ...
##    assert_called(my_double, 'foo')
##    assert_called(my_double.foo)
##    assert_called(my_double, 'foo', [1, 2, 3])
##    assert_called(my_double.foo.bind(1, 2, 3))
## [/codeblock]
func assert_called(inst, method_name=null, parameters=null):

	if(_fail_if_parameters_not_array(parameters)):
		return

	var converted = _convert_spy_args(inst, method_name, parameters)
	if(converted.invalid_message != 'ok'):
		fail_test(converted.invalid_message)
		return

	var disp = str('Expected [',converted.method_name,'] to have been called on ',_str(converted.object))
	if(converted.arguments != null):
		disp += str(' with parameters ', converted.arguments)

	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(gut.get_spy().was_called(
			converted.object, converted.method_name, converted.arguments)):
			_pass(disp)
		else:
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))


# ------------------------------------------------------------------------------
## Assert that a method was not called on an instance of a doubled class.  If
## parameters are specified then this will only fail if it finds a call that was
## sent matching parameters.
##
## Can be called with a Callabe instead of specifying the object, method_name,
## and parameters.  The Callable's object must be a double.  Bound arguments
## will be used to match calls based on values passed to the method.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    assert_not_called(my_double, 'foo')
##    assert_not_called(my_double.foo)
##    assert_not_called(my_double, 'foo', [1, 2, 3])
##    assert_not_called(my_double.foo.bind(1, 2, 3))
## [/codeblock]
func assert_not_called(inst, method_name=null, parameters=null):

	if(_fail_if_parameters_not_array(parameters)):
		return

	var converted = _convert_spy_args(inst, method_name, parameters)
	if(converted.invalid_message != 'ok'):
		fail_test(converted.invalid_message)
		return

	var disp = str('Expected [', converted.method_name, '] to NOT have been called on ', _str(converted.object))

	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(gut.get_spy().was_called(
			converted.object, converted.method_name, converted.arguments)):
			if(converted.arguments != null):
				disp += str(' with parameters ', converted.arguments)
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))
		else:
			_pass(disp)


## Asserts the the method of a double was called an expected number of times.
## If any arguments are bound to the callable then only calls with matching
## arguments will be counted.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    # assert foo was called on my_double 5 times
##    assert_called_count(my_double.foo, 5)
##    # assert foo, with parameters [1,2,3], was called on my_double 4 times.
##    assert_called_count(my_double.foo.bind(1, 2, 3), 4)
## [/codeblock]
func assert_called_count(callable : Callable, expected_count : int):
	var converted = _convert_spy_args(callable, null, null)
	var count = gut.get_spy().call_count(converted.object, converted.method_name, converted.arguments)

	var param_text = ''
	if(callable.get_bound_arguments_count() > 0):
		param_text = ' with parameters ' + str(callable.get_bound_arguments())
	var disp = 'Expected [%s] on %s to be called [%s] times%s.  It was called [%s] times.'
	disp = disp % [converted.method_name, _str(converted.object), expected_count, param_text, count]


	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(count == expected_count):
			_pass(disp)
		else:
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))


## Asserts the passed in value is null
func assert_null(got, text=''):
	var disp = str('Expected [', _str(got), '] to be NULL:  ', text)
	if(got == null):
		_pass(disp)
	else:
		_fail(disp)


## Asserts the passed in value is not null.
func assert_not_null(got, text=''):
	var disp = str('Expected [', _str(got), '] to be anything but NULL:  ', text)
	if(got == null):
		_fail(disp)
	else:
		_pass(disp)


## Asserts that the passed in object has been freed.  This assertion requires
## that  you pass in some text in the form of a title since, if the object is
## freed, we won't have anything to convert to a string to put in the output
## statement.
## [br]
## [b]Note[/b] that this currently does not detect if a node has been queued free.
## [codeblock]
##    var obj = Node.new()
##    obj.free()
##    test.assert_freed(obj, "New Node")
## [/codeblock]
func assert_freed(obj, title='something'):
	var disp = title
	if(is_instance_valid(obj)):
		disp = _strutils.type2str(obj) + title
	assert_true(not is_instance_valid(obj), "Expected [%s] to be freed" % disp)


## The inverse of [method assert_freed]
func assert_not_freed(obj, title='something'):
	var disp = title
	if(is_instance_valid(obj)):
		disp = _strutils.type2str(obj) + title
	assert_true(is_instance_valid(obj), "Expected [%s] to not be freed" % disp)


## This method will assert that no orphaned nodes have been introduced by the
## test when the assert is executed.  See the [wiki]Memory-Management[/wiki]
## page for more information.
func assert_no_new_orphans(text=''):
	var count = gut.get_orphan_counter().get_orphans_since('test')
	var msg = ''
	if(text != ''):
		msg = ':  ' + text
	# Note that get_counter will return -1 if the counter does not exist.  This
	# can happen with a misplaced assert_no_new_orphans.  Checking for > 0
	# ensures this will not cause some weird failure.
	if(count > 0):
		_fail(str('Expected no orphans, but found ', count, msg))
	else:
		_pass('No new orphans found.' + msg)


## @ignore
func assert_set_property(obj, property_name, new_value, expected_value):
	pending("this hasn't been implemented yet")


## @ignore
func assert_readonly_property(obj, property_name, new_value, expected_value):
	pending("this hasn't been implemented yet")


## Assumes backing varible with be _<property_name>.  This will perform all the
## asserts of assert_property.  Then this will set the value through the setter
## and check the backing variable value.  It will then reset throught the setter
## and set the backing variable and check the getter.
func assert_property_with_backing_variable(obj, property_name, default_value, new_value, backed_by_name=null):
	var setter_name = str('@', property_name, '_setter')
	var getter_name = str('@', property_name, '_getter')
	var backing_name = GutUtils.nvl(backed_by_name, str('_', property_name))
	var pre_fail_count = get_fail_count()

	var props = obj.get_property_list()
	var found = false
	var idx = 0
	while(idx < props.size() and !found):
		found = props[idx].name == backing_name
		idx += 1

	assert_true(found, str(obj, ' has ', backing_name, ' variable.'))
	assert_true(obj.has_method(setter_name), str('There should be a setter for ', property_name))
	assert_true(obj.has_method(getter_name), str('There should be a getter for ', property_name))

	if(pre_fail_count == get_fail_count()):
		var call_setter = Callable(obj, setter_name)
		var call_getter = Callable(obj, getter_name)

		assert_eq(obj.get(backing_name), default_value, str('Variable ', backing_name, ' has default value.'))
		assert_eq(call_getter.call(), default_value, 'Getter returns default value.')
		call_setter.call(new_value)
		assert_eq(call_getter.call(), new_value, 'Getter returns value from Setter.')
		assert_eq(obj.get(backing_name), new_value, str('Variable ', backing_name, ' was set'))

	_warn_for_public_accessors(obj, property_name)


## This will verify that the method has a setter and getter for the property.
## It will then use the getter to check the default.  Then use the
## setter with new_value and verify the getter returns the same value.
func assert_property(obj, property_name, default_value, new_value) -> void:
	var pre_fail_count = get_fail_count()

	var setter_name = str('@', property_name, '_setter')
	var getter_name = str('@', property_name, '_getter')

	if(typeof(obj) != TYPE_OBJECT):
		_fail(str(_str(obj), ' is not an object'))
		return

	assert_has_method(obj, setter_name)
	assert_has_method(obj, getter_name)

	if(pre_fail_count == get_fail_count()):
		var call_setter = Callable(obj, setter_name)
		var call_getter = Callable(obj, getter_name)

		assert_eq(call_getter.call(), default_value, 'Default value')
		call_setter.call(new_value)
		assert_eq(call_getter.call(), new_value, 'Getter gets Setter value')

	_warn_for_public_accessors(obj, property_name)


## Performs a deep comparison between two arrays or dictionaries and asserts
## they are equal.  If they are not equal then a formatted list of differences
## are displayed.  See [wiki]Comparing-Things[/wiki] for more information.
func assert_eq_deep(v1, v2):
	var result = compare_deep(v1, v2)
	if(result.are_equal):
		_pass(result.get_short_summary())
	else:
		_fail(result.summary)


## Performs a deep comparison of two arrays or dictionaries and asserts they
## are not equal.  See [wiki]Comparing-Things[/wiki] for more information.
func assert_ne_deep(v1, v2):
	var result = compare_deep(v1, v2)
	if(!result.are_equal):
		_pass(result.get_short_summary())
	else:
		_fail(result.get_short_summary())


## Assert v1 and v2 are the same using [code]is_same[/code].  See @GlobalScope.is_same.
func assert_same(v1, v2, text=''):
	var disp = "[" + _str(v1) + "] expected to be same as  [" + _str(v2) + "]:  " + text
	if(is_same(v1, v2)):
		_pass(disp)
	else:
		_fail(disp)


## Assert using v1 and v2 are not the same using [code]is_same[/code].  See @GlobalScope.is_same.
func assert_not_same(v1, v2, text=''):
	var disp = "[" + _str(v1) + "] expected to not be same as  [" + _str(v2) + "]:  " + text
	if(is_same(v1, v2)):
		_fail(disp)
	else:
		_pass(disp)


# ----------------
#endregion
#region Await Helpers
# ----------------


## Use with await to wait an amount of time in seconds.  The optional message
## will be printed when the await starts.[br]
## See [wiki]Awaiting[/wiki]
func wait_seconds(time, msg=''):
	_lgr.yield_msg(str('-- Awaiting ', time, ' second(s) -- ', msg))
	_awaiter.wait_seconds(time)
	return _awaiter.timeout


## Use with await to wait for a signal to be emitted or a maximum amount of
## time.  Returns true if the signal was emitted, false if not.[br]
## See [wiki]Awaiting[/wiki]
func wait_for_signal(sig : Signal, max_wait, msg=''):
	watch_signals(sig.get_object())
	_lgr.yield_msg(str('-- Awaiting signal "', sig.get_name(), '" or for ', max_wait, ' second(s) -- ', msg))
	_awaiter.wait_for_signal(sig, max_wait)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout


## @deprecated
## Use wait_physics_frames or wait_process_frames
## See [wiki]Awaiting[/wiki]
func wait_frames(frames : int, msg=''):
	_lgr.deprecated("wait_frames has been replaced with wait_physics_frames which is counted in _physics_process.  " +
		"wait_process_frames has also been added which is counted in _process.")
	return wait_physics_frames(frames, msg)


## This returns a signal that is emitted after [param x] physics frames have
## elpased.  You can await this method directly to pause execution for [param x]
## physics frames.  The frames are counted prior to _physics_process being called
## on any node (when [signal SceneTree.physics_frame] is emitted).  This means the
## signal is emitted after [param x] frames and just before the x + 1 frame starts.
## [codeblock]
## await wait_physics_frames(10)
## [/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_physics_frames(x :int , msg=''):
	if(x <= 0):
		var text = str('wait_physics_frames:  frames must be > 0, you passed  ', x, '.  1 frames waited.')
		_lgr.error(text)
		x = 1

	_lgr.yield_msg(str('-- Awaiting ', x, ' physics frame(s) -- ', msg))
	_awaiter.wait_physics_frames(x)
	return _awaiter.timeout


## Alias for [method GutTest.wait_process_frames]
func wait_idle_frames(x : int, msg=''):
	return wait_process_frames(x, msg)


## This returns a signal that is emitted after [param x] process/idle frames have
## elpased.  You can await this method directly to pause execution for [param x]
## process/idle frames.  The frames are counted prior to _process being called
## on any node (when [signal SceneTree.process_frame] is emitted).  This means the
## signal is emitted after [param x] frames and just before the x + 1 frame starts.
## [codeblock]
## await wait_process_frames(10)
## # wait_idle_frames is an alias of wait_process_frames
## await wait_idle_frames(10)
## [/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_process_frames(x : int, msg=''):
	if(x <= 0):
		var text = str('wait_process_frames:  frames must be > 0, you passed  ', x, '.  1 frames waited.')
		_lgr.error(text)
		x = 1

	_lgr.yield_msg(str('-- Awaiting ', x, ' idle frame(s) -- ', msg))
	_awaiter.wait_process_frames(x)
	return _awaiter.timeout


## Use with await to wait for [param callable] to return the boolean value
## [code]true[/code] or a maximum amount of time.  All values that are not the
## boolean value [code]true[/code] are ignored.  [param callable] is called
## every [code]_physics_process[/code] tick unless an optional time between
## calls is specified.[br]
## [param p3] can be the optional message or an amount of time to wait between calls.[br]
## [param p4] is the optional message if you have specified an amount of time to
## wait between calls.[br]
## Returns [code]true[/code] if [param callable] returned true before the timeout, false if not.
##[br]
##[codeblock]
## var foo = 1
## func test_example():
##     var foo_func = func():
##         foo += 1
##         return foo == 10
##     foo = 1
##     wait_until(foo_func, 5, 'optional message')
##     # or give it a time between
##     foo = 1
##     wait_until(foo_func, 5, 1,
##         'this will timeout because we call it every second and are waiting a max of 10 seconds')
##
##[/codeblock]
## See also [method wait_while][br]
## See [wiki]Awaiting[/wiki]
func wait_until(callable, max_wait, p3='', p4=''):
	var time_between = 0.0
	var message = p4
	if(typeof(p3) != TYPE_STRING):
		time_between = p3
	else:
		message = p3

	_lgr.yield_msg(str("--Awaiting callable to return TRUE or ", max_wait, "s.  ", message))
	_awaiter.wait_until(callable, max_wait, time_between)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout


## This is the inverse of [method wait_until].  This will continue to wait while
## [param callable] returns the boolean value [code]true[/code].  If [b]ANY[/b]
## other value is is returned then the wait will end.
## Returns [code]true[/code] if [param callable] returned a value other than
## [code]true[/code] before the timeout, [code]false[/code] if not.
##[codeblock]
## var foo = 1
## func test_example():
##     var foo_func = func():
##         foo += 1
##         if(foo < 10):
##             return true
##         else:
##             return 'this is not a boolean'
##     foo = 1
##     wait_while(foo_func, 5, 'optional message')
##     # or give it a time between
##     foo = 1
##     wait_while(foo_func, 5, 1,
##         'this will timeout because we call it every second and are waiting a max of 10 seconds')
##
##[/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_while(callable, max_wait, p3='', p4=''):
	var time_between = 0.0
	var message = p4
	if(typeof(p3) != TYPE_STRING):
		time_between = p3
	else:
		message = p3

	_lgr.yield_msg(str("--Awaiting callable to return FALSE or ", max_wait, "s.  ", message))
	_awaiter.wait_while(callable, max_wait, time_between)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout



## Returns whether the last wait_* method timed out.  This is always true if
## the last method was wait_xxx_frames or wait_seconds.  It will be false when
## using wait_for_signal and wait_until if the timeout occurs before what
## is being waited on.  The wait_* methods return this value so you should be
## able to avoid calling this directly, but you can.
func did_wait_timeout():
	return _awaiter.did_last_wait_timeout

# ----------------
#endregion
#region Summary Data
# ----------------

## @internal
func get_summary():
	return _summary


## Returns the number of failing asserts in this script at the time this
## method was called.  Call in [method after_all] to get total count for script.
func get_fail_count():
	return _summary.failed


## Returns the number of passing asserts in this script at the time this method
## was called.  Call in [method after_all] to get total count for script.
func get_pass_count():
	return _summary.passed


## Returns the number of pending tests in this script at the time this method
## was called.  Call in [method after_all] to get total count for script.
func get_pending_count():
	return _summary.pending


## Returns the total number of asserts this script has made as of the time of
## this was called.  Call in [method after_all] to get total count for script.
func get_assert_count():
	return _summary.asserts


# Convert the _summary dictionary into text
## @internal
func get_summary_text():
	var to_return = get_script().get_path() + "\n"
	to_return += str('  ', _summary.passed, ' of ', _summary.asserts, ' passed.')
	if(_summary.pending > 0):
		to_return += str("\n  ", _summary.pending, ' pending')
	if(_summary.failed > 0):
		to_return += str("\n  ", _summary.failed, ' failed.')
	return to_return


# ----------------
#endregion
#region Double Methods
# ----------------


## Create a Double of [param thing].  [param thing] should be a Class, script,
## or scene.  See [wiki]Doubles[/wiki]
func double(thing, double_strat=null, not_used_anymore=null):
	if(!_are_double_parameters_valid(thing, double_strat, not_used_anymore)):
		return null

	return _smart_double(thing, double_strat, false)


## Create a Partial Double of [param thing].  [param thing] should be a Class,
## script, or scene.  See [wiki]Partial-Doubles[/wiki]
func partial_double(thing, double_strat=null, not_used_anymore=null):
	if(!_are_double_parameters_valid(thing, double_strat, not_used_anymore)):
		return null

	return _smart_double(thing, double_strat, true)


## @internal
func double_singleton(singleton_name):
	return null
	# var to_return = null
	# if(_validate_singleton_name(singleton_name)):
	# 	to_return = gut.get_doubler().double_singleton(singleton_name)
	# return to_return


## @internal
func partial_double_singleton(singleton_name):
	return null
	# var to_return = null
	# if(_validate_singleton_name(singleton_name)):
	# 	to_return = gut.get_doubler().partial_double_singleton(singleton_name)
	# return to_return


## This was implemented to allow the doubling of classes with static methods.
## There might be other valid use cases for this method, but you should always
## try stubbing before using this method.  Using
## [code]stub(my_double, 'method').to_call_super()[/code] or  creating a
## [method partial_double] works for any other known scenario.  You cannot stub
## or spy on methods passed to [code skip-lint]ignore_method_when_doubling[/code].
func ignore_method_when_doubling(thing, method_name):
	if(typeof(thing) == TYPE_STRING):
		_lgr.error('ignore_method_when_doubling no longer supports paths to scripts or scenes.  Load them and pass them instead.')
		return

	var r = thing
	if(thing is PackedScene):
		r = GutUtils.get_scene_script_object(thing)

	gut.get_doubler().add_ignored_method(r, method_name)


## Stub something.  See [wiki]Stubbing[/wiki] for detailed information about stubbing.
func stub(thing, p2=null, p3=null):
	var method_name = p2
	var subpath = null

	if(p3 != null):
		subpath = p2
		method_name = p3

	if(GutUtils.is_instance(thing)):
		var msg = _get_bad_double_or_method_message(thing, method_name, 'stub')
		if(msg != ''):
			_lgr.error(msg)
			return GutUtils.StubParams.new()

	var sp = null
	if(typeof(thing) == TYPE_CALLABLE):
		if(p2 != null or p3 != null):
			_lgr.error("Only one parameter expected when using a callable.")
		sp = GutUtils.StubParams.new(thing)
	else:
		sp = GutUtils.StubParams.new(thing, method_name, subpath)

	sp.logger = _lgr
	gut.get_stubber().add_stub(sp)
	return sp

# ----------------
#endregion
#region Memory Mgmt
# ----------------


## Marks whatever is passed in to be freed after the test finishes.  It also
## returns what is passed in so you can save a line of code.
##   var thing = autofree(Thing.new())
func autofree(thing):
	gut.get_autofree().add_free(thing)
	return thing


## Works the same as autofree except queue_free will be called on the object
## instead.  This also imparts a brief pause after the test finishes so that
## the queued object has time to free.
func autoqfree(thing):
	gut.get_autofree().add_queue_free(thing)
	return thing


## The same as autofree but it also adds the object as a child of the test.
func add_child_autofree(node, legible_unique_name = false):
	gut.get_autofree().add_free(node)
	# Explicitly calling super here b/c add_child MIGHT change and I don't want
	# a bug sneaking its way in here.
	super.add_child(node, legible_unique_name)
	return node


## The same as autoqfree but it also adds the object as a child of the test.
func add_child_autoqfree(node, legible_unique_name=false):
	gut.get_autofree().add_queue_free(node)
	# Explicitly calling super here b/c add_child MIGHT change and I don't want
	# a bug sneaking its way in here.
	super.add_child(node, legible_unique_name)
	return node



# ----------------
#endregion
#region Deprecated/Removed
# ----------------


## REMOVED
## @ignore
func compare_shallow(v1, v2, max_differences=null):
	_fail('compare_shallow has been removed.  Use compare_deep or just compare using == instead.')
	_lgr.error('compare_shallow has been removed.  Use compare_deep or just compare using == instead.')
	return null


## REMOVED
## @ignore
func assert_eq_shallow(v1, v2):
	_fail('assert_eq_shallow has been removed.  Use assert_eq/assert_same/assert_eq_deep')


## REMOVED
## @ignore
func assert_ne_shallow(v1, v2):
	_fail('assert_eq_shallow has been removed.  Use assert_eq/assert_same/assert_eq_deep')


## @deprecated: use wait_seconds
func yield_for(time, msg=''):
	_lgr.deprecated('yield_for', 'wait_seconds')
	return wait_seconds(time, msg)


## @deprecated: use wait_for_signal
func yield_to(obj, signal_name, max_wait, msg=''):
	_lgr.deprecated('yield_to', 'wait_for_signal')
	return await wait_for_signal(Signal(obj, signal_name), max_wait, msg)


## @deprecated: use wait_frames
func yield_frames(frames, msg=''):
	_lgr.deprecated("yield_frames", "wait_frames")
	return wait_frames(frames, msg)


## @deprecated: no longer supported.  Use double
func double_scene(path, strategy=null):
	_lgr.deprecated('test.double_scene has been removed.', 'double')
	return null


## @deprecated: no longer supported.  Use double
func double_script(path, strategy=null):
	_lgr.deprecated('test.double_script has been removed.', 'double')
	return null

	# var override_strat = GutUtils.nvl(strategy, gut.get_doubler().get_strategy())
	# return gut.get_doubler().double(path, override_strat)


## @deprecated: no longer supported.  Use register_inner_classes + double
func double_inner(path, subpath, strategy=null):
	_lgr.deprecated('double_inner should not be used.  Use register_inner_classes and double instead.', 'double')
	return null

	var override_strat = GutUtils.nvl(strategy, gut.get_doubler().get_strategy())
	return gut.get_doubler().double_inner(path, subpath, override_strat)


## @deprecated:  Use [method assert_called_count] instead.
func assert_call_count(inst, method_name, expected_count, parameters=null):
	gut.logger.deprecated('This has been replaced with assert_called_count which accepts a Callable with optional bound arguments.')
	var callable = Callable.create(inst, method_name)
	if(parameters != null):
		callable = callable.bindv(parameters)
	assert_called_count(callable, expected_count)


## @deprecated: no longer supported.
func assert_setget(
	instance, name_property,
	const_or_setter = null, getter="__not_set__"):
	_lgr.deprecated('assert_property')
	_fail('assert_setget has been removed.  Use assert_property, assert_set_property, assert_readonly_property instead.')


# ----------------
#endregion



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# View readme for usage details.
#
# Version - see gut.gd
# ##############################################################################
# Class that all test scripts must extend.`
#
# This provides all the asserts and other testing features.  Test scripts are
# run by the Gut class in gut.gd
# ##############################################################################


=====================================
FILE: ./addons/gut/diff_formatter.gd
=====================================
var _strutils = GutUtils.Strutils.new()
const INDENT = '    '
var _max_to_display = 30
const ABSOLUTE_MAX_DISPLAYED = 10000
const UNLIMITED = -1


func _single_diff(diff, depth=0):
	var to_return = ""
	var brackets = diff.get_brackets()

	if(brackets != null and !diff.are_equal):
		to_return = ''
		to_return += str(brackets.open, "\n",
			_strutils.indent_text(differences_to_s(diff.differences, depth), depth+1, INDENT), "\n",
			brackets.close)
	else:
		to_return = str(diff)

	return to_return


func make_it(diff):
	var to_return = ''
	if(diff.are_equal):
		to_return = diff.summary
	else:
		if(_max_to_display ==  ABSOLUTE_MAX_DISPLAYED):
			to_return = str(diff.get_value_1(), ' != ', diff.get_value_2())
		else:
			to_return = diff.get_short_summary()
		to_return +=  str("\n", _strutils.indent_text(_single_diff(diff, 0), 1, '  '))
	return to_return


func differences_to_s(differences, depth=0):
	var to_return = ''
	var keys = differences.keys()
	keys.sort()
	var limit = min(_max_to_display, differences.size())

	for i in range(limit):
		var key = keys[i]
		to_return += str(key, ":  ", _single_diff(differences[key], depth))

		if(i != limit -1):
			to_return += "\n"

	if(differences.size() > _max_to_display):
		to_return += str("\n\n... ", differences.size() - _max_to_display, " more.")

	return to_return


func get_max_to_display():
	return _max_to_display


func set_max_to_display(max_to_display):
	_max_to_display = max_to_display
	if(_max_to_display == UNLIMITED):
		_max_to_display = ABSOLUTE_MAX_DISPLAYED



=====================================
FILE: ./addons/gut/logger.gd
=====================================
var types = {
	debug = 'debug',
	deprecated = 'deprecated',
	error = 'error',
	failed = 'failed',
	info = 'info',
	normal = 'normal',
	orphan = 'orphan',
	passed = 'passed',
	pending = 'pending',
	risky = 'risky',
	warn = 'warn',
}

var fmts = {
	red = 'red',
	yellow = 'yellow',
	green = 'green',

	bold = 'bold',
	underline = 'underline',

	none = null
}

var _type_data = {
	types.debug:		{disp='DEBUG', 		enabled=true, fmt=fmts.bold},
	types.deprecated:	{disp='DEPRECATED', enabled=true, fmt=fmts.none},
	types.error:		{disp='ERROR', 		enabled=true, fmt=fmts.red},
	types.failed:		{disp='Failed', 	enabled=true, fmt=fmts.red},
	types.info:			{disp='INFO', 		enabled=true, fmt=fmts.bold},
	types.normal:		{disp='NORMAL', 	enabled=true, fmt=fmts.none},
	types.orphan:		{disp='Orphans',	enabled=true, fmt=fmts.yellow},
	types.passed:		{disp='Passed', 	enabled=true, fmt=fmts.green},
	types.pending:		{disp='Pending',	enabled=true, fmt=fmts.yellow},
	types.risky:		{disp='Risky',		enabled=true, fmt=fmts.yellow},
	types.warn:			{disp='WARNING', 	enabled=true, fmt=fmts.yellow},
}

var _logs = {
	types.warn: [],
	types.error: [],
	types.info: [],
	types.debug: [],
	types.deprecated: [],
}

var _printers = {
	terminal = null,
	gui = null,
	console = null
}

var _gut = null
var _indent_level = 0
var _min_indent_level = 0
var _indent_string = '    '
var _less_test_names = false
var _yield_calls = 0
var _last_yield_text = ''

func _init():
	_printers.terminal = GutUtils.Printers.TerminalPrinter.new()
	_printers.console = GutUtils.Printers.ConsolePrinter.new()
	# There were some problems in the timing of disabling this at the right
	# time in gut_cmdln so it is disabled by default.  This is enabled
	# by plugin_control.gd based on settings.
	_printers.console.set_disabled(true)

func get_indent_text():
	var pad = ''
	for i in range(_indent_level):
		pad += _indent_string

	return pad

func _indent_text(text):
	var to_return = text
	var ending_newline = ''

	if(text.ends_with("\n")):
		ending_newline = "\n"
		to_return = to_return.left(to_return.length() -1)

	var pad = get_indent_text()
	to_return = to_return.replace("\n", "\n" + pad)
	to_return += ending_newline

	return pad + to_return

func _should_print_to_printer(key_name):
	return _printers[key_name] != null and !_printers[key_name].get_disabled()

func _print_test_name():
	if(_gut == null):
		return

	var cur_test = _gut.get_current_test_object()
	if(cur_test == null):
		return false

	if(!cur_test.has_printed_name):
		var param_text = ''
		if(cur_test.arg_count > 0):
			# Just an FYI, parameter_handler in gut might not be set yet so can't
			# use it here for cooler output.
			param_text = '<parameterized>'
		_output(str('* ', cur_test.name, param_text, "\n"))
		cur_test.has_printed_name = true

func _output(text, fmt=null):
	for key in _printers:
		if(_should_print_to_printer(key)):
			_printers[key].send(text, fmt)

func _log(text, fmt=fmts.none):
	_print_test_name()
	var indented = _indent_text(text)
	_output(indented, fmt)

# ---------------
# Get Methods
# ---------------
func get_warnings():
	return get_log_entries(types.warn)

func get_errors():
	return get_log_entries(types.error)

func get_infos():
	return get_log_entries(types.info)

func get_debugs():
	return get_log_entries(types.debug)

func get_deprecated():
	return get_log_entries(types.deprecated)

func get_count(log_type=null):
	var count = 0
	if(log_type == null):
		for key in _logs:
			count += _logs[key].size()
	else:
		count = _logs[log_type].size()
	return count

func get_log_entries(log_type):
	return _logs[log_type]

# ---------------
# Log methods
# ---------------
func _output_type(type, text):
	var td = _type_data[type]
	if(!td.enabled):
		# if(_logs.has(type)):
		# 	_logs[type].append(text)
		return

	_print_test_name()
	if(type != types.normal):
		if(_logs.has(type)):
			_logs[type].append(text)

		var start = str('[', td.disp, ']')
		if(text != null and text != ''):
			start += ':  '
		else:
			start += ' '
		var indented_start = _indent_text(start)
		var indented_end = _indent_text(text)
		indented_end = indented_end.lstrip(_indent_string)
		_output(indented_start, td.fmt)
		_output(indented_end + "\n")


func debug(text):
	_output_type(types.debug, text)

# supply some text or the name of the deprecated method and the replacement.
func deprecated(text, alt_method=null):
	var msg = text
	if(alt_method):
		msg = str('The method ', text, ' is deprecated, use ', alt_method , ' instead.')
	return _output_type(types.deprecated, msg)

func error(text):
	_output_type(types.error, text)
	if(_gut != null):
		_gut._fail_for_error(text)

func failed(text):
	_output_type(types.failed, text)

func info(text):
	_output_type(types.info, text)

func orphan(text):
	_output_type(types.orphan, text)

func passed(text):
	_output_type(types.passed, text)

func pending(text):
	_output_type(types.pending, text)

func risky(text):
	_output_type(types.risky, text)

func warn(text):
	_output_type(types.warn, text)

func log(text='', fmt=fmts.none):
	end_yield()
	if(text == ''):
		_output("\n")
	else:
		_log(text + "\n", fmt)
	return null

func lograw(text, fmt=fmts.none):
	return _output(text, fmt)

# Print the test name if we aren't skipping names of tests that pass (basically
# what _less_test_names means))
func log_test_name():
	# suppress output if we haven't printed the test name yet and
	# what to print is the test name.
	if(!_less_test_names):
		_print_test_name()

# ---------------
# Misc
# ---------------
func get_gut():
	return _gut

func set_gut(gut):
	_gut = gut
	if(_gut == null):
		_printers.gui = null
	else:
		if(_printers.gui == null):
			_printers.gui = GutUtils.Printers.GutGuiPrinter.new()


func get_indent_level():
	return _indent_level

func set_indent_level(indent_level):
	_indent_level = max(_min_indent_level, indent_level)

func get_indent_string():
	return _indent_string

func set_indent_string(indent_string):
	_indent_string = indent_string

func clear():
	for key in _logs:
		_logs[key].clear()

func inc_indent():
	_indent_level += 1

func dec_indent():
	_indent_level = max(_min_indent_level, _indent_level -1)

func is_type_enabled(type):
	return _type_data[type].enabled

func set_type_enabled(type, is_enabled):
	_type_data[type].enabled = is_enabled

func get_less_test_names():
	return _less_test_names

func set_less_test_names(less_test_names):
	_less_test_names = less_test_names

func disable_printer(name, is_disabled):
	if(_printers[name] != null):
		_printers[name].set_disabled(is_disabled)

func is_printer_disabled(name):
	return _printers[name].get_disabled()

func disable_formatting(is_disabled):
	for key in _printers:
		_printers[key].set_format_enabled(!is_disabled)

func disable_all_printers(is_disabled):
	for p in _printers:
		disable_printer(p, is_disabled)

func get_printer(printer_key):
	return _printers[printer_key]

func _yield_text_terminal(text):
	var printer = _printers['terminal']
	if(_yield_calls != 0):
		printer.clear_line()
		printer.back(_last_yield_text.length())
	printer.send(text, fmts.yellow)

func _end_yield_terminal():
	var printer = _printers['terminal']
	printer.clear_line()
	printer.back(_last_yield_text.length())

func _yield_text_gui(text):
	pass
	# var lbl = _gut.get_gui().get_waiting_label()
	# lbl.visible = true
	# lbl.set_bbcode('[color=yellow]' + text + '[/color]')

func _end_yield_gui():
	pass
	# var lbl = _gut.get_gui().get_waiting_label()
	# lbl.visible = false
	# lbl.set_text('')

# This is used for displaying the "yield detected" and "yielding to" messages.
func yield_msg(text):
	if(_type_data.warn.enabled):
		self.log(text, fmts.yellow)

# This is used for the animated "waiting" message
func yield_text(text):
	_yield_text_terminal(text)
	_yield_text_gui(text)
	_last_yield_text = text
	_yield_calls += 1

# This is used for the animated "waiting" message
func end_yield():
	if(_yield_calls == 0):
		return
	_end_yield_terminal()
	_end_yield_gui()
	_yield_calls = 0
	_last_yield_text = ''

func get_gui_bbcode():
	return _printers.gui.get_bbcode()



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This class wraps around the various printers and supplies formatting for the
# various message types (error, warning, etc).
# ##############################################################################


=====================================
FILE: ./addons/gut/GutScene.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://m28heqtswbuq"]

[ext_resource type="Script" path="res://addons/gut/GutScene.gd" id="1_b4m8y"]
[ext_resource type="PackedScene" uid="uid://duxblir3vu8x7" path="res://addons/gut/gui/NormalGui.tscn" id="2_j6ywb"]
[ext_resource type="PackedScene" uid="uid://cnqqdfsn80ise" path="res://addons/gut/gui/MinGui.tscn" id="3_3glw1"]

[node name="GutScene" type="Node2D"]
script = ExtResource("1_b4m8y")

[node name="Normal" parent="." instance=ExtResource("2_j6ywb")]

[node name="Compact" parent="." instance=ExtResource("3_3glw1")]
offset_left = 5.0
offset_top = 273.0
offset_right = 265.0
offset_bottom = 403.0


=====================================
FILE: ./addons/gut/fonts/OFL.txt
=====================================
Copyright (c) 2009, Mark Simonson (http://www.ms-studio.com, mark@marksimonson.com),
with Reserved Font Name Anonymous Pro.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.


=====================================
FILE: ./addons/gut/orphan_counter.gd
=====================================
# ------------------------------------------------------------------------------
# This is used to track the change in orphans over different intervals.
# You use this by adding a counter at the start of an interval and then
# using get_orphans_since to find out how many orphans have been created since
# that counter was added.
#
# For example, when a test starts, gut adds a counter for "test" which
# creates/sets the counter's value to the current orphan count.  At the end of
# the test GUT uses get_orphans_since("test") to find out how many orphans
# were created by the test.
# ------------------------------------------------------------------------------
var _counters = {}

func orphan_count():
	return Performance.get_monitor(Performance.OBJECT_ORPHAN_NODE_COUNT)

func add_counter(name):
	_counters[name] = orphan_count()

# Returns the number of orphans created since add_counter was last called for
# the name.  Returns -1 to avoid blowing up with an invalid name but still
# be somewhat visible that we've done something wrong.
func get_orphans_since(name):
	return orphan_count() - _counters[name] if _counters.has(name) else -1

func get_count(name):
	return _counters.get(name, -1)

func print_orphans(name, lgr):
	var count = get_orphans_since(name)

	if(count > 0):
		var o = 'orphan'
		if(count > 1):
			o = 'orphans'
		lgr.orphan(str(count, ' new ', o, ' in ', name, '.'))

func print_all():
	var msg = str("Total Orphans ", orphan_count(), "\n", JSON.stringify(_counters, "    "))
	print(msg)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This is a utility for tracking changes in the orphan count.  Each time
# add_counter is called it adds/resets the value in the dictionary to the
# current number of orphans.  Each call to get_counter will return the change
# in orphans since add_counter was last called.
# ##############################################################################

=====================================
FILE: ./addons/gut/doubler.gd
=====================================
extends RefCounted


var _base_script_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/script_template.txt')
var _script_collector = GutUtils.ScriptCollector.new()
# used by tests for debugging purposes.
var print_source = false
var inner_class_registry = GutUtils.InnerClassRegistry.new()

# ###############
# Properties
# ###############
var _stubber = GutUtils.Stubber.new()
func get_stubber():
	return _stubber
func set_stubber(stubber):
	_stubber = stubber

var _lgr = GutUtils.get_logger()
func get_logger():
	return _lgr
func set_logger(logger):
	_lgr = logger
	_method_maker.set_logger(logger)

var _spy = null
func get_spy():
	return _spy
func set_spy(spy):
	_spy = spy

var _gut = null
func get_gut():
	return _gut
func set_gut(gut):
	_gut = gut

var _strategy = null
func get_strategy():
	return _strategy
func set_strategy(strategy):
	if(GutUtils.DOUBLE_STRATEGY.values().has(strategy)):
		_strategy = strategy
	else:
		_lgr.error(str('doubler.gd:  invalid double strategy ', strategy))


var _method_maker = GutUtils.MethodMaker.new()
func get_method_maker():
	return _method_maker

var _ignored_methods = GutUtils.OneToMany.new()
func get_ignored_methods():
	return _ignored_methods

# ###############
# Private
# ###############
func _init(strategy=GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY):
	set_logger(GutUtils.get_logger())
	_strategy = strategy


func _get_indented_line(indents, text):
	var to_return = ''
	for _i in range(indents):
		to_return += "\t"
	return str(to_return, text, "\n")


func _stub_to_call_super(parsed, method_name):
	if(!parsed.get_method(method_name).is_eligible_for_doubling()):
		return

	var params = GutUtils.StubParams.new(parsed.script_path, method_name, parsed.subpath)
	params.to_call_super()
	_stubber.add_stub(params)


func _get_base_script_text(parsed, override_path, partial, included_methods):
	var path = parsed.script_path
	if(override_path != null):
		path = override_path

	var stubber_id = -1
	if(_stubber != null):
		stubber_id = _stubber.get_instance_id()

	var spy_id = -1
	if(_spy != null):
		spy_id = _spy.get_instance_id()

	var gut_id = -1
	if(_gut != null):
		gut_id = _gut.get_instance_id()

	var extends_text  = parsed.get_extends_text()

	var values = {
		# Top  sections
		"extends":extends_text,
		"constants":'',#obj_info.get_constants_text(),
		"properties":'',#obj_info.get_properties_text(),

		# metadata values
		"path":path,
		"subpath":GutUtils.nvl(parsed.subpath, ''),
		"stubber_id":stubber_id,
		"spy_id":spy_id,
		"gut_id":gut_id,
		"singleton_name":'',#GutUtils.nvl(obj_info.get_singleton_name(), ''),
		"is_partial":partial,
		"doubled_methods":included_methods,
	}

	return _base_script_text.format(values)


func _is_method_eligible_for_doubling(parsed_script, parsed_method):
	return !parsed_method.is_accessor() and \
		parsed_method.is_eligible_for_doubling() and \
		!_ignored_methods.has(parsed_script.resource, parsed_method.meta.name)


# Disable the native_method_override setting so that doubles do not generate
# errors or warnings when doubling with INCLUDE_NATIVE or when a method has
# been added because of param_count stub.
func _create_script_no_warnings(src):
	var prev_native_override_value = null
	var native_method_override = 'debug/gdscript/warnings/native_method_override'
	prev_native_override_value = ProjectSettings.get_setting(native_method_override)
	ProjectSettings.set_setting(native_method_override, 0)

	var DblClass = GutUtils.create_script_from_source(src)

	ProjectSettings.set_setting(native_method_override, prev_native_override_value)
	return DblClass


func _create_double(parsed, strategy, override_path, partial):
	var path = ""

	path = parsed.script_path
	var dbl_src = ""
	var included_methods = []

	for method in parsed.get_local_methods():
		if(_is_method_eligible_for_doubling(parsed, method)):
			included_methods.append(method.meta.name)
			var mthd = parsed.get_local_method(method.meta.name)
			if(parsed.is_native):
				dbl_src += _get_func_text(method.meta, parsed.resource)
			else:
				dbl_src += _get_func_text(method.meta, path)

	if(strategy == GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE):
		for method in parsed.get_super_methods():
			if(_is_method_eligible_for_doubling(parsed, method)):
				included_methods.append(method.meta.name)
				_stub_to_call_super(parsed, method.meta.name)
				if(parsed.is_native):
					dbl_src += _get_func_text(method.meta, parsed.resource)
				else:
					dbl_src += _get_func_text(method.meta, path)

	var base_script = _get_base_script_text(parsed, override_path, partial, included_methods)
	dbl_src = base_script + "\n\n" + dbl_src


	if(print_source):
		print(GutUtils.add_line_numbers(dbl_src))

	var DblClass = _create_script_no_warnings(dbl_src)
	if(_stubber != null):
		_stub_method_default_values(DblClass, parsed, strategy)

	return DblClass


func _stub_method_default_values(which, parsed, strategy):
	for method in parsed.get_local_methods():
		if(method.is_eligible_for_doubling() and !_ignored_methods.has(parsed.resource, method.meta.name)):
			_stubber.stub_defaults_from_meta(parsed.script_path, method.meta)


func _double_scene_and_script(scene, strategy, partial):
	var dbl_bundle = scene._bundled.duplicate(true)
	var script_obj = GutUtils.get_scene_script_object(scene)
	# I'm not sure if the script object for the root node of a packed scene is
	# always the first entry in "variants" so this tries to find it.
	var script_index = dbl_bundle["variants"].find(script_obj)
	var script_dbl = null

	if(script_obj != null):
		if(partial):
			script_dbl = _partial_double(script_obj, strategy, scene.get_path())
		else:
			script_dbl = _double(script_obj, strategy, scene.get_path())

	if(script_index != -1):
		dbl_bundle["variants"][script_index] = script_dbl

	var doubled_scene = PackedScene.new()
	doubled_scene._set_bundled_scene(dbl_bundle)

	return doubled_scene


func _get_inst_id_ref_str(inst):
	var ref_str = 'null'
	if(inst):
		ref_str = str('instance_from_id(', inst.get_instance_id(),')')
	return ref_str


func _get_func_text(method_hash, path):
	var override_count = null;
	if(_stubber != null):
		override_count = _stubber.get_parameter_count(path, method_hash.name)

	var text = _method_maker.get_function_text(method_hash, override_count) + "\n"

	return text


func _parse_script(obj):
	var parsed = null

	if(GutUtils.is_inner_class(obj)):
		if(inner_class_registry.has(obj)):
			parsed = _script_collector.parse(inner_class_registry.get_base_resource(obj), obj)
		else:
			_lgr.error('Doubling Inner Classes requires you register them first.  Call register_inner_classes passing the script that contains the inner class.')
	else:
		parsed = _script_collector.parse(obj)

	return parsed


# Override path is used with scenes.
func _double(obj, strategy, override_path=null):
	var parsed = _parse_script(obj)
	if(parsed != null):
		return _create_double(parsed, strategy, override_path, false)


func _partial_double(obj, strategy, override_path=null):
	var parsed = _parse_script(obj)
	if(parsed != null):
		return _create_double(parsed, strategy, override_path, true)


# -------------------------
# Public
# -------------------------

# double a script/object
func double(obj, strategy=_strategy):
	return _double(obj, strategy)

func partial_double(obj, strategy=_strategy):
	return _partial_double(obj, strategy)


# double a scene
func double_scene(scene, strategy=_strategy):
	return _double_scene_and_script(scene, strategy, false)


func partial_double_scene(scene, strategy=_strategy):
	return _double_scene_and_script(scene, strategy, true)


func double_gdnative(which):
	return _double(which, GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE)


func partial_double_gdnative(which):
	return _partial_double(which, GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE)


func double_inner(parent, inner, strategy=_strategy):
	var parsed = _script_collector.parse(parent, inner)
	return _create_double(parsed, strategy, null, false)


func partial_double_inner(parent, inner, strategy=_strategy):
	var parsed = _script_collector.parse(parent, inner)
	return _create_double(parsed, strategy, null, true)


func add_ignored_method(obj, method_name):
	_ignored_methods.add(obj, method_name)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################


=====================================
FILE: ./addons/gut/double_templates/function_template.txt
=====================================
{func_decleration}
	{vararg_warning}__gutdbl.spy_on('{method_name}', {param_array})
	if(__gutdbl.is_stubbed_to_call_super('{method_name}', {param_array})):
		return {super_call}
	else:
		return await __gutdbl.handle_other_stubs('{method_name}', {param_array})


=====================================
FILE: ./addons/gut/double_templates/script_template.txt
=====================================
# ##############################################################################
# Gut Doubled Script
# ##############################################################################
{extends}

{constants}

{properties}

# ------------------------------------------------------------------------------
# GUT stuff
# ------------------------------------------------------------------------------
var __gutdbl_values = {
	double = self,
	thepath = '{path}',
	subpath = '{subpath}',
	stubber = {stubber_id},
	spy = {spy_id},
	gut = {gut_id},
	from_singleton = '{singleton_name}',
	is_partial = {is_partial},
	doubled_methods = {doubled_methods},
}
var __gutdbl = load('res://addons/gut/double_tools.gd').new(__gutdbl_values)

# Here so other things can check for a method to know if this is a double.
func __gutdbl_check_method__():
	pass

# ------------------------------------------------------------------------------
# Doubled Methods
# ------------------------------------------------------------------------------


=====================================
FILE: ./addons/gut/double_templates/init_template.txt
=====================================
{func_decleration}:
	super({super_params})
	__gutdbl.spy_on('{method_name}', {param_array})



=====================================
FILE: ./addons/gut/double_tools.gd
=====================================
var thepath = ''
var subpath = ''
var stubber = null
var spy = null
var gut = null
var from_singleton = null
var is_partial = null
var double = null

const NO_DEFAULT_VALUE = '!__gut__no__default__value__!'
func _init(values=null):
	if(values != null):
		double = values.double
		thepath = values.thepath
		subpath = values.subpath
		stubber = from_id(values.stubber)
		spy = from_id(values.spy)
		gut = from_id(values.gut)
		from_singleton = values.from_singleton
		is_partial = values.is_partial

	if(gut != null):
		gut.get_autofree().add_free(double)


func _get_stubbed_method_to_call(method_name, called_with):
	var method = stubber.get_call_this(double, method_name, called_with)
	if(method != null):
		method = method.bindv(called_with)
		return method
	return method


func from_id(inst_id):
	if(inst_id ==  -1):
		return null
	else:
		return instance_from_id(inst_id)


func is_stubbed_to_call_super(method_name, called_with):
	if(stubber != null):
		return stubber.should_call_super(double, method_name, called_with)
	else:
		return false


func handle_other_stubs(method_name, called_with):
	if(stubber == null):
		return

	var method = _get_stubbed_method_to_call(method_name, called_with)
	if(method != null):
		return await method.call()
	else:
		return stubber.get_return(double, method_name, called_with)


func spy_on(method_name, called_with):
	if(spy != null):
		spy.add_call(double, method_name, called_with)


func default_val(method_name, p_index, default_val=NO_DEFAULT_VALUE):
	if(stubber != null):
		return stubber.get_default_value(double, method_name, p_index)
	else:
		return null


func vararg_warning():
	if(gut != null):
		gut.get_logger().warn(
			"This method contains a vararg argument and the paramter count was not stubbed.  " + \
			"GUT adds extra parameters to this method which should fill most needs.  " + \
			"It is recommended that you stub param_count for this object's class to ensure " + \
			"that there are not any parameter count mismatch errors.")


=====================================
FILE: ./docs/TODO.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ████████╗ ██████╗ ██████╗  ██████╗                                         ║
║   ╚══██╔══╝██╔═══██╗██╔══██╗██╔═══██╗                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ╚██████╔╝██████╔╝╚██████╔╝                                        ║
║      ╚═╝    ╚═════╝ ╚═════╝  ╚═════╝                                         ║
║                                                                              ║
║                    Strategic Development Plan & Actionable Tasks             ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 1: FORTIFICATION & PRODUCTION PIPELINES           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Build the safety net. Harden the project against regressions and     ║
║   streamline core workflows to enable rapid, confident development.          ║
║                                                                              ║
║   █ Architecture & Testing                                                   ║
║   ░ Implement the Automated Testing Framework (GUT) to safeguard all         ║
║   ░ future work. This is the highest priority architectural task.            ║
║   ░                                                                          ║
║   ░ □ Integrate the Godot Unit Test (GUT) framework into src/tests/.         ║
║   ░ □ Write initial unit tests for critical, non-visual components:          ║
║   ░   - HealthComponent: Damage application, invincibility, death signal.    ║
║   ░   - PlayerResourceComponent: Determination-to-charge conversion.         ║
║   ░   - ObjectPool: get_instance/return_instance lifecycle.                  ║
║   ░ □ Create a headless integration test to run an encounter for 600         ║
║   ░   frames and assert that no errors are thrown.                           ║
║   ░ □ Update the GitHub Actions CI workflow to run all tests on push.        ║
║                                                                              ║
║   █ Production & Tooling                                                     ║
║   ░ Establish professional-grade tooling for debugging and UI management.    ║
║   ░                                                                          ║
║   ░ □ Implement a Centralized Logging System (LogManager.gd autoload)        ║
║   ░   to replace all print() calls with structured, leveled logging.         ║
║   ░ □ Create a central main_theme.tres resource to unify all UI fonts,       ║
║   ░   colors, and styles, pulling values from Palette.gd.                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            PHASE 2: CONTENT EXPANSION & VISUAL IDENTITY              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Build out the core game experience and implement the signature       ║
║   "Aesthetic Maximalism" visual identity through shaders and feedback.       ║
║                                                                              ║
║   █ Gameplay & Design                                                        ║
║   ░ Transform the single encounter into a playable game loop.                ║
║   ░                                                                          ║
║   ░ □ Implement the Core Game Loop:                                          ║
║   ░   - Create WorldState.tres to track defeated bosses.                     ║
║   ░   - Create a SaveManager using ConfigFile to save/load progress.         ║
║   ░   - Build a functional "Stage Select" screen.                            ║
║   ░ □ Generalize the Boss Attack System to empower design:                   ║
║   ░   - Expand AttackPattern.gd with an AttackType enum and more data.       ║
║   ░   - Refactor StateBossAttack into a generic executor.                    ║
║                                                                              ║
║   █ Juice & Feedback (Game Feel) - CURRENT FOCUS                             ║
║   ░ The focus is now on tangible "game feel" to make interactions satisfying.║
║   ░                                                                          ║
║   ░ □ Implement Screen Shake via FXManager for player damage and boss attacks║
║   ░ □ Implement Hit-Stop via FXManager for close-range melee hits on boss.   ║
║   ░ □ Create and pool a basic "hit spark" particle effect via VFXManager.    ║
║   ░ □ Implement the Full Shader Strategy:                                    ║
║   ░   - Develop an "FX Cookbook" registry in FXManager.                      ║
║   ░   - Implement entity shaders (Hit-Flash, Dissolve).                      ║
║   ░   - Implement UI shaders (SDF Panels for menus).                         ║
║   ░   - Implement fullscreen shaders (Shockwave).                            ║
║                                                                              ║
║   █ Systems & Narrative                                                      ║
║   ░ Flesh out supporting systems required for a complete experience.         ║
║   ░                                                                          ║
║   ░ □ Implement the basic functionality for the DialogueManager and          ║
║   ░   DialogueBox to enable storytelling.                                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 3: POLISHING & PROFESSIONALIZATION                ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Add the features that elevate the project from a great prototype to  ║
║   a shippable, high-quality product, focusing on accessibility and depth.    ║
║                                                                              ║
║   █ Accessibility & Internationalization                                     ║
║   ░ Ensure the game is playable by the widest possible audience.             ║
║   ░                                                                          ║
║   ░ □ Abstract all user-facing text for localization using tr("KEY").        ║
║   ░ □ Implement Control Remapping in the Controls Screen.                    ║
║   ░ □ Implement Colorblind Modes via Palette texture swapping.               ║
║                                                                              ║
║   █ Advanced Mechanics & Game Feel                                           ║
║   ░ Add mechanical depth and a final layer of authored polish.               ║
║   ░                                                                          ║
║   ░ □ Develop a Stun/Poise System for the boss to reward aggression.         ║
║   ░ □ Refactor key moments (player attack, boss intros) to be driven by      ║
║   ░   AnimationPlayer for more authored, cinematic sequences.                ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                    FUTURE CONSIDERATIONS & DEFERRED TASKS            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of lower-priority goals for future consideration.                   ║
║                                                                              ║
║   ░ Fast-Fall: Holding 'Down' in the air increases gravity.                  ║
║   ░ Diegetic UI Implementation (UI integrated into the game world).          ║
║   ░ Advanced Boss AI (Adaptive tactics, environmental interaction).          ║
║   ░ Player Loadout System (Alternative weapons or abilities).                ║
║   ░ Special Game Modes (Boss Rush, Time Attack).                             ║
║   ░ Automated Component Dependency Injection (reduce entity setup boilerplate).║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝



Add dust on landing, walking, touching wall, and jumping from wall.




Older TODO need to investigate again.

# Phase 2 Audit & Elevation Plan

## Snapshot of what’s strong already

* **Centralized FX service**: `FXManager` already cleanly owns screenshake, hit-stop, VFX pooling, prewarm, and camera registration, which is a great separation of concerns for “juice” orchestration. You’re already calling it from gameplay (e.g., Player and Boss).  &#x20;
* **Composable entities**: Componentized player/boss with a state machine that’s DI-friendly via `setup(p_owner, p_dependencies)` and teardown hygiene. That’s very SOLID. &#x20;
* **Damage pipeline**: `HealthComponent` as the single source of truth for invincibility, knockback, and signals (`took_damage`, `died`) is a solid foundation to hook FX and gameplay.&#x20;
* **Events & identifiers**: A global EventBus and typed events are already in use (e.g., boss phase change, healing charges). This supports Dependency Inversion across systems. &#x20;

---

## 1) Juice & Feedback — Elevate the Shader Strategy (and unify FX)

### Key risks/gaps

* **Two managers present**: There’s a `vfx_manager.gd` and a production `FXManager`; only the latter is autoloaded. Remove/rename the legacy script to avoid drift. (Project docs explicitly list `FXManager` as an autoload.)&#x20;
* **Shader effects are not first-class**: VFX pooling exists, but shader FX are not yet modeled as reusable resources or scheduled/stacked like other FX.

### Elevated design (future-proof + SOLID)

**A. Promote shaders to first-class “FX” alongside particles/VFX**

* Introduce `ShaderEffect` (Resource) with:

  * `shader: Shader`
  * `params: Dictionary<String, Variant|Curve>` (supports static or animated values)
  * `duration: float`
  * `target_scope: enum { ENTITY, UI, FULLSCREEN }`
  * `priority: int` (for conflict resolution)
* Add `IFxEffect` interface semantics (or documented contract) so `FXManager` treats `VFXEffect`, `ScreenShakeEffect`, and `ShaderEffect` uniformly (Open/Closed). `FXManager` remains the single façade (DIP).

**B. Binding layer per scope**

* **EntityShaderBinding**: Attaches a temporary `ShaderMaterial` to a `CanvasItem`/`Sprite/Polygon2D/ColorRect`, pushes/restores original material safely, animates params via Tween. Handles **Hit-Flash** and **Dissolve** without leaking. (Entities already expose clear visuals: e.g., Player `ColorRect` at `$ColorRect` and Boss visual nodes.) &#x20;
* **UIShaderBinding**: Applies SDF panel shader to `Control` via theme or per-node `Material`. Encourages design tokens (see below).
* **FullscreenShaderBinding**: A dedicated `CanvasLayer` with a `ColorRect` + `ShaderMaterial` stack; `FXManager.trigger_fullscreen(shader_effect, world_pos?)` injects effects (Shockwave converts world→screen, queues by priority, cleans up).

**C. Effect graph (optional but future-proof)**

* If you foresee multiple overlapping fullscreen shaders (Shockwave + Chromatic Aberration + Bloom mask), model a lightweight “EffectGraph”:

  * A queue of `ShaderEffect` with priorities and **mutual exclusion rules** (e.g., only one exposure-changing effect active).
  * Blends via cumulative uniforms where safe (e.g., max ripple amplitude).
* Keep graph in `FXManager` to avoid coupling gameplay to render internals.

**D. Non-obvious wins**

* **Prewarming & shader cache**: Add `FXManager.prewarm_shaders([ShaderEffect])` mirroring your VFX prewarm to avoid hitching on first use. (You already prewarm pooled nodes; extend the idea to shader variants.)&#x20;
* **Performance guardrails**: `FXManager` tracks a per-frame cost budget; if frame time exceeds a threshold, degrade effect quality (shorter duration, fewer iterations) or skip low-priority FX.
* **Param curves**: Let `params` accept `Curve` resources so designers can sculpt intensity/time without code.
* **Conflict policies**: Screenshake already has clear calls; extend with **priority + override windows** (e.g., boss phase shake overrides minor hit shakes for 0.3s). You’re already calling shakes from Player/Boss. &#x20;
* **Testbed scene**: A `res://tools/fx_playground.tscn` with toggles for each effect, param sliders, and a performance readout to rapidly iterate without booting gameplay.

### Concrete Phase 2 tasks (refined)

* **Task 1 (FX Cookbook for Shaders)**

  * Implement `ShaderEffect.tres` assets and `FXManager.play_shader(effect, target, opts={})`.
  * Provide bindings for `ENTITY`, `UI`, `FULLSCREEN`.
  * Unit test: ensuring materials restore on teardown (esp. entity death and scene changes).
* **Task 2 (Entity Shaders)**

  * **Hit-Flash**: Use `HealthComponent.took_damage` to apply a 0.08–0.12s flash; you already emit `took_damage` with `DamageInfo`. Tie into it.&#x20;
  * **Dissolve**: Triggered in `die()` paths for Player/Boss/Minions; ensure it cannot conflict with Hit-Flash (priority rules).
* **Task 3 (UI SDF)**

  * Add `Theme` with **design tokens** (radius, border thickness, spacing scale, brand colors). Use one SDF shader to produce borders/fills/shadows across panels. Have a single “Aesthetic Maximalism” token sheet.
* **Task 4 (Fullscreen Shockwave)**

  * `FXManager.trigger_shockwave(world_pos)` on boss phase change (you already call hit-stop + shake there—perfect insertion point).&#x20;

**Acceptance checks**

* Damage → flash visible; phase change → shockwave + hit-stop + shake; material restoration verified when an entity queues free; worst-case overlapping FX maintain framerate and prioritize correctly.

---

## 2) Gameplay & Design — Core Loop & Save

### Gaps & design edges

* World/loop scaffolding is light; Stage Select and saves are not yet implemented.
* You already track boss health and emit phase/health events (great). Persisting which bosses are cleared will complete the loop.&#x20;

### Elevated design

**A. Versioned, multi-slot Save**

* `SaveManager` (autoload) manages **profile slots** (e.g., `Slot_1`, `Slot_2`, `Slot_3`).
* **Schema**:
  `WorldState { version:int, bosses:{<boss_id>: {defeated:bool, best_time:float, deaths:int}}, options_ref:<guid> }`
* **Atomic writes**: Save to `*.tmp`, then rename; keep a `.bak` of the last good file.
* **Migration**: On load, if `version < CURRENT`, run registered migrators.
* **Separation of concerns**: Keep **user options** (video, audio) separate from **progress**.

**B. Encounter Registry**

* A `EncounterRegistry.tres` listing available stages (id, name, scene path, thumbnail) so `StageSelect.tscn` can **data-drive** its UI, not hardcode. The registry decouples content shipping from UI logic.

**C. Stage Select screen**

* On `_ready()`, `SaveManager.load_active_slot()` and filter registry; enable/disable buttons with medallions/times.
* UX: show boss card, defeat state, PB time, and a flashy SDF-framed button (uses your new UI shader).

**D. Tests**

* Unit test `SaveManager`: write/read parity; corrupted file fallback; migration path N→N+1.

**Where to hook in current code**

* You already funnel boss phase/health through events; add a **win event** from boss `die()` to update world state. You call `die()` in boss on health zero; emit a `BOSS_DEFEATED` with an ID you store on the boss. &#x20;

---

## 3) Systems & Narrative — Dialogue

### Audit

* `DialogueManager.gd` exists (empty) and `DialogueBox` is in progress with typewriter intent. You have `DialogueData.tres` samples. Good direction, needs flow control & extensibility.&#x20;

### Elevated design

**A. Resource-driven dialogue graph (lightweight)**

* `DialogueData` becomes a mini graph: `lines: Array[DialogueLine]`, optional `branches: Array[DialogueBranch]` with simple conditions (e.g., `boss_defeated("turret")`).
* Conditions implemented via **Query Interface** on `DialogueManager`, not by reading save files directly (Dependency Inversion: manager depends on an abstract `IWorldQuery` you implement using `SaveManager`).

**B. Tags & signals**

* Support **inline tags** (e.g., `[shake]`, `[sfx:blipA]`, `[fx:shockwave]`) that emit signals instead of hard-coding presentation. `DialogueBox` listens and animates UI/SDF or triggers FX via `FXManager`. Separation of concerns: Manager = state, Box = view.

**C. Typewriter polish**

* Variable CPS, optional easing `Curve`, auto-skip on hold, and **smart pauses** on punctuation.
* Accessibility: instant reveal on input; queue mode for multi-line; per-character sfx with pitch variance.

**D. Future-proof**

* Localisation hooks: Each `DialogueLine` carries a key, not raw text (or supports both); swap table per language.

---

## Visual Identity — “Aesthetic Maximalism” without chaos

* **Design Tokens**: `ThemeTokens.tres` (spacing scale, corner radius, border widths, shadow ramp, gradients list, primary/secondary palettes). Your `Palette` constants can seed this.&#x20;
* **Single SDF panel shader** with params from tokens: corner radius, border width, inner glow, hatch pattern toggle, animation seed. Drive hover/press/alert states via uniform changes not separate shaders.
* **Motion language**: micro-tweens (100–180ms), overshoot 1.05, settle to 1.0 with spring; consistent across buttons/modals/stage cards.

---

## SOLID Scorecard (how the plan maps)

* **S**: Shader bindings split by scope; `DialogueManager` vs `DialogueBox`; `SaveManager` vs `EncounterRegistry`.
* **O**: `FXManager` extended to new effect types without modifying callers; `Dialogue` adds tags/branches without altering the runner API.
* **L**: `IFxEffect` contract keeps any new effect substitutable.
* **I**: UI doesn’t need screenshake APIs; it listens to FX tags only. Gameplay doesn’t know how shaders render.
* **D**: Gameplay posts events; `FXManager`, `SaveManager`, `DialogueManager` subscribe. You already use EventBus patterns across the code.&#x20;

---

## Prioritized Phase 2 Backlog (impact → effort)

1. **Shader FX foundation (ENTITY/UI/FULLSCREEN bindings)**

   * `ShaderEffect` resource + `FXManager.play_shader()`
   * Shockwave fullscreen; Hit-Flash; Dissolve; UI SDF panel v1
     *Accept*: Hit-Flash on damage; Dissolve on death; Shockwave on phase change; UI panels themed.

2. **Design Tokens + SDF Theme integration**

   * One shader, many looks; stage cards & menus adopt tokens
     *Accept*: All panels/badges use same shader and tokens; hover/press transitions consistent.

3. **Encounter Registry + Stage Select**

   * Data-driven, thumbnails, defeat status, time PB
     *Accept*: Disabling/enabling and badges reflect `WorldState`.

4. **SaveManager v1 (versioned, atomic, multi-slot)**

   * WorldState schema + migrator scaffolding
     *Accept*: Corrupt file test passes; slots switch; migration stub is callable.

5. **Dialogue v1 (runner + box + tags)**

   * Typewriter polish, skip logic, `[fx:*]` tag to `FXManager`
     *Accept*: Branch by a simple world query; tags fire without coupling.

6. **FX Testbed + Performance budget**

   * Prewarm path for shaders; frame budget degrade path
     *Accept*: Toggle 3+ overlapping effects with steady frametime; low-priority FX drop under load.

---

## Not-obvious pitfalls & mitigations

* **Material leaks**: Always store/restore the previous `material` on entities; guard against `queue_free()` mid-tween (cancel/cleanup). (Your components already have good teardown patterns—reuse those.)&#x20;
* **Manager drift**: Delete/rename `vfx_manager.gd` to avoid confusion with `FXManager`.&#x20;
* **Event storms**: Debounce rapid damage events to not stack infinite Hit-Flashes; let `FXManager` coalesce by priority.
* **Save corruption**: Atomic writes + `.bak` restore; unit tests for both.
* **Over-maximalism**: Let tokens define restraint: limit concurrent UI patterns; use one SDF shader with parameterized patterns.

---

## Tiny code-level contracts (just enough to align)

**ShaderEffect.tres (concept)**

```
class_name ShaderEffect
extends Resource
@export var shader: Shader
@export var duration: float = 0.15
@export var priority: int = 0
@export_enum("ENTITY","UI","FULLSCREEN") var scope := 0
@export var params := {} # { "intensity": 1.0, "tint": Color, "curve": Curve, ... }
```

**FXManager surface (additions)**

```
func play_shader(effect: ShaderEffect, target: Node, opts := {}): void
func trigger_shockwave(world_pos: Vector2): void # convenience wrapper
func prewarm_shaders(effects: Array[ShaderEffect]): void
```

(Backed by scope-specific bindings that do all attach/animate/restore work.)

---

## Where to hook today (concrete)

* **Player damage** → you already request shake/hit-stop and play a hit spark in `_on_health_component_took_damage`—just also call `FXManager.play_shader(hit_flash_effect, self.visual_sprite)`.&#x20;
* **Boss phase change** → extend the existing phase change branch to call `trigger_shockwave(boss.global_position)` alongside shake/hit-stop.&#x20;
* **Entity death** → in `HealthComponent.died` subscribers (Player/Boss/Minion), run `Dissolve` before `queue_free()`. You’re already centralizing death notification.&#x20;

---





Aug 19th TODO from GPT-5. Currently working on this stuff.


===============================================================================
| TODO.txt — FX & Shader Refactor (Mobile Renderer)                                |
| Project: Steven Casteel / Box Battle                                         |
| Purpose: Major overhaul to stabilize .gdshader usage on Mobile renderer, finish   |
|          FX + audio pipelines, and apply Godot 4.4 best practices across the repo |
===============================================================================

ASCII GUIDE: keep this file purely procedural. Use it as the single source of truth
for tasks, ordered PRs, acceptance criteria, and quick implementation notes.

--------------------------------------------------------------------------------
PHASE SUMMARY (HIGH-LEVEL)
--------------------------------------------------------------------------------
  [PHASE 1] Stabilize .gdshader usage on Mobile renderer
  [PHASE 2] Complete and formalize the data-driven FX system
  [PHASE 3] Performance-safe shader patterns & anti-patterns
  [PHASE 4] Audio architecture overhaul (mobile-ready)
  [PHASE 5] Scene & code organization, SOLID idioms (Godot 4.4)
  [PHASE 6] Concrete deliverables & ordered tasks (PR list)
  [PHASE 7] Guardrails, linting, CI checks, docs, QA

--------------------------------------------------------------------------------
PHASE 1 — STABILIZE .GDSHADER (MOBILE RENDERER)
--------------------------------------------------------------------------------
  - Task 1.1: File & Material basics
    * Ensure every runtime FX shader starts with: "shader_type canvas_item;"
    * Convert VisualShader FX used at runtime into text `.gdshader` files.
    * ALWAYS apply ShaderMaterial instances to the node that is actually drawing.
    * Rule: duplicate materials when changing per-node parameters. Never mutably edit
      a shared material at runtime.

  - Task 1.2: Color-space & texture hints
    * Enforce `: source_color` on any albedo/palette sampler declarations.
    * Add a lint rule to scan `.gdshader` files for `sampler2D .*: source_color` hints.

  - Task 1.3: Shader Globals
    * Add global shader uniforms in Project Settings as the canonical place for
      shared values (e.g., fx_global_time, vignette_intensity, pal_index).
    * Add a `ShaderGlobalsOverride` node pattern for level-specific overrides.

  - Task 1.4: Mobile constraints baked into shader style
    * Avoid heavy branching/loops and minimize texture lookups.
    * Pack maps into channels wherever possible (RGB packing).
    * Prefer vertex-computed offsets for distortion effects when possible.

  - Task 1.5: Modular shader includes
    * Create `res://shaders/includes/` and add small, composable `.gdshaderinc`
      files: common_math, color, noise, fx_blend.

  - Task 1.6: Pre-warm materials
    * Add a warm-up routine that compiles important shaders early (staggered
      across frames to avoid hitching on startup).

  - Task 1.7: Renderer verification
    * Confirm `Rendering -> Renderer = Mobile` in Project Settings; document
      behavior and planned fallbacks for older/compat mode.

--------------------------------------------------------------------------------
PHASE 2 — DATA-DRIVEN FX (FINISH THE SYSTEM)
--------------------------------------------------------------------------------
  - Core responsibilities (separate concerns):
    1) Effect Definition (resource): ShaderEffect.gd / VFXEffect.gd
    2) Binding (helpers): EntityShaderBinding.gd (bind/unbind only)
    3) Orchestration (singleton): FXManager.gd (duplicate/apply/drive/teardown)

  - Task 2.1: Standard parameter contract (required across shaders)
    * Per-node shaders must declare:
        uniform float fx_progress;       // 0 -> 1 lifetime driver
        uniform float fx_intensity;      // artist control
        global uniform float fx_global_time; // optional
    * Fullscreen shaders must declare:
        uniform sampler2D SCREEN_TEXTURE; // when used as blit
        uniform vec2 viewport_size;

  - Task 2.2: Effect Resource fields
    * material: ShaderMaterial (reference)
    * duration: float
    * fullscreen: bool
    * default_params: Dictionary
    * sound: AudioStream | AudioStreamRandomizer (optional)
    * tags: Array[String]

  - Task 2.3: FXManager responsibilities
    * Listen to EventBus (damage, heal, parry, low_hp, phase_change) and
      map events -> ShaderEffect resources.
    * Duplicate material instances when applying to nodes.
    * Drive `fx_progress` via Tween or in `_process` (consistent timing).
    * Return materials/nodes to ObjectPool on completion.
    * Provide a warm-up compile pass for top N materials.

  - Task 2.4: Binding behaviour (EntityShaderBinding)
    * Only: bind/unbind/apply parameter dictionary to a given CanvasItem.
    * Do not handle timers, tweens, or lifecycle — orchestration only.

  - Task 2.5: Object pooling
    * Use existing ObjectPool autoload to recycle ShaderMaterial instances,
      GPUParticles2D nodes, ColorRect post layers, and Audio player nodes.

  - Example flows (implementation notes)
    * Hit Flash (per-node): duplicate material -> set fx_progress=0 -> animate -> on
      complete restore previous material.
    * Phase Pulse (fullscreen): enable post layer (ColorRect), animate fx_progress,
      disable layer when done.

--------------------------------------------------------------------------------
PHASE 3 — SHADER PATTERNS & ANTI-PATTERNS
--------------------------------------------------------------------------------
  - Color textures = sRGB. Require `: source_color` on declarations.
  - Default to mediump/half precision mental model on mobile; avoid heavy
    precision-dependent effects.
  - Combine multiple maps into channels to minimize samplers.
  - Reuse shaders and materials; only duplicate when parameters change.
  - Minimize dynamic indexing and branching in fragment shaders.

--------------------------------------------------------------------------------
PHASE 4 — AUDIO PIPELINE (MOBILE READY)
--------------------------------------------------------------------------------
  - Bus layout:
      Master
        ├─ SFX  (short, non-streamed, WAV or small OGG)  // cap polyphony
        ├─ UI   (one-shots, non-positional)
        └─ Music (streaming OGG)  // crossfade via AudioManager
    * Put a Master limiter; gentle compressor on Music for ducking.

  - Import rules:
    * SFX < ~1s -> WAV (decode cost but faster playback); otherwise OGG if size
      is critical. Music/ambience -> OGG streaming.

  - AudioManager features:
    * Pools of AudioStreamPlayer2D (positional SFX) and AudioStreamPlayer
      (non-positional UI/music).
    * `play_sfx(tag, pos)`, `play_ui(tag)`, `play_music(track, crossfade_sec=1.5)`
    * Voice caps per category; implement quietest/oldest stealing.
    * Integrate AudioStreamRandomizer resources for natural variation.

--------------------------------------------------------------------------------
PHASE 5 — SCENE & CODE ORGANIZATION (SOLID + GODOT 4.4 IDIOMS)
--------------------------------------------------------------------------------
  - Autoloads: keep them thin and focused — do not put gameplay state in singletons.
    Examples: FXManager, AudioManager, EventBus, ObjectPool, Router, GlobalState.

  - Component-first nodes: Health, Damageable, VFXAnchor. Use Groups for discovery.

  - Resource-driven definitions: Effect resources, audio sets, curves should be
    .tres resources referenced by scenes and code (no hardcoded paths in scripts).

  - Asset graph discipline: shaders in `res://shaders/`, materials in
    `res://materials/`, effects in `res://data/effects/`, audio in `res://audio/`.

  - Editor-safety: do not rely on editor-only signals for runtime logic.

--------------------------------------------------------------------------------
PHASE 6 — CONCRETE DELIVERABLES & PR ORDER
--------------------------------------------------------------------------------
  PR 01 — shader-foundation
    * Add `res://shaders/includes/` files.
    * Convert critical VisualShaders to `.gdshader` text variants.
    * Add shader parameter contract enforcement linter (script).

  PR 02 — fx-manager-completion
    * Finalize FXManager orchestration (duplicate/apply/drive/teardown).
    * Implement warm-up pass for top materials.
    * Hook FXManager into EventBus mapping table (event -> effect resource).

  PR 03 — audio-bus-and-pool
    * Implement bus layout (Master/SFX/UI/Music), add limiter.
    * Add Audio import presets and AudioManager pooling + voice caps.

  PR 04 — resources-and-samples
    * Add `ShaderEffect` resources for hit-flash, dissolve, palette-swap,
      fullscreen pulse. Include small sample scenes to preview each.

  PR 05 — docs-and-tests
    * Add "How to add a new effect in 5 minutes" doc, shader lint rule,
      CI hooks for missing resource checks, and mobile QA checklist.

  PR 06 — profiling-and-fixes
    * Device profiling harness, baseline captures, and targeted shader fixes.

  Note: Execute PRs in order. Break each PR into bite-sized commits with clear
  atomic messages (e.g., "Add shader include: common_math.gdshaderinc").

--------------------------------------------------------------------------------
PHASE 7 — GUARDRAILS, LINTING, QA
--------------------------------------------------------------------------------
  - Add a shader lint script (CI-friendly) that validates:
    * presence of `shader_type canvas_item` (for FX shaders)
    * required uniforms (`fx_progress`, `fx_intensity`) for effect shaders
    * `: source_color` on color sampler declarations
  - Disk-check CI: fail if a scene references a missing resource path.
  - Enforce: "no set_shader_parameter on shared materials" rule in reviews.
  - Add a mobile QA checklist: test on at least two device tiers, collect
    profile captures for before/after (frame time, active FX count, shader
    compile stalls).

--------------------------------------------------------------------------------
IMPLEMENTATION NOTES & QUICK LOOKUPS
--------------------------------------------------------------------------------
  - Shader apply pattern (pseudocode):

    var inst = effect.material.duplicate()
    for key,val in effect.default_params:
        inst.set_shader_parameter(key, val)
    target.material = inst
    FXManager.drive_progress(inst, effect.duration)
    on_complete: restore previous material or return inst to pool

  - Parameter contract reminder:
      uniform float fx_progress; // 0..1
      uniform float fx_intensity;
      global uniform float fx_global_time;

  - Shader include files to create:
      res://shaders/includes/common_math.gdshaderinc
      res://shaders/includes/color.gdshaderinc
      res://shaders/includes/noise.gdshaderinc
      res://shaders/includes/fx_blend.gdshaderinc

  - Audio tips:
      Master at -6dB headroom; SFX ~-6dB; Music ~-10dB to start. Limiters as safety.
      Pool small AudioStreamPlayers and cap voices per bus.

--------------------------------------------------------------------------------
ACCEPTANCE CRITERIA (for the whole refactor)
--------------------------------------------------------------------------------
  - .gdshader-based FX behave identically (visual parity within +/- subjective
    tolerance) on Mobile renderer and Desktop (compat mode optional fallback).
  - No startup or runtime shader compile hitching greater than a single frame
    after warm-up pass runs.
  - CI enforces shader param contract and missing resource checks.
  - Audio bus + pooling in place; voice caps prevent crashes/overload on device.
  - Designers can create a new ShaderEffect resource, drop it into an effect map,
    and see the result in the sample preview scene within ~5 minutes.

--------------------------------------------------------------------------------
HAND-OFF CHECKLIST FOR THE IMPLEMENTER (Gemini AI)
--------------------------------------------------------------------------------
  1) Implement PR 01 (shader-foundation)
  2) Implement PR 02 (fx-manager-completion)
  3) Implement PR 03 (audio-bus-and-pool)
  4) Create sample resources & scenes (PR 04)
  5) Add docs, lints, and CI hooks (PR 05)
  6) Run device profiling, fix hotspots (PR 06)

--------------------------------------------------------------------------------
NOT-OBVIOUS TIPS & GOTCHAS (from transcripts + repo audit)
--------------------------------------------------------------------------------
  - Always duplicate ShaderMaterials before mutation — this prevents hard-to-see
    issues where multiple nodes share a reference and unexpectedly change.
  - Use `: source_color` texture hints to avoid gamma/space mismatch; these are
    commonly missed when porting from desktop to mobile.
  - Warm compiles: compile-heavy shaders early and stagger the warm-up across
    frames rather than trying to do everything on frame 1.
  - Keep the FXManager as the single place that mutates ShaderMaterial instances.
  - Don’t rely on editor-only events like `Resource.changed` for runtime flows.

--------------------------------------------------------------------------------
QUICK-START: "Do this now" (first 48 hours)
--------------------------------------------------------------------------------
  1) Create `res://shaders/includes/` and add `common_math.gdshaderinc`.
  2) Add shader lint script (scan repository for `.gdshader` files).
  3) Convert 1–2 critical VisualShaders to text shaders (hit-flash + pulse).
  4) Implement material duplicate + apply pattern in FXManager (minimal).
  5) Add Master/SFX/UI/Music buses and a Master limiter in the audio panel.

--------------------------------------------------------------------------------
REVISION HISTORY
--------------------------------------------------------------------------------
  - v1.0 — Initial overhaul TODO — contains full-phase breakdown, PR order,
           acceptance criteria, and quick-start.

===============================================================================
END OF TODO.txt
===============================================================================



=====================================
FILE: ./docs/all_script_errors.txt
=====================================
Run in Box Battle folder for all errors in Terminal


"/Applications/Godot.app/Contents/MacOS/Godot" --verbose --check-only "/Users/stevencasteel/Desktop/GODOT/BOX BATTLE" > all_script_errors.txt


=====================================
FILE: ./docs/last_commit_command.txt
=====================================
git reset --hard origin/main

=====================================
FILE: ./docs/DESIGN.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ███████╗███████╗██╗ ██████╗ ███╗   ██╗                             ║
║   ██╔══██╗██╔════╝██╔════╝██║██╔════╝ ████╗  ██║                             ║
║   ██║  ██║█████╗  ███████╗██║██║  ███╗██╔██╗ ██║                             ║
║   ██║  ██║██╔══╝  ╚════██║██║██║   ██║██║╚██╗██║                             ║
║   ██████╔╝███████╗███████║██║╚██████╔╝██║ ╚████║                             ║
║   ╚═════╝ ╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝                             ║
║                                                                              ║
║      The official documentation for game mechanics and design philosophy.    ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         DESIGN PHILOSOPHY                            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Sublime Movement by Default: The player is given a complete, perfected, ║
║      and expressive moveset from the beginning. The joy of the game comes    ║
║      from mastering these tools, not from unlocking them.                    ║
║                                                                              ║
║   █  Aesthetic Minimalism, Technical Maximalism: The visual style will be    ║
║      clean, minimalist, and beautiful, inspired by high-end web design       ║
║      (e.g., Framer websites). We will use advanced shaders, procedural       ║
║      generation, and particle effects to create a polished, "expensive"      ║
║      look with elements like frosted glass, backlighting, and subtle gradients.║
║                                                                              ║
║   █  Robust, Maintainable Code: Development will adhere to the SOLID principles║
║      (Single Responsibility, Open/Closed, etc.) to ensure the codebase is    ║
║      scalable, easy to debug, and a pleasure to work on. We refactor first.  ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                           CORE MECHANICS                             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ▓  Player Movement                                                         ║
║      ░ ■ Coyote Time & Jump Buffering for forgiving platforming.             ║
║      ░ ■ 4-directional Dash with a cooldown.                                 ║
║      ░ ■ Wall-Sliding and Wall-Jumping for verticality.                      ║
║                                                                              ║
║   ▓  Combat System                                                           ║
║      ░ ■ Primary Melee: A fast, close-range attack.                          ║
║      ░ ■ Charged Shot: A long-range projectile attack.                       ║
║      ░ ■ Pogo Attack: A downward aerial attack that bounces on enemies.      ║
║      ░ ■ Dash Invincibility: The player cannot take damage during a dash.    ║
║                                                                              ║
║   ▓  Planned Combat Refinements                                              ║
║      ░ ■ Enhanced Melee Hitbox: The melee swing will have two hitboxes. The  ║
║      ░   inner box (close to the player) will deal 1.5x damage, rewarding    ║
║      ░   risky positioning. The outer box will deal 1.0x damage.             ║
║      ░ ■ Input Buffering: Attack and dash inputs will be buffered just like  ║
║      ░   the jump input, making the controls feel more responsive.           ║
║      ░ ■ Pogo-Fall Prevention: A brief window after a pogo will prevent      ║
║      ░   accidental fast-falling.                                            ║
║                                                                              ║
║   ▓  Health and Healing: The Determination System                            ║
║      ░  Healing is a resource earned by dealing damage. Landing hits fills a ║
║      ░  `determination_counter` to grant a `healing_charge`.                 ║
║                                                                              ║
║   ▓  Boss Design Template (The "Kitchen Sink")                               ║
║      ░  Our `base_boss` will be a template with a library of toggleable mechanics:║
║      ░  ■ Health Phases: Boss behavior and attacks change at health thresholds.║
║      ░  ■ Armor / Weak Points: Boss can enter armored states where it takes  ║
║      ░    no damage, punctuated by moments of vulnerability.                 ║
║      ░  ■ Clear Telegraphing: All attacks will be preceded by clear visual/audio║
║      ░    cues, ensuring tough but fair encounters.                          ║
║      ░  ■ Modular Movement: Bosses can be configured to fly, dash, jump, etc.║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                 ARENA & BOSS BATTLE CONCEPTS                         ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Each boss battle is a unique mechanical challenge inspired by a classic    ║
║   arcade game loop. The player's sublime moveset is the constant tool used to║
║   solve these varied combat puzzles.                                         ║
║                                                                              ║
║   ▒  Beat Box (Rhythm Game): Platforms appear/disappear on a musical beat.   ║
║   ▒  Sandbox (Momentum Vampirism): Boss steals player momentum on hit.       ║
║   ▒  Circuit Box (Tempest-like): Central core protected by rotating shields. ║
║   ▒  Garden Box (Centipede-like): Segmented boss weaves through obstacles.   ║
║   ▒  Traffic Box (Frogger-like): Cross "lanes" of projectiles to reach boss. ║
║   ▒  Gravity Box (Gravity Man-inspired): Gravity reverses periodically.      ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

DESIGN SUMMARY (core gameplay)
==============================

Purpose
-------
Capture the player-facing rules and important implementation decisions so designers and devs stay aligned.

Mechanics (short)
-----------------
- Movement: standard platformer ground & air with coyote time + jump buffering.
- Pogo: jump-on-enemy mechanic that bounces the player and applies damage to the enemy.
- Contact damage: mutual damage when entity collides with dangerous zones/actors — resolved through CombatUtils.
- Projectiles: use pooled nodes; projectiles are *DamageSource* emitters on hit.

Pogo — implementation notes
---------------------------
Goal: reliable, consistent damage application and deterministic bounce.

Canonical rules:
1. Pogo triggers when the player is moving downward and the player's pogo sensor area overlaps enemy hurtbox while the attack input or a pogo-frame confidence check is true.
2. On pogo hit:
   - Player receives a vertical impulse/bounce and may gain a brief invulnerability window.
   - Enemy receives damage via `CombatUtils.apply_damage(player, enemy, damage_info)`.
   - Use CombatUtils to de-duplicate or throttle repeated hits within the same physics tick.
3. Edge cases to watch:
   - Multiple damage sources on a single frame (ensure CombatUtils dedupes per damage hit-id).
   - Pogo while a boss is invulnerable (respect `is_invulnerable()`).

Jump buffering & coyote time
----------------------------
- Jump-buffer: store jump input for a short window (eg. 0.1s) to allow forgiving timing.
- Coyote time: allow jumping up to a short window after leaving ground (eg. 0.08s).
- Implemented in the player state machine as small time accumulators — prefer deterministic values stored in a `.tres` tuning resource.

Hit detection & damage flow
---------------------------
- Always route damage through CombatUtils; do not directly mutate HP from collision callbacks.
- DamageInfo shape (recommended):
  {
    "amount": int,
    "type": "physical" | "fire" | ...,
    "source": Node,           # optional reference
    "hit_id": String,         # optional dedupe id
    "knockback": Vector2,
    "flags": {"ignore_armor": false, ...}
  }

Data-driven tuning
------------------
- Keep numeric tuning in resource files (`.tres`) stored under `res://assets/config/` or `res://data/`.
- Example resources: `combat_config.tres`, `player_tuning.tres`, `boss_phase_1.tres`
- Designers edit these in the Godot inspector; code reads them at runtime.

Guidelines for adding new mechanics
----------------------------------
- Add logic as a component when it can be reused across entities.
- Add high-level sequencing to Sequencer when you need deterministic, ordered scripts.
- Keep state transitions in the state machine; do not splice logic between multiple components arbitrarily.

Testing checklist (dev)
-----------------------
- Reproduce pogo behavior on small enemy and boss (ensure single hit / correct bounce).
- Verify contact damage doesn't double-apply for simultaneous collisions.
- Run memory/profile track for object pool usage to ensure reuse works.

Where to update this doc
------------------------
- If you change damage_info shape, update `docs/ARCHITECTURE.txt` and this file.


=====================================
FILE: ./docs/ROADMAP.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗  ██████╗  █████╗ ██████╗ ███╗   ███╗ █████╗ ██████╗                ║
║   ██╔══██╗██╔═══██╗██╔══██╗██╔══██╗████╗ ████║██╔══██╗██╔══██╗               ║
║   ██████╔╝██║   ██║███████║██║  ██║██╔████╔██║███████║██████╔╝               ║
║   ██╔══██╗██║   ██║██╔══██║██║  ██║██║╚██╔╝██║██╔══██║██╔═══╝                ║
║   ██║  ██║╚██████╔╝██║  ██║██████╔╝██║ ╚═╝ ██║██║  ██║██║                    ║
║   ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝                    ║
║                                                                              ║
║          The long-term vision and planned features for the project.          ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              VERSION 1.0 GOALS - THE POLISHED SLICE                  ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   The primary objective is to create a single, complete, and highly          ║
║   polished gameplay loop that serves as a benchmark for the entire game.     ║
║                                                                              ║
║   █  A Dynamic Boss: Arena 00 boss is fully functional with multiple,        ║
║      telegraphed attack patterns and basic AI (patrolling, facing player).   ║
║                                                                              ║
║   █  Functional HUD: Clear displays for player health, boss health, and      ║
║      healing charges.                                                        ║
║                                                                              ║
║   █  Satisfying Feedback: All core actions are accompanied by appropriate    ║
║      SFX, VFX (hit-flash, particles), and screen shake. The game feels good. ║
║                                                                              ║
║   █  Complete Flow: Player can go from Title -> Game -> Win/Loss -> Title    ║
║      with smooth transitions.                                                ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         FUTURE VERSIONS                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ▓  v1.1 - "The Content Expansion"                                          ║
║      Focus shifts to expanding content and adding a new dimension to combat. ║
║      ░  ■ Introduce a Second Arena & Boss (e.g., a flying or agile enemy).   ║
║      ░  ■ Introduce a "Minion" Enemy Type for more varied encounters.        ║
║      ░  ■ Refine Player Combat Indicators (Fizzle & Charge Meter).           ║
║                                                                              ║
║   ▓  v2.0 - "The Full Game Loop"                                             ║
║      Transforms the project from encounters into a cohesive game.            ║
║      ░  ■ Implement a Stage Select Screen.                                   ║
║      ░  ■ Basic Progression (Defeating a boss unlocks the next stage).       ║
║      ░  ■ Introduce More Enemy Variety (e.g., a stationary turret).          ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                         DREAM FEATURES                               ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A "blue sky" list of ideas to explore once the core game is robust.        ║
║                                                                              ║
║   ■  Advanced Boss Mechanics (Multi-stage health, cinematic `Path2D` moves). ║
║   ■  Expanded Player Abilities (Unlockable weapons/skills post-boss fight).  ║
║   ■  Deeper Lore & Narrative (Expand on "Determination" theme).              ║
║   ■  Official GitHub Wiki for community documentation.                       ║
║   ■  Robust Debug Tools (More hotkeys and overlays).                         ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/PLAYTESTING.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═════════════╗
║  ██████╗ ██╗      █████╗ ██╗   ██╗████████╗███████╗███████╗████████╗██╗███╗   ██╗ ██████╗  ║
║  ██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║████╗  ██║██╔════╝  ║
║  ██████╔╝██║     ███████║ ╚████╔╝    ██║   █████╗  ███████╗   ██║   ██║██╔██╗ ██║██║  ███╗ ║
║  ██╔═══╝ ██║     ██╔══██║  ╚██╔╝     ██║   ██╔══╝  ╚════██║   ██║   ██║██║╚██╗██║██║   ██║ ║
║  ██║     ███████╗██║  ██║   ██║      ██║   ███████╗███████║   ██║   ██║██║ ╚████║╚██████╔╝ ║
║  ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚══════╝   ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝  ║ 
║                                                                              ╔═════════════╝
║           A log of all playtesting sessions and resulting feedback.          ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       PLAYTEST SESSION LOG                           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   (New playtest session reports should be added here, most recent at top.)   ║
║                                                                              ║
║  --------------------------------------------------------------------------  ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                      TEST SESSION TEMPLATE                           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Date: YYYY-MM-DD                                                        ║
║   █  Tester: [Name or description, e.g., "Developer," "Friend A"]            ║
║   █  Build Version: [e.g., 0.1.0]                                            ║
║   █  Session Goal: [e.g., "Test boss fight fairness", "Check menu UI"]       ║
║                                                                              ║
║   ▓  General Observations & Player Behavior                                  ║
║      ░  What did the player do? Did they understand the goals? Where did     ║
║      ░  they go first? (e.g., "Tester immediately tried to wall-jump.")      ║
║                                                                              ║
║   ▓  Issues & Bugs Found                                                     ║
║      ░  List any bugs, crashes, or moments of confusion. Was anything        ║
║      ░  frustrating or unfair?                                               ║
║                                                                              ║
║   ▓  Positive Feedback                                                       ║
║      ░  What did the player say they enjoyed? What felt good to them?        ║
║      ░  (e.g., "Player audibly said 'nice' after a successful pogo.")        ║
║                                                                              ║
║   ▓  Suggestions & Ideas                                                     ║
║      ░  What did the player suggest? Did they have any ideas for new         ║
║      ░  features or changes?                                                 ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/BUGS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ██╗   ██╗ ██████╗ ███████╗                                         ║
║   ██╔══██╗██║   ██║██╔════╝ ██╔════╝                                         ║
║   ██████╔╝██║   ██║██║  ███╗███████╗                                         ║
║   ██╔══██╗██║   ██║██║   ██║╚════██║                                         ║
║   ██████╔╝╚██████╔╝╚██████╔╝███████║                                         ║
║   ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝                                         ║
║                                                                              ║
║             A tracker for all known issues, their status, and solutions.     ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                             OPEN ISSUES                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                             FIXED ISSUES                             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ■  [BUG-MEM001] ObjectDB instances leaked on exit.                         ║
║      ░  FIXED: 2025-08-18                                                    ║
║      ░  SOLUTION: Implemented a formal `scene_exiting()` contract via an     ║
║      ░  `ISceneController` interface. The `SceneManager` now calls this      ║
║      ░  method on the outgoing scene, allowing entities like Player and      ║
║      ░  Boss to run their explicit `teardown()` logic. This breaks the       ║
║      ░  dangling references held by global singletons (e.g., EventBus)       ║
║      ░  that were preventing garbage collection.                             ║
║                                                                              ║
║   ■  [BUG-F007] Intermittent major hitch on first run or debug mode toggle.  ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Implemented a shader pre-warming system in `LoadingScreen`.║
║                                                                              ║
║   ■  [BUG-F006] Significant stutter/hitch occurred on arena load.            ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Replaced synchronous level generation with a new asynchronous║
║      ░  system in `ArenaBuilder.gd`.                                         ║
║                                                                              ║
║   ■  [BUG-F005] Player death caused a physics crash.                         ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Scene changes now use `call_deferred()` to prevent deleting║
║      ░  a physics body during a physics callback.                            ║
║                                                                              ║
║   ■  [BUG-F004] Hazard tiles did not deal contact damage.                    ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Corrected collision layer and group setup in `ArenaBuilder`.║
║                                                                              ║
║   ■  [BUG-F003] Drop-through platforms ("-") were not functioning.           ║
║      ░  FIXED: 2025-08-06                                                    ║
║      ░  SOLUTION: Re-implemented Down+Jump logic in `state_move`.            ║
║                                                                              ║
║   ■  [BUG-F002] Player pogo attack was not working correctly on all surfaces.║
║      ░  FIXED: 2025-08-05                                                    ║
║      ░  SOLUTION: Re-implemented the physics query to handle all surfaces.   ║
║                                                                              ║
║   ■  [BUG-F001] Player was not taking contact damage from boss/hazards.      ║
║      ░  FIXED: 2025-08-05                                                    ║
║      ░  SOLUTION: Corrected the player's `collision_mask` in `player.tscn`.  ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/DOCS_PROTOCOL.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗  ██████╗  ██████╗ ███████╗                                         ║
║   ██╔══██╗██╔═══██╗██╔════╝ ██╔════╝                                         ║
║   ██║  ██║██║   ██║██║      ███████╗                                         ║
║   ██║  ██║██║   ██║██║   ██╗╚════██║                                         ║
║   ██████╔╝╚██████╔╝╚██████╔╝███████║                                         ║
║   ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝                                         ║
║                                                                              ║
║    ██████╗ ██████╗  ██████╗ ████████╗ ██████╗  ██████╗  ██████╗ ██╗          ║
║    ██╔══██╗██╔══██╗██╔═══██╗╚══██╔══╝██╔═══██╗██╔════╝ ██╔═══██╗██║          ║
║    ██████╔╝██████╔╝██║   ██║   ██║   ██║   ██║██║      ██║   ██║██║          ║
║    ██╔═══╝ ██╔══██╗██║   ██║   ██║   ██║   ██║██║   ██╗██║   ██║██║          ║
║    ██║     ██║  ██║╚██████╔╝   ██║   ╚██████╔╝╚██████╔╝╚██████╔╝███████╗     ║
║    ╚═╝     ╚═╝  ╚═╝ ╚═════╝    ╚═╝    ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝     ║
║                                                                              ║
║           Project Documentation & Communication Formatting Standard          ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       DOCUMENTATION STANDARDS                        ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This document defines the visual and structural standards for all `.txt`   ║
║   project files. Its purpose is to maintain a cohesive, readable, and        ║
║   thematically appropriate aesthetic that reflects the game's design.        ║
║                                                                              ║
║   █  FILE STRUCTURE                                                          ║
║      All `.md` files essential for GitHub integration (README.md,            ║
║      LICENSE.md) will remain as Markdown. All other project documents        ║
║      (TODO, ROADMAP, DESIGN, etc.) will be `.txt` files following this guide.║
║                                                                              ║
║   █  DOCUMENT FRAME                                                          ║
║      Each document will be enclosed in a double-line box frame.              ║
║      (Characters: ╔ ╗ ╚ ╝ ║ ═ ╠ ╣)                                           ║
║                                                                              ║
║   █  TITLE BLOCK                                                             ║
║      Each document begins with its custom ASCII art title block, followed    ║
║      by a one-line subtitle describing its purpose.                          ║
║                                                                              ║
║   █  SECTION HEADERS                                                         ║
║      Major sections are demarcated with a dithered block header. The text    ║
║      should be centered and padded within the solid blocks.                  ║
║                                                                              ║
║        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ║
║        ██                        SECTION TITLE                         ██    ║
║        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ║
║                                                                              ║
║   █  BODY TEXT & PARAGRAPHS                                                  ║
║      Standard body text should be indented by 2 spaces from the main frame.  ║
║      Paragraphs should have a single blank line between them for spacing.    ║
║      Text should be manually wrapped to fit within the document frame.       ║
║                                                                              ║
║   █  BULLET POINTS & HIERARCHY (PRIORITY GRADIENT)                           ║
║      Lists will use dithered blocks to indicate importance or sequence.      ║
║      All bullet points should be indented by 3 spaces. Sub-points should     ║
║      be indented an additional 2 spaces using the `░` character.             ║
║                                                                              ║
║        █  Primary Point / Critical Item / Most Important                     ║
║        ▓  Secondary Point / High Priority                                    ║
║        ▒  Tertiary Point / Medium Priority                                   ║
║        ░  Note, Sub-point, or Low Priority Item                              ║
║                                                                              ║
║        ■  Checklist item (complete).                                         ║
║        □  Checklist item (incomplete).                                       ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                 ARCHIVE OF ADVANCED & ESOTERIC STYLES                ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   The following are alternative formatting ideas. They are archived here for ║
║   future inspiration but are not part of the current standard to maintain    ║
║   simplicity and consistency.                                                ║
║                                                                              ║
║   ▒  Progress Bars & Status Indicators                                       ║
║      Use the priority gradient to create visual progress meters.             ║
║                                                                              ║
║      ░  LOADING       █████████████▓▓▓▓▒▒▒░░░ 73%                            ║
║      ░  BOSS HEALTH   ████████▓▓▓▓▒▒▒▒░░░░░░░░ 58%                           ║
║                                                                              ║
║   ▒  Circuit Board Style                                                     ║
║      A highly technical aesthetic for documents like ARCHITECTURE.txt.       ║
║                                                                              ║
║      ┌─┬─┬─┬─┬─┬─┬─┬─┬── SECTION ──┬─┬─┬─┬─┬─┬─┬─┬─┐                         ║
║      │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │                         ║
║      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘                         ║
║                                                                              ║
║   ▒  PETSCII-style Graphics                                                  ║
║      A retro computer aesthetic using block and pattern characters.          ║
║                                                                              ║
║      ▗▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▖     ║
║      ▐ ▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚  SECTION TITLE HERE  ▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚▚ ▌     ║
║      ▝▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▘     ║
║                                                                              ║
║   ▒  Geometric Separators                                                    ║
║      Use repeating patterns to divide sections instead of headers.           ║
║                                                                              ║
║      ◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇◆◇                    ║
║      ▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼▲▼            ║
║                                                                              ║
║   ▒  Square Density Patterns                                                 ║
║      An alternative to the priority gradient for status tracking.            ║
║                                                                              ║
║      ■■■■■■■■■■ COMPLETE                                                     ║
║      ■■■■■■■□□□ IN PROGRESS                                                  ║
║      ■□□□□□□□□□ PLANNED                                                      ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/sprint_0_audit/TEST-002_Smoke_Tests.md
=====================================


=====================================
FILE: ./docs/sprint_0_audit/TEST-001_Baseline_Metrics.md
=====================================


=====================================
FILE: ./docs/sprint_0_audit/FSM-001_Entity_State_Flows.md
=====================================
# State Machine Flow Diagrams

**Date:** 2025-08-10

**Status:** Documented

---

This document provides a visual representation of the Finite State Machines (FSMs) for the core entities in the game. These diagrams are generated using Mermaid syntax and represent the logical flow of states based on player input and game physics.

## Player State Machine

The Player FSM is complex and responsive, designed to facilitate a fluid and expressive moveset. The core loop revolves around the `Move`, `Fall`, and `Jump` states, with multiple entry points into action states like `Dash` and `Attack`.

```mermaid
graph TD
    subgraph Core Movement
        MOVE <-->|Gravity/On Floor| FALL;
        MOVE -->|Jump Input| JUMP;
        FALL -->|Coyote Time Jump| JUMP;
        JUMP -->|Apex Reached| FALL;
    end

    subgraph Wall Interaction
        FALL -->|Holding Direction into Wall| WALL_SLIDE;
        JUMP -->|Holding Direction into Wall| WALL_SLIDE;
        WALL_SLIDE -->|Jump Input| JUMP;
        WALL_SLIDE -->|Not Holding Direction| FALL;
    end

    subgraph Action States
        MOVE --> DASH;
        FALL --> DASH;
        JUMP --> DASH;
        WALL_SLIDE --> DASH;
        DASH -->|Duration Ends| FALL;

        MOVE --> ATTACK;
        FALL --> ATTACK;
        JUMP --> ATTACK;
        WALL_SLIDE --> ATTACK;
        ATTACK -->|Duration Ends| FALL;
    end

    subgraph Special States
        ANY_STATE[Any State] -->|Takes Damage| HURT;
        HURT -->|Knockback Ends| FALL;
        MOVE -->|Hold Heal Buttons| HEAL;
        HEAL -->|Buttons Released| MOVE;
    end

    style MOVE fill:#cde4f0,stroke:#333,stroke-width:2px
    style FALL fill:#cde4f0,stroke:#333,stroke-width:2px
    style JUMP fill:#cde4f0,stroke:#333,stroke-width:2px
    style WALL_SLIDE fill:#e8d1e8,stroke:#333,stroke-width:2px
    style DASH fill:#f0e4cd,stroke:#333,stroke-width:2px
    style ATTACK fill:#f0e4cd,stroke:#333,stroke-width:2px
    style HURT fill:#f8cbcb,stroke:#333,stroke-width:2px
    style HEAL fill:#d1e8d1,stroke:#333,stroke-width:2px


## Boss State Machine

The Base Boss FSM is a simple, predictable loop designed as a template for more complex behaviors. It cycles cleanly through its states based on timers.


graph TD
    COOLDOWN -->|Cooldown Timer Finishes| PATROL;
    PATROL -->|Patrol Timer Finishes| IDLE;
    IDLE -->|Immediately| ATTACK;
    ATTACK -->|Immediately| COOLDOWN;

    style COOLDOWN fill:#cde4f0,stroke:#333,stroke-width:2px
    style PATROL fill:#e8d1e8,stroke:#333,stroke-width:2px
    style IDLE fill:#f0e4cd,stroke:#333,stroke-width:2px
    style ATTACK fill:#f8cbcb,stroke:#333,stroke-width:2px


=====================================
FILE: ./docs/sprint_0_audit/event_usage.txt
=====================================
--- EventCatalog.gd ---
# src/core/event_catalog.gd
# This script serves as the canonical, central list of all event names in the project.
# By using these constants instead of raw strings, we gain IDE autocompletion and
# prevent typos that would lead to silent runtime failures.
extends Object
class_name EventCatalog

# --- Player Events ---
const PLAYER_HEALTH_CHANGED = "player.health_changed"
const PLAYER_HEALING_CHARGES_CHANGED = "player.healing_charges_changed"
const PLAYER_TOOK_DAMAGE = "player.took_damage"
const PLAYER_DIED = "player.died"

# --- Boss / Entity Events ---
const BOSS_HEALTH_CHANGED = "boss.health_changed"
const BOSS_DIED = "boss.died"

# --- Game State Events ---
const GAME_PAUSED = "game.paused"
const GAME_RESUMED = "game.resumed"

# --- UI State Events ---
const MENU_OPENED = "ui.menu_opened"
const MENU_CLOSED = "ui.menu_closed"

--- EventBus.on() Subscriptions ---
src/ui/game_hud/game_hud.gd:17:	_player_health_token = EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, on_player_health_changed)
src/ui/game_hud/game_hud.gd:18:	_player_charges_token = EventBus.on(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, on_player_healing_charges_changed)
src/ui/game_hud/game_hud.gd:19:	_boss_health_token = EventBus.on(EventCatalog.BOSS_HEALTH_CHANGED, on_boss_health_changed)
src/ui/global_hud/global_hud.gd:35:	_menu_opened_token = EventBus.on(EventCatalog.MENU_OPENED, _on_menu_opened)
src/ui/global_hud/global_hud.gd:36:	_menu_closed_token = EventBus.on(EventCatalog.MENU_CLOSED, _on_menu_closed)
src/scenes/game/game.gd:17:	_pause_token = EventBus.on(EventCatalog.GAME_PAUSED, _on_game_paused)
src/scenes/game/game.gd:18:	_resume_token = EventBus.on(EventCatalog.GAME_RESUMED, _on_game_resumed)


--- EventBus.emit() Emissions ---
src/ui/screens/controls_menu/controls_menu.gd:9:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/controls_menu/controls_menu.gd:70:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/credits_menu/credits_menu.gd:9:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/credits_menu/credits_menu.gd:60:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/options_menu/options_menu.gd:9:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/options_menu/options_menu.gd:61:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/sound_menu/sound_menu.gd:19:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/sound_menu/sound_menu.gd:47:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/title_screen/title_screen.gd:10:	EventBus.emit(EventCatalog.MENU_OPENED) # Announce that a menu is open
src/ui/screens/title_screen/title_screen.gd:42:	EventBus.emit(EventCatalog.MENU_CLOSED) # Announce that the menu is closing
src/core/sequencing/steps/emit_step.gd:16:	EventBus.emit(event_name, payload)
src/entities/boss/base_boss.gd:121:	EventBus.emit(EventCatalog.BOSS_HEALTH_CHANGED, ev, self)
src/entities/player/player.gd:127:	EventBus.emit(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, ev, self)
src/entities/player/player.gd:191:	EventBus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev, self)


=====================================
FILE: ./docs/sprint_0_audit/EVENT-001_Event_Flow_Map.md
=====================================
# Event Flow Map

**Date:** 2025-08-10
**Status:** Generated

---

This document maps all events defined in `EventCatalog.gd`. For each event, it lists all scripts that emit the event and all scripts that subscribe (listen) to it.

## Event: `PLAYER_HEALTH_CHANGED`

**Path:** `player.health_changed`

### Emitters (who sends this event?)
```
src/entities/player/player.gd:	EventBus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev, self)
```

### Listeners (who listens for this event?)
```
src/ui/game_hud/game_hud.gd:	_player_health_token = EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, on_player_health_changed)
```

---

## Event: `PLAYER_HEALING_CHARGES_CHANGED`

**Path:** `player.healing_charges_changed`

### Emitters (who sends this event?)
```
src/entities/player/player.gd:	EventBus.emit(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, ev, self)
```

### Listeners (who listens for this event?)
```
src/ui/game_hud/game_hud.gd:	_player_charges_token = EventBus.on(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, on_player_healing_charges_changed)
```

---

## Event: `PLAYER_TOOK_DAMAGE`

**Path:** `player.took_damage`

### Emitters (who sends this event?)
```
No emitters found.
```

### Listeners (who listens for this event?)
```
No listeners found.
```

---

## Event: `PLAYER_DIED`

**Path:** `player.died`

### Emitters (who sends this event?)
```
No emitters found.
```

### Listeners (who listens for this event?)
```
No listeners found.
```

---

## Event: `BOSS_HEALTH_CHANGED`

**Path:** `boss.health_changed`

### Emitters (who sends this event?)
```
src/entities/boss/base_boss.gd:	EventBus.emit(EventCatalog.BOSS_HEALTH_CHANGED, ev, self)
```

### Listeners (who listens for this event?)
```
src/ui/game_hud/game_hud.gd:	_boss_health_token = EventBus.on(EventCatalog.BOSS_HEALTH_CHANGED, on_boss_health_changed)
```

---

## Event: `BOSS_DIED`

**Path:** `boss.died`

### Emitters (who sends this event?)
```
No emitters found.
```

### Listeners (who listens for this event?)
```
No listeners found.
```

---

## Event: `GAME_PAUSED`

**Path:** `game.paused`

### Emitters (who sends this event?)
```
No emitters found.
```

### Listeners (who listens for this event?)
```
src/scenes/game/game.gd:	_pause_token = EventBus.on(EventCatalog.GAME_PAUSED, _on_game_paused)
```

---

## Event: `GAME_RESUMED`

**Path:** `game.resumed`

### Emitters (who sends this event?)
```
No emitters found.
```

### Listeners (who listens for this event?)
```
src/scenes/game/game.gd:	_resume_token = EventBus.on(EventCatalog.GAME_RESUMED, _on_game_resumed)
```

---

## Event: `MENU_OPENED`

**Path:** `ui.menu_opened`

### Emitters (who sends this event?)
```
src/ui/screens/controls_menu/controls_menu.gd:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/credits_menu/credits_menu.gd:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/options_menu/options_menu.gd:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/sound_menu/sound_menu.gd:	EventBus.emit(EventCatalog.MENU_OPENED)
src/ui/screens/title_screen/title_screen.gd:	EventBus.emit(EventCatalog.MENU_OPENED) # Announce that a menu is open
```

### Listeners (who listens for this event?)
```
src/ui/global_hud/global_hud.gd:	_menu_opened_token = EventBus.on(EventCatalog.MENU_OPENED, _on_menu_opened)
```

---

## Event: `MENU_CLOSED`

**Path:** `ui.menu_closed`

### Emitters (who sends this event?)
```
src/ui/screens/controls_menu/controls_menu.gd:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/credits_menu/credits_menu.gd:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/options_menu/options_menu.gd:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/sound_menu/sound_menu.gd:	EventBus.emit(EventCatalog.MENU_CLOSED)
src/ui/screens/title_screen/title_screen.gd:	EventBus.emit(EventCatalog.MENU_CLOSED) # Announce that the menu is closing
```

### Listeners (who listens for this event?)
```
src/ui/global_hud/global_hud.gd:	_menu_closed_token = EventBus.on(EventCatalog.MENU_CLOSED, _on_menu_closed)
```

---



=====================================
FILE: ./docs/sprint_0_audit/ARCH-002_Acceptance_Criteria.md
=====================================
# ARCH-002: Refactoring Acceptance Criteria

**Date:** 2025-08-10

**Status:** Adopted

---

## Context

This document serves as a high-level checklist for our entire refactoring initiative. A sprint's work is considered "done" when it meets its specific criteria, and the entire initiative is "done" when all items on this list are checked.

## Global Acceptance Criteria

The refactoring is complete when all of the following are true:

### Architectural Health
- [ ] **Single Source of State:** All mutable runtime state (player data, game state) is managed via `Resource`-based data containers, eliminating the "dual architecture" of stateful singletons.
- [ ] **Standardized Configuration:** All tunable gameplay values are sourced from `.tres` `Resource` files, not `Constants.gd` or hardcoded magic numbers. A validation system checks for missing configs at startup.
- [ ] **Explicit Dependencies:** Core components (`HealthComponent`, `CombatComponent`, etc.) receive their dependencies via a `setup(config, services)` method, not by calling global singletons directly.
- [ ] **Clear Communication Rules:** The `EventBus` is used for global, cross-system messages. Godot signals are used for local, intra-scene communication. Direct calls between components are minimized or eliminated.

### Testing & Verification
- [ ] **Baseline Metrics Met:** The refactored game performs equal to or better than the baseline metrics established in `TEST-001_Baseline_Metrics.md`.
- [ ] **Regression Tests Pass:** The game successfully passes all manual checks in the `TEST-003_Regression_Checklist.md`.
- [ ] **Smoke Tests Pass:** The game is verifiably stable and key systems are functional as defined in `TEST-002_Smoke_Tests.md`.

### Code Quality & Documentation
- [ ] **No Dead Code:** All old, replaced systems and scripts have been safely removed from the project.
- [ ] **Documentation Updated:** All relevant architectural documents (`README.md`, ADRs) have been updated to reflect the new patterns.
- [ ] **Linter/Formatter Clean:** The entire codebase is formatted consistently and passes static analysis checks without warnings.


=====================================
FILE: ./docs/sprint_0_audit/ARCH-001_Refactoring_Principles.md
=====================================
# ARCH-001: Refactoring Principles

**Date:** 2025-08-10

**Status:** Adopted

---

## Context

To ensure our refactoring effort is focused, consistent, and successful, we must operate from a shared set of guiding principles. These principles will act as a tie-breaker when design decisions are unclear and will define the target state of our architecture.

## Guiding Principles

1.  **Work *With* the Engine, Not Against It.**
    *   **Rationale:** Our attempt to force a classic DI pattern failed because it fought Godot's startup lifecycle. All future architectural decisions must respect and leverage Godot's idiomatic patterns (nodes, scenes, signals, resources).
    *   **In Practice:** We will prefer solutions that feel natural in Godot over patterns that require complex workarounds to function.

2.  **Every Change Must Be Verifiable.**
    *   **Rationale:** Refactoring without testing is just moving code around. To prevent regressions, every significant change must be accompanied by a clear method of verification.
    *   **In Practice:** This means creating smoke tests, regression checklists, and eventually, automated unit tests. We will use the documents `TEST-002` and `TEST-003` to track this.

3.  **Prioritize Decoupling and Explicit Dependencies.**
    *   **Rationale:** The primary weakness of the current Service Locator pattern is that dependencies are hidden. Our goal is to make dependencies explicit.
    *   **In Practice:** Components and systems should receive their dependencies through a `setup()` method where possible, rather than calling global singletons in their internal logic. Communication should favor events (`EventBus`) for global messages and signals for local, parent-child messages.

4.  **Standardize Patterns; Eliminate "Dual Architectures".**
    *   **Rationale:** The audit identified several areas (state management, configuration) where two different patterns exist to solve the same problem. This increases cognitive load and maintenance cost.
    *   **In Practice:** We will choose a single, standard way to manage state (the `Resource`-based data pattern) and a single way to manage configuration (`tres` config resources), and migrate all existing code to these standards.

5.  **The Strangler Fig Pattern: Migrate Incrementally.**
    *   **Rationale:** Big-bang rewrites are risky and prone to failure. We will adopt the Strangler Fig pattern.
    *   **In Practice:** We will create the new, improved system alongside the old one. We will then migrate dependencies one by one to the new system. Once all dependencies are migrated, we can safely delete the old system. This ensures the game remains functional throughout the entire process.


=====================================
FILE: ./docs/sprint_0_audit/config_usage.txt
=====================================
src/ui/game_hud/game_hud.gd:22:	var max_health = Config.get_value("player.health.max_health", 5)
src/ui/game_hud/game_hud.gd:25:	boss_health_bar.max_value = Config.get_value("boss.stats.health", 30)
src/core/data/config/config.gd:14:# Example: Config.get_value("player.physics.speed")
src/entities/boss/base_boss.gd:31:	b_data.patrol_speed = Config.get_value("boss.stats.patrol_speed", 100.0)
src/entities/boss/base_boss.gd:57:		velocity.y += Config.get_value("general.physics.gravity") * delta
src/entities/components/combat_component.gd:23:	p_data.attack_cooldown_timer = Config.get_value("player.combat.attack_cooldown")
src/entities/components/combat_component.gd:37:	owner_node.velocity.y = -Config.get_value("player.physics.pogo_force")
src/entities/components/combat_component.gd:40:	p_data.air_jumps_left = Config.get_value("player.physics.max_air_jumps")
src/entities/components/health_component.gd:47:	max_health = Config.get_value(config_paths.max_health, 10)
src/entities/components/health_component.gd:48:	invincibility_duration = Config.get_value(config_paths.get("invincibility", "player.health.invincibility_duration"), 1.0)
src/entities/components/health_component.gd:84:	var knockback_speed = Config.get_value(_knockback_config.speed, 400.0)
src/entities/components/health_component.gd:86:		knockback_speed = Config.get_value(_knockback_config.hazard_speed, knockback_speed)
src/entities/components/input_component.gd:24:		p_data.jump_buffer_timer = Config.get_value("player.physics.jump_buffer")
src/entities/components/input_component.gd:35:			if p_data.charge_timer >= Config.get_value("player.combat.charge_time"):
src/entities/player/player.gd:87:		p_data.wall_coyote_timer = Config.get_value("player.physics.wall_coyote_time")
src/entities/player/player.gd:120:	velocity.x = Input.get_axis("ui_left", "ui_right") * Config.get_value("player.physics.speed")
src/entities/player/player.gd:144:	if p_data.healing_charges >= Config.get_value("player.health.max_healing_charges"): return
src/entities/player/player.gd:146:	if p_data.determination_counter >= Config.get_value("player.combat.determination_per_charge"):
src/entities/player/states/state_jump.gd:6:	player.velocity.y = -Config.get_value("player.physics.jump_force")
src/entities/player/states/state_jump.gd:15:		player.velocity.y *= Config.get_value("player.physics.jump_release_dampener")
src/entities/player/states/state_jump.gd:26:	player.velocity.y += Config.get_value("general.physics.gravity") * delta
src/entities/player/states/state_dash.gd:9:	p_data.dash_duration_timer = Config.get_value("player.physics.dash_duration")
src/entities/player/states/state_dash.gd:10:	p_data.dash_cooldown_timer = Config.get_value("player.physics.dash_cooldown")
src/entities/player/states/state_dash.gd:11:	player.velocity = _get_dash_direction() * Config.get_value("player.physics.dash_speed")
src/entities/player/states/state_heal.gd:7:	player.healing_timer.start(Config.get_value("player.health.heal_duration"))
src/entities/player/states/state_wall_slide.gd:7:	p_data.air_jumps_left = Config.get_value("player.physics.max_air_jumps")
src/entities/player/states/state_wall_slide.gd:14:	var gravity = Config.get_value("general.physics.gravity")
src/entities/player/states/state_wall_slide.gd:15:	var wall_slide_speed = Config.get_value("player.physics.wall_slide_speed")
src/entities/player/states/state_wall_slide.gd:38:	player.velocity.y = -Config.get_value("player.physics.wall_jump_force_y")
src/entities/player/states/state_wall_slide.gd:39:	player.velocity.x = p_data.last_wall_normal.x * Config.get_value("player.physics.wall_jump_force_x")
src/entities/player/states/state_attack.gd:6:	p_data.attack_duration_timer = Config.get_value("player.combat.attack_duration")
src/entities/player/states/state_attack.gd:7:	p_data.attack_cooldown_timer = Config.get_value("player.combat.attack_cooldown")
src/entities/player/states/state_attack.gd:33:		var friction = Config.get_value("player.combat.attack_friction")
src/entities/player/states/state_hurt.gd:8:	p_data.knockback_timer = Config.get_value("player.combat.knockback_duration")
src/entities/player/states/state_hurt.gd:11:	player.velocity.y += Config.get_value("general.physics.gravity") * delta
src/entities/player/states/state_fall.gd:27:		gravity_multiplier = Config.get_value("player.physics.fast_fall_gravity_multiplier")
src/entities/player/states/state_fall.gd:28:	player.velocity.y += Config.get_value("general.physics.gravity") * gravity_multiplier * delta
src/entities/player/states/state_fall.gd:40:	player.velocity.x = p_data.last_wall_normal.x * Config.get_value("player.physics.wall_jump_force_x")
src/entities/player/states/state_move.gd:6:	p_data.air_jumps_left = Config.get_value("player.physics.max_air_jumps")
src/entities/player/states/state_move.gd:10:	p_data.coyote_timer = Config.get_value("player.physics.coyote_time")
src/entities/player/states/state_move.gd:12:	player.velocity.y += Config.get_value("general.physics.gravity") * delta


=====================================
FILE: ./docs/sprint_0_audit/singleton_map.txt
=====================================

Settings="*res://src/core/data/config/settings.gd"
AudioManager="*res://src/core/systems/audio_manager.gd"
CursorManager="*res://src/core/systems/cursor_manager.gd"
Constants="*res://src/core/util/constants.gd"
AssetPaths="*res://src/core/util/asset_paths.gd"
GlobalHud="*res://src/ui/global_hud/global_hud.tscn"
GameManager="*res://src/core/systems/game_manager.gd"
ArenaBuilder="*res://src/core/building/arena_builder.gd"
EventBus="*res://src/core/events/event_bus.gd"
Sequencer="*res://src/core/sequencing/sequencer.gd"
Config="*res://src/core/data/config/config.gd"
Palette="*res://src/core/util/palette.gd"
ObjectPool="*res://src/core/systems/object_pool.gd"
PhysicsLayers="*res://src/core/util/physics_layers.gd"



=====================================
FILE: ./docs/sprint_0_audit/state_machine_flow.md
=====================================


=====================================
FILE: ./docs/sprint_0_audit/TEST-003_Regression_Checklist.md
=====================================


=====================================
FILE: ./docs/sprint_0_audit/ADR-002_Communication_Patterns.md
=====================================
# ADR-002: Communication Patterns (Signal vs. EventBus)

**Date:** 2025-08-10

**Status:** Adopted

---

## Context

The project utilizes two primary methods for communication between different parts of the codebase: Godot's built-in **Signal** system and our custom global **EventBus**. Without a clear standard, it can be ambiguous which tool to use, potentially leading to tightly-coupled systems that are difficult to maintain or debug.

This document defines the official standard for choosing a communication pattern.

## Decision

We will adhere to a clear "Local vs. Global" distinction for communication:

1. **Use Godot Signals for *Local* Communication.**
2. **Use the EventBus for *Global* Communication.**

---

### 1. Godot Signals: Local Communication

Signals are the preferred method for communication **within a single, self-contained scene** or between a parent node and its direct children. This represents a tightly-coupled, "owner-to-part" relationship.

**Use a Signal when:**
- A child node needs to tell its parent that something happened (e.g., a `Button` telling a `Menu` it was pressed).
- A parent node needs to broadcast a message to all of its direct children.
- A component needs to communicate its result back to its owner (e.g., `CombatComponent` emitting `pogo_bounce_requested` for `Player` to handle).

**Litmus Test:** If the sender and receiver are part of the same scene file (`.tscn`) and have a direct parent-child relationship, use a signal.

**Example (`player.gd`):**
```gdscript
# The HealthComponent (child) emits a signal.
signal died

# The Player (parent) listens to its own component.
health_component.died.connect(_on_health_component_died)
```

### 2. EventBus: Global Communication

The EventBus is the preferred method for communication **between disparate, decoupled systems**. The sender and receiver should have no direct knowledge of each other. This represents a loosely-coupled, "system-to-system" relationship.

**Use the EventBus when:**
- A gameplay event needs to be reflected in the UI (e.g., the Player's health changes, and the GameHUD must be updated).
- A UI action needs to trigger a global system change (e.g., a TitleScreen button opens a menu, and the GlobalHUD must show the mute icon).
- An entity in the game world needs to trigger an audio cue (e.g., the Boss dies, and the AudioManager needs to play a victory sound).

**Litmus Test:** If the sender and receiver are in completely different parts of the scene tree and do not know about each other's existence, use the EventBus.

**Example (player.gd emitting, game_hud.gd listening):**

```gdscript
# player.gd (Sender)
var ev = PlayerHealthChangedEvent.new()
EventBus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev)

# game_hud.gd (Receiver)
EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, on_player_health_changed)
```

## Consequences

**Positive:** This standard provides a clear, unambiguous rule that is easy to follow, promoting clean architecture and preventing "spaghetti" code where everything is globally connected via the EventBus. It keeps scenes self-contained and makes systems highly modular.

**Negative:** None. This is a best-practice clarification that reduces cognitive overhead.

=====================================
FILE: ./docs/sprint_0_audit/ADR.mdADR-001_Service_Locator_Pattern.md
=====================================
# ADR-001: Global System Access via Autoload Singletons (Service Locator)

**Date:** 2025-08-10

**Status:** Accepted (Existing Pattern)

---

## Context

The project requires numerous cross-cutting services that need to be accessible from various parts of the codebase. These include core systems (EventBus, AudioManager, ObjectPool), data providers (Config, Settings, Palette), and utility services (AssetPaths, PhysicsLayers).

A simple and idiomatic way to achieve this in Godot is by using the **Autoload** feature, which creates a globally accessible singleton instance of a script or scene. This effectively implements the **Service Locator** design pattern, where any node in the game can directly access a service by its global name (e.g., `EventBus.emit()`, `Config.get_value()`).

## Decision

We will use the Godot Autoload (Service Locator) pattern as the primary mechanism for providing global services throughout the application.

This decision was made because it is the most direct, performant, and engine-idiomatic way to solve the problem of global access in Godot 4. It avoids the need for complex dependency injection frameworks or manual "prop-drilling" of dependencies through the node tree.

The audit file `singleton_map.txt` confirms there are currently 14 such services registered in `project.godot`.

## Consequences

### Positive:
-   **Simplicity & Speed:** Accessing a service is trivial (`ServiceName.method()`). There is no setup boilerplate required in consumer scripts.
-   **Performance:** Autoloads are instantiated once at startup, providing fast and reliable access.
-   **Decoupling:** Systems can communicate through a central service like `EventBus` without needing direct references to each other, as shown in `event_usage.txt`.

### Negative (Risks & Architectural Debt):
-   **Hidden Dependencies:** The dependencies of a script are not explicitly declared in its API. To know that `player.gd` depends on `Config`, one must read the entire script body. This makes the code harder to reason about.
-   **Difficult to Test:** This is the most significant drawback. It is very difficult to unit-test a script that calls a global singleton. You cannot easily replace `EventBus` with a "mock" or "fake" version for a test, which was the root cause of the failed DI refactor attempt.
-   **Risk of Tight Coupling:** Because services are so easy to access, it can encourage developers to create a "spaghetti" architecture where everything calls everything else, bypassing more structured communication patterns.
-   **Configuration Fragility:** The heavy reliance on string-based keys for services like `Config` and `EventBus` is fragile. A typo will result in a runtime error, not a compile-time one. The `config_usage.txt` file shows dozens of such calls, each being a potential point of failure.

---

## Next Steps (Refactoring Plan)

This pattern, while accepted, is the primary target for refinement in our upcoming refactoring sprints. The plan is not to eliminate autoloads, but to mitigate their negative consequences by:
1.  **Standardizing Configuration (Sprint 1):** Introduce validation to catch bad config paths at startup.
2.  **Unifying Data Architecture (Sprint 2):** Reduce the number of singletons that hold mutable state.
3.  **Refining Communication (Sprint 3):** Clarify when to use `EventBus` versus other patterns to reduce the risk of "spaghetti" code.


=====================================
FILE: ./docs/sprint_0_audit/STYLE-001_GDScript_Style_Guide.md
=====================================
# STYLE-001: GDScript Style Guide

**Date:** 2025-08-16
**Status:** Adopted

---

## Context

This document codifies the official style and formatting standards for all GDScript files in the project. The purpose is to maintain a cohesive, readable, and predictable codebase that is easy for any developer to navigate.

## Script Structure Standard

All `.gd` script files **MUST** adhere to the following structure and order:

1.  **File Path Header:** A single-line comment with the full `res://` path.
    ```gdscript
    # src/entities/player/player.gd
    ```
2.  **`@tool` Annotation:** If the script needs to run in the editor.
3.  **Class Docstring:** A multi-line `##` comment explaining the class's purpose.
4.  **`class_name` Declaration:** If applicable.
5.  **`extends` Declaration.**
6.  **Signals:** All `signal` definitions.
7.  **Enums:** All `enum` definitions.
8.  **Constants:** All `const` definitions.
9.  **`@export` Variables:** Grouped with `@export_group`.
10. **Node References:** All `@onready var` declarations.
11. **Public Member Variables:** Documented with a `##` comment.
12. **Private Member Variables:** Prefixed with an underscore `_`.
13. **Godot Lifecycle Methods:** `_ready`, `_process`, `_physics_process`, etc.
14. **Public Methods:** The primary API of the class.
15. **Private Methods:** Helper functions, prefixed with an underscore `_`.
16. **Signal Handlers:** All `_on_*` methods.

## Naming Conventions

-   **Classes & Nodes:** `PascalCase` (e.g., `Player`, `HealthComponent`).
-   **Files:** `snake_case` (e.g., `player.gd`, `health_component.gd`).
-   **Functions & Variables:** `snake_case` (e.g., `apply_damage`, `current_health`).
-   **Private Members:** `_snake_case` (e.g., `_player_node`).
-   **Constants & Enums:** `UPPER_SNAKE_CASE` (e.g., `CLOSE_RANGE_THRESHOLD`, `State.MOVE`).
-   **Interfaces:** `IPascalCase` (e.g., `IDamageable`, `IComponent`).

## Documentation

-   **Class Docstrings:** Use `##` on the lines before `class_name` to provide a high-level overview of the class's responsibility.
-   **Function/Variable Docstrings:** Use `##` on the line immediately preceding a function, signal, or public variable to generate an in-editor tooltip.
-   **Brevity:** Keep comments concise and focused on the "why," not the "what." The code should explain what it does; comments should explain why it does it that way.

=====================================
FILE: ./docs/sprint_0_audit/ADR.md
=====================================


=====================================
FILE: ./docs/ARCHITECTURE.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═════════════════╗
║  █████╗ ██████╗  ██████╗██╗  ██╗██╗████████╗███████╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗ ║
║ ██╔══██╗██╔══██╗██╔════╝██║  ██║██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗██╔════╝ ║
║ ███████║██████╔╝██║     ███████║██║   ██║   █████╗  ██║        ██║   ██║   ██║██████╔╝█████╗   ║
║ ██╔══██║██╔══██╗██║     ██╔══██║██║   ██║   ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗██╔══╝   ║
║ ██║  ██║██║  ██║╚██████╗██║  ██║██║   ██║   ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║███████╗ ║
║ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝ ║
║                                                                              ╔═════════════════╝
║          A high-level summary of the project's technical patterns.           ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       KEY ARCHITECTURAL PATTERNS                     ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Singleton-Driven Core (Service Locator)                                 ║
║      ░ Global systems (e.g., `AudioManager`, `ObjectPool`, `EventBus`) are   ║
║      ░ managed by Autoload singletons for universal, easy access.            ║
║                                                                              ║
║   █  Component-Based Entities                                                ║
║      ░ Entities (Player, Boss) are orchestrators for a collection of         ║
║      ░ single-responsibility components (e.g., `HealthComponent`). All       ║
║      ░ components extend the `IComponent` interface contract.                ║
║                                                                              ║
║   █  State Pattern for Logic                                                 ║
║      ░ Complex entity behavior is managed by a `BaseStateMachine`. Each state║
║      ░ (e.g., `StateMove`, `StateAttack`) is its own class, encapsulating    ║
║      ░ logic for a single behavior.                                          ║
║                                                                              ║
║   █  Data-Driven Design via Resources                                        ║
║      ░ All tunable gameplay values (damage, health, cooldowns) are defined   ║
║      ░ in custom `Resource` files (`.tres`), primarily `combat_config.tres`. ║
║      ░ This decouples game balance from code and allows for rapid tuning.    ║
║                                                                              ║
║   █  Owner-Driven Dependency Injection                                       ║
║      ░ This is the official DI pattern. An owner node (like `player.gd`) is  ║
║      ░ responsible for gathering its dependencies (child nodes, global configs)║
║      ░ in its `_ready()` function and injecting them into its components via ║
║      ░ their `setup()` method. Components NEVER call singletons directly.    ║
║                                                                              ║
║   █  Communication Patterns                                                  ║
║      ░ ■ Godot Signals: Used for **local**, intra-scene communication,       ║
║      ░   typically between a component and its owner or a child and parent.  ║
║      ░ ■ EventBus: Used for **global**, cross-system communication between   ║
║      ░   decoupled parts of the game (e.g., `Player` -> `GameHUD`).          ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/ASSETS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    █████╗ ███████╗███████╗███████╗████████╗███████╗                          ║
║   ██╔══██╗██╔════╝██╔════╝██╔════╝╚══██╔══╝██╔════╝                          ║
║   ███████║███████╗███████╗███████╗   ██║   ███████╗                          ║
║   ██╔══██║╚════██║╚════██║██╔════╝   ██║   ╚════██║                          ║
║   ██║  ██║███████║███████║███████╗   ██║   ███████║                          ║
║   ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝   ╚═╝   ╚══════╝                          ║
║                                                                              ║
║        A registry for asset sources, licenses, and style guidelines.         ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                            STYLE GUIDE                               ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Visual Style                                                            ║
║      ░  Overall: Clean, minimalist, and geometric.                           ║
║      ░  Color Palette: High-contrast grayscale for placeholders.             ║
║      ░  Shape Language: A strict adherence to square-based geometry.         ║
║      ░  Rectangles are only permitted for static environmental elements.     ║
║                                                                              ║
║   █  Audio Style                                                             ║
║      ░  Music: Chiptune-inspired, melodic, and loopable tracks.              ║
║      ░  Sound Effects: Crisp, digital, and immediately recognizable SFX.     ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                           ASSET SOURCES                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Graphics                                                                ║
║      ░  Source: All current visual assets (sprites, icons) are original      ║
║      ░  creations for this project.                                          ║
║      ░  License: N/A (Internal)                                              ║
║                                                                              ║
║   █  Audio                                                                   ║
║      ░  Source: All audio assets were generated by the project creator using ║
║      ░  paid subscriptions to ElevenLabs (SFX) and Udio (Music).             ║
║      ░  License: CC0 1.0 Universal (Public Domain).                          ║
║                                                                              ║
║   █  Fonts                                                                   ║
║      ░  Source: "M PLUS Rounded 1c" by the M+ FONTS PROJECT.                 ║
║      ░  License: SIL Open Font License (OFL).                                ║
║      ░  Source Link: `https://fonts.google.com/specimen/M+PLUS+Rounded+1c`   ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                      ATTRIBUTION REQUIREMENTS                        ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Per the CC0 license for audio and original creation for graphics, no       ║
║   attribution is required for any asset. It is good practice to keep the     ║
║   OFL.txt for the font with the project files.                               ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/CHANGELOG.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═╗
║   ██████╗██╗  ██╗ █████╗ ███╗   ██╗ ██████╗ ███████╗██╗      ██████╗  ██████╗  ║
║  ██╔════╝██║  ██║██╔══██╗████╗  ██║██╔════╝ ██╔════╝██║     ██╔═══██╗██╔════╝  ║
║  ██║     ███████║███████║██╔██╗ ██║██║  ███╗█████╗  ██║     ██║   ██║██║  ███╗ ║
║  ██║     ██╔══██║██╔══██║██║╚██╗██║██║   ██║██╔══╝  ██║     ██║   ██║██║   ██║ ║
║  ╚██████╗██║  ██║██║  ██║██║ ╚████║╚██████╔╝███████╗███████╗╚██████╔╝╚██████╔╝ ║
║   ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝╚══════╝ ╚═════╝  ╚═════╝  ║
║                                                                              ╔═╝
║                  A log of all notable changes to the project.                ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██     [0.13.0] - UNTITLED AND UNDETERMINED TITLE STILL - 08/XX/2025    ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║

   PERFORMANCE: FXCOMPONENT OPTIMIZATION
   Completed a full optimization pass on the FXComponent to eliminate runtime
   allocations, resulting in smoother performance during intense combat with
   many simultaneous visual effects.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Implemented Tween Pooling: The FXComponent now creates and reuses a
      ░   single Tween object, preventing the performance cost of creating and
      ░   destroying Tweens for every effect.
      ░ ■ Implemented Material Reuse: The component now uses a single,
      ░   duplicated ShaderMaterial instance. Effects are played by copying
      ░   shader parameters to this instance rather than duplicating an entire
      ░   material resource on every playback.
   █  Fixed
      ░ ■ Resolved a series of subtle race conditions and API misuse errors
      ░   related to the Tween lifecycle, making the interruption of effects
      ░   (e.g., rapid hits) robust and error-free.
      ░ ■ Corrected the logic for copying shader uniforms to use the proper
      ░   Godot 4 API (`Shader.get_shader_uniform_list`), resolving a critical
      ░   API call error.




   FXCOMPONENT HARDENING & VERIFICATION
   Improved the robustness and testability of the core visual effects system.
   This completes the safety and verification phase of the FX refactor.
   ────────────────────────────────────────────────────────────────────────
   █  Added
      ░ ■ Added a `get_current_effect_name()` method to `FXComponent` to allow
      ░   external systems to query its state for debugging purposes.
      ░ ■ Created a reusable `MockEntity` script in the `tools/` directory to
      ░   facilitate isolated component testing in the future.
   █  Changed
      ░ ■ Hardened the `DebugOverlay` to safely inspect entities that may not
      ░   have a full complement of components, preventing potential crashes
      ░   when debugging new or incomplete entity types.
   █  Fixed
      ░ ■ Resolved a critical timing issue in the `DebugOverlay` that prevented
      ░   it from correctly reading dynamically-added properties from mock
      ░   entities in a test environment.




   DATA-DRIVEN SHADER SYSTEM INTEGRATION
   Completed the full integration of the "FX Cookbook" system, migrating the
   game's core hit-flash effect to the new data-driven, component-based
   architecture. This makes all entity visual feedback modular and extensible.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Refactored `FXComponent` into a generic "effect player." It no longer
      ░   contains hardcoded effect logic and can now play any `ShaderEffect`
      ░   resource it is given.
      ░ ■ The `FXComponent` now correctly subscribes to its sibling
      ░   `HealthComponent`'s `took_damage` signal, fully decoupling the trigger
      ░   (taking damage) from the visual response (playing a shader effect).
   █  Changed
      ░ ■ The Player, BaseBoss, and Turret entities now inject a preloaded
      ░   `ShaderEffect` resource into their `FXComponent` upon initialization,
      ░   adhering to the Owner-Driven Dependency Injection pattern.
   █  Fixed
      ░ ■ Resolved a critical bug where the hit-flash effect was not playing
      ░   during gameplay. The issue was traced to a missing signal connection
      ░   between the `HealthComponent` and the `FXComponent`, which has now
      ░   been correctly established in the `FXComponent`'s `setup` method.


   DATA-DRIVEN SHADER SYSTEM (FX COOKBOOK)
   Established the foundational architecture for the "FX Cookbook," a data-
   driven system for defining and triggering shader-based visual effects.
   This completes the first phase of the "Juice & Feedback" initiative.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Created a new `ShaderEffect` custom resource. This allows visual
      ░   effects to be defined as data files (`.tres`), fully decoupling
      ░   effect configuration from game logic.
      ░ ■ Established a robust, code-first pattern for loading custom resources
      ░   that depend on sub-resources, resolving a series of critical engine-
      ░   level resource caching and loading errors.
   █  Added
      ░ ■ Created a new `fx_playground.tscn` scene to serve as a minimal
      ░   testbed for rapidly prototyping and verifying new shader effects in
      ░   complete isolation from the main game loop.
   █  Changed
      ░ ■ The existing red hit-flash shader has been migrated to the new
      ░   `ShaderEffect` system, serving as the pilot and proof-of-concept for
      ░   the new architecture.



   UI ARCHITECTURE REFINEMENT (DECOUPLING)
   Completed a full refactor of all reusable UI components to eliminate
   hidden dependencies on global singletons, aligning the UI with the
   project's core architectural patterns.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Refactored `StyledMenuItem`, `MuteButton`, and `LogoDisplay` to be
      ░   purely presentational. They no longer call `AudioManager` directly.
      ░ ■ UI components now only emit signals (e.g., `pressed`) to announce
      ░   user interaction.
      ░ ■ The owner menu scenes (e.g., `TitleScreen`) are now solely
      ░   responsible for listening to these signals and triggering audio
      ░   feedback, enforcing the Owner-Driven Dependency Injection pattern.



   ARCHITECTURAL HARDENING (DEPENDENCY INJECTION)
   Completed a full-scale refactor to enforce the Owner-Driven Dependency
   Injection pattern across all entities and components, eliminating hidden
   dependencies on global singletons and improving architectural clarity.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Refactored all entity components (`CombatComponent`,
      ░   `PlayerResourceComponent`, `FXComponent`) to receive their singleton
      ░   dependencies (`ObjectPool`, `EventBus`) via their `setup()` methods.
      ░ ■ Updated all projectile scripts to receive their `ObjectPool` dependency
      ░   on activation, making them fully self-contained.
      ░ ■ Centralized all visual effect logic into the `FXComponent`, which now
      ░   listens for local signals from `HealthComponent` to trigger effects.
   █  Removed
      ░ ■ Removed all direct calls to `FXManager`, `ObjectPool`, and `EventBus`
      ░   from entity main scripts and components, formalizing their roles as
      ░   dependency injectors and orchestrators.



   ARCHITECTURAL HARDENING & MEMORY MANAGEMENT
   Completed a major architectural push to enforce the Owner-Driven Dependency
   Injection pattern and resolve all memory leaks on game exit. The codebase
   is now more robust, testable, and free of dangling resource references.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Enforced the Owner-Driven Dependency Injection pattern project-wide.
      ░   Components now receive their dependencies (e.g., ObjectPool, EventBus)
      ░   from their owner via their `setup()` method and no longer call
      ░   global singletons directly.
      ░ ■ Refactored all projectile scenes to receive their ObjectPool dependency
      ░   upon activation, fully decoupling them from the global singleton.
   █  Fixed
      ░ ■ Resolved all `ObjectDB instances leaked at exit` warnings by
      ░   implementing robust `_exit_tree` cleanup methods in all core
      ░   singletons (`ObjectPool`, `EventBus`, `AudioManager`).
      ░ ■ Eliminated all RenderingServer `RID` leaks by ensuring all pooled
      ░   nodes and their rendering resources are explicitly freed on exit.
      ░ ■ Fixed a race condition in projectile scripts that could cause a crash
      ░   if an object was returned to the pool multiple times in one frame.
      ░ ■ Resolved all remaining assertion and parse errors related to the new
      ░   dependency injection pattern.



PLAYER MECHANICS HARDENING & REFACTOR
   Completed a full refactor of the player's jump system to be state-driven,
   resolving an infinite jump bug and enabling air jumps during ascent. Also
   unified all player knockback values for consistent gameplay feedback.
   ────────────────────────────────────────────────────────────────────────
   █  Architectural Changes
      ░ ■ Refactored all jump logic out of the generic `PlayerAbilityComponent`
      ░   and into the relevant states (`StateMove`, `StateFall`, `StateJump`),
      ░   making the behavior context-aware and architecturally robust.
   █  Fixed
      ░ ■ Resolved a critical bug that allowed for infinite air jumps. Air jumps
      ░   are now correctly consumed and reset upon landing or wall contact.
      ░ ■ The player can now correctly perform an air jump at any point during
      ░   their initial jump arc (both ascending and descending).
      ░ ■ Unified the knockback speed for enemy and hazard damage in the
      ░   `CombatConfig`, ensuring consistent and predictable feedback when
      ░   the player takes damage from any source.





   NEW BOSS ATTACK & SYSTEM HARDENING                                          
   Implemented a complex, data-driven homing projectile attack for the boss    
   and resolved a series of critical, low-level bugs related to resource       
   loading, physics safety, and object pooling state.                          
   ────────────────────────────────────────────────────────────────────────    
   █  Added                                                                    
      ░ ■ Implemented a new `HomingOmniBurst` attack for the boss's third phase,
      ░   featuring 30 projectiles that actively seek the player and shrink    
      ░   over their lifetime.                                                 
      ░ ■ Created a new `HomingBossShot` projectile scene and script with      
      ░   built-in tween-based scaling and target tracking logic.              
      ░ ■ Integrated the new projectile into the `ObjectPool`, `Identifiers`,  
      ░   and `AssetPaths` singletons for project-wide consistency.   



   ARCHITECTURAL REFINEMENT & GAMEPLAY FIXES                                   
   Completed a deep refactor of the entity state machine and attack systems    
   to use the Command Pattern, fully decoupling logic from implementation.     
   This also resolved a series of critical, long-standing gameplay bugs.     
   ────────────────────────────────────────────────────────────────────────    
   █  Architectural Changes                                                    
      ░ ■ Refactored the `AttackLogic` system to use the Command Pattern.      
      ░   Attack logic resources now return a `Callable` command instead of    
      ░   executing actions directly, making the system more modular and reusable.
      ░ ■ Refactored the Player's state machine to emit an `action_requested`  
      ░   signal with a `Callable` payload, decoupling states from the Player's
      ░   internal component structure.                                        
      ░ ■ Centralized all remaining "magic numbers" (e.g., lunge speed,       
      ░   projectile stats, melee range) from scripts into `CombatConfig.tres`,
      ░   making the project fully data-driven.                                



   GAMEPLAY MECHANICS & BUG FIXES                                              
   Restored and hardened several core player mechanics that had regressed      
   during previous architectural refactors.                                    
   ────────────────────────────────────────────────────────────────────────    
   █  Fixed                                                                    
      ░ ■ Restored the pogo attack, which was non-functional due to a race     
      ░   condition in the attack state. Logic was separated into a dedicated  
      ░   `StatePogo` for clarity and reliability.                             
      ░ ■ Fixed a bug where the pogo attack did not generate visual effects by 
      ░   ensuring the `DamageInfo` object contained the necessary impact data.
      ░ ■ Restored the healing mechanic, which was broken by an incorrect      
      ░   input check (`is_action_just_pressed` vs. `is_action_pressed`).      
      ░ ■ Fixed a bug where the HUD did not update after healing by ensuring   
      ░   all changes to healing charges are routed through the                
      ░   `PlayerResourceComponent` to guarantee the proper event is emitted.  
      ░ ■ Restored the ability to drop through one-way platforms by            
      ░   centralizing and correctly ordering input action logic in the        
      ░   `PlayerAbilityComponent`.                                            
   █  Code Quality                                                             
      ░ ■ Resolved a critical circular dependency between `Player`,            
      ░   `BaseEntity`, and `PlayerResourceComponent` that was causing a parse 
      ░   error on startup.
║                                                                              ║
║                                                                              ║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██   [0.12.0] - UNIFIED ENTITY ARCHITECTURE & ROBUSTNESS - 08/20/2025   ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║                                                                              ║
║  ENTITY ARCHITECTURE UNIFICATION                                             ║
║  Completed a major refactor to unify all entities under the `BaseEntity` and ║
║  `EntityArchetype` pattern, eliminating the "dual architecture" and          ║
║  enforcing a single, consistent method for building entities.                ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Refactored `BaseBoss` and `Turret` to extend `BaseEntity`.           ║
║     ░ ■ Created `boss_archetype.tres` and `turret_archetype.tres` to define  ║
║     ░   their component compositions as data, not scene structure.           ║
║     ░ ■ Simplified the `base_boss.tscn` and `turret.tscn` scenes to be minimal║
║     ░   nodes that reference their respective archetypes.                    ║
║                                                                              ║
║  DATA-DRIVEN & POLA REFINEMENTS                                              ║
║  Enhanced adherence to data-driven design and the Principle of Least         ║
║  Astonishment (POLA) by centralizing configuration and clarifying APIs.      ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Refactored all entities (`Player`, `BaseBoss`, `Turret`) to expose   ║
║     ░   their state script dependencies as `@export` variables, fully        ║
║     ░   decoupling them from hardcoded `load()` paths.                       ║
║     ░ ■ Centralized all remaining entity configuration (`turret_fire_rate`,  ║
║     ░   `player_attack_shape`s) into the `CombatConfig.tres` resource.       ║
║     ░ ■ Cleaned up entity APIs by making internal helper methods (`_die`,     ║
║     ░   `_fire_at_player`) private to prevent misuse and clarify the public- ║
║     ░   facing contract of each entity.                                      ║
║  █  Code Quality                                                             ║
║     ░ ■ Systematically organized and commented all key configuration files   ║
║     ░   (`.tres`, `.tscn`, `project.godot`) for improved readability and     ║
║     ░   maintainability.                                                     ║
║  █  Fixed                                                                    ║
║     ░ ■ Resolved a critical bug in the `turret.gd` `teardown()` method, which║
║     ░   was failing to disconnect signals, preventing a future memory leak.  ║
║     ░ ■ Corrected a syntax error in the `.tres` file format that was causing ║
║     ░   a parse failure on startup.                                          ║
║                                                                              ║
║  ARCHITECTURAL REFINEMENT & CODE QUALITY                                     ║
║  Completed a targeted refactor to improve architectural clarity and adhere    ║
║  more closely to the Principle of Least Astonishment.                        ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Eliminated the `CombatDB` singleton. All scripts now load the        ║
║     ░   `CombatConfig.tres` resource directly, removing an unnecessary layer ║
║     ░   of abstraction and making dependencies more transparent.             ║
║     ░ ■ Renamed the `Interfaces.gd` autoload to `GlobalPreloader.gd` to      ║
║     ░   accurately reflect its true purpose of resolving critical script     ║
║     ░   parse-order dependencies, not just defining interfaces.              ║
║  █  Fixed                                                                    ║
║     ░ ■ Resolved a `class_name` conflict with the preloader autoload that was║
║     ░   causing a parse error on startup.                                    ║
║                                                                              ║
║  VISUAL EFFECTS & ROBUSTNESS                                                 ║
║  Implemented a robust, code-driven hit-flash shader effect and resolved      ║
║  critical resource loading errors. The new system is immune to editor cache  ║
║  issues and provides reliable visual feedback for combat.                    ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Fixed                                                                    ║
║     ░ ■ Corrected the hit-flash shader to use the `COLOR` varying instead of ║
║     ░   `texture(TEXTURE, UV)`, enabling it to work correctly on `ColorRect` ║
║     ░   nodes.                                                               ║
║     ░ ■ Refactored the `FXComponent` to be self-sufficient, creating and     ║
║     ░   managing its own shader materials and tweens, which bypasses fragile ║
║     ░   resource chains.                                                     ║
║  █  Removed                                                                  ║
║     ░ ■ Deleted obsolete shader, material, and effect resource files related ║
║     ░   to the old hit-flash system.                                         ║
║     ░ ■ Removed the now-unused `EntityShaderBinding` system.                 ║
║                                                                              ║
║  ARCHITECTURAL PREPARATION FOR FX & SHADER OVERHAUL                          ║
║  Laid the complete file and folder foundation for a multi-phase refactor of  ║
║  the visual effects and shader pipelines. This work prepares the project for ║
║  a new data-driven, mobile-first rendering architecture.                     ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Added                                                                    ║
║     ░ ■ Created a new, organized `shaders/` directory with subfolders for    ║
║     ░   entity, fullscreen, UI, and reusable include files (`.gdshaderinc`). ║
║     ░ ■ Added a corresponding `materials/` directory for all `ShaderMaterial`║
║     ░   resources.                                                           ║
║     ░ ■ Established new file scaffolds for data-driven `ShaderEffect`        ║
║     ░   resources (`dissolve_effect.tres`, `shockwave_effect.tres`).         ║
║     ░ ■ Created placeholder scripts for new `FXManager` binding layers that  ║
║     ░   will manage applying effects to their targets.                       ║
║     ░ ■ Added a scene and script for a new `fx_playground` developer tool to ║
║     ░   enable rapid iteration and testing of visual effects.                ║
║     ░ ■ Added a placeholder script for a CI-driven shader linter to enforce  ║
║     ░   code quality and mobile best practices.                              ║
║                                                                              ║
║  ENTITY ARCHITECTURE OVERHAUL (ENTITY ARCHETYPE PATTERN)                     ║
║  Completed a full-scale refactor of the entity system to a data-driven,      ║
║  archetype-based architecture. This foundational change enhances modularity, ║
║  improves adherence to SOLID principles, and establishes a robust, future-   ║
║  proof pipeline for managing complex entities and their visual effects.      ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Implemented the Entity Archetype pattern. Entities are now built     ║
║     ░   at runtime based on a new `EntityArchetype.tres` resource, which     ║
║     ░   defines an entity's composition by listing its component scenes.     ║
║     ░ ■ Created a new generic `BaseEntity.gd` class that reads an archetype, ║
║     ░   instantiates all components, and caches typed references, serving as ║
║     ░   a Composition Root and Facade for all entities.                      ║
║     ░ ■ Implemented a robust Three-Phase Initialization pattern (Construct,  ║
║     ░   Inject, Setup) to resolve complex dependency ordering issues between ║
║     ░   entities and their components, particularly for `@onready` variables.║
║     ░ ■ Created a new `FXComponent` to be the sole manager of all entity-    ║
║     ░   specific visual effects, fully decoupling visual feedback from game  ║
║     ░   logic components like `HealthComponent`.                             ║
║  █  Refactored                                                               ║
║     ░ ■ Migrated the `Player` and its components to the new archetype system.║
║     ░   The `player.tscn` scene has been drastically simplified, with its    ║
║     ░   structure now defined in `player_archetype.tres`.                    ║
║     ░ ■ All individual component `.gd` scripts have been converted to reusable║
║     ░   `.tscn` files to support the new archetype system.                   ║
║  █  Fixed                                                                    ║
║     ░ ■ Resolved a persistent, silent failure with shader effects. The complex║
║     ░   `Tween`-based animation was replaced with a simpler, more reliable   ║
║     ░   `Timer`-based approach within the `FXComponent`, resulting in a      ║
║     ░   functional hit-flash effect.                                         ║
║     ░ ■ Eliminated all parse-order errors related to `BaseEntity` by correctly║
║     ░   registering it as a `class_name` and preloading it.                  ║
║     ░ ■ Fixed a resource UID conflict in `player.tscn` that was preventing the║
║     ░   scene from loading correctly.                                        ║
║                                                                              ║
║  MEMORY MANAGEMENT & CRITICAL BUG FIXES                                      ║
║  Resolved a critical crash-on-death and a major memory leak on scene exit    ║
║  by hardening entity lifecycle management and teardown patterns.             ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Refactored the `BaseState` class to extend `Object` instead of       ║
║     ░   `RefCounted` to enforce explicit memory management.                  ║
║     ░ ■ Upgraded `BaseStateMachine` to manually free its state objects during║
║     ░   `teardown()`, breaking a critical cyclic reference that was causing  ║
║     ░   the memory leak.                                                     ║
║  █  Fixed                                                                    ║
║     ░ ■ Resolved a null reference crash in `PlayerPhysicsComponent` that     ║
║     ░   occurred when the player was freed mid-physics-frame after dying.    ║
║     ░ ■ Eliminated all `ObjectDB instances leaked at exit` warnings and their║
║     ░   associated RID leaks by fixing the state machine's memory management.║
║  █  Removed                                                                  ║
║     ░ ■ Deleted the unused `vfx_manager.gd` to eliminate ambiguity with the  ║
║     ░   primary `FXManager` singleton.                                       ║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██      [0.11.0] - VISUAL EFFECTS & MEMORY MANAGEMENT - 08/18/2025      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║                                                                              ║
║  VFX & OBJECT POOLING FOUNDATION                                             ║
║  Established a scalable, data-driven system for spawning visual effects      ║
║  and hardened the ObjectPool to be architecturally sound and free of         ║
║  race conditions.                                                            ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Implemented a "VFX Cookbook" pattern by creating a `VFXEffect`       ║
║     ░   Resource. This allows designers to define particle effects as data assets.║
║     ░ ■ Upgraded `FXManager` with a `play_vfx()` method to serve as the      ║
║     ░   single, decoupled API for triggering all visual effects.             ║
║     ░ ■ Refactored the `ObjectPool` to use a canonical, robust pattern that  ║
║     ░   eliminates all parenting-related errors and physics race conditions. ║
║  █  Added                                                                    ║
║     ░ ■ Created a new reusable, pooled `hit_spark.tscn` particle effect.     ║
║     ░ ■ The `DamageInfo` resource was expanded to include `impact_position`  ║
║     ░   and `impact_normal` to provide VFX with necessary spawn data.        ║
║  █  Fixed                                                                    ║
║     ░ ■ Resolved a critical crash caused by incorrect state change calls in  ║
║     ░   the `PlayerPhysicsComponent` during contact damage checks.           ║
║     ░ ■ Eliminated a visual bug where pooled projectiles would not disappear ║
║     ░   after being returned to the pool by adding `visible = false` to      ║
║     ░   their `deactivate()` methods.                                        ║
║                                                                              ║
║  MEMORY MANAGEMENT & ARCHITECTURAL REFINEMENT                                ║
║  Resolved critical memory leaks on scene transitions by implementing a formal║
║  scene teardown contract and refining the engine's script loading order.     ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Introduced a new `ISceneController` interface with a `scene_exiting()`║
║     ░   method to ensure robust, explicit cleanup before scene changes.      ║
║     ░ ■ Upgraded `SceneManager` to call `scene_exiting()` on the active scene,║
║     ░   allowing nodes like Player and Boss to properly run their `teardown()` logic.║
║     ░ ■ Created a central `Interfaces.gd` autoload to manage the preloading of║
║     ░   all interface scripts, resolving all `class_name` parse order errors.║
║  █  Fixed                                                                    ║    
║     ░ ■ Resolved all `ObjectDB instances leaked at exit` warnings and all    ║
║     ░   associated RID allocation leaks by breaking dangling references held ║
║     ░   by global singletons.                                                ║
║     ░ ■ Fixed all `SHADOWED_GLOBAL_IDENTIFIER` warnings related to the new   ║
║     ░   interface autoload script for a completely clean build.              ║
║                                                                              ║
║  GAME FEEL & IMPACT FEEDBACK (JUICE)                                         ║
║  Implemented a suite of data-driven feedback systems, including screen shake ║
║  and hit-stop, to add significant weight and satisfaction to core combat actions.║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Created a new `CameraShaker` component that uses Perlin noise to     ║
║     ░   procedurally generate smooth, non-repeating camera shake effects.    ║
║     ░ ■ Implemented a `ScreenShakeEffect` Resource to define shake properties║
║     ░   (amplitude, frequency, duration) as reusable, designer-tunable assets.║
║     ░ ■ Upgraded `FXManager` to be the central API for all screen effects.   ║
║     ░ ■ Expanded `CombatConfig.tres` with four new tunable properties to     ║
║     ░   control the duration of hit-stop for specific gameplay events.       ║
║  █  Added                                                                    ║
║     ░ ■ Integrated screen shake effects for key gameplay events: boss intro, ║
║     ░   player damage, phase transitions, and boss death.                    ║
║     ░ ■ Implemented a hierarchical hit-stop system to punctuate pivotal moments:║
║     ░   - A micro-pause rewards the player for landing high-risk, close-range attacks.║
║     ░   - A brief pause occurs when the player takes damage, emphasizing impact.║
║     ░   - A significant pause marks boss phase transitions.                  ║
║     ░   - A dramatic pause emphasizes the final, killing blow on a boss.     ║
║  █  Changed                                                                  ║
║     ░ ■ Refactored the location of `combat_config.tres` to align with project║
║     ░   structure standards.                                                 ║
║  █  Fixed                                                                    ║
║     ░ ■ Corrected the camera shake implementation to use the `Camera2D.offset`║
║     ░   property, ensuring the shake works correctly with the camera system. ║
║                                                                              ║
║  SCREEN SHAKE & GAME FEEL FOUNDATION                                         ║
║  Implemented a robust, data-driven screen shake system to serve as the       ║
║  foundation for the "Juice & Feedback" initiative, adding significant        ║
║  impact to key gameplay moments.                                             ║
║  ────────────────────────────────────────────────────────────────────────    ║
║  █  Architectural Changes                                                    ║
║     ░ ■ Created a new `CameraShaker` component that uses Perlin noise to     ║
║     ░   procedurally generate smooth, non-repeating camera shake effects.    ║
║     ░ ■ Implemented a new `ScreenShakeEffect` Resource type, allowing for    ║
║     ░   the creation of reusable, designer-tunable shake assets that define  ║
║     ░   amplitude, frequency, and duration.                                  ║
║     ░ ■ Upgraded `FXManager` to be the central API for requesting all screen ║
║     ░   effects, decoupling gameplay logic from the camera implementation.   ║
║  █  Added                                                                    ║
║     ░ ■ Integrated screen shake effects for several key gameplay events:     ║
║     ░   - A high-impact shake on boss intro.                                 ║
║     ░   - A jarring shake when the player takes damage.                      ║
║     ░   - A substantial shake for boss phase transitions.                    ║
║     ░   - A climactic shake when the boss is defeated.                       ║
║  █  Fixed                                                                    ║
║     ░ ■ Corrected the camera shake implementation to use the `Camera2D.offset`║
║     ░   property, ensuring the shake works correctly with the existing       ║
║     ░   camera and level rendering architecture.║                            ║
║                                                                              ║
║                                                                              ║
║   DATA-DRIVEN ATTACK SYSTEM & DEBUGGER OVERHAUL                              ║
║   Completed a full-scale refactor of the boss combat system to be data-driven║
║   and extensible, and upgraded the debug overlay into a powerful, multi-     ║
║   target entity inspector.                                                   ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Refactored the entire boss attack system to use the Strategy Pattern.║
║      ░   Attack execution is now encapsulated in modular `AttackLogic`       ║
║      ░   resources, fully decoupling states from specific attack types.      ║
║      ░ ■ `StateBossAttack` is now a generic executor that reads attack data  ║
║      ░   from `AttackPattern` resources, enabling designers to create new    ║
║      ░   attacks without modifying state machine code.                       ║
║      ░ ■ Refactored the invincibility system into a centralized, token-based ║
║      ░   model within `HealthComponent`, making it reusable for any entity.  ║
║      ░ ■ Standardized all entities (`Player`, `BaseBoss`, `Turret`) to use a ║
║      ░   public `entity_data` property for architectural consistency.        ║
║   █  Added                                                                   ║
║      ░ ■ Created a skeleton for a new, complex attack (`HomingOmniBurstLogic`)║
║      ░   to serve as a template and proof-of-concept for the new system.     ║
║      ░ ■ Upgraded the `DebugOverlay` into a multi-target "Entity Inspector"  ║
║      ░   that can cycle through all player and enemy nodes in the scene.     ║
║      ░ ■ Added new input actions (`debug_toggle_overlay`, `debug_cycle_target`)║
║      ░   mapped to `Y` and `U` for controlling the new inspector.            ║
║   █  Removed                                                                 ║
║      ░ ■ The `ArmorComponent` is now obsolete and has been removed, its      ║
║      ░   functionality absorbed by the new token-based invincibility system. ║
║      ░ ■ Legacy invincibility flags (`is_invincible`, `is_dash_invincible`)  ║
║      ░   have been removed from all entity data resources.                   ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a critical bug where the boss lunge attack would fail due  ║
║      ░   to an incomplete resource refactor. The lunge and its correct       ║
║      ░   directional telegraph are now fully functional.                     ║
║      ░ ■ Fixed a "stale reference" crash in the debug overlay that occurred  ║
║      ░   when cycling targets after an entity had been destroyed.            ║
║      ░ ■ Ensured all spawned minions (`Turret`) are given unique, sequential ║
║      ░   names (e.g., `Turret_1`, `Turret_2`) for easier debugging.          ║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██         [0.10.0] - CI & DEPLOYMENT AUTOMATION - 08/18/2025           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Established a comprehensive, automated testing pipeline using the Godot    ║
║   Unit Test (GUT) framework to harden core systems and safeguard against     ║
║   future regressions, officially completing the "Fortification" phase.       ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  CI & Tooling                                                            ║
║      ░ ■ Created a full suite of unit tests for critical, non-visual systems,║
║      ░   including `HealthComponent`, `CombatComponent`, `ObjectPool`,       ║
║      ░   `PlayerResourceComponent`, `InputComponent`, and `CombatUtils`.     ║
║      ░ ■ Implemented a high-fidelity integration test (`test_integration_combat_loop`)║
║      ░   that validates the entire end-to-end combat sequence, from player   ║
║      ░   input to boss damage and event emission.                            ║
║      ░ ■ Created a data-driven unit test for the `LevelParser`, verifying    ║
║      ░   the correct parsing of `.tres` layout files into build data.        ║
║   █  Fixed                                                                   ║
║      ░ ■ Used the new test suite to identify and resolve multiple cyclic     ║
║      ░   reference bugs in entity and component `teardown` methods,          ║
║      ░   significantly improving memory management.                          ║
║      ░ ■ Corrected a subtle but critical bug in the integration test's input ║
║      ░   simulation, which was simulating a "hold" instead of a "press,"     ║
║      ░   validating the test's sensitivity to timing issues.                 ║
║   █  Known Issues                                                            ║
║      ░ ■ The test suite continues to correctly identify the deferred memory  ║
║      ░   leak (`BUG-MEM001`) related to the Player scene's lifecycle.        ║
║                                                                              ║
║   AUTOMATED TESTING & CORE SYSTEM HARDENING                                  ║
║   Integrated the Godot Unit Test (GUT) framework to establish an automated   ║
║   testing pipeline and used it to identify and resolve critical system bugs. ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  CI & Tooling                                                            ║
║      ░ ■ Integrated the Godot Unit Test (GUT) framework, establishing the    ║
║      ░   foundation for headless, command-line-driven testing.               ║
║      ░ ■ Created comprehensive unit test suites for critical components:     ║
║      ░   - `ObjectPool`: Verifies instance lifecycle, reuse, and reset logic.║
║      ░   - `HealthComponent`: Verifies damage, invincibility, and death logic║
║      ░   - `PlayerResourceComponent`: Verifies determination/healing economy.║
║      ░   - `CombatComponent`: Verifies projectile and pogo attack logic.     ║
║   █  Fixed                                                                   ║
║      ░ ■ Used unit tests to discover and fix a critical logic bug in         ║
║      ░   `ObjectPool` that prevented the correct reuse of returned instances.║
║      ░ ■ Resolved physics callback errors by restoring the deferred          ║
║      ░   deactivation of pooled objects and hardening the tests to handle    ║
║      ░   asynchronicity.                                                     ║
║      ░ ■ Fixed a flaw in `CombatUtils`'s dependency on node names by making  ║
║      ░   the corresponding test more explicit, hardening the test itself.    ║
║   █  Known Issues                                                            ║
║      ░ ■ A memory leak related to the `Player.tscn` lifecycle has been       ║
║      ░   identified and is now tracked as `BUG-MEM001`. This has been        ║
║      ░   strategically deferred to allow for the completion of the wider     ║
║      ░   test suite.                                                         ║
║                                                                              ║
║   AUTOMATED BUILD & RELEASE WORKFLOW                                         ║
║   Implemented a comprehensive GitHub Actions workflow to automate the entire ║
║   build, test, and release cycle for both development and public releases.   ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  CI & Tooling                                                            ║
║      ░ ■ Implemented a new GitHub Actions workflow (`main.yml`) that         ║
║      ░   automatically builds and packages the game for all target platforms ║
║      ░ ■ The pipeline automates two key cycles:                              ║
║      ░   - On push to `main`: Compiles builds and saves them as downloadable ║
║      ░     `Artifacts` for internal testing.                                 ║
║      ░   - On version tag (`v*`): Performs all builds and creates a new,     ║
║      ░     public GitHub Release with the final game packages attached.      ║
║                                                                              ║
║   CROSS-PLATFORM EXPORT & DEPENDENCY MANAGEMENT                              ║
║   Configured the pipeline for full cross-platform compatibility and solved   ║
║   critical dependencies to make the CI environment fully self-contained.     ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  CI & Tooling                                                            ║
║      ░ ■ Configured four parallel build jobs to compile and export for       ║
║      ░   Windows, macOS, Linux, and Web, ensuring continuous compatibility.  ║
║      ░ ■ Solved a critical build dependency by automating the download and   ║
║      ░   installation of Godot's export templates within the CI environment. ║
║                                                                              ║
║   ASSET PACKAGING & PUBLISHING                                               ║
║   Implemented a robust post-build strategy for packaging and publishing      ║
║   release assets, resolving several critical deployment errors.              ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  CI & Tooling                                                            ║
║      ░ ■ Standardized release assets by packaging all builds into clean,     ║
║      ░   platform-specific `.zip` archives with consistent filenames.        ║
║      ░ ■ Fixed GitHub Release publishing by resolving asset filename         ║
║      ░   collisions and correcting workflow permissions (`403 Forbidden`     ║
║      ░   error).                                                             ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██         [0.9.0] - CODEBASE STANDARDIZATION - 08/15/2025              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║      This version completes a full-scale refactor of the entire codebase to  ║
║      enhance modularity and establish a strict, project-wide code style for  ║
║      readability, consistency, and in-editor documentation.                  ║
║                                                                              ║
║   PLAYER COMPONENT REFACTOR                                                  ║
║   Deconstructed the monolithic Player script into a collection of single-    ║
║   responsibility components, transforming the Player into a pure orchestrator.║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Refactored `player.gd` by abstracting its core duties into three new,║
║      ░   single-purpose components:                                          ║
║      ░   - `PlayerPhysicsComponent`: Handles `move_and_slide` and contact damage.║
║      ░   - `PlayerAbilityComponent`: Manages activation logic for actions.   ║
║      ░   - `PlayerResourceComponent`: Manages determination and healing charges.║
║      ░ ■ The main `_physics_process` loop has been removed from `player.gd`. ║
║      ░ ■ Formalized the `IComponent` and `IDamageable` interface contracts   ║
║      ░   and applied them consistently across all relevant components.       ║
║                                                                              ║
║   PROJECT-WIDE CODE QUALITY & STYLE STANDARDIZATION                          ║
║   Established and applied a formal cosmetic and documentation standard to    ║
║   every script file, enforcing type safety and in-editor documentation.      ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Code Quality & Tooling                                                  ║
║      ░ ■ Established a formal, project-wide script structure standard (header,║
║      ░   docstring, signals, enums, exports, methods, etc.).                 ║
║      ░ ■ Implemented Godot-style docstrings (`##`) for all classes and methods,║
║      ░   providing in-editor tooltips and integrated help.                   ║
║      ░ ■ Enforced full type hinting for all function arguments and return    ║
║      ░   values across the entire codebase to improve static safety.         ║
║                                                                              ║
║   DATA-DRIVEN ENCOUNTER REFACTOR                                             ║
║   Completed the migration of level and encounter definitions from scripts to ║
║   data-driven, designer-friendly Resource files.                             ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Moved all arena data from hardcoded `.gd` scripts into new          ║
║      ░   `EncounterData.tres` and `LevelLayout.tres` custom resources.       ║
║      ░ ■ Updated `ArenaBuilder` and `LevelParser` to be fully data-driven by ║
║      ░   loading and parsing these new `.tres` files at runtime.             ║
║   █  Removed                                                                 ║
║      ░ ■ Deleted all obsolete encounter and layout `.gd` scripts.            ║
║                                                                              ║
║   SYSTEM ABSTRACTION & DEV TOOLING                                           ║
║   Decoupled core systems, improved designer workflows, and added a robust    ║
║   real-time debugging tool.                                                  ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Abstracted the input system to use a command buffer, fully          ║
║      ░   decoupling game logic from the global `Input` singleton.            ║
║      ░ ■ Established a new `FXManager` singleton to serve as a dedicated     ║
║      ░   subsystem for "game feel" effects like hit-stop and screen shake.   ║
║   █  Added                                                                   ║
║      ░ ■ Implemented a toggleable Developer Debug Overlay (F1) that displays ║
║      ░   the player's real-time state, velocity, and input buffer.           ║
║   █  Editor & Tooling                                                        ║
║      ░ ■ Added a configuration warning system to the `LevelLayout` resource  ║
║      ░   that notifies designers in-editor if a layout is invalid.           ║
║                                                                              ║
║   STABILIZATION & CLEAN BUILD                                                ║
║   Resolved all remaining parse errors and static analysis warnings for a     ║
║   completely clean build, including fundamental architectural conflicts.     ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a fundamental conflict by removing `class_name` from all   ║
║      ░   autoload singletons, fixing a cascade of parse errors.              ║
║      ░ ■ Resolved all `MISSING_TOOL`, `STATIC_CALLED_ON_INSTANCE`, and other ║
║      ░   static analysis warnings for a completely clean build.              ║
║      ░ ■ Enhanced the shader pre-warming system to include entity actions,   ║
║      ░   significantly reducing first-action stutter at the start of a match.║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██           [0.8.0] - UI & ARCHITECTURE OVERHAUL - 08/14/2025          ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║      This version completes two major initiatives: a full-scale refactor of  ║
║      the entire UI system to a modern, scene-based architecture, and a deep  ║
║      enforcement of the project's core architectural patterns to enhance     ║
║      modularity and type safety.                                             ║
║                                                                              ║
║   UI SYSTEM OVERHAUL                                                         ║
║   Migrated the entire legacy UI from a procedural system to a new, scene-based║
║   architecture built on reusable, editor-friendly components.                ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Completed a full UI refactor, moving all menus to self-contained    ║
║      ░   scenes in `src/scenes/menus` that use `Container` nodes for robust layout.║
║      ░ ■ Deprecated and removed the `GlobalHud` autoload, replacing its      ║
║      ░   functionality with a reusable `MuteButton` component.               ║
║   █  Added                                                                   ║
║      ░ ■ Created new reusable, procedurally-drawn UI components, including   ║
║      ░   `StyledMenuItem` and `LogoDisplay`.                                 ║
║      ░ ■ Rebuilt all menu screens (Title, Options, Sound, etc.) as scenes    ║
║      ░   with `@tool` scripts for full in-editor visibility and editing.     ║
║   █  Removed                                                                 ║
║      ░ ■ Deleted the entire legacy `src/ui/screens` directory and all of its ║
║      ░   obsolete, procedurally-generated menu files and assets.             ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a critical state bug in `MenuManager` that caused          ║
║      ░   unpredictable keyboard navigation after mouse use.                  ║
║      ░ ■ Resolved persistent `invalid UID` warnings by re-saving all scenes. ║
║                                                                              ║
║   ARCHITECTURAL PATTERN ENFORCEMENT                                          ║
║   Enforced core architectural patterns across all entities to fully decouple ║
║   state logic from global singletons and formalize data contracts.           ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Enforced the "Owner-Driven Injection" pattern for both Player and   ║
║      ░   Boss state machines, fully decoupling all states from `CombatDB`.   ║
║      ░ ■ Formalized the damage system with typed `DamageInfo` and `DamageResult`║
║      ░   resources, replacing untyped Dictionaries for type-safe combat.     ║
║      ░ ■ Standardized all entity components to formally implement the `IComponent`║
║      ░   contract, unifying their lifecycle and setup methods.               ║
║      ░ ■ Created the `Identifiers` singleton to hold all string-based group  ║
║      ░   names and pool keys, eliminating the risk of runtime errors from typos.║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a "zombie minion" bug where Turrets would continue to fire ║
║      ░   after the boss was defeated.                                        ║
║      ░ ■ Fixed a visual bug where the entity hit-flash color would not reset ║
║      ░   correctly by using a more robust metadata-based system.             ║
║      ░ ■ Eliminated all `STATIC_CALLED_ON_INSTANCE` warnings project-wide.   ║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██           [0.7.0] - DATA-DRIVEN ARCHITECTURE - 08/13/2025            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║      This version completes the transformation to a fully data-driven        ║
║      architecture, implements robust memory management patterns, and         ║
║      enhances the combat system with distance-based mechanics and            ║
║      comprehensive scene validation tools.                                   ║
║                                                                              ║
║   DATA-DRIVEN ARCHITECTURE COMPLETION                                        ║
║   Unified the project's configuration system to be exclusively driven by     ║
║   editor-friendly Resource files, fully decoupling game design from code.    ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Unified the configuration system to be exclusively driven by the    ║
║      ░   `CombatDB` singleton and its `CombatConfig.tres` resource.          ║
║      ░ ■ Refactore`BaseBoss` to be fully data-driven, with attack patterns for║
║      ░   each phase assigned via exported arrays in the Godot Inspector.     ║
║      ░ ■ Converted all gameplay tuning data into editor-friendly Resources   ║
║      ░   with `@export_group` and `@export_range` hints for designers.       ║
║                                                                              ║
║   ENHANCED COMBAT MECHANICS                                                  ║
║   Implemented a more nuanced melee system that rewards player positioning    ║
║   and improves hitbox accuracy for different attack angles.                  ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Added                                                                   ║
║      ░ ■ Implemented a two-tier melee hitbox system with distance-based      ║
║      ░   damage calculation, rewarding close-range attacks with higher damage.║
║      ░ ■ The melee hitbox now dynamically changes shape and position for     ║
║      ░   upward attacks, ensuring precise coverage above the player.         ║
║                                                                              ║
║   SYSTEM HARDENING & MEMORY MANAGEMENT                                       ║
║   Improved memory safety and stability by implementing formal teardown       ║
║   patterns and hardening core systems against race conditions.               ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Unified the state machine architecture with formal `teardown` patterns║
║      ░   to prevent memory leaks and cyclic references.                      ║
║      ░ ■ Hardened the `Sequencer` by adding `cancel_all()` to prevent sequences║
║      ░   from running across scene transitions.                              ║
║      ░ ■ Hardened the `ObjectPool` by deferring the deactivation of returned ║
║      ░   instances, preventing same-frame access race conditions.            ║
║                                                                              ║
║   CRITICAL BUG FIXES & STABILIZATION                                         ║
║   Resolved several high-priority bugs related to combat reliability, scene   ║
║   loading, and asset database corruption.                                    ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Fixed                                                                   ║
║      ░ ■ Hardened the player's pogo attack physics query to be more reliable ║
║      ░   against complex colliders.                                          ║
║      ░ ■ Resolved a critical race condition where the `ArenaBuilder` could   ║
║      ░   finish before the boss was spawned by correctly awaiting a `SequenceHandle`.║
║      ░ ■ Corrected resource loading errors and asset database corruption     ║
║      ░   caused by duplicated UIDs in scene and resource files.              ║
║      ░ ■ Resolved a "modulo by zero" crash in the boss's idle state by       ║
║      ░   adding guard clauses for when no attack patterns are assigned.      ║
║      ░ ■ Resolved a visual regression with the Game HUD's phase indicators.  ║
║                                                                              ║
║   EDITOR TOOLING & DOCUMENTATION                                             ║
║   Improved the development workflow with in-editor validation and formalized ║
║   the project's dependency injection pattern in documentation.               ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Created a central, static `SceneValidator` utility to provide       ║
║      ░   in-editor warnings for misconfigured scenes like `BaseBoss`.        ║
║   █  Documentation                                                           ║
║      ░ ■ Formalized the "Owner-Driven Injection" pattern in `ARCHITECTURE.txt`.║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            [0.6.0] - DYNAMIC ENCOUNTERS - 08/11/2025                 ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║      This version introduces dynamic multi-phase boss encounters, minion     ║
║      support, widescreen compatibility, and comprehensive visual and         ║
║      performance improvements to create engaging, scalable combat scenarios. ║
║                                                                              ║
║   MULTI-PHASE BOSS ENCOUNTERS & MINION SUPPORT                               ║
║   Implemented a dynamic, data-driven combat system allowing for multi-phase  ║
║   boss fights, new minion types, and reusable attack components.             ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Added                                                                   ║
║      ░ ■ Implemented a dynamic, three-phase boss fight where bosses become   ║
║      ░   more aggressive by using different `AttackPattern` resources as     ║
║      ░   health decreases.                                                   ║
║      ░ ■ Introduced an `ArmorComponent` to support invulnerable attack states║
║      ░   such as a new high-speed "armored lunge" attack.                    ║
║      ░ ■ Implemented a "Turret" minion enemy system, proving the reusability ║
║      ░   of the unified component and state machine architecture.            ║
║      ░ ■ Added real-time phase indicator icons to the Game HUD.              ║
║   █  Changed                                                                 ║
║      ░ ■ The `HealthComponent` was upgraded to detect health threshold       ║
║      ░   crossings, emitting signals to drive the new phase transitions.     ║
║      ░ ■ The encounter system now supports spawning lists of minions from    ║
║      ░   level layout files in addition to the main boss.                    ║
║                                                                              ║
║   WIDESCREEN SUPPORT & DYNAMIC ARENA SCALABILITY                             ║
║   Overhauled the rendering and level generation systems to support modern    ║
║   widescreen aspect ratios and dynamically sized arenas.                     ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Created a `CameraManager` and `GridUtils` singleton to decouple all ║
║      ░   game logic from screen resolution, allowing the camera to fit any   ║
║      ░   arena size.                                                         ║
║      ░ ■ Enhanced `TerrainBuilder` to procedurally fill the entire camera    ║
║      ░   viewport with background tiles for seamless, scalable play areas.   ║
║   █  Changed                                                                 ║
║      ░ ■ Project display settings were updated to widescreen 16:9 (1920x1080)║
║      ░ ■ Procedural UI menus were refactored to use `Container` nodes for    ║
║      ░   robust resizing behavior across different aspect ratios.            ║
║                                                                              ║
║   CORE SYSTEMS HARDENING                                                     ║
║   Improved the stability and reliability of the `Sequencer`, `ObjectPool`,   ║
║   and `EventBus` to prevent state bugs, memory leaks, and race conditions.   ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Hardened the `Sequencer` by returning a `SequenceHandle`, allowing  ║
║      ░   cinematic sequences to be safely cancelled during scene transitions.║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a potential memory leak in the `EventBus` by implementing a║
║      ░   self-cleaning mechanism that prunes dead subscriptions.             ║
║      ░ ■ Corrected `async`/`await` errors in the `Sequencer` to ensure reliable║
║      ░   execution of cinematic events.                                      ║
║      ░ ■ Fixed a bug where projectiles persisted across scenes by adding a   ║
║      ░   global reset function to the `ObjectPool`.                          ║
║                                                                              ║
║   CRITICAL BUG FIXES & STABILIZATION                                         ║
║   Resolved a series of high-impact bugs related to combat logic, entity      ║
║   state, and object pooling to create a more stable gameplay experience.     ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a "zombie attack" bug by adding an `_is_dead` flag to      ║
║      ░   prevent the boss from firing projectiles after dying.               ║
║      ░ ■ Fixed a critical bug where turrets stopped firing by refactoring    ║
║      ░   their state machine logic to be continuous rather than one-shot.    ║
║      ░ ■ Ensured minion projectiles are correctly returned to the `ObjectPool`║
║      ░   instead of being deleted, preventing performance degradation.       ║
║      ░ ■ Fixed a race condition that could prevent the victory screen from   ║
║      ░   triggering by moving the win logic to the global `EventBus`.        ║
║      ░ ■ Replaced in-world `ColorRect` visuals with `Polygon2D` nodes to     ║
║      ░   prevent rendering conflicts with debug collision shapes.            ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██          [0.5.0] - ARCHITECTURAL UNIFICATION - 08/10/2025            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║      This version completes a foundational architectural refactor, unifying  ║
║      the player and boss state machines, introducing a robust interface-based║
║      damage system, and fully decoupling all entity components to create a   ║
║      highly scalable and maintainable codebase.                              ║
║                                                                              ║
║   ENTITY ARCHITECTURE UNIFICATION                                            ║
║   Unified the Player and Boss architectures under a single, reusable State   ║
║   Machine and Component pattern, adhering to Dependency Inversion.           ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Created a reusable, node-based `BaseStateMachine` and `BaseState` to║
║      ░   unify all entity logic, removing duplicated code.                   ║
║      ░ ■ Refactored both the Player and BaseBoss to use the new `BaseStateMachine`,║
║      ░   simplifying their core scripts into pure orchestrators.             ║
║      ░ ■ Established a formal `IComponent` interface contract (`setup`/`teardown`)║
║      ░   and decoupled all components by injecting dependencies from the owner.
║      ░ ■ Refactored the Player's state machine to load state scripts at runtime
║      ░   instead of using `preload()`, breaking a brittle dependency cycle.  ║
║                                                                              ║
║   DATA-DRIVEN SYSTEMS & API STANDARDIZATION                                  ║
║   Overhauled core systems to be data-driven and established formal, type-safe
║   APIs for damage, configuration, and scene navigation.                      ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Replaced the JSON-based `Config.gd` with a type-safe, `Resource`-based║
║      ░   system (`CombatConfig.tres`, `CombatDB.gd`), improving type safety  ║
║      ░   and enabling direct editor tuning.                                  ║
║      ░ ■ Introduced a robust `IDamageable` interface and a `CombatUtils`     ║
║      ░   singleton to standardize how all damage is applied and received.    ║
║      ░ ■ Created a new `SceneManager` autoload to centralize all scene       ║
║      ░   transition logic, removing scattered `get_tree().change_scene` calls.║
║      ░ ■ Refactored `GameManager` to use a `GameStateData` resource, eliminating║
║      ░   the "dual architecture" of stateful singletons for runtime data.    ║
║      ░ ■ Implemented self-validating property setters in data resources      ║
║      ░   (`PlayerStateData`) to prevent invalid states (e.g., health > max). ║
║                                                                              ║
║   POGO MECHANIC OVERHAUL & BUG FIX                                           ║
║   Resolved a series of critical bugs with the pogo mechanic, unifying its    ║
║   physics and decoupling it from other combat timers.                        ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved complex bugs that made the pogo mechanic unreliable. It now║
║      ░   consistently damages the boss and bounces off projectiles.          ║
║      ░ ■ Unified ground and air pogo logic into a single, physics-driven     ║
║      ░   system that correctly handles all valid bounce surfaces.            ║
║      ░ ■ Separated the pogo mechanic from the melee attack cooldown, allowing║
║      ░   for seamless transitions between bouncing and attacking.            ║
║      ░ ■ Corrected the pogo's physics query to include `Area2D` nodes,       ║
║      ░   restoring its ability to destroy projectiles.                       ║
║                                                                              ║
║   CODEBASE HARDENING & STABILIZATION                                         ║
║   Performed a full-codebase sweep to resolve all remaining parse errors,     ║
║   static analysis warnings, and critical race conditions.                    ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Changed                                                                 ║
║      ░ ■ Standardized project structure, renaming scripts to `snake_case` and║
║      ░   reorganizing `src/core` into purpose-driven subdirectories.         ║
║      ░ ■ Added validation to `AssetPaths.gd` and `Settings.gd` to prevent    ║
║      ░   runtime errors from missing files or invalid data.                  ║
║      ░ ■ Cleaned all remaining GDScript static analysis warnings for a clean build.║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a cascade of parse errors related to the new `CombatConfig`║
║      ░   resource, invalid `class_name` usage, and updated autoload paths.   ║
║      ░ ■ Fixed a critical race condition where invincibility timers for the  ║
║      ░   Player and Boss were being incorrectly assigned.                    ║
║      ░ ■ Implemented robust `teardown` methods in all components and state   ║
║      ░   machines to prevent memory leaks from cyclic references.            ║
║                                                                              ║
║   SPRINT 0 AUDIT & DOCUMENTATION                                             ║
║   Completed and formalized the "Sprint 0" architectural audit, documenting   ║
║   all key design patterns and decisions for future development.              ║
║   ────────────────────────────────────────────────────────────────────────   ║
║   █  Documentation                                                           ║
║      ░ ■ Generated audit reports for singletons, event usage, and config usage.║
║      ░ ■ Authored `ADR-001` (Service Locator) and `ADR-002` (Communication Patterns)║
║      ░   to formally document architectural decisions.                       ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            [0.4.0] - THE COMPONENT REFACTOR - 2025-08-09             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This version completes the migration to a fully component-based entity     ║
║   architecture, enhances performance, and resolves all known bugs for a      ║
║   stable, production-ready foundation.                                       ║
║                                                                              ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Refactored the monolithic `player.gd` script into a component-based ║
║      ░   architecture, adhering to the Single Responsibility Principle.      ║
║      ░ ■ Created a `HealthComponent` to manage all health, damage, and       ║
║      ░   invincibility logic, making it reusable for other entities.         ║
║      ░ ■ Created a `CombatComponent` to centralize player attack logic.      ║
║      ░ ■ Created an `InputComponent` to decouple input polling from the player.║
║      ░ ■ Created a `PlayerStateData` resource to act as a central data       ║
║      ░   container, decoupling state from the Player node itself.            ║
║      ░ ■ Refactored `ArenaBuilder` to be data-driven, reading the layout file║
║      ░   path from a constant in the encounter script, removing brittle      ║
║      ░   string manipulation logic.                                          ║
║      ░ ■ Decoupled `GlobalHUD` from specific menu scenes by making its       ║
║      ░   visibility fully event-driven (`MENU_OPENED`, `MENU_CLOSED`),       ║
║      ░   resolving an Open/Closed Principle violation.                       ║
║      ░ ■ Refactored the monolithic `base_boss.gd` script into a component-   ║
║      ░   based architecture, adhering to SRP and mirroring the Player's design.║
║      ░ ■ Created `BossStateData.gd` resource to act as a central data        ║
║      ░   container, decoupling the boss's state from the node itself.        ║
║                                                                              ║
║   █  Performance                                                             ║
║      ░ ■ Implemented a robust, generic `ObjectPool` singleton to manage      ║
║      ░   reusable nodes like projectiles.                                    ║
║      ░ ■ Refactored Player and Boss to get/return projectiles from the pool, ║
║      ░   eliminating runtime instantiation to prevent GC spikes and stutter. ║
║                                                                              ║
║   █  Changed                                                                 ║
║      ░ ■ Refactored `Sequencer.gd` to use type-safe `SequenceStep` resources ║
║      ░   instead of ad-hoc dictionaries, preventing runtime errors and       ║
║      ░   improving editor autocompletion.                                    ║
║      ░ ■ Refactored `AudioManager.gd` and `GlobalHUD` to be event-driven,    ║
║      ░   subscribing to a new `audio_settings_changed` signal instead of     ║
║      ░   polling for changes every frame.                                    ║
║                                                                              ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a complex circular dependency parse error between the Player║
║      ░   and its new components by fully decoupling them with signals.       ║
║      ░ ■ Fixed a bug where the boss was immune to rapid attacks by giving it ║
║      ░   a unique, shorter invincibility duration in the project config.     ║
║      ░ ■ Fixed a bug where player's body dealt rapid contact damage to the boss.║
║      ░ ■ Unified all damage-dealing logic (melee, pogo, projectile, contact) ║
║      ░   to consistently and correctly interact with the target's HealthComponent.║
║      ░ ■ Fixed a visual bug where the Boss's hit-flash color would not reset ║
║      ░   correctly by ensuring the correct initialization order in `base_boss.gd`.║
║      ░ ■ Resolved an audio stream memory leak on exit by implementing a      ║
║      ░   robust cleanup handler for `NOTIFICATION_WM_CLOSE_REQUEST`.         ║
║      ░ ■ Resolved all `SHADOWED_GLOBAL_IDENTIFIER` warnings by removing      ║
║      ░   unnecessary `preload` calls for scripts with a `class_name`.        ║
║      ░ ■ Resolved a critical physics crash by redesigning the `ObjectPool` to║
║      ░   use a signal-based, non-re-parenting architecture that is immune to ║
║      ░   race conditions.                                                    ║
║      ░ ■ Resolved all memory leaks by implementing proper cleanup in         ║
║      ░   `_exit_tree` for all state machines, components, and singletons.    ║
║      ░ ■ Resolved a leak caused by creating orphaned nodes in `ArenaBuilder`.║
║      ░ ■ Corrected `Config.gd` to ensure deterministic config loading.       ║
║      ░ ■ Fixed a critical crash in the `EventBus` related to polymorphism.   ║
║      ░ ■ Resolved all remaining static analysis warnings for a clean build.  ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              [0.3.0] - THE VISUAL FOUNDATION - 2025-08-08            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This version completes the core architectural refactor and establishes the ║
║   foundational visual and data-driven systems for the entire project.        ║
║                                                                              ║
║   █  Added                                                                   ║
║      ░ ■ Implemented the `Palette.gd` autoload singleton, which defines a    ║
║      ░   project-wide 32-step grayscale value scale.                         ║
║      ░ ■ Added semantic color constants (e.g., `COLOR_PLAYER`) to establish a║
║      ░   clear visual hierarchy for all game elements.                       ║
║      ░ ■ Implemented the `Config.gd` autoload for loading all `.json` files. ║
║      ░ ■ Created `combat_config.json` to house all gameplay-related tuning.  ║
║      ░ ■ Implemented the `Sequencer.gd` autoload for managing timed event.   ║
║      ░ ■ Added `GAME_PAUSED` and `GAME_RESUMED` events to the `EventCatalog`.║
║      ░ ■ Implemented a professional-grade, singleton-based Event Bus.        ║
║      ░ ■ Added an `EventCatalog` and typed `Resource`-based event payloads.  ║
║                                                                              ║
║   █  Changed                                                                 ║
║      ░ ■ Refactored Player, Boss, Projectiles, and TerrainBuilder to source  ║
║      ░   all their colors from the new `Palette` singleton.                  ║
║      ░ ■ The game world is now visually rendered with a consistent value scale.║
║      ░ ■ Refactored the entire codebase to be data-driven via `Config.gd`.   ║
║      ░ ■ The `Constants.gd` singleton has been streamlined.                  ║
║      ░ ■ The `EncounterDirector` now uses the `Sequencer` for boss intros.   ║
║      ░ ■ The main `game.gd` scene now handles the global pause state.        ║
║      ░ ■ Refactored the `GameHUD` to be fully driven by the Event Bus.       ║
║      ░ ■ Refactored the ArenaBuilder to strictly adhere to SRP.              ║
║      ░ ■ Refactored the BaseBoss and Player nodes to use the State Pattern.  ║
║                                                                              ║
║   █  Fixed                                                                   ║
║      ░ ■ Resolved a cascade of parse errors in `Palette.gd` by using the     ║
║      ░   `Color("#hex")` constructor, which is a valid constant expression.  ║
║      ░ ■ Corrected `Palette.gd` to extend `Node` so it can be autoloaded.    ║
║      ░ ■ Renamed `Config.get()` to `Config.get_value()` to resolve a conflict.║
║      ░ ■ Resolved `SHADOWED_GLOBAL_IDENTIFIER` warnings in `base_boss.gd`.   ║
║      ░ ■ Resolved `Identifier not declared` errors in `player.gd`.           ║
║      ░ ■ Resolved bug where Player hit flash timer would not reset.          ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██           [0.2.0] - THE ARCHITECTURAL REFACTOR - 08-07-2025          ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This version represents a foundational overhaul of the project's technical ║
║   architecture. The focus was on implementing professional design patterns   ║
║   (SOLID, State Pattern) and eliminating performance issues to prepare for   ║
║   future content and feature development.                                    ║
║                                                                              ║
║   █  Architectural Changes                                                   ║
║      ░ ■ Overhauled level loading to use an asynchronous, batch-based system ║
║      ░   in `ArenaBuilder`, eliminating stuttering when entering the arena.  ║
║      ░ ■ Implemented a shader pre-warming system in a new `LoadingScreen` to ║
║      ░   prevent any "first-appearance" hitches for entities.                ║
║      ░ ■ Formalized the project's guiding principles (SOLID, DRY, KISS) in   ║
║      ░   the official documentation.                                         ║
║                                                                              ║
║   █  Bug Fixes                                                               ║
║      ░ ■ Resolved a critical stutter/hitch on arena load via async generation.║
║      ░ ■ Eliminated intermittent stutter on first run via shader pre-warming.║
║      ░ ■ Resolved a physics crash on entity death by using `call_deferred`   ║
║      ░   for scene transitions.                                              ║
║      ░ ■ Corrected implementation of hazard tiles to ensure contact damage.  ║
║                                                                              ║
║   █  Documentation                                                           ║
║      ░ ■ Overhauled `TODO.txt` with a new, multi-phase development roadmap.  ║
║      ░ ■ Updated `DESIGN.txt` and `ARCHITECTURE.txt` to reflect the new      ║
║      ░   design philosophies, patterns, and planned features.                ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██        [0.1.0] - MIGRATION FROM KAPLAY TO GODOT - 08-05-2025         ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This version marks the initial architectural overhaul, transforming the    ║
║   project from a functional prototype into a robust and scalable foundation. ║
║                                                                              ║
║   █  Added                                                                   ║
║      ░ ■ Player Character with rich moveset (dash, wall-jump, etc.).         ║
║      ░ ■ Combat System with melee, charged shot, and pogo mechanics.         ║
║      ░ ■ "Determination" healing system & Data-Driven Arena system.          ║
║      ░ ■ Basic Boss entity framework & Reusable Menu System.                 ║
║      ░ ■ Full suite of initial project documentation (.txt files).           ║
║                                                                              ║
║   █  Changed                                                                 ║
║      ░ ■ Complete Architectural Refactor to use professional design patterns.║
║      ░ ■ Player Logic: Migrated from boolean flags to a formal FSM.          ║
║      ░ ■ Global Singletons: Centralized constants and asset paths.           ║
║      ░ ■ File Organization: Restructured project directories.                ║
║                                                                              ║
║   █  Fixed                                                                   ║
║      ░ ■ Restored player contact damage from enemies and hazards.            ║
║      ░ ■ Fully restored the pogo mechanic.                                   ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/BRAINSTORM.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ╚═══════╗
║    ██████╗ ██████╗  █████╗ ██╗███╗   ██╗███████╗████████╗ ██████╗ ██████╗ ███╗  ███╗ ║
║   ██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗████╗ ████║ ║
║   ██████╔╝██████╔╝███████║██║██╔██╗ ██║███████╗   ██║   ██║   ██║██████╔╝██╔████╔██║ ║
║   ██╔══██╗██╔══██╗██╔══██║██║██║╚██╗██║╚════██║   ██║   ██║   ██║██╔══██╗██║╚██╔╝██║ ║
║   ██████╔╝██║  ██║██║  ██║██║██║ ╚████║███████║   ██║   ╚██████╔╝██║  ██║██║ ╚═╝ ██║ ║
║   ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝ ║
║                                                                              ╔═══════╝
║              A free-form collection of creative ideas and experiments.       ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       BOX BATTLE BOSS CONCEPTS                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A categorized list of all potential boss ideas for the game. Each concept  ║
║   includes ideas for its theme, mechanics, and unique shader effects.        ║
║                                                                              ║
║   █  PUN-BASED CONCEPTS                                                      ║
║      ░ ■ Beat Box: Rhythm-based boss. Platforms and attacks sync to a beat.  ║
║      ░ ■ Sandbox: Deforms terrain, uses momentum-stealing attacks.           ║
║      ░ ■ Matchbox: Fire-themed, tight vertical arena, limited dash.          ║
║      ░ ■ Toolbox: Utility-themed, projectile-only combat.                    ║
║      ░ ■ Gearbox: Mechanical theme with rotating platforms and gravity shifts.║
║      ░ ■ Strongbox: Defense-themed, tries to corner player.                  ║
║      ░ ■ Icebox: Slippery physics, reduced friction.                         ║
║      ░ ■ Shoebox: Cramped arena, precise movement required.                  ║
║      ░ ■ Jukebox: Different songs change the environmental physics.          ║
║      ░ ■ Mailbox: Arena is filled with flying "letters" as platforms.        ║
║      ░ ■ Puzzle Box: Arena rearranges itself as movement puzzles are solved. ║
║      ░ ■ Shadow Box: Past movements leave shadow trails that become platforms.║
║      ░ ■ Cardboard Box: Platforms are fragile and break after use.           ║
║      ░ ■ Pandora's Box: Randomly opens to release temporary chaos effects.   ║
║      ░ ■ Rubik's Box: Arena rotates in 90-degree chunks.                     ║
║                                                                              ║
║   █  MEGA MAN-INSPIRED CONCEPTS                                              ║
║      ░ ■ Flame Box (Heat Man): Teleports in fire bursts, leaves flame trails.║
║      ░ ■ Ice Box (Ice Man): Slides with momentum, freezes platforms.         ║
║      ░ ■ Electric Box (Elec Man): Zips in straight lines at high speed.      ║
║      ░ ■ Wind Box (Air Man): Constant wind pushes player, affects jumps.     ║
║      ░ ■ Gravity Box (Gravity Man): Gravity flips, ceiling becomes floor.    ║
║      ░ ■ Time Box (Flash Man): Slow-motion bursts, delayed attacks.          ║
║      ░ ■ Plant Box (Wood Man): Platforms grow and shrink, sticky surfaces.   ║
║      ░ ■ Slash Box (Zero/Harpuia): Fast strikes cut through platforms.       ║
║      ░ ■ Phantom Box (Phantom): Stealth/clone attacks, false reflections.    ║
║                                                                              ║
║   █  LOOP-THEMED CONCEPTS                                                    ║
║      ░ ■ Infinite Box: Arena wraps around (left edge connects to right).     ║
║      ░ ■ Möbius Box: Twisted space; jumping up can make you fall down.       ║
║      ░ ■ Pendulum Box: Gravity shifts left/right in a rhythmic swing.        ║
║      ░ ■ Echo Box: Player inputs are repeated after a short delay.           ║
║      ░ ■ Ouroboros Box: The room slowly "eats" itself from the edges inward. ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                        SHADER & VFX BRAINSTORM                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of potential shader and visual effect ideas.                        ║
║                                                                              ║
║   ▒  Prism Box: Chromatic aberration effect, splits attacks into RGB channels.║
║   ▒  Void Box: Black hole distortion that pulls the player and projectiles.  ║
║   ▒  Static Box: Digital noise/glitch effects that can corrupt controls.     ║
║   ▒  Mirror Box: Kaleidoscope/reflection effects, duplicates player attacks. ║
║   ▒  Pulse Box: Rhythmic, concentric shockwave rings.                        ║
║   ▒  Phase Box: Flickers in and out of existence, unpredictable collision.   ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                   ADVANCED MOVEMENT & MECHANICS                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ▒  Parrying System: A simple parry could stun the boss or grant the player ║
║      a momentum boost, rewarding precise timing.                             ║
║                                                                              ║
║   ▒  Ledge Grab: A brief pause/slowdown when hitting the top edge of a wall  ║
║      to create a more forgiving window for wall-jumping.                     ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██           ADVANCED COMBAT & FEEDBACK CONCEPTS (from Audit)           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A collection of high-impact ideas for improving the "game feel" of combat. ║
║                                                                              ║
║   ▒  Hit-Stop / Hit-Freeze: A micro-pause (e.g., 0.05 seconds) of the entire ║
║      game simulation when a high-impact melee hit connects. This adds a      ║
║      feeling of weight and power to attacks.                                 ║
║                                                                              ║
║   ▒  Attack-Interrupting Windows: Specific boss telegraph animations could   ║
║      have a brief "vulnerable" window. Landing a hit during this window      ║
║      would interrupt the boss's attack and potentially trigger a mini-stun.  ║
║                                                                              ║
║   ▒  Cinematic Phase Transitions: When the boss's health crosses a threshold,║
║      it could enter a brief, invulnerable `PhaseChange` state, play a unique ║
║      animation or visual effect, and then resume combat with its new attack  ║
║      patterns. This makes the phase shifts feel like significant events.     ║
║                                                                              ║
║   ▒  Enhanced Stun Feedback: As the boss's stun meter fills, provide clear   ║
║      feedback to the player. This could include a subtle vignette effect, a  ║
║      pulsing glow on the boss, or a rising audio cue that indicates a stun   ║
║      is imminent.                                                            ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                 DEVELOPER TOOLS & TOOLING (from Audit)               ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Ideas for internal systems that would improve the development workflow.    ║
║                          _NOTE: This is not user-facing text._               ║
║                                                                              ║
║   ▒  Diagnostics Singleton: A dedicated global service for logging important ║
║      but non-crashing gameplay events. For example, it could record every    ║
║      time a pogo attack fails its physics check, or when a damage calculation║
║      is ignored due to invincibility. This would create a detailed log to help║
║      reproduce and debug subtle, hard-to-find edge cases.                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                UI / UX ENHANCEMENT CONCEPTS                          ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A collection of high-impact, mobile-friendly UI effects inspired by        ║
║   modern web design (Framer) and arcade games (Geometry Wars).               ║
║                                                                              ║
║   █  Animation & Motion                                                      ║
║      ░ ■ Entrance Stack: Slide, scale, and fade-in menu items with a         ║
║      ░   slight overshoot and a staggered delay for a cascading reveal.      ║
║      ░   (Technique: `create_tween()` with `TRANS_BACK`)                     ║
║      ░ ■ Micro-motion / Idle Breathing: Subtle, slow, looping scale or       ║
║      ░   rotation animations on UI panels to keep the screen feeling alive.  ║
║      ░   (Technique: `AnimationPlayer` or looping `Tween`)                   ║
║      ░ ■ Directional Hover Parallax: Make text/icon layers on a button       ║
║      ░   shift slightly in the opposite direction of the mouse cursor.       ║
║      ░   (Technique: Child `Control` nodes, `Input.get_local_mouse_position()` + `lerp`)║
║      ░ ■ Energy Bursts on Click: A small burst of particles on button press. ║
║      ░   (Technique: `GPUParticles2D` with a low-count, short-lived emission)║
║                                                                              ║
║   █  Shape & Form (Procedural Drawing)                                       ║
║      ░ ■ Animated Rounded Corners: Tween the corner radius of a procedurally ║
║      ░   drawn shape on hover for a fluid morphing effect.                   ║
║      ░   (Technique: `_draw()` with `draw_circle` + `draw_rect`, property tween)║
║      ░ ■ Inset / Layered Borders: Use multiple `draw_rect` calls with        ║
║      ░   different palette colors and slight offsets to create a 2.5D bevel. ║
║      ░ ■ Chamfered Corners: Use `draw_polygon()` to create geometric cutouts.║
║      ░ ■ Dynamic Clipping Mask: Reveal content by animating the size of a    ║
║      ░   parent `Control` node with `clip_contents` enabled.                 ║
║                                                                              ║
║   █  Interactivity & Feedback                                                ║
║      ░ ■ Click Ripple: A circular ripple animates outwards from the click point.║
║      ░   (Technique: `_input()` + tweened properties + `draw_circle()`)      ║
║      ░ ■ Keyboard/Controller Focus Ring: A distinct visual state for non-mouse║
║      ░   selection, like a subtle pulsing of the existing glow effect.       ║
║      ░   (Technique: Animate `glow_size` property when `is_selected` is true)║
║      ░ ■ Haptic Feedback: Use `OS.vibrate()` on mobile for subtle physical feedback.║
║                                                                              ║
║   █  Simple & Efficient Shaders                                              ║
║      ░ ■ Sheen / Moving Highlight: A simple shader that moves a soft gradient║
║      ░   across a surface to simulate a glassy reflection.                   ║
║      ░   (Technique: `ShaderMaterial` with a `smoothstep` ramp, driven by `TIME`)║
║      ░ ■ Noise Grain Overlay: A subtle, low-alpha tiling noise texture to add║
║      ░   surface detail without blurring. (Technique: `TextureRect` with `BLEND_MODE_ADD`)║
║      ░ ■ Vertex Displacement Parallax: A very cheap shader that slightly     ║
║      ░   offsets vertices based on mouse position for a subtle 3D effect.    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                          FUTURE GAME SYSTEMS                         ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   High-level ideas for new architectural components and features.            ║
║                                                                              ║
║   ▒  Advanced SFX Management                                                 ║
║      ░ Expand `AudioManager` to manage audio buses dynamically, limit voice  ║
║      ░ counts for specific sounds (e.g., footsteps), and handle positional   ║
║      ░ audio via `AudioStreamPlayer2D` nodes for world-space sound effects.  ║
║                                                                              ║
║   ▒  Dynamic Music System                                                    ║
║      ░ A system to dynamically layer or transition music based on combat     ║
║      ░ intensity, boss health phases, or location in the arena.              ║
║                                                                              ║
║   ▒  Object Pool Expansion                                                   ║
║      ░ Pool VFX particle effects (`GPUParticles2D` scenes).                  ║
║      ░ Pool common, weak minion types to optimize performance in encounters  ║
║      ░ with many enemies.                                                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                        GAMEPLAY ENHANCEMENTS                         ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Ideas for mechanics and feedback to improve the player experience.         ║
║                                                                              ║
║   ▒  Combat Feel                                                             ║
║      ░ Attack-Interrupting Windows: Specific boss animations could have a    ║
║      ░ "vulnerable" window where a player hit interrupts the attack.         ║
║      ░ Cinematic Phase Transitions: When a boss changes phase, trigger a     ║
║      ░ brief, scripted sequence with unique animations or effects.           ║
║                                                                              ║
║   ▒  New Interfaces & Mechanics                                              ║
║      ░ `IInteractable`: For world objects the player can interact with.      ║
║      ░ Damage Type Enum: If combat complexity increases, create an enum for  ║
║      ░ `DamageType { MELEE, PROJECTILE, HAZARD }` to allow for resistances.  ║
║                                                                              ║
║   ▒  Boss Concepts                                                           ║
║      ░ Beat Box: Rhythm-based boss where platforms and attacks sync to music.║
║      ░ Gravity Box: Arena gravity flips periodically between floor and ceiling.
║      ░ Garden Box: Segmented, Centipede-style boss weaves through obstacles. ║
║      ░ Circuit Box: Tempest-style boss in the center of a circular arena.    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                     DEVELOPER EXPERIENCE & TOOLING                   ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Ideas for internal systems to improve the development workflow.            ║
║                                                                              ║
║   ▒  In-Game Debug Console                                                   ║
║      ░ A Quake-style dropdown console to run debug commands like `kill_boss`,║
║      ░ `give_heal`, `noclip`, or `set_player_speed`.                         ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝






=====================================
FILE: ./docs/ARENA_CONCEPTS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    █████╗ ██████╗ ███████╗███╗   ██╗ █████╗     ██████╗  ██████╗ ███╗   ███╗ ║
║   ██╔══██╗██╔══██╗██╔════╝████╗  ██║██╔══██╗   ██╔═══██╗██╔═══██╗████╗ ████║ ║
║   ███████║██████╔╝█████╗  ██╔██╗ ██║███████║   ██║   ██║██║   ██║██╔████╔██║ ║
║   ██╔══██║██╔══██╗██╔══╝  ██║╚██╗██║██╔══██║   ██║   ██║██║   ██║██║╚██╔╝██║ ║
║   ██║  ██║██║  ██║███████╗██║ ╚████║██║  ██║   ╚██████╔╝╚██████╔╝██║ ╚═╝ ██║ ║
║   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝    ╚═════╝  ╚═════╝ ╚═╝     ╚═╝ ║
║                                                                              ║
║           A visual library of potential boss battle arena layouts.           ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                       PUN-THEMED ARENA MOCKUPS                       ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  "SANDBOX" - Momentum Vampirism                                          ║
║      SPECIAL RULE: No Wall-Jump ability. Boss steals player speed on hit.    ║
║      ####################                                                    ║
║      #..................#                                                    ║
║      #..@...........&...#                                                    ║
║      #..................#                                                    ║
║      #....##########....#                                                    ║
║      #....#........#....#                                                    ║
║      #....#..^^^^..#....#                                                    ║
║      #....#........#....#                                                    ║
║      #....##--##--##....#                                                    ║
║      #..................#                                                    ║
║      #..##...........##.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..#......--.....#.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..##...........##.#                                                    ║
║      #..................#                                                    ║
║      #^^^^^^^^....^^^^^^#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║   █  "MATCHBOX" - Fire Theme                                                 ║
║      SPECIAL RULE: Only ONE dash per ground contact.                         ║
║      ####################                                                    ║
║      #@.................#                                                    ║
║      #..................#                                                    ║
║      #..####....####....#                                                    ║
║      #..#..#....#..#....#                                                    ║
║      #..#..######..#....#                                                    ║
║      #..#..........#....#                                                    ║
║      #..#..--##--..#....#                                                    ║
║      #..#........&.#....#                                                    ║
║      #..#..--##--..#....#                                                    ║
║      #..#..........#....#                                                    ║
║      #..#..######..#....#                                                    ║
║      #..#..#....#..#....#                                                    ║
║      #..####....####....#                                                    ║
║      #..................#                                                    ║
║      #..^^^^^^^^^^^^^^..#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║   █  "ICEBOX" - Slippery Mechanics                                           ║
║      SPECIAL RULE: Reduced friction - momentum carries much further.         ║
║      ####################                                                    ║
║      #@................&#                                                    ║
║      #--................#                                                    ║
║      #..................#                                                    ║
║      #......########....#                                                    ║
║      #......#......#....#                                                    ║
║      #......#..--..#....#                                                    ║
║      #......#......#....#                                                    ║
║      #......########....#                                                    ║
║      #..................#                                                    ║
║      #........^^^^......#                                                    ║
║      #..................#                                                    ║
║      #......########....#                                                    ║
║      #......#......#....#                                                    ║
║      #......#..--..#....#                                                    ║
║      #......#......#....#                                                    ║
║      #......########....#                                                    ║
║      #..................#                                                    ║
║      #................--#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                     CLASSIC ARCADE-THEMED MOCKUPS                    ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  "CIRCUIT BOX" - Tempest-style                                           ║
║      MECHANIC: Boss in center shoots through tunnels. Player circles outer ring.║
║      ####################                                                    ║
║      #..................#                                                    ║
║      #..###############.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..#..##########.#.#                                                    ║
║      #..#..#........#.#.#                                                    ║
║      #..#..#..####..#.#.#                                                    ║
║      #..#..#..#&&#..#.#.#                                                    ║
║      #..#..#..####..#.#.#                                                    ║
║      #..#..#..@.....#.#.#                                                    ║
║      #..#..##########.#.#                                                    ║
║      #..#.............#.#                                                    ║
║      #..###############.#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
║   █  "GARDEN BOX" - Centipede-style                                          ║
║      MECHANIC: Boss is a long segmented entity weaving between obstacles.    ║
║      ####################                                                    ║
║      #@................&#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      #..##..##..##..##..#                                                    ║
║      #..................#                                                    ║
║      #....##..##..##....#                                                    ║
║      #..................#                                                    ║
║      ####################                                                    ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝


=====================================
FILE: ./docs/DEPRECATION.md
=====================================
# Project Deprecation Map

This document tracks major file renames and moves across the entire project.

| Old Path | New Path | Reason | Date | Migration Note |
|---|---|---|---|---|
| `res://src/core/Config.gd` | `res://src/core/data/config/config.gd` | Architectural refactor | 2025-08-10 | Autoload path updated in `project.godot`. No script changes required. |
| `res://src/core/settings.gd` | `res://src/core/data/config/settings.gd` | Architectural refactor | 2025-08-10 | Autoload path updated in `project.godot`. No script changes required. |
| `res://src/core/events/*_event.gd` | `res://src/core/events/typed_events/*_event.gd` | Architectural refactor | 2025-08-10 | Update `preload` or `load` paths in scripts if referenced directly. |

=====================================
FILE: ./docs/HOW_TO_ADD_AN_EFFECT.md
=====================================
# How to Add a New Effect

## TODO: Write a step-by-step guide for designers.
1. Create a new ShaderEffect resource...
2. Configure the shader and parameters...
3. Link it to an event in FXManager...


=====================================
FILE: ./README.md
=====================================
# BOX BATTLE

```
██████╗  ██████╗ ██╗  ██╗    ██████╗  █████╗ ████████╗████████╗██╗     ███████╗
██╔══██╗██╔═══██╗╗██╗██╔╝    ██╔══██╗██╔══██╗╚══██╔══╝╚══██╔══╝██║     ██╔════╝
██████╔╝██║   ██║╚███╔╝      ██████╔╝███████║   ██║      ██║   ██║     █████╗  
██╔══██╗██║   ██║██╔██╗      ██╔══██╗██╔══██║   ██║      ██║   ██║     ██╔══╝  
██████╔╝╚██████╔╝██╔╝ ██╗    ██████╔╝██║  ██║   ██║      ██║   ███████╗███████╗
╚═════╝  ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚══════╝
```


A combat-focused 2D action game built in Godot 4. This repo contains the engine, gameplay systems, and tools used to produce a modular, maintainable boss-arena prototype.

**Current Status:** Architecturally stable. The codebase has been fully refactored to use a modular, component-based entity system, a standardized code style, and data-driven design patterns.

---

## Architectural Highlights
- **Component-Based Entities:** The Player and Boss are lean orchestrators for single-responsibility components (`HealthComponent`, `PlayerPhysicsComponent`, `IComponent` interface).
- **State Pattern:** Complex entity logic is encapsulated in discrete state classes (`BaseState`, `BaseStateMachine`).
- **Data-Driven Design:** All gameplay tuning is managed in `Resource` files (`.tres`) for easy balancing.
- **Robust Core Systems:** A suite of decoupled singletons manage global services (`EventBus`, `SceneManager`, `ObjectPool`, `AudioManager`).
- **Performance:** Stutter is minimized via asynchronous level building, object pooling, and enhanced shader pre-warming.

---

## Quick Start
1.  Install Godot 4.x.
2.  Clone the repository.
3.  Open the project in Godot and run `res://src/scenes/main/main.tscn`.

**Controls (default)**
-   Move: Arrow Keys / WASD
-   Jump / Confirm: X / Space / Enter
-   Attack / Pogo: C / Left-Click
-   Dash: Z / Shift
-   Heal: Down + Jump (on ground)

---

## Repository Layout

src/
├── api/ # "Interface" contracts (IComponent, IDamageable)
├── core/ # Autoloaded singletons and core infrastructure
├── data/ # Data resources (.tres files for encounters, layouts)
├── entities/ # Player, Boss, Minions, and their components/states
├── scenes/ # Main scenes (game, loading, menus)
├── ui/ # UI components, HUD, and menu controllers
└── ...
docs/ # High-level design, architecture, and style guide


---

## Key Documentation
-   `docs/ARCHITECTURE.txt`: A high-level summary of all key technical patterns.
-   `docs/sprint_0_audit/STYLE-001_GDScript_Style_Guide.md`: The official coding standard for the project.
-   `docs/DESIGN.txt`: The design philosophy and breakdown of core gameplay mechanics.
-   `docs/CHANGELOG.txt`: A log of all notable changes to the project.

=====================================
FILE: ./default_bus_layout.tres
=====================================
[gd_resource type="AudioBusLayout" format=3 uid="uid://c65ja7dwrkbrc"]

[resource]
bus/1/name = &"Music"
bus/1/solo = false
bus/1/mute = false
bus/1/bypass_fx = false
bus/1/volume_db = 0.0
bus/1/send = &"Master"
bus/2/name = &"SFX"
bus/2/solo = false
bus/2/mute = false
bus/2/bypass_fx = false
bus/2/volume_db = 0.0
bus/2/send = &"Master"

=====================================
FILE: ./.github/scripts/get_version.gd
=====================================
# .github/scripts/get_version.gd
# This script runs in the CI environment to get the version
# from project.godot and print it to the command line.
extends SceneTree

func _init():
    var version = ProjectSettings.get_setting("application/config/version")
    print(version)
    quit()

=====================================
FILE: ./.github/scripts/lint_shaders.gd
=====================================
# .github/scripts/lint_shaders.gd
extends SceneTree

# TODO: Implement linter to scan .gdshader files for required headers (shader_type) and hints (: source_color).


=====================================
FILE: ./shaders/ui/sdf_panel.gdshader
=====================================
# shaders/ui/sdf_panel.gdshader
shader_type canvas_item;

# TODO: Implement SDF for rounded corners, borders, and glow.


=====================================
FILE: ./shaders/entity/dissolve.gdshader
=====================================
# shaders/entity/dissolve.gdshader
shader_type canvas_item;

# TODO: Implement dissolve effect driven by fx_progress.


=====================================
FILE: ./shaders/entity/red_hit_flash_test.gdshader
=====================================
// shaders/entity/red_hit_flash_test.gdshader
shader_type canvas_item;

uniform vec4 tint_color : source_color = vec4(1.0, 0.0, 0.0, 1.0);
// The effect's progress, from 0.0 (start) to 1.0 (end).
uniform float fx_progress : hint_range(0.0, 1.0);

void fragment() {
    // Get the base color from the ColorRect
    vec4 original_color = COLOR;
    
    // As fx_progress goes from 0 to 1, intensity goes from 1 to 0.
    float intensity = 1.0 - fx_progress;
    
    // Mix the original color with the tint color
    vec3 mixed_rgb = mix(original_color.rgb, tint_color.rgb, intensity);
    
    // Apply the mixed color, preserving the original alpha
    COLOR = vec4(mixed_rgb, original_color.a);
}

=====================================
FILE: ./shaders/fullscreen/shockwave.gdshader
=====================================
# shaders/fullscreen/shockwave.gdshader
shader_type canvas_item;

# TODO: Implement shockwave post-processing effect using SCREEN_TEXTURE.


=====================================
FILE: ./project.godot
=====================================
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="BOX BATTLE"
config/version="0.13.0"
run/main_scene="res://src/scenes/main/main.tscn"
config/features=PackedStringArray("4.4", "Mobile")
config/icon="res://icon.svg"

[autoload]

GameManager="*res://src/core/systems/game_manager.gd"
SceneManager="*res://src/core/systems/scene_manager.gd"
AudioManager="*res://src/core/systems/audio_manager.gd"
FXManager="*res://src/core/systems/fx_manager.gd"
CameraManager="*res://src/core/systems/camera_manager.gd"
CursorManager="*res://src/core/systems/cursor_manager.gd"
ObjectPool="*res://src/core/systems/object_pool.gd"
EventBus="*res://src/core/events/event_bus.gd"
Sequencer="*res://src/core/sequencing/sequencer.gd"
ArenaBuilder="*res://src/core/building/arena_builder.gd"
Settings="*res://src/core/data/config/settings.gd"
GlobalPreloader="*res://src/api/global_preloader.gd"
AssetPaths="*res://src/core/util/asset_paths.gd"
Constants="*res://src/core/util/constants.gd"
GridUtils="*res://src/core/util/grid_utils.gd"
CombatUtils="*res://src/core/util/combat_utils.gd"
Identifiers="*res://src/core/util/identifiers.gd"
Palette="*res://src/core/util/palette.gd"
PhysicsLayers="*res://src/core/util/physics_layers.gd"

[display]

window/size/viewport_width=1800
window/size/viewport_height=1000
window/stretch/mode="canvas_items"

[editor_plugins]

enabled=PackedStringArray("res://addons/gut/plugin.cfg")

[input]

ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194319,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
]
}
ui_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194321,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
]
}
ui_up={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194320,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
]
}
ui_down={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194322,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
]
}
ui_jump={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":32,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":88,"physical_keycode":88,"key_label":0,"unicode":120,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":46,"physical_keycode":46,"key_label":0,"unicode":46,"location":0,"echo":false,"script":null)
]
}
ui_attack={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":67,"physical_keycode":67,"key_label":0,"unicode":99,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":44,"physical_keycode":44,"key_label":0,"unicode":44,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":true,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777218,"physical_keycode":16777218,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":2,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
ui_dash={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":90,"physical_keycode":90,"key_label":0,"unicode":122,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":47,"physical_keycode":47,"key_label":0,"unicode":47,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":true,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777217,"physical_keycode":16777217,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":3,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
debug_toggle_overlay={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":89,"key_label":0,"unicode":121,"location":0,"echo":false,"script":null)
]
}
debug_cycle_target={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":85,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="player"
2d_physics/layer_2="platforms"
2d_physics/layer_3="enemy"
2d_physics/layer_4="hazard"
2d_physics/layer_5="enemy_projectile"
2d_physics/layer_6="player_hitbox"
2d_physics/layer_7="player_hurtbox"
2d_physics/layer_8="solid_world"

[rendering]

renderer/rendering_method="mobile"
textures/vram_compression/import_etc2_astc=true
environment/defaults/default_clear_color=Color(0, 0, 0, 1)

[shader_globals]

fx_global_time={
"type": "float",
"value": 0.0
}
vignette_intensity={
"type": "float",
"value": 0.0
}
desat_amount={
"type": "float",
"value": 0.0
}
pal_index={
"type": "int",
"value": 0
}


=====================================
FILE: ./.vscode/settings.json
=====================================
{
    "godotTools.editorPath.godot4": "/Applications/Godot.app"
}

=====================================
FILE: ./src/ui/game_hud/game_hud.gd
=====================================
# src/ui/game_hud/game_hud.gd
## Manages the in-game heads-up display.
##
## Subscribes to [EventBus] events to keep the player health, boss health,
## and phase indicators updated in real-time.
extends CanvasLayer

# --- Constants ---
const COMBAT_CONFIG = preload("res://src/data/combat_config.tres")

# --- Node References ---
@onready var player_health_value: Label = $PlayerInfo/PlayerHealthHBox/PlayerHealthValue
@onready var player_heal_charges_value: Label = $PlayerInfo/PlayerHealChargesHBox/PlayerHealChargesValue
@onready var boss_health_bar: ProgressBar = $BossHealthBar
@onready var phase_indicators: HBoxContainer = $PhaseIndicators

# --- Private Member Variables ---
var _phase_squares: Array[Panel] = []
var _total_phases: int = 3
var _player_health_token: int
var _player_charges_token: int
var _boss_health_token: int
var _boss_phase_token: int
var _boss_died_token: int
var _filled_style: StyleBoxFlat
var _empty_style: StyleBoxFlat

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	_subscribe_to_events()
	_create_styles()
	_initialize_ui_state()

func _exit_tree() -> void:
	_unsubscribe_from_events()

# --- Private Methods ---

func _subscribe_to_events() -> void:
	_player_health_token = EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, on_player_health_changed)
	_player_charges_token = EventBus.on(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, on_player_healing_charges_changed)
	_boss_health_token = EventBus.on(EventCatalog.BOSS_HEALTH_CHANGED, on_boss_health_changed)
	_boss_phase_token = EventBus.on(EventCatalog.BOSS_PHASE_CHANGED, on_boss_phase_changed)
	_boss_died_token = EventBus.on(EventCatalog.BOSS_DIED, on_boss_died)

func _unsubscribe_from_events() -> void:
	EventBus.off(_player_health_token)
	EventBus.off(_player_charges_token)
	EventBus.off(_boss_health_token)
	EventBus.off(_boss_phase_token)
	EventBus.off(_boss_died_token)

func _initialize_ui_state() -> void:
	var max_health = COMBAT_CONFIG.player_max_health
	player_health_value.text = "%d / %d" % [max_health, max_health]
	player_heal_charges_value.text = "0"

	var health_bar_style = boss_health_bar.get_theme_stylebox("fill").duplicate()
	health_bar_style.bg_color = Palette.COLOR_PLAYER_PROJECTILE
	boss_health_bar.add_theme_stylebox_override("fill", health_bar_style)

	boss_health_bar.max_value = COMBAT_CONFIG.boss_health
	boss_health_bar.value = boss_health_bar.max_value

	phase_indicators.add_theme_constant_override("separation", 5)
	_create_phase_indicators()

func _create_styles() -> void:
	_filled_style = StyleBoxFlat.new()
	_filled_style.bg_color = Palette.COLOR_HAZARD_PRIMARY
	_filled_style.border_width_bottom = 3
	_filled_style.border_width_left = 3
	_filled_style.border_width_right = 3
	_filled_style.border_width_top = 3
	_filled_style.border_color = Palette.COLOR_UI_ACCENT_PRIMARY

	_empty_style = _filled_style.duplicate()
	_empty_style.bg_color = Palette.COLOR_BACKGROUND

func _create_phase_indicators() -> void:
	for i in range(_total_phases):
		var panel = Panel.new()
		panel.custom_minimum_size = Vector2(40, 40)
		phase_indicators.add_child(panel)
		_phase_squares.append(panel)
	_update_phase_visuals(_total_phases)

func _update_phase_visuals(phases_remaining: int) -> void:
	for i in range(_phase_squares.size()):
		var square = _phase_squares[i]
		if i < phases_remaining:
			square.add_theme_stylebox_override("panel", _filled_style)
		else:
			square.add_theme_stylebox_override("panel", _empty_style)

# --- EventBus Callbacks ---

func on_player_health_changed(payload: PlayerHealthChangedEvent) -> void:
	player_health_value.text = str(payload.current_health) + " / " + str(payload.max_health)

func on_player_healing_charges_changed(payload: PlayerHealingChargesChangedEvent) -> void:
	player_heal_charges_value.text = str(payload.current_charges)

func on_boss_health_changed(payload: BossHealthChangedEvent) -> void:
	boss_health_bar.max_value = payload.max_health
	boss_health_bar.value = payload.current_health

func on_boss_phase_changed(payload: Dictionary) -> void:
	var phases_remaining = payload.get("phases_remaining", 1)
	_update_phase_visuals(phases_remaining)

func on_boss_died(_payload) -> void:
	_update_phase_visuals(0)

=====================================
FILE: ./src/ui/game_hud/game_hud.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://c1qkhw0snj226"]

[ext_resource type="Script" path="res://src/ui/game_hud/game_hud.gd" id="1_3f8wa"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_1"]
bg_color = Color(0.262745, 0.262745, 0.262745, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_2"]
bg_color = Color(0.92549, 0.92549, 0.92549, 1)

[node name="GameHUD" type="CanvasLayer"]
script = ExtResource("1_3f8wa")

[node name="PlayerInfo" type="VBoxContainer" parent="."]
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 20.0
offset_top = -100.0
offset_right = 220.0
offset_bottom = -20.0
grow_vertical = 0

[node name="PlayerHealthHBox" type="HBoxContainer" parent="PlayerInfo"]
layout_mode = 2

[node name="PlayerHealthLabel" type="Label" parent="PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Health:"

[node name="PlayerHealthValue" type="Label" parent="PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "5 / 5"

[node name="PlayerHealChargesHBox" type="HBoxContainer" parent="PlayerInfo"]
layout_mode = 2

[node name="PlayerHealChargesLabel" type="Label" parent="PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Heal Charges:"

[node name="PlayerHealChargesValue" type="Label" parent="PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"

[node name="BossHealthBar" type="ProgressBar" parent="."]
anchors_preset = 10
anchor_right = 1.0
offset_left = 250.0
offset_top = 20.0
offset_right = -250.0
offset_bottom = 50.0
grow_horizontal = 2
theme_override_styles/background = SubResource("StyleBoxFlat_1")
theme_override_styles/fill = SubResource("StyleBoxFlat_2")
max_value = 30.0
step = 1.0
value = 30.0
show_percentage = false

[node name="PhaseIndicators" type="HBoxContainer" parent="."]
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -220.0
offset_top = 20.0
offset_right = -20.0
offset_bottom = 60.0
grow_horizontal = 0
alignment = 2

=====================================
FILE: ./src/ui/menu_manager/menu_manager.gd
=====================================
# src/ui/menu_manager/menu_manager.gd
## A helper node that manages keyboard navigation and cursor display for a menu.
##
## This is intended to be instanced by a menu scene at runtime. It handles
## focus changes and draws selection cursors next to the focused item.
extends Node

# --- Member Variables ---
var menu_items: Array[Control] = []
var current_selection_index: int = 0

var _cursor_left: ColorRect
var _cursor_right: ColorRect

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	_cursor_left = ColorRect.new()
	_cursor_left.size = Vector2(20, 20)
	_cursor_left.color = Palette.COLOR_UI_ACCENT_PRIMARY
	_cursor_left.visible = false
	add_child(_cursor_left)

	_cursor_right = ColorRect.new()
	_cursor_right.size = Vector2(20, 20)
	_cursor_right.color = Palette.COLOR_UI_ACCENT_PRIMARY
	_cursor_right.visible = false
	add_child(_cursor_right)

func _unhandled_input(event: InputEvent) -> void:
	if menu_items.is_empty(): return

	if event.is_action_pressed("ui_down"):
		_change_selection(1)
		get_viewport().set_input_as_handled()
	elif event.is_action_pressed("ui_up"):
		_change_selection(-1)
		get_viewport().set_input_as_handled()

# --- Public Methods ---

## Initializes the manager with a list of menu items to control.
func setup_menu(items: Array[Control]) -> void:
	if items.is_empty(): return
	self.menu_items = items

	for item in menu_items:
		item.focus_entered.connect(_on_item_focused.bind(item))

# --- Private Methods ---

func _change_selection(amount: int) -> void:
	if menu_items.size() <= 1:
		AudioManager.play_sfx(AssetPaths.SFX_UI_ERROR)
		return

	var new_selection = (current_selection_index + amount + menu_items.size()) % menu_items.size()
	menu_items[new_selection].grab_focus()

func _update_cursors(selected_item: Control) -> void:
	await get_tree().process_frame # Wait for layout to settle

	if not is_instance_valid(selected_item): return

	var item_pos = selected_item.global_position
	var item_size = selected_item.size
	var cursor_padding = 40.0

	_cursor_left.global_position.y = item_pos.y + (item_size.y - _cursor_left.size.y) / 2.0
	_cursor_left.global_position.x = item_pos.x - cursor_padding - _cursor_left.size.x

	_cursor_right.global_position.y = item_pos.y + (item_size.y - _cursor_right.size.y) / 2.0
	_cursor_right.global_position.x = item_pos.x + item_size.x + cursor_padding

	_cursor_left.visible = true
	_cursor_right.visible = true

# --- Signal Handlers ---

func _on_item_focused(focused_item: Control) -> void:
	var index = menu_items.find(focused_item)
	if index != -1:
		current_selection_index = index

	_update_cursors(focused_item)
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)

=====================================
FILE: ./src/ui/dialogue/dialogue_box.gd
=====================================
# src/ui/dialogue/dialogue_box.gd
## The UI scene responsible for displaying dialogue text.
##
## It receives data from the [DialogueManager] and handles the visual
## presentation, including animated text effects.
class_name DialogueBox
extends Control

# TODO: Create @onready vars for Label nodes (character name, main text).
# @onready var name_label: Label = %NameLabel
# @onready var text_label: RichTextLabel = %TextLabel

# --- Public Methods ---

## Displays a single line of dialogue.
func display_line(_line_data: DialogueData.DialogueLine) -> void:
	assert(false, "DialogueBox.display_line() is not yet implemented.")
	pass

# --- Private Methods ---

# TODO: Implement a tween or timer-based text animation effect.
# func _animate_text(p_full_text: String) -> void:

=====================================
FILE: ./src/ui/dialogue/dialogue_box.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dialogue_box_tscn"]

[ext_resource type="Script" path="res://src/ui/dialogue/dialogue_box.gd" id="1_dialogue_box_script"]

[node name="DialogueBox" type="Control"]
layout_mode = 3
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -250.0
grow_horizontal = 2
grow_vertical = 0
script = ExtResource("1_dialogue_box_script")

[node name="Panel" type="Panel" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2

[node name="NameLabel" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Character Name"

[node name="TextLabel" type="RichTextLabel" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 28
bbcode_enabled = true
text = "This is where the dialogue text will appear, animating one character at a time..."

=====================================
FILE: ./src/ui/components/mute_button/mute_button.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://d1g2h3i4j5k6l"]

[ext_resource type="Texture2D" uid="uid://dmdfbw1txq0nf" path="res://assets/sprites/ui/icons/icon_ui_sound_off.png" id="1_g0pcd"]
[ext_resource type="Script" uid="uid://cotrj67gsvbw8" path="res://src/ui/components/mute_button/mute_button.gd" id="1_mute_button_script"]

[node name="MuteButton" type="TextureButton"]
focus_mode = 0
texture_normal = ExtResource("1_g0pcd")
script = ExtResource("1_mute_button_script")


=====================================
FILE: ./src/ui/components/mute_button/mute_button.gd
=====================================
# src/ui/components/mute_button/mute_button.gd
@tool
## A reusable UI component for toggling the game's music mute state.
##
## It automatically syncs its icon with the global [Settings] resource.
class_name MuteButton
extends TextureButton

# --- Constants ---
const ICON_SOUND_ON = preload(AssetPaths.ICON_UI_SOUND_ON)
const ICON_SOUND_OFF = preload(AssetPaths.ICON_UI_SOUND_OFF)

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	focus_mode = FOCUS_NONE
	_update_icon()

	if not Engine.is_editor_hint():
		self.pressed.connect(_on_pressed)
		Settings.audio_settings_changed.connect(_update_icon)
		mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if Settings.audio_settings_changed.is_connected(_update_icon):
			Settings.audio_settings_changed.disconnect(_update_icon)

# --- Private Methods ---

func _update_icon() -> void:
	if Settings.music_muted:
		self.texture_normal = ICON_SOUND_OFF
	else:
		self.texture_normal = ICON_SOUND_ON

# --- Signal Handlers ---

func _on_pressed() -> void:
	Settings.music_muted = not Settings.music_muted

=====================================
FILE: ./src/ui/components/styled_menu_item/styled_menu_item.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cgt63w7k4w5gq"]

[ext_resource type="Script" path="res://src/ui/components/styled_menu_item/styled_menu_item.gd" id="1_menu_item_script"]

[node name="StyledMenuItem" type="Control"]
custom_minimum_size = Vector2(400, 80)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_menu_item_script")

=====================================
FILE: ./src/ui/components/styled_menu_item/styled_menu_item.gd
=====================================
# src/ui/components/styled_menu_item/styled_menu_item.gd
@tool
## A reusable, procedurally-drawn menu item component.
##
## Handles its own drawing, state changes (hover, press, focus), input,
## and animations for a self-contained, highly configurable button.
class_name StyledMenuItem
extends Control

# --- Signals ---
## Emitted when the menu item is clicked or activated via keyboard.
signal pressed

# --- Editor Properties ---
@export var text: String = "Menu Item" : set = set_text
@export var font_size: int = 48 : set = set_font_size
@export var glow_size: float = 0.0 : set = set_glow_size
@export var glow_alpha: float = 0.0 : set = set_glow_alpha

# --- Member Variables ---
var is_hovered: bool = false
var is_pressed: bool = false
var is_selected: bool = false

# --- Private Member Variables ---
var _font: Font
var _active_tween: Tween

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	_font = load(AssetPaths.FONT_MAIN_BOLD)
	focus_mode = FOCUS_ALL
	mouse_filter = MOUSE_FILTER_STOP

	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	resized.connect(queue_redraw)
	focus_entered.connect(_on_focus_entered)
	focus_exited.connect(_on_focus_exited)

func _gui_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_accept") and has_focus():
		get_viewport().set_input_as_handled()
		emit_signal("pressed")
		_show_keyboard_press_feedback()
		return

	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.is_pressed():
			is_pressed = true
			queue_redraw()
		elif is_pressed: # On release
			emit_signal("pressed")
			is_pressed = false
			queue_redraw()

func _draw() -> void:
	var bg_color: Color
	var text_color: Color
	var border_color: Color
	var border_width: float = 3.0

	if is_pressed:
		bg_color = Palette.get_color(2)
		text_color = Palette.COLOR_TEXT_PRIMARY
		border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	elif is_hovered or is_selected:
		bg_color = Palette.COLOR_UI_ACCENT_PRIMARY
		text_color = Palette.COLOR_BACKGROUND
		border_color = Palette.get_color(4)
	else:
		bg_color = Palette.COLOR_UI_PANEL_BG
		text_color = Palette.COLOR_TEXT_PRIMARY
		border_color = Palette.COLOR_UI_ACCENT_PRIMARY

	if (is_hovered or is_selected) and glow_size > 0.0 and glow_alpha > 0.0:
		var glow_base_color = Palette.COLOR_UI_GLOW
		var final_glow_color = Color(glow_base_color.r, glow_base_color.g, glow_base_color.b, glow_alpha)
		var glow_rect = Rect2(Vector2.ZERO, size).grow(glow_size)
		draw_rect(glow_rect, final_glow_color)

	draw_rect(Rect2(Vector2.ZERO, size), bg_color)
	draw_rect(Rect2(Vector2.ZERO, size), border_color, false, border_width)

	var text_width = _font.get_string_size(text, HORIZONTAL_ALIGNMENT_CENTER, -1, font_size).x
	var text_pos_x = (size.x - text_width) / 2.0
	var text_pos_y = (size.y / 2.0) + (font_size / 3.0)
	draw_string(_font, Vector2(text_pos_x, text_pos_y), text, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, text_color)

# --- Public Setters ---

func set_text(new_text: String) -> void:
	if text != new_text:
		text = new_text
		queue_redraw()

func set_font_size(new_size: int) -> void:
	if font_size != new_size:
		font_size = new_size
		queue_redraw()

func set_glow_size(value: float) -> void:
	glow_size = value
	queue_redraw()

func set_glow_alpha(value: float) -> void:
	glow_alpha = value
	queue_redraw()

# --- Private Methods ---

func _show_keyboard_press_feedback() -> void:
	is_pressed = true
	queue_redraw()
	await get_tree().create_timer(0.1).timeout
	if is_instance_valid(self):
		is_pressed = false
		queue_redraw()

func _animate_selection(p_is_selected: bool) -> void:
	if _active_tween and _active_tween.is_valid():
		_active_tween.kill()

	_active_tween = create_tween().set_parallel(true)
	var target_glow_size = 28.0 if p_is_selected else 0.0
	var target_glow_alpha = 0.2 if p_is_selected else 0.0
	var duration = 0.3 if p_is_selected else 0.2

	_active_tween.tween_property(self, "glow_size", target_glow_size, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	_active_tween.tween_property(self, "glow_alpha", target_glow_alpha, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

# --- Signal Handlers ---

func _on_mouse_entered() -> void:
	is_hovered = true
	grab_focus()
	CursorManager.set_pointer_state(true)

func _on_mouse_exited() -> void:
	is_hovered = false
	if is_pressed:
		is_pressed = false
		queue_redraw()
	CursorManager.set_pointer_state(false)

func _on_focus_entered() -> void:
	is_selected = true
	_animate_selection(true)
	queue_redraw()

func _on_focus_exited() -> void:
	is_selected = false
	_animate_selection(false)
	queue_redraw()

=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.gd
=====================================
# src/ui/components/custom_slider/custom_slider.gd
@tool
## A self-contained, reusable custom slider component.
extends TextureRect

# --- Signals ---
## Emitted when the slider's value changes.
signal value_changed(value: float)

# --- Member Variables ---
var knob: TextureRect
var is_dragging: bool = false
var min_x_pos: float = 0.0
var max_x_pos: float = 0.0
var drag_offset: float = 0.0
var _initial_value: float = -1.0 # Used to set value before node is ready

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	self.texture = load(AssetPaths.SPRITE_SLIDER_TRACK)

	knob = TextureRect.new()
	knob.texture = load(AssetPaths.SPRITE_SLIDER_KNOB)
	add_child(knob)

	knob.mouse_entered.connect(_on_knob_mouse_entered)
	knob.mouse_exited.connect(_on_knob_mouse_exited)

	# Wait for the next frame to ensure parent containers have arranged children.
	await get_tree().process_frame

	knob.position.y = (size.y - knob.size.y) / 2.0
	min_x_pos = global_position.x
	max_x_pos = global_position.x + size.x - knob.size.x

	if _initial_value >= 0.0:
		var new_x_pos = min_x_pos + (max_x_pos - min_x_pos) * _initial_value
		knob.global_position.x = clamp(new_x_pos, min_x_pos, max_x_pos)

func _process(_delta: float) -> void:
	if is_dragging:
		var global_mouse_pos = get_global_mouse_position()
		knob.global_position.x = clamp(global_mouse_pos.x - drag_offset, min_x_pos, max_x_pos)

		if (max_x_pos - min_x_pos) > 0:
			var current_value = (knob.global_position.x - min_x_pos) / (max_x_pos - min_x_pos)
			emit_signal("value_changed", current_value)

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		var knob_rect = knob.get_global_rect()

		if event.is_pressed():
			if knob_rect.has_point(event.global_position):
				is_dragging = true
				drag_offset = event.global_position.x - knob.global_position.x
		else:
			is_dragging = false
			if not knob_rect.has_point(get_global_mouse_position()):
				CursorManager.set_pointer_state(false)
			drag_offset = 0.0

# --- Public Methods ---

## Sets the initial value of the slider.
func set_value(initial_value: float) -> void:
	_initial_value = initial_value

# --- Signal Handlers ---

func _on_knob_mouse_entered() -> void:
	CursorManager.set_pointer_state(true)

func _on_knob_mouse_exited() -> void:
	if not is_dragging:
		CursorManager.set_pointer_state(false)

=====================================
FILE: ./src/ui/components/logo_display/logo_display.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1c2d3e4f5g6h"]

[ext_resource type="Script" path="res://src/ui/components/logo_display/logo_display.gd" id="1_logo_script"]

[node name="LogoDisplay" type="Control"]
custom_minimum_size = Vector2(200, 200)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_logo_script")

[node name="TextureRect" type="TextureRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
expand_mode = 1
stretch_mode = 5

=====================================
FILE: ./src/ui/components/logo_display/logo_display.gd
=====================================
# src/ui/components/logo_display/logo_display.gd
@tool
## A reusable UI component for displaying an interactive logo.
##
## Provides visual feedback on hover and emits a signal when pressed.
class_name LogoDisplay
extends Control

# --- Signals ---
## Emitted when the logo is clicked, passing its [member logo_name].
signal pressed(logo_name: String)

# --- Node References ---
@onready var texture_rect: TextureRect = $TextureRect

# --- Editor Properties ---
@export var texture: Texture2D:
	set(value):
		texture = value
		if is_instance_valid(texture_rect):
			texture_rect.texture = texture

@export var logo_name: String = "Logo"
@export var glow_size: float = 0.0 : set = set_glow_size
@export var glow_alpha: float = 0.0 : set = set_glow_alpha

# --- Member Variables ---
var is_hovered: bool = false
var is_pressed: bool = false

# --- Private Member Variables ---
var _active_tween: Tween

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	mouse_filter = MOUSE_FILTER_STOP

	if is_instance_valid(texture_rect) and texture:
		texture_rect.texture = texture

	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)

func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.is_pressed():
			is_pressed = true
			queue_redraw()
		elif is_pressed: # On release
			emit_signal("pressed", logo_name)
			is_pressed = false
			queue_redraw()

func _draw() -> void:
	if is_hovered and glow_size > 0.0 and glow_alpha > 0.0:
		var glow_base_color = Palette.COLOR_UI_GLOW
		var final_glow_color = Color(glow_base_color.r, glow_base_color.g, glow_base_color.b, glow_alpha)
		var glow_rect = Rect2(Vector2.ZERO, size).grow(glow_size)
		draw_rect(glow_rect, final_glow_color)

# --- Public Setters ---

func set_glow_size(value: float) -> void:
	glow_size = value
	queue_redraw()

func set_glow_alpha(value: float) -> void:
	glow_alpha = value
	queue_redraw()

# --- Private Methods ---

func _animate_hover(p_is_hovered: bool) -> void:
	if _active_tween and _active_tween.is_valid():
		_active_tween.kill()

	_active_tween = create_tween().set_parallel(true)
	var target_glow_size = 20.0 if p_is_hovered else 0.0
	var target_glow_alpha = 0.2 if p_is_hovered else 0.0
	var duration = 0.3 if p_is_hovered else 0.2

	_active_tween.tween_property(self, "glow_size", target_glow_size, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)
	_active_tween.tween_property(self, "glow_alpha", target_glow_alpha, duration).set_trans(Tween.TRANS_SINE).set_ease(Tween.EASE_OUT)

# --- Signal Handlers ---

func _on_mouse_entered() -> void:
	is_hovered = true
	CursorManager.set_pointer_state(true)
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)
	_animate_hover(true)

func _on_mouse_exited() -> void:
	is_hovered = false
	if is_pressed:
		is_pressed = false
		queue_redraw()
	CursorManager.set_pointer_state(false)
	_animate_hover(false)

=====================================
FILE: ./src/ui/dev/debug_overlay.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://debug_overlay_scene_id"]

[ext_resource type="Script" path="res://src/ui/dev/debug_overlay.gd" id="1_debug_script"]

[node name="DebugOverlay" type="CanvasLayer"]
layer = 100
script = ExtResource("1_debug_script")

[node name="Panel" type="Panel" parent="."]
unique_name_in_owner = true
layout_mode = 0
offset_left = 10.0
offset_top = 10.0
offset_right = 460.0
offset_bottom = 330.0
mouse_filter = 2

[node name="MarginContainer" type="MarginContainer" parent="Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="VBoxContainer" type="VBoxContainer" parent="Panel/MarginContainer"]
layout_mode = 2

[node name="FPSLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "FPS:"

[node name="HSeparator" type="HSeparator" parent="Panel/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="StateLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 20
text = "State:"
autowrap_mode = 2

[node name="VelocityLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Velocity:"

[node name="FlagsLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 20
text = "Flags:"
autowrap_mode = 2

[node name="StateHistoryLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 20
text = "History:"
autowrap_mode = 2

[node name="HSeparator2" type="HSeparator" parent="Panel/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="InputBufferLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 20
text = "Input:"
autowrap_mode = 2

[node name="HSeparator3" type="HSeparator" parent="Panel/MarginContainer/VBoxContainer"]
layout_mode = 2

[node name="ObjectPoolLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 20
text = "Pools:"
autowrap_mode = 2

[node name="FXLabel" type="Label" parent="Panel/MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_font_sizes/font_size = 20
text = "FX:"
autowrap_mode = 2

=====================================
FILE: ./src/ui/dev/debug_overlay.gd
=====================================
# src/ui/dev/debug_overlay.gd
## A toggleable overlay for displaying real-time developer debug information.
class_name DebugOverlay
extends CanvasLayer

# --- Node References ---
@onready var state_label: Label = %StateLabel
@onready var velocity_label: Label = %VelocityLabel
@onready var flags_label: Label = %FlagsLabel
@onready var state_history_label: Label = %StateHistoryLabel
@onready var input_buffer_label: Label = %InputBufferLabel
@onready var object_pool_label: Label = %ObjectPoolLabel
@onready var fx_label: Label = %FXLabel
@onready var panel: Panel = %Panel

# --- Private Member Variables ---
var _target_entity: Node = null

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	var panel_style = StyleBoxFlat.new()
	panel_style.bg_color = Color(0, 0, 0, 0.6)
	panel_style.border_width_left = 2
	panel_style.border_width_top = 2
	panel_style.border_width_right = 2
	panel_style.border_width_bottom = 2
	panel_style.border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	panel.add_theme_stylebox_override("panel", panel_style)
	
	state_history_label.clip_text = true
	input_buffer_label.clip_text = true
	object_pool_label.clip_text = true

func _process(_delta: float) -> void:
	var fps_text = "FPS: %d" % Engine.get_frames_per_second()
	
	if not is_instance_valid(_target_entity):
		state_label.text = "NO TARGET SELECTED"
		velocity_label.text = fps_text
		flags_label.text = ""
		state_history_label.text = ""
		input_buffer_label.text = ""
		object_pool_label.text = ""
		fx_label.text = "FX: N/A"
		return

	velocity_label.text = "%s | %s" % [_target_entity.name, fps_text]

	var state_machine: BaseStateMachine = _target_entity.state_machine if "state_machine" in _target_entity else null
	var current_state_name = "N/A"
	if is_instance_valid(state_machine) and is_instance_valid(state_machine.current_state):
		current_state_name = state_machine.current_state.get_script().resource_path.get_file()

	state_label.text = "State: %s" % current_state_name

	# --- Flags ---
	var health_comp: HealthComponent = _target_entity.health_component if "health_component" in _target_entity else null
	var is_invincible_str = str(health_comp.is_invincible()) if is_instance_valid(health_comp) else "N/A"
	var on_floor_str = str(_target_entity.is_on_floor()) if _target_entity is CharacterBody2D else "N/A"
	
	var flags_text = "Flags: OnFloor(%s) Invincible(%s)" % [on_floor_str, is_invincible_str]
	if _target_entity is Player:
		flags_text += " CanDash(%s)" % _target_entity.entity_data.can_dash
		state_history_label.text = "History: " + ", ".join(state_machine.state_history)
		_update_player_input_buffer()
	else:
		state_history_label.text = ""
		input_buffer_label.text = ""

	flags_label.text = flags_text
	
	# --- FX Component ---
	var fx_comp: FXComponent = _target_entity.fx_component if "fx_component" in _target_entity else null
	if is_instance_valid(fx_comp):
		fx_label.text = "FX: %s" % fx_comp.get_current_effect_name()
	else:
		fx_label.text = "FX: N/A"

	# --- Object Pool (global) ---
	var pool_stats: Dictionary = ObjectPool.get_pool_stats()
	var pool_text_parts: Array[String] = []
	for pool_name in pool_stats:
		var stats = pool_stats[pool_name]
		pool_text_parts.append("%s [%d/%d]" % [pool_name, stats.active, stats.total])
	object_pool_label.text = "Pools: " + " ".join(pool_text_parts)

# --- Public Methods ---
func set_target(entity: Node) -> void:
	_target_entity = entity

# --- Private Methods ---
func _update_player_input_buffer() -> void:
	var input_buffer: Dictionary = _target_entity.input_component.buffer
	var input_text_parts: Array[String] = []
	for key in input_buffer:
		var value = input_buffer[key]
		var should_display = false
		if value is bool and value == true:
			should_display = true
		elif value is float and not is_zero_approx(value):
			should_display = true
		
		if should_display:
			input_text_parts.append("%s: %s" % [key, value])
			
	input_buffer_label.text = "Input: " + ", ".join(input_text_parts)

=====================================
FILE: ./src/scenes/loading/loading_screen.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://loading_screen_scene_id"]

[ext_resource type="Script" path="res://src/scenes/loading/loading_screen.gd" id="1_loading_script"]

[node name="LoadingScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_loading_script")

[node name="ColorRect" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="Label" type="Label" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -75.0
offset_top = -16.5
offset_right = 75.0
offset_bottom = 16.5
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 30
text = "Loading..."
horizontal_alignment = 1
vertical_alignment = 1

[node name="ShaderPrewarmViewport" type="SubViewportContainer" parent="."]
custom_minimum_size = Vector2(1, 1)
layout_mode = 0
offset_left = -10.0
offset_top = -10.0
offset_right = -9.0
offset_bottom = -9.0
stretch = true

[node name="SubViewport" type="SubViewport" parent="ShaderPrewarmViewport"]
handle_input_locally = false
size = Vector2i(1, 1)
render_target_update_mode = 4

=====================================
FILE: ./src/scenes/loading/loading_screen.gd
=====================================
# src/scenes/loading/loading_screen.gd
## Handles asynchronous level building and shader pre-warming.
##
## This scene acts as an intermediary to prevent stuttering. It first builds
## the level in batches, then pre-instantiates key entities in an off-screen
## viewport to force shader compilation before transitioning to the game scene.
extends Control

# --- Constants ---
const SHADER_PREWARM_SCENES = [
	AssetPaths.SCENE_PLAYER,
	AssetPaths.SCENE_BASE_BOSS,
	AssetPaths.SCENE_PLAYER_SHOT,
	AssetPaths.SCENE_BOSS_SHOT,
	AssetPaths.SCENE_TURRET_SHOT
]

# --- Node References ---
@onready var prewarm_viewport: SubViewport = $ShaderPrewarmViewport/SubViewport

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	if GameManager.state.current_encounter_path.is_empty():
		print("ERROR: No encounter script specified in GameManager. Returning to title.")
		SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)
		return

	_load_level()

# --- Private Methods ---

## The main loading and pre-warming sequence.
func _load_level() -> void:
	await get_tree().process_frame # Wait one frame for UI to draw "Loading..."

	await _prewarm_shaders()

	# Build the level and store the resulting node in the GameManager state.
	GameManager.state.prebuilt_level = await ArenaBuilder.build_level_async()

	await get_tree().process_frame # Wait one more frame for safety.

	SceneManager.go_to_scene(AssetPaths.SCENE_ENCOUNTER) # UPDATED

## Instantiates scenes off-screen to compile their shaders.
func _prewarm_shaders() -> void:
	print("Starting shader pre-warming...")
	for scene_path in SHADER_PREWARM_SCENES:
		if not FileAccess.file_exists(scene_path): continue
		var instance = load(scene_path).instantiate()
		prewarm_viewport.add_child(instance)
		
		# --- Trigger Actions to Compile More Shaders ---
		if instance is Player:
			instance.velocity.x = 100
			instance.state_machine.change_state(instance.State.ATTACK)
		elif instance is BaseBoss:
			instance.velocity.x = 100

		await get_tree().process_frame
		instance.queue_free()
	print("Shader pre-warming complete.")


=====================================
FILE: ./src/scenes/game/encounter_scene.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://game_scene_unique_id"]

[ext_resource type="Script" path="res://src/scenes/game/encounter_scene.gd" id="1_game_script"]

[node name="EncounterScene" type="Node"]
script = ExtResource("1_game_script")

[node name="Camera2D" type="Camera2D" parent="."]

=====================================
FILE: ./src/scenes/game/encounter_scene.gd
=====================================
# src/scenes/game/encounter_scene.gd
## The main game scene controller.
##
## Responsible for asynchronously building the level, spawning entities,
## managing the game camera, and handling victory/defeat sequences.
## It also manages the developer debug overlay and target inspection.
class_name EncounterScene
extends ISceneController

# --- Node References ---
@onready var camera: Camera2D = $Camera2D

# --- Private Member Variables ---
var _level_container: Node = null
var _debug_overlay: DebugOverlay = null
var _boss_died_token: int = 0
var _death_sequence_handle: SequenceHandle
var _camera_shaker: CameraShaker = null

# --- Debug Inspector ---
var _inspectable_entities: Array[Node] = []
var _current_inspect_index: int = 0

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	_boss_died_token = EventBus.on(EventCatalog.BOSS_DIED, _on_boss_died)

	if is_instance_valid(GameManager.state.prebuilt_level):
		_level_container = GameManager.state.prebuilt_level
		GameManager.state.prebuilt_level = null
	else:
		_level_container = await ArenaBuilder.build_level_async()

	if is_instance_valid(_level_container):
		add_child(_level_container)
		await get_tree().process_frame

		var build_data: LevelBuildData = _level_container.get_meta("build_data")
		if build_data:
			CameraManager.center_camera_on_arena(camera, build_data.dimensions_tiles)
			await get_tree().process_frame
			var terrain_builder = TerrainBuilder.new()
			terrain_builder.fill_viewport(_level_container, build_data, camera)

	_initialize_camera_shaker()
	_initialize_debug_inspector()

	var player_node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node):
		player_node.died.connect(_on_player_died)

func _unhandled_input(_event: InputEvent) -> void:
	if Input.is_action_just_pressed("debug_toggle_overlay"):
		if is_instance_valid(_debug_overlay):
			_debug_overlay.visible = not _debug_overlay.visible

	if Input.is_action_just_pressed("debug_cycle_target"):
		if is_instance_valid(_debug_overlay) and _debug_overlay.visible:
			_cycle_debug_target()

func _exit_tree() -> void:
	# This is the safety net that catches exits not handled by SceneManager.
	_cleanup_entities()

	EventBus.off(_boss_died_token)
	FXManager.unregister_camera_shaker()
	if is_instance_valid(_death_sequence_handle): _death_sequence_handle.cancel()
	if is_instance_valid(camera): camera.offset = Vector2.ZERO
	get_tree().paused = false

# --- Public Methods (ISceneController Contract) ---

func scene_exiting() -> void:
	_cleanup_entities()

# --- Private Methods ---

func _cleanup_entities() -> void:
	# This centralized function ensures all entities are properly torn down.
	var player_node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node) and player_node.has_method("teardown"):
		player_node.teardown()

	var enemy_nodes = get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY)
	for enemy in enemy_nodes:
		if is_instance_valid(enemy) and enemy.has_method("teardown"):
			enemy.teardown()

func _initialize_camera_shaker() -> void:
	var shaker_scene = load("res://src/core/systems/camera_shaker.tscn")
	if shaker_scene:
		_camera_shaker = shaker_scene.instantiate() as CameraShaker
		add_child(_camera_shaker)
		_camera_shaker.target_camera = camera
		FXManager.register_camera_shaker(_camera_shaker)

func _initialize_debug_inspector() -> void:
	_debug_overlay = load(AssetPaths.SCENE_DEBUG_OVERLAY).instantiate()
	add_child(_debug_overlay)
	_debug_overlay.visible = false
	
	_inspectable_entities.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.PLAYER))
	_inspectable_entities.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY))
	
	if not _inspectable_entities.is_empty():
		_debug_overlay.set_target(_inspectable_entities[0])

func _cycle_debug_target() -> void:
	_inspectable_entities = _inspectable_entities.filter(func(e): return is_instance_valid(e))

	if _inspectable_entities.is_empty():
		_debug_overlay.set_target(null)
		return

	_current_inspect_index = (_current_inspect_index + 1) % _inspectable_entities.size()
	var new_target = _inspectable_entities[_current_inspect_index]
	_debug_overlay.set_target(new_target)

func _deactivate_all_minions() -> void:
	var minions = get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY)
	for minion in minions:
		if minion.has_method("deactivate"):
			minion.deactivate()

# --- Signal Handlers ---

func _on_player_died() -> void:
	SceneManager.go_to_game_over()

func _on_boss_died(payload: Dictionary) -> void:
	var player_node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node): player_node.set_physics_process(false)
	var boss_node = payload.get("boss_node")

	_deactivate_all_minions()
	
	var wait_step_1 = WaitStep.new(); wait_step_1.duration = 1.0
	var wait_step_2 = WaitStep.new(); wait_step_2.duration = 1.5
	var death_sequence: Array[SequenceStep] = [wait_step_1, wait_step_2]

	_death_sequence_handle = Sequencer.run_sequence(death_sequence)
	await _death_sequence_handle.finished

	if is_instance_valid(boss_node): boss_node.queue_free()
	if is_instance_valid(_death_sequence_handle):
		SceneManager.go_to_victory()

=====================================
FILE: ./src/scenes/menus/options_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://cuiywha4vccw"]

[ext_resource type="Script" uid="uid://c7ggk7djqvf53" path="res://src/scenes/menus/options_screen.gd" id="1_options_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="OptionsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_options_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "OPTIONS"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MainVBox"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="SoundButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ControlsButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="CreditsButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/title_screen.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://beattfyix2423"]

[ext_resource type="Script" uid="uid://d0pxln7nldjne" path="res://src/scenes/menus/title_screen.gd" id="1_title_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="PackedScene" uid="uid://b1c2d3e4f5g6h" path="res://src/ui/components/logo_display/logo_display.tscn" id="3_logo_display"]
[ext_resource type="Texture2D" uid="uid://t2u26wkw02xm" path="res://assets/sprites/ui/logos/newgrounds_logo.png" id="4_logo_ng"]
[ext_resource type="Texture2D" uid="uid://2gqa4m05wd20" path="res://assets/sprites/ui/logos/godot_logo.png" id="5_logo_godot"]
[ext_resource type="Texture2D" uid="uid://d0fuu548hoouq" path="res://assets/sprites/ui/logos/itch_logo.png" id="6_logo_itch"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="7_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="8_mute_button"]

[node name="TitleScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_title_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("7_font_black")
theme_override_font_sizes/font_size = 128
text = "BOX BATTLE"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 30)
layout_mode = 2

; --- Menu Items ---
[node name="MenuItemsVBox" type="VBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="StartButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="OptionsButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExitButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

; --- Footer Logos ---
[node name="FooterHBox" type="HBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 50
alignment = 1

[node name="NewgroundsLogo" parent="MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("4_logo_ng")
logo_name = "Newgrounds"

[node name="GodotLogo" parent="MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("5_logo_godot")
logo_name = "Godot"

[node name="ItchLogo" parent="MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("6_logo_itch")
logo_name = "Itch"

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2

; --- Global UI ---
[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("8_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0

=====================================
FILE: ./src/scenes/menus/title_screen.gd
=====================================
# src/scenes/menus/title_screen.gd
## The controller for the main title screen scene.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var background_color: ColorRect = $BackgroundColor
@onready var start_button: StyledMenuItem = %StartButton
@onready var options_button: StyledMenuItem = %OptionsButton
@onready var exit_button: StyledMenuItem = %ExitButton
@onready var newgrounds_logo: LogoDisplay = %NewgroundsLogo
@onready var godot_logo: LogoDisplay = %GodotLogo
@onready var itch_logo: LogoDisplay = %ItchLogo
@onready var mute_button: MuteButton = $MuteButtonContainer/MuteButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	background_color.color = Palette.COLOR_BACKGROUND

	start_button.text = "START GAME"
	options_button.text = "OPTIONS"
	exit_button.text = "EXIT"

	if not Engine.is_editor_hint():
		# --- Connect Signals ---
		start_button.pressed.connect(_on_start_button_pressed)
		options_button.pressed.connect(_on_options_button_pressed)
		exit_button.pressed.connect(get_tree().quit)
		newgrounds_logo.pressed.connect(_on_logo_pressed)
		godot_logo.pressed.connect(_on_logo_pressed)
		itch_logo.pressed.connect(_on_logo_pressed)
		
		# Connect all pressable items to the audio handler
		start_button.pressed.connect(_on_any_item_pressed)
		options_button.pressed.connect(_on_any_item_pressed)
		exit_button.pressed.connect(_on_any_item_pressed)
		mute_button.pressed.connect(_on_any_item_pressed)
		newgrounds_logo.pressed.connect(_on_any_item_pressed)
		godot_logo.pressed.connect(_on_any_item_pressed)
		itch_logo.pressed.connect(_on_any_item_pressed)


		# --- Initialize Menu Manager ---
		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		var menu_items: Array[Control] = [start_button, options_button, exit_button]
		menu_manager.setup_menu(menu_items)

		await get_tree().process_frame
		start_button.grab_focus()

# --- Signal Handlers ---

func _on_any_item_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
	
func _on_start_button_pressed() -> void:
	SceneManager.start_game(AssetPaths.ENCOUNTER_00)

func _on_options_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)

func _on_logo_pressed(logo_name: String) -> void:
	print("%s Pressed" % logo_name)

=====================================
FILE: ./src/scenes/menus/credits_screen.gd
=====================================
# src/scenes/menus/credits_screen.gd
## The controller for the credits screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)
const CREDITS_BBCODE = """
[center]A Game By Steven Casteel[/center]
[center][url=https://www.stevencasteel.com/]www.stevencasteel.com[/url][/center]

[center]Built with the [url=https://godotengine.org/]Godot Engine[/url][/center]
[center]AI-Assisted by [url=https://gemini.google.com/]Gemini[/url][/center]

[center]Find me on [url=https://www.youtube.com/@stevencasteel]YouTube[/url] and [url=http://github.com/stevencasteel]GitHub[/url][/center]
"""

# --- Node References ---
@onready var credits_label_container: Control = %CreditsLabelContainer
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	for c in credits_label_container.get_children(): c.queue_free()

	var credits_label = RichTextLabel.new()
	credits_label.set_anchors_preset(Control.PRESET_FULL_RECT)
	credits_label.bbcode_enabled = true
	credits_label.mouse_filter = MOUSE_FILTER_PASS
	credits_label.add_theme_font_override("normal_font", load(AssetPaths.FONT_MAIN_REGULAR))
	credits_label.add_theme_font_size_override("normal_font_size", 38)
	credits_label.add_theme_color_override("default_color", Color.WHITE)
	credits_label.text = CREDITS_BBCODE
	credits_label_container.add_child(credits_label)

	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)
		credits_label.meta_clicked.connect(_on_meta_clicked)
		credits_label.meta_hover_started.connect(func(_meta): CursorManager.set_pointer_state(true))
		credits_label.meta_hover_ended.connect(func(_meta): CursorManager.set_pointer_state(false))

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Signal Handlers ---

func _on_meta_clicked(meta) -> void:
	OS.shell_open(str(meta))

func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)

=====================================
FILE: ./src/scenes/menus/sound_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://dsvv7o1v1j8t1"]

[ext_resource type="Script" uid="uid://451xh65eo2eo" path="res://src/scenes/menus/sound_screen.gd" id="1_sound_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="SoundScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_sound_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "SOUND"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 90)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/credits_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://c5v6x7y81aa0b"]

[ext_resource type="Script" uid="uid://b5n30r8nhclsb" path="res://src/scenes/menus/credits_screen.gd" id="1_credits_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="CreditsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_credits_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "CREDITS"
horizontal_alignment = 1

[node name="CreditsLabelContainer" type="Control" parent="MainVBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 450)
layout_mode = 2

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/options_screen.gd
=====================================
# src/scenes/menus/options_screen.gd
## The controller for the main options menu scene.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var sound_button: StyledMenuItem = %SoundButton
@onready var controls_button: StyledMenuItem = %ControlsButton
@onready var credits_button: StyledMenuItem = %CreditsButton
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	sound_button.text = "SOUND"
	controls_button.text = "CONTROLS"
	credits_button.text = "CREDITS"
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		# --- Connect Signals ---
		sound_button.pressed.connect(_on_sound_button_pressed)
		controls_button.pressed.connect(_on_controls_button_pressed)
		credits_button.pressed.connect(_on_credits_button_pressed)
		back_button.pressed.connect(_on_back_button_pressed)

		# --- Initialize Menu Manager ---
		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		var menu_items: Array[Control] = [sound_button, controls_button, credits_button, back_button]
		menu_manager.setup_menu(menu_items)

		await get_tree().process_frame
		sound_button.grab_focus()

# --- Signal Handlers ---

func _on_sound_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_SOUND_SCREEN)

func _on_controls_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_CONTROLS_SCREEN)

func _on_credits_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_CREDITS_SCREEN)

func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/scenes/menus/sound_screen.gd
=====================================
# src/scenes/menus/sound_screen.gd
## The controller for the sound options menu.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)
const CustomSliderScript = preload(AssetPaths.SCRIPT_CUSTOM_SLIDER)

# --- Node References ---
@onready var menu_items_vbox: VBoxContainer = %MenuItemsVBox
@onready var back_button: StyledMenuItem = %BackButton

# --- Private Member Variables ---
var _master_volume_label: Label
var _music_volume_label: Label
var _sfx_volume_label: Label
var _master_mute_checkbox: TextureButton
var _music_mute_checkbox: TextureButton
var _sfx_mute_checkbox: TextureButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	# --- Procedurally build the UI rows ---
	for c in menu_items_vbox.get_children():
		c.queue_free()
	menu_items_vbox.add_child(_create_volume_row("MASTER", Settings.master_volume, "master"))
	menu_items_vbox.add_child(_create_volume_row("MUSIC", Settings.music_volume, "music"))
	menu_items_vbox.add_child(_create_volume_row("SFX", Settings.sfx_volume, "sfx"))
	_update_ui_from_settings()

	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)
		Settings.audio_settings_changed.connect(_update_ui_from_settings)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()

func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if Settings.audio_settings_changed.is_connected(_update_ui_from_settings):
			Settings.audio_settings_changed.disconnect(_update_ui_from_settings)

# --- Private Methods ---

func _update_ui_from_settings() -> void:
	if _master_volume_label: _master_volume_label.text = str(int(Settings.master_volume * 100))
	if _music_volume_label: _music_volume_label.text = str(int(Settings.music_volume * 100))
	if _sfx_volume_label: _sfx_volume_label.text = str(int(Settings.sfx_volume * 100))
	if _master_mute_checkbox: _update_checkbox_texture(_master_mute_checkbox, Settings.master_muted)
	if _music_mute_checkbox: _update_checkbox_texture(_music_mute_checkbox, Settings.music_muted)
	if _sfx_mute_checkbox: _update_checkbox_texture(_sfx_mute_checkbox, Settings.sfx_muted)

func _create_volume_row(label_text: String, initial_volume: float, type: String) -> HBoxContainer:
	var hbox = HBoxContainer.new()
	hbox.alignment = HBoxContainer.ALIGNMENT_CENTER
	hbox.add_theme_constant_override("separation", 20)

	var row_label = Label.new()
	row_label.text = label_text
	row_label.custom_minimum_size.x = 220
	row_label.add_theme_font_override("font", load(AssetPaths.FONT_MAIN_BOLD))
	row_label.add_theme_font_size_override("font_size", 48)
	hbox.add_child(row_label)

	var slider = CustomSliderScript.new()
	slider.set_value(initial_volume)
	slider.size_flags_vertical = Control.SIZE_SHRINK_CENTER
	slider.focus_mode = FOCUS_NONE
	hbox.add_child(slider)

	var volume_label = Label.new()
	volume_label.custom_minimum_size.x = 120
	volume_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	volume_label.add_theme_font_override("font", load(AssetPaths.FONT_MAIN_REGULAR))
	volume_label.add_theme_font_size_override("font_size", 48)
	hbox.add_child(volume_label)

	var checkbox = TextureButton.new()
	checkbox.size_flags_vertical = Control.SIZE_SHRINK_CENTER
	checkbox.focus_mode = FOCUS_NONE
	hbox.add_child(checkbox)

	match type:
		"master":
			_master_volume_label = volume_label; _master_mute_checkbox = checkbox
			if not Engine.is_editor_hint():
				slider.value_changed.connect(func(val): Settings.master_volume = val)
				checkbox.pressed.connect(func(): Settings.master_muted = not Settings.master_muted)
		"music":
			_music_volume_label = volume_label; _music_mute_checkbox = checkbox
			if not Engine.is_editor_hint():
				slider.value_changed.connect(func(val): Settings.music_volume = val)
				checkbox.pressed.connect(func(): Settings.music_muted = not Settings.music_muted)
		"sfx":
			_sfx_volume_label = volume_label; _sfx_mute_checkbox = checkbox
			if not Engine.is_editor_hint():
				slider.value_changed.connect(func(val): Settings.sfx_volume = val)
				checkbox.pressed.connect(func(): Settings.sfx_muted = not Settings.sfx_muted)

	return hbox

func _update_checkbox_texture(button_ref: TextureButton, is_muted: bool) -> void:
	var new_texture = load(AssetPaths.SPRITE_CHECKBOX_UNCHECKED) if not is_muted else load(AssetPaths.SPRITE_CHECKBOX_CHECKED)
	if button_ref.texture_normal != new_texture:
		button_ref.texture_normal = new_texture

# --- Signal Handlers ---

func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)

=====================================
FILE: ./src/scenes/menus/controls_screen.gd
=====================================
# src/scenes/menus/controls_screen.gd
## The controller for the controls display screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)
const CONTROLS_DATA = [
	{ "action": "Movement", "keys": "Arrow Keys / WASD / Mouse" },
	{ "action": "Primary Action", "keys": "X / . / Space / Left-Click" },
	{ "action": "Secondary Action", "keys": "C / , / Shift / Right-Click" },
	{ "action": "Tertiary Action", "keys": "Z / / / Ctrl / Middle-Click" },
	{ "action": "Pause / Menu", "keys": "Enter / P / Escape" },
	{ "action": "Back / Cancel", "keys": "Escape / Backspace" }
]

# --- Node References ---
@onready var controls_vbox: VBoxContainer = %ControlsVBox
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	# --- Procedurally build the UI rows ---
	for c in controls_vbox.get_children(): c.queue_free()
	for data in CONTROLS_DATA:
		controls_vbox.add_child(_create_control_row(data))

	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Private Methods ---

func _create_control_row(data: Dictionary) -> HBoxContainer:
	var hbox = HBoxContainer.new()
	hbox.size_flags_horizontal = Control.SIZE_SHRINK_CENTER
	hbox.add_theme_constant_override("separation", 40)

	var action_label = Label.new()
	action_label.text = data.action
	action_label.custom_minimum_size.x = 400
	action_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	action_label.add_theme_font_override("font", load(AssetPaths.FONT_MAIN_BOLD))
	action_label.add_theme_font_size_override("font_size", 36)
	hbox.add_child(action_label)

	var keys_label = Label.new()
	keys_label.text = data.keys
	keys_label.custom_minimum_size.x = 500
	keys_label.add_theme_font_override("font", load(AssetPaths.FONT_MAIN_REGULAR))
	keys_label.add_theme_font_size_override("font_size", 36)
	hbox.add_child(keys_label)

	return hbox

# --- Signal Handlers ---

func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)

=====================================
FILE: ./src/scenes/menus/controls_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://df5wylg5n16f"]

[ext_resource type="Script" uid="uid://bm6noor4pxywc" path="res://src/scenes/menus/controls_screen.gd" id="1_controls_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="ControlsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_controls_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "CONTROLS"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2

[node name="ControlsRowHBox" type="HBoxContainer" parent="MainVBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="LeftSpacer" type="Control" parent="MainVBox/ControlsRowHBox"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_stretch_ratio = 0.8

[node name="ControlsVBox" type="VBoxContainer" parent="MainVBox/ControlsRowHBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 20
alignment = 1

[node name="RightSpacer" type="Control" parent="MainVBox/ControlsRowHBox"]
layout_mode = 2
size_flags_horizontal = 3

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/game_over/game_over_screen.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://dnlf14n0wfxm1"]

[ext_resource type="Script" uid="uid://dnkj277olbn3c" path="res://src/scenes/game_over/game_over_screen.gd" id="1_goscr"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]

[node name="GameOverScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_goscr")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.2, 0.2, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "GAME OVER"
horizontal_alignment = 1

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64


=====================================
FILE: ./src/scenes/game_over/game_over_screen.gd
=====================================
# src/scenes/game_over/game_over_screen.gd
## The controller for the "Game Over" screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	back_button.text = "BACK TO TITLE"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Signal Handlers ---

func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/scenes/main/main.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bt1c5p8wphc4a"]

[ext_resource type="Script" uid="uid://cu5lshffdfr4h" path="res://src/scenes/main/main.gd" id="1_main_script"]

[node name="Main" type="Node"]
script = ExtResource("1_main_script")


=====================================
FILE: ./src/scenes/main/main.gd
=====================================
# src/scenes/main/main.gd
## The main entry point for the entire application.
extends Node

func _ready() -> void:
	if OS.is_debug_build():
		AssetPaths.validate_all_paths()

	AudioManager.play_music(AssetPaths.MUSIC_MENU_LOOP)

	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/scenes/victory/victory_screen.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://cx6i2wt2j05y4"]

[ext_resource type="Script" uid="uid://d030qowpraecr" path="res://src/scenes/victory/victory_screen.gd" id="1_vsscr"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]

[node name="VictoryScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_vsscr")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.2, 0.8, 0.2, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "VICTORY"
horizontal_alignment = 1

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64


=====================================
FILE: ./src/scenes/victory/victory_screen.gd
=====================================
# src/scenes/victory/victory_screen.gd
## The controller for the "Victory" screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	back_button.text = "BACK TO TITLE"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Signal Handlers ---

func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/core/sequencing/sequence_step.gd
=====================================
# src/core/sequencing/sequence_step.gd
@tool
## The abstract base class for all steps in a sequence.
##
## It defines the contract that all steps must follow: an `execute` method.
class_name SequenceStep
extends Resource

# --- Virtual Methods ---

## This method is implemented by all concrete step classes. It contains the
## logic for what the step does. It can return a [Signal] or [Coroutine]
## to make the [Sequencer] pause execution.
func execute(_sequencer_node: Node) -> Variant:
	return null

=====================================
FILE: ./src/core/sequencing/sequence_handle.gd
=====================================
# src/core/sequencing/sequence_handle.gd
## A handle representing a running sequence.
##
## Allows for safe cancellation and emits a signal when the sequence is
## completed or cancelled.
class_name SequenceHandle
extends RefCounted

# --- Signals ---
## Emitted when the sequence finishes or is cancelled.
signal finished

# --- Member Variables ---
var is_running: bool = true

# --- Public Methods ---

## Cancels the execution of the associated sequence.
func cancel() -> void:
	if is_running:
		is_running = false
		finished.emit()

=====================================
FILE: ./src/core/sequencing/sequencer.gd
=====================================
# src/core/sequencing/sequencer.gd
## An autoloaded singleton that runs linear sequences of timed events.
##
## It is used for cinematic moments like boss intros. It tracks all active
## sequences and can safely cancel them, preventing errors during scene transitions.
extends Node

# --- Private Member Variables ---
var _active_handles: Array[SequenceHandle] = []

# --- Public Methods ---

## Executes a series of [SequenceStep] resources and returns a handle.
func run_sequence(steps: Array[SequenceStep]) -> SequenceHandle:
	var handle = SequenceHandle.new()
	_active_handles.append(handle)
	handle.finished.connect(_on_sequence_finished.bind(handle))

	_execute_sequence(steps, handle)
	return handle

## Immediately cancels all running sequences.
func cancel_all() -> void:
	# Iterate over a copy, as cancelling a handle modifies the original array.
	for handle in _active_handles.duplicate():
		handle.cancel()

# --- Private Methods ---

## The core async function that executes the sequence steps.
func _execute_sequence(steps: Array[SequenceStep], handle: SequenceHandle) -> void:
	if steps.is_empty():
		if handle.is_running:
			handle.is_running = false
			handle.finished.emit()
		return

	for step in steps:
		if not handle.is_running: return # Stop if cancelled

		if not step is SequenceStep:
			push_warning("Sequencer: Invalid step found. Skipping.")
			continue

		var awaitable = await step.execute(self)
		if awaitable:
			await awaitable

	if handle.is_running:
		handle.is_running = false
		handle.finished.emit()

# --- Signal Handlers ---

## Cleans up a finished or cancelled sequence from the tracking array.
func _on_sequence_finished(handle_to_remove: SequenceHandle) -> void:
	var index = _active_handles.find(handle_to_remove)
	if index != -1:
		_active_handles.remove_at(index)

=====================================
FILE: ./src/core/sequencing/steps/emit_step.gd
=====================================
# src/core/sequencing/steps/emit_step.gd
@tool
## A sequence step that emits an event on the global [EventBus].
class_name EmitStep
extends SequenceStep

# --- Editor Properties ---
@export var event_name: StringName = &""
@export var payload: Variant = null

# --- Virtual Methods ---

func execute(_sequencer_node: Node) -> Variant:
	if event_name == &"":
		push_warning("EmitStep: 'event_name' is not set.")
		return null
	EventBus.emit(event_name, payload)
	return null

=====================================
FILE: ./src/core/sequencing/steps/callable_step.gd
=====================================
# src/core/sequencing/steps/callable_step.gd
@tool
## A sequence step that executes a [Callable].
class_name CallableStep
extends SequenceStep

# --- Editor Properties ---
@export var callable: Callable

# --- Virtual Methods ---

func execute(_sequencer_node: Node) -> Variant:
	if callable.is_valid():
		# Await the result of the call. If the function is async, this will
		# pause the sequence until it completes.
		var result = await callable.call()
		# If the function itself returns ANOTHER awaitable (like a Signal),
		# return it to the sequencer to be awaited as well.
		if result is Signal or (typeof(result) == TYPE_OBJECT and result.has_method("is_valid")):
			return result
	else:
		push_warning("CallableStep: 'callable' is not set or is invalid.")

	return null

=====================================
FILE: ./src/core/sequencing/steps/wait_step.gd
=====================================
# src/core/sequencing/steps/wait_step.gd
@tool
## A sequence step that pauses execution for a set duration.
class_name WaitStep
extends SequenceStep

# --- Editor Properties ---
@export var duration: float = 1.0

# --- Virtual Methods ---

func execute(sequencer_node: Node) -> Variant:
	if duration > 0.0:
		# Return the timer's 'timeout' signal for the sequencer to await.
		return sequencer_node.get_tree().create_timer(duration).timeout
	return null

=====================================
FILE: ./src/core/util/combat_utils.gd
=====================================
# src/core/util/combat_utils.gd
## An autoloaded singleton containing static helper functions for combat logic.
extends Node

# --- Static Functions ---

## Traverses up the scene tree from a given node to find the first node that
## implements the IDamageable interface (i.e., has an `apply_damage` method).
## This is the canonical way to find a valid damage target from a collision.
static func find_damageable(from_node: Node) -> Node:
	if not is_instance_valid(from_node):
		return null

	var current_node = from_node
	while is_instance_valid(current_node):
		if current_node.has_method("apply_damage"):
			return current_node

		# HealthComponent is the primary implementer, check for it directly.
		var hc = current_node.get_node_or_null("HealthComponent")
		if is_instance_valid(hc) and hc.has_method("apply_damage"):
			return hc

		current_node = current_node.get_parent()

	return null

=====================================
FILE: ./src/core/util/grid_utils.gd
=====================================
# src/core/util/grid_utils.gd
## An autoloaded singleton providing a single source of truth for all conversions
## between the logical tile grid and world-space pixel coordinates.
extends Node

# --- Static Functions ---

## Converts a grid coordinate (e.g., [Vector2i(2, 3)]) to a world position.
static func grid_to_world(tile_pos: Vector2i, tile_size: int = Constants.TILE_SIZE) -> Vector2:
	var half_tile = tile_size / 2.0
	return Vector2(tile_pos.x * tile_size + half_tile, tile_pos.y * tile_size + half_tile)

## Converts a world position (in pixels) to its corresponding grid coordinate.
static func world_to_grid(world_pos: Vector2, tile_size: int = Constants.TILE_SIZE) -> Vector2i:
	return Vector2i(floor(world_pos.x / tile_size), floor(world_pos.y / tile_size))

=====================================
FILE: ./src/core/util/physics_layers.gd
=====================================
# src/core/util/physics_layers.gd
## An autoloaded singleton that provides named constants for the 2D physics
## layers defined in the project settings.
##
## This prevents the use of "magic numbers" for collision layers and masks.
extends Node

# --- Layer Constants ---
const PLAYER = 1           # Layer 1
const PLATFORMS = 2        # Layer 2
const ENEMY = 4            # Layer 3
const HAZARD = 8           # Layer 4
const ENEMY_PROJECTILE = 16  # Layer 5
const PLAYER_HITBOX = 32   # Layer 6
const PLAYER_HURTBOX = 64  # Layer 7
const SOLID_WORLD = 128    # Layer 8

=====================================
FILE: ./src/core/util/scene_validator.gd
=====================================
# src/core/util/scene_validator.gd
@tool
## A central utility for validating scene configurations in the editor.
##
## Its functions are static, allowing them to be called from any @tool script
## to provide configuration warnings in the Godot editor.
class_name SceneValidator
extends Object

# --- Static Validation Functions ---

## Validates a node to ensure it meets the BaseBoss contract.
static func validate_boss_scene(node: Node) -> PackedStringArray:
	var warnings = PackedStringArray()

	if not node.has_node("HealthComponent"):
		warnings.append("A HealthComponent node is required.")
	if not node.has_node("StateMachine"):
		warnings.append("A StateMachine node is required.")
	if not node.has_node("ArmorComponent"):
		warnings.append("An ArmorComponent node is required.")

	if node.get("phase_1_patterns") == null or node.get("phase_1_patterns").is_empty():
		warnings.append("Phase 1 has no attack patterns assigned. The boss will be unable to attack.")

	return warnings

=====================================
FILE: ./src/core/util/palette.gd
=====================================
# src/core/util/palette.gd
## An autoloaded singleton that holds the project's master color palette.
##
## It establishes a single source of truth for all visual elements, ensuring a
## cohesive aesthetic based on a 32-step grayscale value scale.
extends Node

# --- Private Member Variables ---
const _palette: Array[Color] = [
	Color("#000000"), Color("#080808"), Color("#101010"), Color("#191919"),
	Color("#212121"), Color("#292929"), Color("#313131"), Color("#3a3a3a"),
	Color("#424242"), Color("#4a4a4a"), Color("#525252"), Color("#5a5a5a"),
	Color("#636363"), Color("#6b6b6b"), Color("#737373"), Color("#7b7b7b"),
	Color("#848484"), Color("#8c8c8c"), Color("#949494"), Color("#9c9c9c"),
	Color("#a5a5a5"), Color("#adadad"), Color("#b5b5b5"), Color("#bdbdbd"),
	Color("#c5c5c5"), Color("#cecece"), Color("#d6d6d6"), Color("#dedede"),
	Color("#e6e6e6"), Color("#efefef"), Color("#f7f7f7"), Color("#ffffff")
]

# --- Semantic Constants ---
# Use these constants in code, not raw palette indices.
# This makes the code readable and easy to theme.

# Gameplay
const COLOR_PLAYER: Color = _palette[31]
const COLOR_BOSS_PRIMARY: Color = _palette[30]
const COLOR_PLAYER_PROJECTILE: Color = _palette[29]
const COLOR_HAZARD_PRIMARY: Color = _palette[28] # Also Enemy Projectiles

# Environment
const COLOR_BACKGROUND: Color = _palette[0]
const COLOR_GRID: Color = _palette[2]
const COLOR_TERRAIN_PRIMARY: Color = _palette[4]
const COLOR_TERRAIN_SECONDARY: Color = _palette[6]

# UI/UX
const COLOR_TEXT_HEADER: Color = _palette[30]
const COLOR_UI_ACCENT_PRIMARY: Color = _palette[28]
const COLOR_TEXT_PRIMARY: Color = _palette[26]
const COLOR_TEXT_DISABLED: Color = _palette[16]
const COLOR_UI_GLOW: Color = _palette[20]
const COLOR_UI_PANEL_BG: Color = _palette[8]

# --- Public Methods ---
## Provides a safe way to get a color by its raw index if needed.
func get_color(index: int) -> Color:
	if index >= 0 and index < _palette.size():
		return _palette[index]
	push_warning("Palette: Invalid color index requested: %d" % index)
	return Color.MAGENTA # Return a highly visible error color

=====================================
FILE: ./src/core/util/identifiers.gd
=====================================
# src/core/util/identifiers.gd
## An autoloaded singleton that provides a central authority for all string-based
## identifiers used in the project, such as group names and pool keys.
##
## Using these constants prevents bugs caused by typos in raw strings.
extends Node

## A container for all physics group names.
## Usage: Identifiers.Groups.PLAYER
class Groups:
	const PLAYER = "player"
	const ENEMY = "enemy"
	const WORLD = "world"
	const HAZARD = "hazard"
	const ONEWAY_PLATFORMS = "oneway_platforms"
	const PLAYER_PROJECTILE = "player_projectile"
	const ENEMY_PROJECTILE = "enemy_projectile"

## A container for all ObjectPool keys.
## Usage: Identifiers.Pools.PLAYER_SHOTS
class Pools:
	const PLAYER_SHOTS = &"player_shots"
	const BOSS_SHOTS = &"boss_shots"
	const TURRET_SHOTS = &"turret_shots"
	const HOMING_BOSS_SHOTS = &"homing_boss_shots"
	const HIT_SPARKS = &"hit_sparks"

=====================================
FILE: ./src/core/util/asset_paths.gd
=====================================
# src/core/util/asset_paths.gd
## An autoloaded singleton containing verified, static paths to all critical assets.
##
## Using these constants prevents runtime errors from typos in string paths and
## provides a central place to manage asset locations. Includes a validation
## system to check for missing files at startup in debug builds.
extends Node

# --- CORE SYSTEMS ---
const SCRIPT_COMBAT_UTILS = "res://src/core/util/combat_utils.gd"
const SCENE_MAIN = "res://src/scenes/main/main.tscn"
const SCENE_ENCOUNTER = "res://src/scenes/game/encounter_scene.tscn"
const SCENE_LOADING_SCREEN = "res://src/scenes/loading/loading_screen.tscn"
const SCRIPT_MENU_MANAGER = "res://src/ui/menu_manager/menu_manager.gd"
const SCRIPT_CUSTOM_SLIDER = "res://src/ui/components/custom_slider/custom_slider.gd"

# --- DATA ---
const ENCOUNTER_00 = "res://src/data/encounters/encounter_00.tres"

# --- PLAYER & RELATED ---
const SCENE_PLAYER = "res://src/entities/player/player.tscn"
const SCENE_PLAYER_SHOT = "res://src/projectiles/player_shot.tscn"

# --- BOSS, MINIONS & RELATED ---
const SCENE_BASE_BOSS = "res://src/entities/boss/base_boss.tscn"
const SCENE_BOSS_SHOT = "res://src/projectiles/boss_shot.tscn"
const SCENE_HOMING_BOSS_SHOT = "res://src/projectiles/homing_boss_shot.tscn"
const SCENE_TELEGRAPH_COMPONENT = "res://src/entities/components/telegraph_component.tscn"
const SCENE_TURRET = "res://src/entities/minions/turret.tscn"
const SCENE_TURRET_SHOT = "res://src/projectiles/turret_shot.tscn"

# --- UI & SCENES ---
const SCENE_GAME_HUD = "res://src/ui/game_hud/game_hud.tscn"
const SCENE_GAME_OVER_SCREEN = "res://src/scenes/game_over/game_over_screen.tscn"
const SCENE_VICTORY_SCREEN = "res://src/scenes/victory/victory_screen.tscn"
const SCENE_TITLE_SCREEN = "res://src/scenes/menus/title_screen.tscn"
const SCENE_OPTIONS_SCREEN = "res://src/scenes/menus/options_screen.tscn"
const SCENE_SOUND_SCREEN = "res://src/scenes/menus/sound_screen.tscn"
const SCENE_CONTROLS_SCREEN = "res://src/scenes/menus/controls_screen.tscn"
const SCENE_CREDITS_SCREEN = "res://src/scenes/menus/credits_screen.tscn"

# --- UI COMPONENTS ---
const SCENE_STYLED_MENU_ITEM = "res://src/ui/components/styled_menu_item/styled_menu_item.tscn"
const SCENE_LOGO_DISPLAY = "res://src/ui/components/logo_display/logo_display.tscn"
const SCENE_MUTE_BUTTON = "res://src/ui/components/mute_button/mute_button.tscn"

# --- DEV TOOLS ---
const SCENE_DEBUG_OVERLAY = "res://src/ui/dev/debug_overlay.tscn"

# --- VFX ---
const SCENE_HIT_SPARK = "res://src/vfx/hit_spark.tscn"

# --- SPRITES & ICONS ---
const SPRITE_CURSOR_DEFAULT = "res://assets/sprites/ui/cursors/sprite_cursor_default.png"
const SPRITE_CURSOR_POINTER = "res://assets/sprites/ui/cursors/sprite_cursor_pointer.png"
const SPRITE_SLIDER_TRACK = "res://assets/sprites/ui/slider/slider-track.png"
const SPRITE_SLIDER_KNOB = "res://assets/sprites/ui/slider/slider-knob.png"
const SPRITE_CHECKBOX_CHECKED = "res://assets/sprites/ui/checkbox/checkbox-checked.png"
const SPRITE_CHECKBOX_UNCHECKED = "res://assets/sprites/ui/checkbox/checkbox-unchecked.png"
const ICON_UI_SOUND_ON = "res://assets/sprites/ui/icons/icon_ui_sound_on.png"
const ICON_UI_SOUND_OFF = "res://assets/sprites/ui/icons/icon_ui_sound_off.png"

# --- FONTS ---
const FONT_MAIN_BLACK = "res://assets/fonts/font_main_black.ttf"
const FONT_MAIN_BOLD = "res://assets/fonts/font_main_bold.ttf"
const FONT_MAIN_REGULAR = "res://assets/fonts/font_main_regular.ttf"

# --- AUDIO ---
const MUSIC_MENU_LOOP = "res://assets/audio/music/music_menu_loop.mp3"
const SFX_UI_BACK = "res://assets/audio/sfx/sfx_ui_back.mp3"
const SFX_UI_ERROR = "res://assets/audio/sfx/sfx_ui_error.mp3"
const SFX_UI_MOVE = "res://assets/audio/sfx/sfx_ui_move.mp3"
const SFX_UI_SELECT = "res://assets/audio/sfx/sfx_ui_select.mp3"
const SFX_GAME_START = "res://assets/audio/sfx/sfx_game_start.mp3"


# --- Validation System ---
## Checks all defined paths to ensure the files exist on disk.
func validate_all_paths() -> void:
	print("AssetPaths: Validating all asset paths...")
	var constants = get_script().get_script_constant_map()
	var missing_assets = false

	for key in constants:
		var value = constants[key]
		if value is String and value.begins_with("res://"):
			if not FileAccess.file_exists(value):
				push_error("Asset path validation failed! File not found for '%s': %s" % [key, value])
				missing_assets = true

	if not missing_assets:
		print("AssetPaths: All paths validated successfully.")

=====================================
FILE: ./src/core/util/constants.gd
=====================================
# src/core/util/constants.gd
## An autoloaded singleton for true global constants that define the
## project's foundational architecture or core system limits.
##
## GUIDELINE: Only add values here that are fundamental and unlikely to
## ever change. Gameplay tuning values belong in [CombatConfig].
extends Node

# --- Audio ---
## The number of simultaneous sound effects that can be played at once.
const NUM_SFX_PLAYERS = 8

# --- Arena Design ---
## The universal size (width and height) of a single grid tile in pixels.
const TILE_SIZE = 50

=====================================
FILE: ./src/core/README.md
=====================================
# Core Subsystem

This directory contains all of the project's global systems, singletons, and core logic that is not specific to a single entity or scene.

## Subdirectories

-   **/building**: Contains the classes responsible for procedural level generation (`ArenaBuilder`, `LevelParser`, etc.).
-   **/data**: Manages game data, including the new `Resource`-based configurations.
-   **/events**: Contains the global `EventBus` and all typed event definitions.
-   **/sequencing**: Manages the `Sequencer` for creating scripted, timed events.
-   **/systems**: Contains the primary global managers (`AudioManager`, `GameManager`, etc.).
-   **/util**: A collection of stateless utility singletons like `AssetPaths` and `Palette`.

## Autoloaded Singletons (Global Access)

The following scripts are registered as autoloads in `project.godot` and can be accessed globally:

-   `Settings`: Manages persistent game settings.
-   `AudioManager`: Controls all audio playback.
-   `CursorManager`: Manages the custom mouse cursor.
-   `Constants`: Holds engine-level constants.
-   `AssetPaths`: Provides safe, static paths to all project assets.
-   `GlobalHud`: The persistent UI layer for global elements.
-   `GameManager`: Manages game state and scene flow.
-   `ArenaBuilder`: The main entry point for level construction.
-   `EventBus`: The global event dispatcher.
-   `Sequencer`: Manages timed event sequences.
-   `Config`: Handles loading data from `Resource`-based configs.
-   `Palette`: Defines the global color scheme.
-   `ObjectPool`: Manages reusable nodes to improve performance.
-   `PhysicsLayers`: Provides named constants for physics collision layers.

## Public API

The primary public API for inter-system communication is the `EventBus`. Systems should emit events to signal state changes and listen for events to react to them, rather than calling each other directly.

=====================================
FILE: ./src/core/events/event_bus.gd
=====================================
# src/core/events/event_bus.gd
## An autoloaded singleton that provides a global event dispatch system.
##
## This allows for loosely-coupled communication between disparate parts of the
## codebase, such as between gameplay systems and the UI.
extends Node

# --- Private Member Variables ---
var _subscribers: Dictionary = {}
var _by_id: Dictionary = {}
var _next_id: int = 1

# --- Godot Lifecycle Methods ---

func _exit_tree() -> void:
	# Clear all subscriptions to break potential cyclic references on exit.
	_subscribers.clear()
	_by_id.clear()

# --- Public Methods ---

## Subscribes a callback to a specific event. Returns a token ID for unsubscribing.
func on(event_name: StringName, callback: Callable) -> int:
	assert(callback.is_valid(), "EventBus.on: callback must be a valid Callable")

	var subs: Array = _subscribers.get(event_name, [])
	var owner_node = callback.get_object()
	var weak_ref = weakref(owner_node) if owner_node is Node else null

	var entry := {
		"id": _next_id, "callback": callback, "owner_weak": weak_ref,
	}
	subs.append(entry)
	_subscribers[event_name] = subs

	_by_id[_next_id] = event_name # Map the token ID back to the event name
	_next_id += 1
	return entry.id

## Unsubscribes from an event using the token returned by on().
func off(token: int) -> void:
	if not _by_id.has(token): return

	var event_name: StringName = _by_id[token]
	if _subscribers.has(event_name):
		var subs = _subscribers[event_name]
		for i in range(subs.size() - 1, -1, -1):
			if subs[i].id == token:
				subs.remove_at(i)
				break
		if subs.is_empty():
			_subscribers.erase(event_name)

	_by_id.erase(token)

## Emits an event to all subscribers.
func emit(event_name: StringName, payload = null) -> void:
	if not _subscribers.has(event_name): return

	var subs: Array = _subscribers[event_name]
	# Iterate backwards to safely remove dead references during the loop.
	for i in range(subs.size() - 1, -1, -1):
		var sub = subs[i]

		# Auto-prune subscriptions whose owner nodes have been freed.
		if sub.owner_weak and not sub.owner_weak.get_ref():
			_by_id.erase(sub.id)
			subs.remove_at(i)
			continue

		sub.callback.call(payload)

	if subs.is_empty():
		_subscribers.erase(event_name)

=====================================
FILE: ./src/core/events/typed_events/boss_health_changed_event.gd
=====================================
# src/core/events/typed_events/boss_health_changed_event.gd
## A typed payload for the [constant EventCatalog.BOSS_HEALTH_CHANGED] event.
class_name BossHealthChangedEvent
extends Resource

@export var current_health: int = 0
@export var max_health: int = 0

=====================================
FILE: ./src/core/events/typed_events/player_health_changed_event.gd
=====================================
# src/core/events/typed_events/player_health_changed_event.gd
## A typed payload for the [constant EventCatalog.PLAYER_HEALTH_CHANGED] event.
class_name PlayerHealthChangedEvent
extends Resource

@export var current_health: int = 0
@export var max_health: int = 0

=====================================
FILE: ./src/core/events/typed_events/player_healing_charges_changed_event.gd
=====================================
# src/core/events/typed_events/player_healing_charges_changed_event.gd
## A typed payload for the [constant EventCatalog.PLAYER_HEALING_CHARGES_CHANGED] event.
class_name PlayerHealingChargesChangedEvent
extends Resource

@export var current_charges: int = 0

=====================================
FILE: ./src/core/events/event_catalog.gd
=====================================
# src/core/events/event_catalog.gd
## A central, canonical list of all event names in the project.
##
## By using these constants instead of raw strings (e.g., [code]EventBus.emit(EventCatalog.PLAYER_DIED)[/code]),
## we gain IDE autocompletion and prevent typos that lead to silent runtime failures.
class_name EventCatalog
extends Object

# --- Player Events ---
const PLAYER_HEALTH_CHANGED = "player.health_changed"
const PLAYER_HEALING_CHARGES_CHANGED = "player.healing_charges_changed"

# --- Boss / Entity Events ---
const BOSS_HEALTH_CHANGED = "boss.health_changed"
const BOSS_DIED = "boss.died"
const BOSS_PHASE_CHANGED = "boss.phase_changed"

# --- UI State Events ---
const MENU_OPENED = "ui.menu_opened"
const MENU_CLOSED = "ui.menu_closed"

=====================================
FILE: ./src/core/systems/camera_shaker.gd
=====================================
# src/core/systems/camera_shaker.gd
## A self-contained component that applies a procedural shake to a target Camera2D.
##
## It uses Perlin noise to generate a smooth, decaying shake effect by manipulating
## the target camera's `offset` property.
class_name CameraShaker
extends Node

# --- Public Member Variables ---
## A reference to the Camera2D node this shaker will control.
var target_camera: Camera2D = null

# --- Private Member Variables ---
var _noise := FastNoiseLite.new()
var _noise_y_offset: float = 0.0 # Use a different seed for the y-axis
var _shake_duration: float = 0.0
var _shake_timer: float = 0.0
var _shake_amplitude: float = 0.0
var _shake_frequency: float = 0.0

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	_noise.noise_type = FastNoiseLite.TYPE_PERLIN
	_noise.seed = randi()
	_noise_y_offset = randf() * 1000.0

func _process(delta: float) -> void:
	if not is_instance_valid(target_camera): return

	if _shake_timer > 0:
		_shake_timer -= delta
		if _shake_timer <= 0:
			target_camera.offset = Vector2.ZERO
		else:
			var decay_progress: float = 1.0 - (_shake_timer / _shake_duration)
			var current_amplitude: float = _shake_amplitude * (1.0 - decay_progress)

			var time: float = Time.get_ticks_msec() * (_shake_frequency / 1000.0)
			var noise_x: float = _noise.get_noise_2d(time, 0)
			var noise_y: float = _noise.get_noise_2d(time, _noise_y_offset)

			target_camera.offset.x = noise_x * current_amplitude
			target_camera.offset.y = noise_y * current_amplitude
	else:
		target_camera.offset = Vector2.ZERO

# --- Public API ---

func start_shake(effect: ScreenShakeEffect) -> void:
	if not is_instance_valid(effect):
		push_error("CameraShaker: Invalid ScreenShakeEffect resource provided.")
		return

	_shake_amplitude = effect.amplitude
	_shake_frequency = effect.frequency
	_shake_duration = effect.duration
	_shake_timer = _shake_duration

=====================================
FILE: ./src/core/systems/camera_manager.gd
=====================================
# src/core/systems/camera_manager.gd
## An autoloaded singleton responsible for all camera logic.
extends Node

# --- Public Methods ---

## Centers the camera on the arena for a pixel-perfect setup.
func center_camera_on_arena(camera: Camera2D, arena_size_tiles: Vector2i) -> void:
	if not is_instance_valid(camera):
		push_error("CameraManager: Invalid Camera2D provided.")
		return

	var arena_pixel_size = Vector2(arena_size_tiles) * Constants.TILE_SIZE
	camera.position = arena_pixel_size / 2.0

=====================================
FILE: ./src/core/systems/dialogue_manager.gd
=====================================
# src/core/systems/dialogue_manager.gd
## An autoloaded singleton for managing and displaying dialogue.
##
## It will be responsible for loading [DialogueData] resources and commanding
## a UI scene to display the conversation line by line.
extends Node

# --- Private Member Variables ---
var _dialogue_box_instance: Control = null
var _is_dialogue_active: bool = false

# --- Public Methods ---

## Starts a conversation using the data from a [DialogueData] resource.
func start_conversation(_p_data: DialogueData) -> void:
	assert(false, "DialogueManager.start_conversation() is not yet implemented.")
	pass

# TODO: Add a method to advance the dialogue (e.g., on player input).
# func advance_dialogue() -> void:

# TODO: Add a method to properly instance and display the dialogue box UI.
# func _show_dialogue_box() -> void:

# TODO: Add a method to clean up and hide the dialogue box UI.
# func _hide_dialogue_box() -> void:

=====================================
FILE: ./src/core/systems/game_manager.gd
=====================================
# src/core/systems/game_manager.gd
## An autoloaded singleton that manages the state of the game session.
##
## It holds a reference to a [GameStateData] resource, which acts as the
## single source of truth for all runtime session data.
extends Node

# --- Constants ---
const GameStateDataScript = preload("res://src/core/data/game_state_data.gd")

# --- Public Member Variables ---
## The active [GameStateData] resource for the current session.
var state: GameStateData = null

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	# Create a new, clean instance of the game state every time the
	# GameManager is initialized at game startup.
	state = GameStateDataScript.new()

func _exit_tree() -> void:
	# Manually release our reference to the state resource. This allows
	# Godot's garbage collector to free it, preventing memory leaks on exit.
	if is_instance_valid(state):
		state = null

=====================================
FILE: ./src/core/systems/scene_manager.gd
=====================================
# src/core/systems/scene_manager.gd
## A centralized singleton for handling all scene transitions.
##
## This provides a robust, single API for navigation and ensures that
## necessary cleanup (like resetting the ObjectPool) happens automatically.
extends Node

# --- Public API ---

## Generic method to transition to any scene by its path.
func go_to_scene(path: String) -> void:
	_switch_to_scene(path)

## Transitions to the main title screen.
func go_to_title_screen() -> void:
	go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

## Starts a new game with a specific encounter.
func start_game(encounter_path: String) -> void:
	GameManager.state.current_encounter_path = encounter_path
	go_to_scene(AssetPaths.SCENE_LOADING_SCREEN)

## Transitions to the game over screen.
func go_to_game_over() -> void:
	go_to_scene(AssetPaths.SCENE_GAME_OVER_SCREEN)

## Transitions to the victory screen.
func go_to_victory() -> void:
	go_to_scene(AssetPaths.SCENE_VICTORY_SCREEN)

# --- Private Methods ---

## The core scene-switching logic.
func _switch_to_scene(path: String) -> void:
	# --- Perform Pre-Transition Cleanup ---
	# 1. Call the formal teardown method on the current scene controller if it exists.
	var current_scene = get_tree().current_scene
	if is_instance_valid(current_scene) and current_scene.has_method("scene_exiting"):
		await current_scene.scene_exiting()

	# 2. Reset global systems.
	ObjectPool.reset()
	Sequencer.cancel_all()

	# 3. Change the scene.
	get_tree().call_deferred("change_scene_to_file", path)

=====================================
FILE: ./src/core/systems/object_pool.gd
=====================================
# src/core/systems/object_pool.gd
## An autoloaded singleton that manages pools of reusable nodes.
##
## This system prevents performance degradation (stutter) from frequent
## instantiation and deletion of nodes like projectiles and visual effects.
extends Node

# --- Private Member Variables ---
var _pools: Dictionary = {}

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	_create_pool_for_scene(Identifiers.Pools.PLAYER_SHOTS, load(AssetPaths.SCENE_PLAYER_SHOT), 15)
	_create_pool_for_scene(Identifiers.Pools.BOSS_SHOTS, load(AssetPaths.SCENE_BOSS_SHOT), 30)
	_create_pool_for_scene(Identifiers.Pools.TURRET_SHOTS, load(AssetPaths.SCENE_TURRET_SHOT), 20)
	_create_pool_for_scene(Identifiers.Pools.HOMING_BOSS_SHOTS, load(AssetPaths.SCENE_HOMING_BOSS_SHOT), 40)
	_create_pool_for_scene(Identifiers.Pools.HIT_SPARKS, load(AssetPaths.SCENE_HIT_SPARK), 25)

func _exit_tree() -> void:
	# When the game quits, forcefully free all pooled objects and their containers
	# to ensure all associated rendering resources (RIDs) are released.
	for i in range(get_child_count() - 1, -1, -1):
		var child = get_child(i)
		for j in range(child.get_child_count() - 1, -1, -1):
			child.get_child(j).free()
		child.free()
	_pools.clear()

# --- Public Methods ---

## Returns a dictionary containing the active/total counts for each pool.
func get_pool_stats() -> Dictionary:
	var stats: Dictionary = {}
	for pool_name in _pools:
		var pool = _pools[pool_name]
		var total_count = pool.container.get_child_count()
		var inactive_count = pool.inactive.size()
		stats[pool_name] = {
			"active": total_count - inactive_count,
			"total": total_count
		}
	return stats

## Returns all active instances in all pools to their inactive state.
func reset() -> void:
	for pool_name in _pools:
		var pool = _pools[pool_name]
		var active_nodes_to_return: Array[Node] = []
		for child in pool.container.get_children():
			if not pool.inactive.has(child):
				active_nodes_to_return.append(child)
		
		for node in active_nodes_to_return:
			return_instance.call_deferred(node)

## Retrieves an inactive instance from the specified pool.
func get_instance(p_pool_name: StringName) -> Node:
	if not _pools.has(p_pool_name):
		push_error("ObjectPool: Pool '%s' does not exist." % p_pool_name)
		return null

	var pool = _pools[p_pool_name]
	var instance: Node

	if not pool.inactive.is_empty():
		instance = pool.inactive.pop_front()
	else:
		instance = pool.scene.instantiate()
		instance.set_meta("pool_name", p_pool_name)
		pool.container.add_child(instance)

	return instance

## Returns an active instance to its pool.
func return_instance(p_instance: Node) -> void:
	if not is_instance_valid(p_instance): return

	var pool_name = p_instance.get_meta("pool_name", "")
	if pool_name == "" or not _pools.has(pool_name):
		p_instance.queue_free()
		return

	var pool = _pools[pool_name]
	if not pool.inactive.has(p_instance):
		pool.inactive.push_front(p_instance)

	if p_instance.has_method("deactivate"):
		p_instance.deactivate()

# --- Private Methods ---

func _create_pool_for_scene(p_pool_name: StringName, p_scene: PackedScene, p_initial_size: int) -> void:
	if _pools.has(p_pool_name): return

	var pool_container = Node.new()
	pool_container.name = p_pool_name
	add_child(pool_container)

	_pools[p_pool_name] = {
		"scene": p_scene,
		"inactive": [],
		"container": pool_container
	}

	for i in range(p_initial_size):
		var instance = p_scene.instantiate()
		instance.set_meta("pool_name", p_pool_name)
		pool_container.add_child(instance)
		if instance.has_method("deactivate"):
			instance.deactivate()
		_pools[p_pool_name].inactive.append(instance)

=====================================
FILE: ./src/core/systems/audio_manager.gd
=====================================
# src/core/systems/audio_manager.gd
## An autoloaded singleton responsible for all audio playback.
##
## Manages separate channels for music and sound effects, and responds
## dynamically to changes in the global [Settings] resource. It includes
## robust cleanup handlers to prevent memory leaks on game exit.
extends Node

# --- Private Member Variables ---
var _sfx_players: Array[AudioStreamPlayer] = []
var _sfx_player_index: int = 0
var _music_player: AudioStreamPlayer

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	# --- Create SFX Players ---
	for i in range(Constants.NUM_SFX_PLAYERS):
		var player = AudioStreamPlayer.new()
		player.name = "SFXPlayer_%d" % i
		player.bus = "SFX"
		add_child(player)
		_sfx_players.append(player)

	# --- Create Music Player ---
	_music_player = AudioStreamPlayer.new()
	_music_player.name = "MusicPlayer"
	_music_player.bus = "Music"
	add_child(_music_player)

	# --- Connect to Settings ---
	Settings.audio_settings_changed.connect(_on_audio_settings_changed)
	_on_audio_settings_changed() # Apply initial settings

func _notification(what: int) -> void:
	# A robust, system-level notification for cleaning up before the app quits.
	if what == NOTIFICATION_WM_CLOSE_REQUEST:
		if is_instance_valid(_music_player):
			_music_player.stop()
			_music_player.stream = null

func _exit_tree() -> void:
	# Disconnect from the signal to be a good citizen.
	if Settings.audio_settings_changed.is_connected(_on_audio_settings_changed):
		Settings.audio_settings_changed.disconnect(_on_audio_settings_changed)

	# Secondary cleanup method for when the node is removed from the tree.
	if is_instance_valid(_music_player):
		_music_player.stop()
		_music_player.stream = null

# --- Public Methods ---

## Plays a one-shot sound effect.
func play_sfx(sound_path: String) -> void:
	var player = _sfx_players[_sfx_player_index]
	player.stream = load(sound_path)
	player.play()
	_sfx_player_index = (_sfx_player_index + 1) % Constants.NUM_SFX_PLAYERS

## Plays a looping music track.
func play_music(music_path: String) -> void:
	if _music_player.stream and _music_player.stream.resource_path == music_path and _music_player.playing:
		return

	_music_player.stream = load(music_path)
	_music_player.play()

## Stops the current music track.
func stop_music() -> void:
	_music_player.stop()

# --- Signal Handlers ---

func _on_audio_settings_changed() -> void:
	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Master"), linear_to_db(Settings.master_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Master"), Settings.master_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Music"), linear_to_db(Settings.music_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Music"), Settings.music_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("SFX"), linear_to_db(Settings.sfx_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("SFX"), Settings.sfx_muted)

=====================================
FILE: ./src/core/systems/fx_bindings/fullscreen_shader_binding.gd
=====================================
# src/core/systems/fx_bindings/fullscreen_shader_binding.gd
class_name FullscreenShaderBinding
extends CanvasLayer

# TODO: Manage a full-screen ColorRect to apply and animate post-processing shaders.


=====================================
FILE: ./src/core/systems/fx_bindings/ui_shader_binding.gd
=====================================
# src/core/systems/fx_bindings/ui_shader_binding.gd
class_name UIShaderBinding
extends Node

# TODO: Manage applying shader effects to UI Control nodes.


=====================================
FILE: ./src/core/systems/camera_shaker.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://camera_shaker_scene_id"]

[ext_resource type="Script" path="res://src/core/systems/camera_shaker.gd" id="1_shaker_script"]

[node name="CameraShaker" type="Node"]
script = ExtResource("1_shaker_script")

=====================================
FILE: ./src/core/systems/cursor_manager.gd
=====================================
# src/core/systems/cursor_manager.gd
## An autoloaded singleton that manages the game's custom "fake" cursor.
##
## This provides full control over the cursor's appearance and ensures it
## renders above all other UI and game elements.
extends CanvasLayer

# --- Constants ---
const CURSOR_DEFAULT = preload(AssetPaths.SPRITE_CURSOR_DEFAULT)
const CURSOR_POINTER = preload(AssetPaths.SPRITE_CURSOR_POINTER)

# --- Private Member Variables ---
var _cursor_sprite: TextureRect

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	# A high layer number ensures the cursor renders above everything else.
	layer = 10
	Input.set_mouse_mode(Input.MOUSE_MODE_HIDDEN)

	_cursor_sprite = TextureRect.new()
	_cursor_sprite.texture = CURSOR_DEFAULT
	# CRITICAL: This makes the cursor "click-through," so it never blocks
	# mouse events intended for UI elements underneath it.
	_cursor_sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE
	add_child(_cursor_sprite)

func _process(_delta: float) -> void:
	# Sync the custom cursor's position to the real mouse position every frame.
	_cursor_sprite.position = get_viewport().get_mouse_position()

# --- Public Methods ---

## Sets the cursor's appearance (e.g., when hovering a button).
func set_pointer_state(is_pointing: bool) -> void:
	if is_pointing:
		_cursor_sprite.texture = CURSOR_POINTER
	else:
		_cursor_sprite.texture = CURSOR_DEFAULT

=====================================
FILE: ./src/core/systems/fx_manager.gd
=====================================
# src/core/systems/fx_manager.gd
## An autoloaded singleton to handle purely aesthetic "game feel" effects.
##
## This separates feedback like hit-stop and screen shake from core gameplay
## logic, improving modularity and adhering to SRP.
extends Node

# --- Private Member Variables ---
var _is_hit_stop_active: bool = false
var _camera_shaker: CameraShaker = null

# --- Public Methods ---

## Stores a reference to the active CameraShaker in the scene.
func register_camera_shaker(shaker: CameraShaker) -> void:
	_camera_shaker = shaker

## Clears the reference to the CameraShaker when the scene changes.
func unregister_camera_shaker() -> void:
	_camera_shaker = null

## The main public API for triggering a screen shake effect.
func request_screen_shake(shake_effect: ScreenShakeEffect) -> void:
	if is_instance_valid(_camera_shaker):
		_camera_shaker.start_shake(shake_effect)
	else:
		push_warning("FXManager: request_screen_shake called, but no CameraShaker is registered.")

## The main public API for spawning a visual effect from the object pool.
func play_vfx(effect: VFXEffect, global_position: Vector2, direction: Vector2 = Vector2.ZERO) -> void:
	if not is_instance_valid(effect):
		push_warning("FXManager: play_vfx called with an invalid VFXEffect resource.")
		return

	if effect.pool_key == &"":
		push_warning("FXManager: VFXEffect resource is missing a 'pool_key'.")
		return

	var vfx_instance = ObjectPool.get_instance(effect.pool_key)
	if not is_instance_valid(vfx_instance):
		push_error("FXManager: Failed to get instance for pool key '%s'." % effect.pool_key)
		return

	vfx_instance.global_position = global_position

	if vfx_instance.has_method("activate"):
		vfx_instance.call("activate", direction)

## The main public API for triggering a shader-based effect.
func play_shader(effect: ShaderEffect, target_node: Node, _options: Dictionary = {}) -> void:
	if not is_instance_valid(effect) or not is_instance_valid(target_node):
		push_warning("FXManager.play_shader: Invalid effect or target node provided.")
		return

	match effect.target_scope:
		# ENTITY scope is now handled directly by FXComponent.
		ShaderEffect.TargetScope.UI:
			print("FXManager: Playing UI shader on ", target_node.name)
			# TODO: Implement UIShaderBinding logic
		ShaderEffect.TargetScope.FULLSCREEN:
			print("FXManager: Playing FULLSCREEN shader.")
			# TODO: Implement FullscreenShaderBinding logic
		_:
			push_error("FXManager: Unknown ShaderEffect.TargetScope.")

## Pauses the entire game tree for a short duration to add impact to an event.
func request_hit_stop(duration: float) -> void:
	if _is_hit_stop_active:
		return

	_is_hit_stop_active = true
	get_tree().paused = true

	var timer = get_tree().create_timer(duration, true, false, true)
	await timer.timeout

	if get_tree().paused and _is_hit_stop_active:
		get_tree().paused = false
		_is_hit_stop_active = false


=====================================
FILE: ./src/core/data/config/settings.gd
=====================================
# src/core/data/config/settings.gd
## An autoloaded singleton that manages persistent game settings.
##
## This script uses property setters to automatically emit the
## [signal audio_settings_changed] signal whenever a value is modified,
## allowing other systems to react dynamically.
extends Node

# --- Signals ---
## Emitted whenever any audio-related setting is changed.
signal audio_settings_changed

# --- Audio Settings ---
@export var master_volume: float = 1.0:
	set(value):
		var clamped_value = clampf(value, 0.0, 1.0)
		if not is_equal_approx(master_volume, clamped_value):
			master_volume = clamped_value
			audio_settings_changed.emit()

@export var music_volume: float = 1.0:
	set(value):
		var clamped_value = clampf(value, 0.0, 1.0)
		if not is_equal_approx(music_volume, clamped_value):
			music_volume = clamped_value
			audio_settings_changed.emit()

@export var sfx_volume: float = 1.0:
	set(value):
		var clamped_value = clampf(value, 0.0, 1.0)
		if not is_equal_approx(sfx_volume, clamped_value):
			sfx_volume = clamped_value
			audio_settings_changed.emit()

@export var master_muted: bool = false:
	set(value):
		if master_muted != value:
			master_muted = value
			audio_settings_changed.emit()

@export var music_muted: bool = true:
	set(value):
		if music_muted != value:
			music_muted = value
			audio_settings_changed.emit()

@export var sfx_muted: bool = false:
	set(value):
		if sfx_muted != value:
			sfx_muted = value
			audio_settings_changed.emit()

=====================================
FILE: ./src/core/data/config/combat_config.gd
=====================================
# src/core/data/config/combat_config.gd
@tool
## A single, flat Resource that exposes all gameplay tuning values.
##
## This allows designers to balance the game directly in the Godot Inspector
## using organized, range-limited sliders.
class_name CombatConfig
extends Resource

@export_group("Player - Health & Resources")
@export_range(1, 20, 1) var player_max_health: int = 5
@export_range(1, 10, 1) var player_max_healing_charges: int = 1
@export_range(0.1, 5.0, 0.1) var player_heal_duration: float = 2.0
@export_range(1, 100, 1) var player_determination_per_charge: int = 10
@export_range(0.1, 5.0, 0.1) var player_invincibility_duration: float = 1.5

@export_group("Player - Movement & Physics")
@export_range(100, 1000, 5) var player_speed: float = 450.0
@export_range(200, 1500, 10) var player_jump_force: float = 680.0
@export_range(0.1, 1.0, 0.05) var player_jump_release_dampener: float = 0.4
@export_range(0.0, 0.5, 0.01) var player_coyote_time: float = 0.1
@export_range(0.0, 0.5, 0.01) var player_jump_buffer: float = 0.1
@export_range(1.0, 3.0, 0.1) var player_fast_fall_gravity_multiplier: float = 1.4
@export var player_max_air_jumps: int = 1

@export_group("Player - Wall Interaction")
@export_range(50, 500, 5) var player_wall_slide_speed: float = 120.0
@export_range(0.0, 0.5, 0.01) var player_wall_coyote_time: float = 0.05
@export_range(500, 2500, 50) var player_wall_jump_force_x: float = 1650.0
@export_range(200, 1500, 10) var player_wall_jump_force_y: float = 680.0

@export_group("Player - Dash")
@export_range(500, 2500, 50) var player_dash_speed: float = 1400.0
@export_range(0.05, 0.5, 0.01) var player_dash_duration: float = 0.15
@export_range(0.1, 2.0, 0.05) var player_dash_cooldown: float = 0.5

@export_group("Player - Combat")
@export var player_forward_attack_shape: Shape2D
@export var player_upward_attack_shape: Shape2D
@export_range(0.05, 1.0, 0.01) var player_attack_cooldown: float = 0.12
@export_range(0.05, 0.5, 0.01) var player_attack_duration: float = 0.1
@export_range(100, 5000, 100) var player_attack_friction: float = 2000.0
@export_range(0.1, 1.0, 0.01) var player_charge_time: float = 0.35
@export_range(200, 1000, 10) var player_pogo_force: float = 450.0
@export_range(100, 1500, 25) var player_knockback_speed: float = 400.0
@export_range(0.05, 0.5, 0.01) var player_knockback_duration: float = 0.1
@export_range(100, 1500, 25) var player_hazard_knockback_speed: float = 400.0
@export_range(10, 200, 5) var player_close_range_threshold: float = 75.0

@export_group("Boss - General")
@export_range(10, 500, 5) var boss_health: int = 30
@export_range(50, 500, 5) var boss_patrol_speed: float = 100.0
@export_range(0.0, 2.0, 0.01) var boss_invincibility_duration: float = 0.1

@export_group("Boss - Lunge Attack")
@export_range(500, 3000, 50) var boss_lunge_speed: float = 1200.0

@export_group("Minion - Turret")
@export_range(0.5, 5.0, 0.1) var turret_fire_rate: float = 2.0
@export_range(100, 1000, 10) var turret_detection_radius: float = 400.0

@export_group("Projectiles")
@export_range(1, 20, 1) var homing_shot_damage: int = 1
@export_range(100, 1000, 10) var homing_shot_speed: float = 250.0
@export_range(1.0, 20.0, 0.5) var homing_shot_lifespan: float = 10.0

@export_group("Global - Physics")
@export_range(500, 3000, 10) var gravity: float = 1200.0

@export_group("Global - Juice & Feedback (Hit-Stop)")
@export_range(0.0, 0.5, 0.01) var player_melee_close_range_hit_stop_duration: float = 0.025
@export_range(0.0, 0.5, 0.01) var player_damage_taken_hit_stop_duration: float = 0.04
@export_range(0.0, 1.0, 0.01) var boss_phase_change_hit_stop_duration: float = 0.1
@export_range(0.0, 1.0, 0.01) var boss_death_hit_stop_duration: float = 0.2

=====================================
FILE: ./src/core/data/game_state_data.gd
=====================================
# src/core/data/game_state_data.gd
## A Resource that holds all shared runtime state for the game session.
class_name GameStateData
extends Resource

# --- Member Variables ---
## The full 'res://' path to the [EncounterData] resource for the current level.
var current_encounter_path: String = ""
## A reference to the fully constructed, but currently hidden, level node.
var prebuilt_level: Node = null

=====================================
FILE: ./src/core/data/effects/player_damage_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://player_damage_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 12.0
frequency = 35.0
duration = 0.3

=====================================
FILE: ./src/core/data/effects/dissolve_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" format=3]

# TODO: Configure this resource to define the dissolve effect.


=====================================
FILE: ./src/core/data/effects/boss_death_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_death_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 40.0
frequency = 10.0
duration = 1.2

=====================================
FILE: ./src/core/data/effects/shockwave_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" format=3]

# TODO: Configure this resource to define the shockwave effect.


=====================================
FILE: ./src/core/data/effects/player_hit_spark_effect.tres
=====================================
[gd_resource type="Resource" script_class="VFXEffect" load_steps=3 format=3 uid="uid://player_hit_spark_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/vfx_effect.gd" id="1_vfx_effect"]
[ext_resource type="PackedScene" uid="uid://c8g7f6e5d4b3a" path="res://src/vfx/hit_spark.tscn" id="2_hit_spark_scene"]

[resource]
script = ExtResource("1_vfx_effect")

; --- Configuration ---
scene = ExtResource("2_hit_spark_scene")
pool_key = &"hit_sparks"

=====================================
FILE: ./src/core/data/effects/boss_phase_change_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_phase_change_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 25.0
frequency = 12.0
duration = 0.8

=====================================
FILE: ./src/core/data/effects/screen_shake_effect.gd
=====================================
# src/core/data/effects/screen_shake_effect.gd
@tool
## A data resource that defines the properties of a screen shake effect.
##
## This allows for the creation of reusable, designer-tunable shake assets.
class_name ScreenShakeEffect
extends Resource

## The maximum offset in pixels. Higher values create a more intense shake.
@export_range(0.0, 100.0, 1.0) var amplitude: float = 10.0

## The speed of the shake. Higher values create a more frantic shake.
@export_range(0.1, 50.0, 0.1) var frequency: float = 15.0

## The total duration of the shake effect in seconds.
@export_range(0.1, 5.0, 0.05) var duration: float = 0.5

=====================================
FILE: ./src/core/data/effects/shader_effect.gd
=====================================
# src/core/data/effects/shader_effect.gd
@tool
## A data resource that defines a "recipe" for a shader-based visual effect.
##
## This allows the FXManager to treat shaders as reusable, configurable assets,
## just like particle effects or screen shakes.
class_name ShaderEffect
extends Resource

## The scope determines where the shader will be applied.
enum TargetScope {
	ENTITY,     # Applied to a single entity's visual node.
	UI,         # Applied to a single UI control.
	FULLSCREEN  # Applied to the entire screen.
}

# --- Editor Properties ---
## The actual ShaderMaterial resource to be applied.
@export var material: ShaderMaterial

## The duration of the effect in seconds. A value of 0 means it runs indefinitely
## until manually stopped.
@export_range(0.0, 5.0, 0.01) var duration: float = 0.15

## A priority level to resolve conflicts if multiple effects are triggered at once.
## Higher numbers have higher priority.
@export var priority: int = 0

## The target scope for this effect.
@export var target_scope: TargetScope = TargetScope.ENTITY

## A dictionary of uniform parameters to be passed to the shader.
## Example: { "intensity": 1.0, "tint_color": Color.RED }
@export var params: Dictionary = {}

=====================================
FILE: ./src/core/data/effects/vfx_effect.gd
=====================================
# src/core/data/effects/vfx_effect.gd
@tool
## A data resource that defines a "recipe" for a visual effect.
##
## It tells the FXManager which scene to retrieve from which ObjectPool.
## This allows for the creation of reusable, data-driven visual effects.
class_name VFXEffect
extends Resource

## The PackedScene of the visual effect to be instanced from the pool.
@export var scene: PackedScene

## The StringName key for the ObjectPool where this VFX scene is stored.
@export var pool_key: StringName = &""

=====================================
FILE: ./src/core/DEPRECATION.md
=====================================
# Core Subsystem Deprecation Map

This document tracks file renames and moves specifically within `src/core`.

| Old Path | New Path | Reason | Date | Migration Note |
|---|---|---|---|---|
| `res://src/core/data/Config.gd` | `res://src/core/data/config/config.gd` | Naming convention and grouping. | 2025-08-10 | Autoload path was updated in `project.godot`. |
| `res://src/core/data/settings.gd` | `res://src/core/data/config/settings.gd` | Grouped with other data configs. | 2025-08-10 | Autoload path was updated in `project.godot`. |

=====================================
FILE: ./src/core/building/level_parser.gd
=====================================
# src/core/building/level_parser.gd
@tool
## Parses an [EncounterData] resource into a [LevelBuildData] object.
##
## This class is responsible for translating the character-based layout
## into structured data that the builders can use.
class_name LevelParser
extends RefCounted

# --- Constants ---
const GridUtilsScript = preload("res://src/core/util/grid_utils.gd")

# --- Public Methods ---

## Parses the provided [EncounterData] and returns a populated [LevelBuildData].
func parse_level_data(encounter_data: EncounterData) -> LevelBuildData:
	var data = LevelBuildData.new()
	if not is_instance_valid(encounter_data):
		push_error("LevelParser: Invalid EncounterData provided.")
		return data

	var layout: LevelLayout = encounter_data.level_layout
	if not is_instance_valid(layout):
		push_error("LevelParser: EncounterData is missing a valid LevelLayout.")
		return data

	var terrain_data_array: PackedStringArray = layout.terrain_data
	var grid_height: int = terrain_data_array.size()
	var grid_width: int = 0
	if grid_height > 0: grid_width = terrain_data_array[0].length()
	data.dimensions_tiles = Vector2i(grid_width, grid_height)

	var player_marker: String = encounter_data.player_spawn_marker
	var boss_marker: String = encounter_data.boss_spawn_marker
	var minion_spawn_dict: Dictionary = encounter_data.minion_spawns

	for y in range(grid_height):
		var row_string: String = terrain_data_array[y]
		for x in range(row_string.length()):
			var tile_char: String = row_string[x]
			var tile_grid_pos = Vector2i(x, y)
			var tile_world_pos = GridUtilsScript.grid_to_world(tile_grid_pos)

			match tile_char:
				"#": data.terrain_tiles.append(tile_world_pos)
				"-": data.oneway_platforms.append(tile_world_pos)
				"^": data.hazard_tiles.append(tile_world_pos)
				".": data.background_tiles.append(tile_grid_pos)
				_:
					data.background_tiles.append(tile_grid_pos)
					if tile_char == player_marker:
						data.player_spawn_pos = tile_world_pos
					elif tile_char == boss_marker:
						data.boss_spawn_pos = tile_world_pos
					elif minion_spawn_dict.has(tile_char):
						var scene_to_spawn: PackedScene = minion_spawn_dict[tile_char]
						var spawn_data = LevelBuildData.MinionSpawnData.new(scene_to_spawn, tile_world_pos)
						data.minion_spawns.append(spawn_data)
	return data


=====================================
FILE: ./src/core/building/terrain_builder.gd
=====================================
# src/core/building/terrain_builder.gd
@tool
## Responsible for creating all static level geometry nodes.
##
## This includes solid walls, one-way platforms, hazards, and background tiles.
## It uses [Polygon2D] for in-game visuals to prevent conflicts with debug drawing.
class_name TerrainBuilder
extends Node

# --- Constants ---
const GridUtilsScript = preload("res://src/core/util/grid_utils.gd")

# --- Public Methods ---

## Asynchronously creates all terrain nodes defined in the [LevelBuildData].
func build_terrain_async(parent_node: Node, build_data: LevelBuildData, tree: SceneTree) -> void:
	const BATCH_SIZE = 20

	for i in range(build_data.terrain_tiles.size()):
		_create_solid_tile(parent_node, build_data.terrain_tiles[i])
		if i % BATCH_SIZE == 0: await tree.process_frame

	for i in range(build_data.oneway_platforms.size()):
		_create_oneway_platform(parent_node, build_data.oneway_platforms[i])
		if i % BATCH_SIZE == 0: await tree.process_frame

	for i in range(build_data.hazard_tiles.size()):
		_create_hazard_tile(parent_node, build_data.hazard_tiles[i])
		if i % BATCH_SIZE == 0: await tree.process_frame

	await tree.process_frame

## Procedurally fills the camera's viewport with background grid tiles.
func fill_viewport(parent_node: Node, build_data: LevelBuildData, camera: Camera2D) -> void:
	var view_transform = camera.get_viewport().get_canvas_transform().affine_inverse()
	var world_top_left = view_transform.origin
	var world_bottom_right = world_top_left + camera.get_viewport_rect().size * view_transform.get_scale()

	var grid_top_left: Vector2i = GridUtilsScript.world_to_grid(world_top_left)
	var grid_bottom_right: Vector2i = GridUtilsScript.world_to_grid(world_bottom_right)

	var existing_bg_tiles = {}
	for pos in build_data.background_tiles:
		existing_bg_tiles[pos] = true

	for y in range(grid_top_left.y, grid_bottom_right.y + 1):
		for x in range(grid_top_left.x, grid_bottom_right.x + 1):
			var grid_pos = Vector2i(x, y)
			if not existing_bg_tiles.has(grid_pos):
				_create_background_tile(parent_node, grid_pos)

# --- Private Methods ---

func _create_background_tile(parent_node: Node, grid_pos: Vector2i) -> void:
	var visual_rect = ColorRect.new()
	visual_rect.color = Palette.COLOR_GRID
	visual_rect.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	visual_rect.position = Vector2(grid_pos) * Constants.TILE_SIZE
	parent_node.add_child(visual_rect)
	parent_node.move_child(visual_rect, 0)

func _create_solid_tile(parent_node: Node, pos: Vector2) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = PhysicsLayers.SOLID_WORLD
	static_body.add_to_group(Identifiers.Groups.WORLD)

	var collision_shape := CollisionShape2D.new()
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)

	var visual_poly := Polygon2D.new()
	var half_size = Constants.TILE_SIZE / 2.0
	visual_poly.polygon = PackedVector2Array([
		Vector2(-half_size, -half_size), Vector2(half_size, -half_size),
		Vector2(half_size, half_size), Vector2(-half_size, half_size)
	])
	visual_poly.color = Palette.COLOR_TERRAIN_PRIMARY
	static_body.add_child(visual_poly)

	parent_node.add_child(static_body)

func _create_oneway_platform(parent_node: Node, pos: Vector2) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = PhysicsLayers.PLATFORMS
	static_body.add_to_group(Identifiers.Groups.WORLD)
	static_body.add_to_group(Identifiers.Groups.ONEWAY_PLATFORMS)

	var collision_shape := CollisionShape2D.new()
	collision_shape.one_way_collision = true
	var rectangle_shape := RectangleShape2D.new()
	var platform_height = 10.0
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, platform_height)
	collision_shape.shape = rectangle_shape
	collision_shape.position.y = -(Constants.TILE_SIZE / 2.0) + (rectangle_shape.size.y / 2.0)
	static_body.add_child(collision_shape)

	var visual_poly := Polygon2D.new()
	var half_width = Constants.TILE_SIZE / 2.0
	var half_height = platform_height / 2.0
	visual_poly.position = collision_shape.position
	visual_poly.polygon = PackedVector2Array([
		Vector2(-half_width, -half_height), Vector2(half_width, -half_height),
		Vector2(half_width, half_height), Vector2(-half_width, half_height)
	])
	visual_poly.color = Palette.COLOR_TERRAIN_SECONDARY
	static_body.add_child(visual_poly)

	parent_node.add_child(static_body)

func _create_hazard_tile(parent_node: Node, pos: Vector2) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = PhysicsLayers.HAZARD | PhysicsLayers.SOLID_WORLD
	static_body.add_to_group(Identifiers.Groups.WORLD)
	static_body.add_to_group(Identifiers.Groups.HAZARD)

	var collision_shape := CollisionShape2D.new()
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)

	var visual_poly := Polygon2D.new()
	var half_size = Constants.TILE_SIZE / 2.0
	visual_poly.polygon = PackedVector2Array([
		Vector2(-half_size, -half_size), Vector2(half_size, -half_size),
		Vector2(half_size, half_size), Vector2(-half_size, half_size)
	])
	visual_poly.color = Palette.COLOR_HAZARD_PRIMARY
	static_body.add_child(visual_poly)

	parent_node.add_child(static_body)

=====================================
FILE: ./src/core/building/level_build_data.gd
=====================================
# src/core/building/level_build_data.gd
@tool
## A custom Resource that acts as a data container for a parsed level.
##
## It holds all the necessary information for the [ArenaBuilder] to construct
## the level, including tile positions and entity spawn points.
class_name LevelBuildData
extends Resource

# --- Inner Classes ---
## A simple data container for a single minion spawn.
class MinionSpawnData extends RefCounted:
	var scene: PackedScene
	var position: Vector2
	func _init(p_scene: PackedScene, p_pos: Vector2) -> void:
		scene = p_scene
		position = p_pos

# --- Member Variables ---
var terrain_tiles: Array[Vector2] = []
var oneway_platforms: Array[Vector2] = []
var hazard_tiles: Array[Vector2] = []
var background_tiles: Array[Vector2i] = []
var player_spawn_pos: Vector2 = Vector2.ZERO
var boss_spawn_pos: Vector2 = Vector2.ZERO
var encounter_data_resource: EncounterData = null
var dimensions_tiles: Vector2i = Vector2i.ZERO
var minion_spawns: Array[MinionSpawnData] = []

=====================================
FILE: ./src/core/building/arena_builder.gd
=====================================
# src/core/building/arena_builder.gd
## An autoload that procedurally constructs the entire level scene.
##
## It parses data from [EncounterData] and [LevelLayout] resources, then uses
## builder sub-systems to spawn the terrain, entities, and UI.
extends Node

# --- Private Member Variables ---
var _current_build_data: LevelBuildData
var _current_level_container: Node
var _intro_sequence_handle: SequenceHandle
var _minion_spawn_counts: Dictionary = {}

# --- Public Methods ---

## Asynchronously builds the entire level and returns the root node.
func build_level_async() -> Node:
	if is_instance_valid(_intro_sequence_handle): _intro_sequence_handle.cancel()
	_intro_sequence_handle = null
	_minion_spawn_counts.clear() # THE FIX: Reset counts for each new build.

	_current_level_container = Node.new(); _current_level_container.name = "LevelContainer"

	var encounter_path: String = GameManager.state.current_encounter_path
	if encounter_path.is_empty(): return _current_level_container

	var encounter_data: EncounterData = load(encounter_path)
	if not is_instance_valid(encounter_data):
		push_error("ArenaBuilder: Failed to load EncounterData at path: %s" % encounter_path)
		return _current_level_container

	var parser = LevelParser.new()
	_current_build_data = parser.parse_level_data(encounter_data)
	_current_build_data.encounter_data_resource = encounter_data
	_current_level_container.set_meta("build_data", _current_build_data)

	await get_tree().process_frame

	var terrain_builder = TerrainBuilder.new()
	await terrain_builder.build_terrain_async(_current_level_container, _current_build_data, get_tree())

	await _spawn_player_async()
	await _spawn_hud_async()
	await _spawn_minions_async()

	_intro_sequence_handle = _run_intro_sequence()
	if is_instance_valid(_intro_sequence_handle):
		await _intro_sequence_handle.finished

	await get_tree().process_frame

	return _current_level_container

# --- Private Methods ---

func _spawn_player_async() -> void:
	var instance = load(AssetPaths.SCENE_PLAYER).instantiate()
	instance.global_position = _current_build_data.player_spawn_pos
	_current_level_container.add_child(instance)
	await get_tree().process_frame

func _spawn_boss_async() -> Node:
	var boss_scene: PackedScene = _current_build_data.encounter_data_resource.boss_scene
	if not boss_scene: return null
	var instance = boss_scene.instantiate()
	instance.global_position = _current_build_data.boss_spawn_pos
	_current_level_container.add_child(instance)
	await get_tree().process_frame
	return instance

func _spawn_hud_async() -> void:
	var instance = load(AssetPaths.SCENE_GAME_HUD).instantiate()
	_current_level_container.add_child(instance)
	await get_tree().process_frame

func _spawn_minions_async() -> void:
	for spawn_data in _current_build_data.minion_spawns:
		var instance = spawn_data.scene.instantiate()
		
		# THE FIX: Programmatically assign a unique, sequential name.
		var base_name = instance.name
		var current_count = _minion_spawn_counts.get(base_name, 0) + 1
		_minion_spawn_counts[base_name] = current_count
		instance.name = "%s_%d" % [base_name, current_count]
		
		instance.global_position = spawn_data.position
		_current_level_container.add_child(instance)
		await get_tree().process_frame

func _run_intro_sequence() -> SequenceHandle:
	var wait_step = WaitStep.new(); wait_step.duration = 0.5
	var spawn_boss_step = CallableStep.new()
	spawn_boss_step.callable = Callable(self, "_spawn_boss_async")
	var intro_steps: Array[SequenceStep] = [wait_step, spawn_boss_step]
	return Sequencer.run_sequence(intro_steps)


=====================================
FILE: ./src/tests/unit/test_input_component.gd
=====================================
# src/tests/unit/test_input_component.gd
extends GutTest

# --- Constants ---
const Player = preload("res://src/entities/player/player.tscn")
const InputComponent = preload("res://src/entities/components/input_component.gd")
const CombatConfig = preload("res://data/combat_config.tres")

# --- Test Internals ---
var _player: Player
var _input_component: InputComponent

# --- Test Lifecycle ---

func before_each():
	# We need a real Player to host the component.
	_player = Player.instantiate()
	add_child(_player)
	_input_component = _player.get_node("InputComponent")
	
	# Manually call setup since we are not running the full game scene.
	_input_component.setup(_player, {
		"data_resource": _player.p_data,
		"state_machine": _player.state_machine,
		"config": CombatConfig
	})
	
	await get_tree().process_frame

func after_each():
	# Ensure all simulated actions are released to prevent state leakage between tests.
	Input.action_release("ui_right")
	Input.action_release("ui_attack")

	if is_instance_valid(_player):
		_player.free()

# --- The Tests ---

func test_move_axis_is_buffered_correctly():
	# Simulate pressing the "right" action.
	Input.action_press("ui_right")
	# Manually call the component's physics process to update its buffer.
	_input_component._physics_process(0.016)
	
	assert_eq(_input_component.buffer.get("move_axis"), 1.0, "Move axis should be 1.0 when 'ui_right' is pressed.")
	
	# Simulate releasing the action.
	Input.action_release("ui_right")
	_input_component._physics_process(0.016)
	
	assert_eq(_input_component.buffer.get("move_axis"), 0.0, "Move axis should be 0.0 when 'ui_right' is released.")

func test_action_just_pressed_is_buffered_for_one_frame():
	# THE FIX: Simulate pressing the correct action ("ui_attack") to match the assertion.
	Input.action_press("ui_attack")
	_input_component._physics_process(0.016)
	
	assert_true(_input_component.buffer.get("attack_just_pressed", false), "attack_just_pressed should be true on the frame it is pressed.")
	
	# THE FIX: Yield to the engine to allow the Input singleton to update its state.
	await get_tree().process_frame
	_input_component._physics_process(0.016)
	
	assert_false(_input_component.buffer.get("attack_just_pressed", false), "attack_just_pressed should be false on subsequent frames.")
	
	Input.action_release("ui_attack")

func test_action_released_is_buffered_for_one_frame():
	Input.action_press("ui_attack")
	_input_component._physics_process(0.016) # Frame 1: Pressed
	await get_tree().process_frame
	
	_input_component._physics_process(0.016) # Frame 2: Held
	assert_false(_input_component.buffer.get("attack_released", false), "attack_released should be false while the action is held.")
	
	# Now, simulate the release.
	Input.action_release("ui_attack")
	_input_component._physics_process(0.016) # Frame 3: Released
	assert_true(_input_component.buffer.get("attack_released", false), "attack_released should be true on the frame it is released.")
	
	# THE FIX: Yield to the engine to allow the Input singleton to update its state.
	await get_tree().process_frame
	_input_component._physics_process(0.016) # Frame 4: After release
	
	assert_false(_input_component.buffer.get("attack_released", false), "attack_released should be false on the frame after it is released.")

=====================================
FILE: ./src/tests/unit/test_player_resource_component.gd
=====================================
# src/tests/unit/test_player_resource_component.gd
extends GutTest

# --- Constants ---
const Player = preload("res://src/entities/player/player.tscn")
const PlayerResourceComponent = preload("res://src/entities/player/components/player_resource_component.gd")
const CombatConfig = preload("res://data/combat_config.tres")
const EventCatalog = preload("res://src/core/events/event_catalog.gd")
# NOTE: We DO NOT preload the EventBus script. We use the global singleton instance.

# --- Test Internals ---
var _player: Player
var _resource_component: PlayerResourceComponent
var _healing_charge_event_fired: bool = false
var _event_token: int

# --- Test Lifecycle ---

func before_each():
	_healing_charge_event_fired = false
	_player = partial_double(Player).instantiate()
	add_child(_player)

	_resource_component = _player.get_node("PlayerResourceComponent")
	var dependencies = { "data_resource": _player.p_data }
	_resource_component.setup(_player, dependencies)

	# Subscribe our local handler to the real EventBus singleton instance
	_event_token = EventBus.on(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, Callable(self, "_on_healing_charges_changed"))

func after_each():
	# Disconnect from the EventBus to prevent test leakage
	EventBus.off(_event_token)
	_player.queue_free()

# --- The Tests ---

func test_on_damage_dealt_increments_determination():
	var initial_determination = _player.p_data.determination_counter
	_resource_component.on_damage_dealt()
	assert_eq(_player.p_data.determination_counter, initial_determination + 1, "Determination should increment by 1.")

func test_healing_charge_gained_at_threshold():
	_player.p_data.healing_charges = 0
	_player.p_data.determination_counter = CombatConfig.player_determination_per_charge - 1

	_resource_component.on_damage_dealt()

	assert_eq(_player.p_data.healing_charges, 1, "Should gain 1 healing charge at the threshold.")
	assert_eq(_player.p_data.determination_counter, 0, "Determination should reset to 0 after gaining a charge.")

func test_healing_charges_are_capped():
	_player.p_data.healing_charges = CombatConfig.player_max_healing_charges
	_player.p_data.determination_counter = CombatConfig.player_determination_per_charge - 1

	_resource_component.on_damage_dealt()

	assert_eq(_player.p_data.healing_charges, CombatConfig.player_max_healing_charges, "Healing charges should not exceed the max.")
	assert_eq(_player.p_data.determination_counter, CombatConfig.player_determination_per_charge - 1, "Determination should not increment if charges are already at max.")

func test_event_emitted_when_charge_gained():
	_player.p_data.healing_charges = 0
	_player.p_data.determination_counter = CombatConfig.player_determination_per_charge - 1

	_resource_component.on_damage_dealt()
	
	await get_tree().process_frame

	assert_true(_healing_charge_event_fired, "Should emit PLAYER_HEALING_CHARGES_CHANGED event.")

# --- Signal Handlers ---

func _on_healing_charges_changed(_payload):
	_healing_charge_event_fired = true

=====================================
FILE: ./src/tests/unit/test_health_component.gd
=====================================
# src/tests/unit/test_health_component.gd
extends GutTest

# --- Constants ---
const HealthComponent = preload("res://src/entities/components/health_component.gd")
const Player = preload("res://src/entities/player/player.tscn")
const DamageInfo = preload("res://src/api/combat/damage_info.gd")
const CombatConfig = preload("res://data/combat_config.tres")
const Identifiers = preload("res://src/core/util/identifiers.gd")

# --- Test Internals ---
var _player: Player
var _health_component: HealthComponent
var _damage_source: Node2D
var _died_signal_was_emitted: bool = false

# --- Test Lifecycle ---

func before_each():
	_died_signal_was_emitted = false
	# We use a partial_double to prevent the Player's own _ready function from running.
	_player = partial_double(Player).instantiate()
	_player.name = "TestPlayer"
	_player.add_to_group(Identifiers.Groups.PLAYER)
	add_child(_player)

	# We must manually ready the component since the Player's _ready is stubbed.
	_health_component = _player.get_node("HealthComponent")
	_health_component._ready()

	# Manually call setup with our test dependencies.
	var dependencies = {
		"data_resource": _player.p_data,
		"config": CombatConfig
	}
	_health_component.setup(_player, dependencies)

	_damage_source = Node2D.new()
	add_child(_damage_source)

func after_each():
	if is_instance_valid(_health_component) and _health_component.died.is_connected(_on_health_component_died):
		_health_component.died.disconnect(_on_health_component_died)

	# THE FIX: Use free() instead of queue_free() for immediate cleanup in a test context.
	if is_instance_valid(_player):
		_player.free()
	if is_instance_valid(_damage_source):
		_damage_source.free()

# --- The Tests ---

func test_initial_health_is_max_health():
	assert_eq(_player.p_data.health, _player.p_data.max_health, "Health should be max at start.")

func test_apply_damage_reduces_health():
	var initial_health = _player.p_data.health
	var damage_info = DamageInfo.new()
	damage_info.amount = 2
	damage_info.source_node = _damage_source

	var result = _health_component.apply_damage(damage_info)
	
	assert_true(result.was_damaged, "The apply_damage result should indicate damage was taken.")
	assert_eq(_player.p_data.health, initial_health - 2, "Health should be reduced by 2.")

func test_cannot_damage_when_invincible():
	var damage_info = DamageInfo.new()
	damage_info.amount = 1
	damage_info.source_node = _damage_source
	_health_component.apply_damage(damage_info)
	
	assert_true(_player.p_data.is_invincible, "Player should be invincible after first hit.")
	
	var result = _health_component.apply_damage(damage_info)
	assert_false(result.was_damaged, "Should not be able to take damage while invincible.")
	assert_eq(_player.p_data.health, _player.p_data.max_health - 1, "Health should not have changed on second hit.")

func test_died_signal_emitted_when_health_is_zero():
	var damage_info = DamageInfo.new()
	damage_info.amount = _player.p_data.max_health
	damage_info.source_node = _damage_source

	_health_component.died.connect(_on_health_component_died)
	_health_component.apply_damage(damage_info)
	await get_tree().physics_frame

	assert_true(_died_signal_was_emitted, "The 'died' signal should have been emitted.")
	assert_eq(_player.p_data.health, 0, "Health should be 0 after lethal damage.")

# --- Signal Handlers ---

func _on_health_component_died():
	_died_signal_was_emitted = true

=====================================
FILE: ./src/tests/unit/test_memory_leaks.gd
=====================================
# src/tests/unit/test_memory_leaks.gd
extends GutTest

const PlayerScene = preload("res://src/entities/player/player.tscn")

# This test verifies that instantiating and freeing the Player scene does not
# result in a net increase of objects in memory.
func test_player_scene_does_not_leak_objects_on_free():
	await get_tree().process_frame
	var pre_count = Performance.get_monitor(Performance.OBJECT_COUNT)

	var player = PlayerScene.instantiate()
	add_child(player)
	await get_tree().process_frame

	# THE FIX: Explicitly call the player's own public teardown method before freeing.
	player.teardown()
	player.free()
	await get_tree().process_frame

	var post_count = Performance.get_monitor(Performance.OBJECT_COUNT)
	assert_eq(post_count, pre_count, "Object count should return to baseline after freeing the player. If not, a leak has occurred in Player.gd's cleanup.")

=====================================
FILE: ./src/tests/unit/test_object_pool.gd
=====================================
# src/tests/unit/test_object_pool.gd
extends GutTest

var object_pool: ObjectPool
const POOL_KEY = Identifiers.Pools.PLAYER_SHOTS

func before_each():
	object_pool = get_node("/root/ObjectPool")
	object_pool.reset()
	await get_tree().process_frame

func test_get_instance_returns_valid_node_and_can_be_activated():
	var instance = object_pool.get_instance(POOL_KEY)
	assert_not_null(instance, "get_instance should return a valid node.")
	assert_true(instance is Node, "Instance should be a Node.")
	assert_eq(instance.process_mode, PROCESS_MODE_INHERIT, "get_instance should activate the node.")

# THE FIX: This test must now be async to handle the deferred call.
func test_return_instance_makes_it_inactive() -> void:
	var instance = object_pool.get_instance(POOL_KEY)
	object_pool.return_instance(instance)
	
	# Wait for the next frame for the deferred call to 'deactivate' to execute.
	await get_tree().process_frame
	
	assert_eq(instance.process_mode, PROCESS_MODE_DISABLED, "return_instance should deactivate the node after one frame.")

func test_pool_reuses_returned_instances() -> void:
	var first_instance = object_pool.get_instance(POOL_KEY)
	var first_instance_id = first_instance.get_instance_id()
	
	object_pool.return_instance(first_instance)
	
	# The instance is now available again on the next frame.
	await get_tree().process_frame
	
	var second_instance = object_pool.get_instance(POOL_KEY)
	var second_instance_id = second_instance.get_instance_id()
	
	assert_eq(first_instance_id, second_instance_id, "The pool should return the same instance that was just returned to it.")

func test_reset_returns_all_active_instances() -> void:
	var instance1 = object_pool.get_instance(POOL_KEY)
	var instance2 = object_pool.get_instance(POOL_KEY)
	var instance3 = object_pool.get_instance(POOL_KEY)
	
	var stats_before = object_pool.get_pool_stats()
	assert_eq(stats_before[POOL_KEY].active, 3, "There should be 3 active instances before reset.")
	
	object_pool.reset()
	await get_tree().process_frame
	
	var stats_after = object_pool.get_pool_stats()
	assert_eq(stats_after[POOL_KEY].active, 0, "There should be 0 active instances after reset.")

=====================================
FILE: ./src/tests/unit/test_combat_utils.gd
=====================================
# src/tests/unit/test_combat_utils.gd
extends GutTest

# --- Constants ---
const CombatUtils = preload("res://src/core/util/combat_utils.gd")
const HealthComponent = preload("res://src/entities/components/health_component.gd")

# --- Test Internals ---
var _root: Node
var _damageable_parent: Node
var _non_damageable_child: Node

# --- Test Lifecycle ---

func before_each():
	# Create a simple scene tree for testing tree traversal.
	# Root -> DamageableParent -> NonDamageableChild
	_root = Node.new()
	add_child(_root) # The test runner will manage this node.
	
	_damageable_parent = Node2D.new()
	_damageable_parent.name = "DamageableParent"
	
	# THE FIX: Create the component, give it a name, then add it as a child.
	var health_comp = HealthComponent.new()
	health_comp.name = "HealthComponent"
	_damageable_parent.add_child(autofree(health_comp))
	
	_root.add_child(_damageable_parent)
	
	_non_damageable_child = Node2D.new()
	_non_damageable_child.name = "NonDamageableChild"
	_damageable_parent.add_child(_non_damageable_child)

func test_find_damageable_returns_self_if_damageable():
	# This test is now inverted: the component, not the parent, is the damageable node.
	var health_comp = _damageable_parent.get_node("HealthComponent")
	var result = CombatUtils.find_damageable(health_comp)
	assert_same(result, health_comp, "Should return the component itself if it's damageable.")

func test_find_damageable_returns_parent_component_if_child_is_not_damageable():
	var health_comp = _damageable_parent.get_node("HealthComponent")
	var result = CombatUtils.find_damageable(_non_damageable_child)
	assert_same(result, health_comp, "Should traverse up and find the parent's HealthComponent.")

func test_find_damageable_returns_null_if_no_damageable_ancestor_exists():
	var standalone_node = autofree(Node2D.new())
	var result = CombatUtils.find_damageable(standalone_node)
	assert_null(result, "Should return null when no damageable parent is found.")

=====================================
FILE: ./src/tests/unit/test_level_parser.gd
=====================================
# src/tests/unit/test_level_parser.gd
extends GutTest

# --- Constants ---
const LevelParser = preload("res://src/core/building/level_parser.gd")
const TestEncounterData = preload("res://src/tests/data/test_encounter.tres")

# --- Test Internals ---
var _parser: LevelParser
var _build_data: LevelBuildData

# --- Test Lifecycle ---

func before_all():
	_parser = LevelParser.new()
	_build_data = _parser.parse_level_data(TestEncounterData)

# --- The Tests ---

func test_parses_correct_dimensions():
	assert_eq(_build_data.dimensions_tiles, Vector2i(5, 3), "Grid dimensions should be parsed correctly.")

func test_parses_terrain_and_platform_tiles():
	assert_eq(_build_data.terrain_tiles.size(), 11, "Should parse 11 solid wall tiles ('#').")
	assert_eq(_build_data.oneway_platforms.size(), 1, "Should parse 1 one-way platform tile ('-').")
	assert_eq(_build_data.hazard_tiles.size(), 1, "Should parse 1 hazard tile ('^').")

func test_parses_spawn_positions():
	# Use grid_to_world to verify the expected pixel coordinates
	var expected_player_pos = GridUtils.grid_to_world(Vector2i(1, 1))
	var expected_boss_pos = GridUtils.grid_to_world(Vector2i(3, 1))
	
	assert_eq(_build_data.player_spawn_pos, expected_player_pos, "Player spawn position should be parsed correctly.")
	assert_eq(_build_data.boss_spawn_pos, expected_boss_pos, "Boss spawn position should be parsed correctly.")

func test_parses_background_tiles():
	# The parser correctly identifies '.', '@', and '&' as background tiles for rendering.
	assert_eq(_build_data.background_tiles.size(), 3, "Should correctly identify all non-terrain/entity tiles as background.")

=====================================
FILE: ./src/tests/unit/test_combat_component.gd
=====================================
# src/tests/unit/test_combat_component.gd
extends GutTest

# --- Constants ---
const Player = preload("res://src/entities/player/player.tscn")
const CombatComponent = preload("res://src/entities/components/combat_component.gd")
const HealthComponent = preload("res://src/entities/components/health_component.gd")
const DamageResult = preload("res://src/api/combat/damage_result.gd")
const CombatConfig = preload("res://data/combat_config.tres")
const Identifiers = preload("res://src/core/util/identifiers.gd")

# --- Test Internals ---
var _player: Player
var _combat_component: CombatComponent
var _object_pool: ObjectPool
var _pogo_bounce_was_requested: bool = false

# --- Test Lifecycle ---

func before_each():
	_pogo_bounce_was_requested = false

	# Get a reference to the real ObjectPool to monitor its state
	_object_pool = get_node("/root/ObjectPool")
	_object_pool.reset()

	# Create a partial double of the Player. This gives us a real Player node
	# with all its components, but we can stub out its functions if needed.
	_player = partial_double(Player).instantiate()
	add_child(_player)

	_combat_component = _player.get_node("CombatComponent")
	var dependencies = { "data_resource": _player.p_data }
	_combat_component.setup(_player, dependencies)

	# Connect the component's signal to our local test handler
	_combat_component.pogo_bounce_requested.connect(_on_pogo_bounce_requested)
	
	await get_tree().process_frame

func after_each():
	if is_instance_valid(_combat_component) and _combat_component.pogo_bounce_requested.is_connected(_on_pogo_bounce_requested):
		_combat_component.pogo_bounce_requested.disconnect(_on_pogo_bounce_requested)

	if is_instance_valid(_player):
		_player.free()

# --- The Tests ---

func test_fire_shot_gets_instance_from_pool():
	var stats_before = _object_pool.get_pool_stats()
	var initial_active_count = stats_before[Identifiers.Pools.PLAYER_SHOTS].active

	_combat_component.fire_shot()
	await get_tree().process_frame # Allow shot to be added to scene

	var stats_after = _object_pool.get_pool_stats()
	var final_active_count = stats_after[Identifiers.Pools.PLAYER_SHOTS].active

	assert_eq(final_active_count, initial_active_count + 1, "fire_shot() should make one more projectile active in the pool.")

func test_trigger_pogo_on_enemy_emits_bounce_request():
	var mock_enemy = CharacterBody2D.new()
	var mock_health = double(HealthComponent).new()
	mock_health.name = "HealthComponent"
	stub(mock_health, "apply_damage").to_return(DamageResult.new())
	mock_enemy.add_child(mock_health)
	add_child(mock_enemy)

	var pogo_succeeded = _combat_component.trigger_pogo(mock_enemy)
	await get_tree().process_frame

	assert_true(pogo_succeeded, "trigger_pogo should return true when hitting a valid enemy.")
	assert_true(_pogo_bounce_was_requested, "pogo_bounce_requested signal should be emitted after a successful pogo.")

	# THE FIX: Explicitly free the test double and its parent.
	mock_health.free()
	mock_enemy.free()

func test_trigger_pogo_on_projectile_returns_it_to_pool():
	# This test requires a real pooled projectile instance.
	var mock_projectile = _object_pool.get_instance(Identifiers.Pools.TURRET_SHOTS)
	# Set the required metadata for pogo to work on it
	mock_projectile.add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)
	_player.p_data.is_pogo_attack = true # The component checks this flag

	var stats_before = _object_pool.get_pool_stats()
	var initial_active_count = stats_before[Identifiers.Pools.TURRET_SHOTS].active
	assert_eq(initial_active_count, 1, "There should be 1 active turret shot before the test.")

	_combat_component.trigger_pogo(mock_projectile)
	await get_tree().process_frame # Allow the deferred return_instance to process

	var stats_after = _object_pool.get_pool_stats()
	var final_active_count = stats_after[Identifiers.Pools.TURRET_SHOTS].active
	
	assert_eq(final_active_count, 0, "Pogoing a projectile should return it to the pool, making 0 active.")

# --- Signal Handlers ---

func _on_pogo_bounce_requested():
	_pogo_bounce_was_requested = true

=====================================
FILE: ./src/tests/integration/test_integration_combat_loop.gd
=====================================
# src/tests/integration/test_integration_combat_loop.gd
extends GutTest

# --- Test Internals ---
var _level_container: Node
var _player: Player
var _boss: BaseBoss
var _boss_health_changed_event_fired: bool = false
var _event_token: int

# --- Test Lifecycle ---

func before_each():
	_boss_health_changed_event_fired = false

	GameManager.state.current_encounter_path = AssetPaths.ENCOUNTER_00
	_level_container = await ArenaBuilder.build_level_async()
	add_child(_level_container)
	
	_player = _level_container.get_node("Player")
	_boss = _level_container.get_node("BaseBoss")
	
	_event_token = EventBus.on(EventCatalog.BOSS_HEALTH_CHANGED, Callable(self, "_on_boss_health_changed"))
	await get_tree().process_frame

func after_each():
	EventBus.off(_event_token)
	if is_instance_valid(_level_container):
		# Explicitly call teardown on both actors before freeing the container.
		# This is the correct pattern to prevent our known memory leak issues.
		if is_instance_valid(_player):
			_player.teardown()
		if is_instance_valid(_boss):
			_boss.teardown()
		_level_container.free()

# --- The Integration Test ---

func test_player_attack_damages_boss_and_fires_event():
	# 1. VERIFY SETUP
	assert_not_null(_player, "Player should be instanced in the scene.")
	assert_not_null(_boss, "Boss should be instanced in the scene.")
	var boss_health_comp: HealthComponent = _boss.get_node("HealthComponent")
	var initial_boss_health = boss_health_comp.entity_data.health
	
	# 2. POSITION ACTORS & WAIT FOR STABLE STATE
	_player.global_position = _boss.global_position + Vector2(-60, 0)
	_player.p_data.facing_direction = 1
	
	var wait_frames = 10
	for i in wait_frames:
		if _player.state_machine.current_state == _player.state_machine.states[_player.State.MOVE]:
			break
		await get_tree().physics_frame
	
	assert_eq(_player.state_machine.current_state, _player.state_machine.states[_player.State.MOVE], "Player must be in MOVE state before attacking.")
	
	# 3. SIMULATE INPUT & TIME
	# A melee attack requires a press and a quick release.
	Input.action_press("ui_attack")
	await get_tree().physics_frame # Wait one frame for the press to register
	Input.action_release("ui_attack")
	
	var simulation_frames = 30
	for i in simulation_frames:
		await get_tree().physics_frame
	
	# 4. ASSERT THE OUTCOME
	var final_boss_health = boss_health_comp.entity_data.health
	
	assert_lt(final_boss_health, initial_boss_health, "Boss health should be lower after being hit by a player melee attack.")
	assert_true(_boss_health_changed_event_fired, "A BOSS_HEALTH_CHANGED event should be emitted on the global EventBus.")
	
	assert_gt(_player.p_data.determination_counter, 0, "Player determination should increase after dealing damage.")

# --- EventBus Signal Handler ---

func _on_boss_health_changed(_payload):
	_boss_health_changed_event_fired = true

=====================================
FILE: ./src/tests/isolation/test_player_lifecycle.gd
=====================================
# src/tests/isolation/test_player_lifecycle.gd
extends GutTest

const PlayerScene = preload("res://src/entities/player/player.tscn")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const BaseStateMachine = preload("res://src/entities/components/base_state_machine.gd")
const BaseState = preload("res://src/entities/components/base_state.gd")
const CombatConfig = preload("res://data/combat_config.tres")

var _pre_counts: Dictionary = {}
var _post_counts: Dictionary = {}

func before_all():
	await get_tree().process_frame
	_pre_counts = {
		"objects": Performance.get_monitor(Performance.OBJECT_COUNT),
		"resources": Performance.get_monitor(Performance.OBJECT_RESOURCE_COUNT)
	}
	print("Baseline Counts | Objects: ", _pre_counts.objects, ", Resources: ", _pre_counts.resources)

func after_all():
	await get_tree().process_frame
	_post_counts = {
		"objects": Performance.get_monitor(Performance.OBJECT_COUNT),
		"resources": Performance.get_monitor(Performance.OBJECT_RESOURCE_COUNT)
	}
	print("Final Counts    | Objects: ", _post_counts.objects, ", Resources: ", _post_counts.resources)
	
	assert_eq(_post_counts.objects, _pre_counts.objects, "Final object count must return to baseline.")
	assert_eq(_post_counts.resources, _pre_counts.resources, "Final resource count must return to baseline.")

# --- ISOLATION TESTS ---

func test_A_create_and_free_resource():
	var p_data = PlayerStateData.new()
	p_data.config = CombatConfig
	await get_tree().process_frame
	assert_true(true, "Test A completed without crashing.")

func test_B_create_and_free_state_machine_cycle():
	var mock_owner = Node.new()
	add_child(mock_owner)
	
	var mock_fsm = BaseStateMachine.new()
	mock_owner.add_child(mock_fsm)
	
	var mock_state = BaseState.new(mock_owner, mock_fsm, null)
	mock_fsm.setup(mock_owner, {"states": {1: mock_state}, "initial_state_key": 1})
	
	await get_tree().process_frame
	
	mock_owner.free()
	await get_tree().process_frame
	assert_true(true, "Test B completed without crashing.")

func test_C_create_and_free_full_player_scene():
	var player = PlayerScene.instantiate()
	add_child(player)
	await get_tree().process_frame
	
	# THE FIX: The owner of the object (this test) is responsible for
	# explicitly calling the teardown method before freeing it.
	player.teardown()
	player.free()
	
	await get_tree().process_frame
	assert_true(true, "Test C completed without crashing.")

=====================================
FILE: ./src/tests/data/test_encounter.tres
=====================================
[gd_resource type="Resource" script_class="EncounterData" load_steps=3 format=3 uid="uid://test_encounter_tres"]

[ext_resource type="Script" path="res://src/data/encounters/encounter_data.gd" id="1_encounter"]
[ext_resource type="Resource" path="res://src/tests/data/test_layout.tres" id="2_layout"]

[resource]
script = ExtResource("1_encounter")

; --- Test Configuration ---
level_layout = ExtResource("2_layout")
player_spawn_marker = "@"
boss_spawn_marker = "&"

=====================================
FILE: ./src/tests/data/test_layout.tres
=====================================
[gd_resource type="Resource" script_class="LevelLayout" load_steps=2 format=3 uid="uid://test_layout_tres"]

[ext_resource type="Script" path="res://src/data/layouts/level_layout.gd" id="1_layout"]

[resource]
script = ExtResource("1_layout")
terrain_data = PackedStringArray(
"#####",
"#@.&-#",
"#^###"
)

=====================================
FILE: ./src/vfx/hit_spark.gd
=====================================
# src/vfx/hit_spark.gd
## A self-cleaning, poolable particle effect for hit sparks.
class_name HitSpark
extends GPUParticles2D

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	self.finished.connect(_on_finished)

# --- Public Methods (IPoolable Contract) ---

## Activates the particle effect.
func activate(direction: Vector2 = Vector2.RIGHT) -> void:
	process_mode = PROCESS_MODE_INHERIT
	visible = true
	self.rotation = direction.angle()
	restart()

## Deactivates the particle effect.
func deactivate() -> void:
	process_mode = PROCESS_MODE_DISABLED
	visible = false

# --- Signal Handlers ---

func _on_finished() -> void:
	ObjectPool.return_instance(self)

=====================================
FILE: ./src/vfx/hit_spark.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://c8g7f6e5d4b3a"]

[ext_resource type="Script" path="res://src/vfx/hit_spark.gd" id="1_hit_spark_script"]

[sub_resource type="Gradient" id="Gradient_1"]
offsets = PackedFloat32Array(0, 0.5, 1)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_1"]
gradient = SubResource("Gradient_1")

[sub_resource type="Curve" id="Curve_1"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), 0.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_1"]
curve = SubResource("Curve_1")

[sub_resource type="Gradient" id="Gradient_2"]
colors = PackedColorArray(1, 0.898039, 0.4, 1, 1, 1, 1, 1)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_2"]
gradient = SubResource("Gradient_2")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_1"]
particle_flag_disable_z = true
emission_shape = 1
emission_sphere_radius = 1.0
direction = Vector3(1, 0, 0)
spread = 90.0
initial_velocity_min = 150.0
initial_velocity_max = 400.0
gravity = Vector3(0, 0, 0)
damping_min = 200.0
damping_max = 300.0
scale_min = 1.5
scale_max = 2.5
scale_curve = SubResource("CurveTexture_1")
color_ramp = SubResource("GradientTexture1D_1")
color_initial_ramp = SubResource("GradientTexture1D_2")

[node name="HitSpark" type="GPUParticles2D"]
emitting = false
amount = 30
process_material = SubResource("ParticleProcessMaterial_1")
lifetime = 0.35
one_shot = true
explosiveness = 1.0
local_coords = true
fixed_fps = 60
script = ExtResource("1_hit_spark_script")
metadata/pool_name = &"hit_sparks"

=====================================
FILE: ./src/api/combat/damage_info.gd
=====================================
# src/api/combat/damage_info.gd
## A typed Resource that defines a complete damage event.
class_name DamageInfo
extends Resource

# --- Editor Properties ---
@export var amount: int = 1
@export var bypass_invincibility: bool = false

# --- Member Variables ---
## A reference to the node that was the source of the damage.
var source_node: Node = null
## The global position where the impact occurred.
var impact_position: Vector2 = Vector2.ZERO
## The normal vector of the surface that was hit, used for directing VFX.
var impact_normal: Vector2 = Vector2.ZERO

=====================================
FILE: ./src/api/combat/damage_result.gd
=====================================
# src/api/combat/damage_result.gd
## A typed Resource for the return value of an `apply_damage` call.
class_name DamageResult
extends Resource

# --- Member Variables ---
## True if damage was successfully applied.
var was_damaged: bool = false
## The calculated knockback velocity that should be applied to the target.
var knockback_velocity: Vector2 = Vector2.ZERO

=====================================
FILE: ./src/api/global_preloader.gd
=====================================
# src/api/global_preloader.gd
## A central autoload script whose sole purpose is to preload all interface
## and critical base class scripts in the project. This ensures their 'class_name'
## is registered with Godot's ScriptServer before any other script tries to use them,
## resolving parse order errors.
extends Node

func _ready() -> void:
	# Preload all interfaces and critical base classes to register them globally.
	preload("res://src/api/interfaces/IComponent.gd")
	preload("res://src/api/interfaces/IDamageable.gd")
	preload("res://src/api/interfaces/IPoolable.gd")
	preload("res://src/api/interfaces/ISceneController.gd")
	preload("res://src/entities/base_entity.gd")


=====================================
FILE: ./src/api/interfaces/IPoolable.gd
=====================================
# src/api/interfaces/IPoolable.gd
## The "interface" contract for any scene that can be managed by the [ObjectPool].
class_name IPoolable
extends Node

# --- The Contract ---

## Prepares the node for use after being retrieved from the pool.
func activate(_dependencies: Dictionary = {}) -> void:
	pass

## Prepares the node to be returned to the pool's inactive list.
func deactivate() -> void:
	pass

=====================================
FILE: ./src/api/interfaces/ISceneController.gd
=====================================
# src/api/interfaces/ISceneController.gd
## The conceptual "interface" for all main scene controller scripts.
##
## This defines a formal contract for scenes that require explicit cleanup
## logic to be run by the SceneManager before the scene is changed.
class_name ISceneController
extends Node

# --- Virtual Methods ---

## Called by the SceneManager immediately before it changes the scene.
## This function can be async to allow for cleanup animations or sequences.
func scene_exiting() -> void:
	pass


=====================================
FILE: ./src/api/interfaces/IDamageable.gd
=====================================
# src/api/interfaces/IDamageable.gd
## The "interface" contract for any object that can take damage.
class_name IDamageable
extends Node

# --- The Contract ---

## Applies damage to the object.
## [param damage_info]: A [DamageInfo] resource detailing the damage event.
## [return]: A [DamageResult] resource indicating the outcome.
func apply_damage(_damage_info: DamageInfo) -> DamageResult:
	# This is a virtual method and should be overridden by implementers.
	return DamageResult.new()

=====================================
FILE: ./src/api/interfaces/IComponent.gd
=====================================
# src/api/interfaces/IComponent.gd
## The conceptual "interface" for all entity components.
##
## This script defines the formal contract that components like [HealthComponent]
## and [CombatComponent] adhere to. It is not meant to be instanced directly.
class_name IComponent
extends Node

# --- Virtual Methods ---

## Initializes the component and injects its dependencies.
##
## [param p_owner]: A reference to the node that owns this component.
## [param p_dependencies]: A dictionary of any other required nodes or resources.
func setup(_p_owner: Node, _p_dependencies: Dictionary = {}) -> void:
	pass

## Called when the owner is being destroyed to clean up connections and references.
func teardown() -> void:
	pass

=====================================
FILE: ./src/projectiles/player_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cmdkxwvysirh1"]

[ext_resource type="Script" path="res://src/projectiles/player_shot.gd" id="1_4wg7x"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playershot"]
size = Vector2(40, 40)

[node name="PlayerShot" type="Area2D" groups=["player_projectile"]]
collision_layer = 0
collision_mask = 148
script = ExtResource("1_4wg7x")
metadata/pool_name = &"player_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.92549, 0.92549, 0.92549, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playershot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-20, -20, 40, 40)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]

=====================================
FILE: ./src/projectiles/turret_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://d1e2f3g4h5i6j"]

[ext_resource type="Script" path="res://src/projectiles/turret_shot.gd" id="1_turret_shot_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_turretshot"]
size = Vector2(20, 20)

[node name="TurretShot" type="Area2D"]
collision_layer = 16
collision_mask = 193
script = ExtResource("1_turret_shot_script")
metadata/pool_name = &"turret_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -10.0
offset_top = -10.0
offset_right = 10.0
offset_bottom = 10.0
color = Color(0.898039, 0.898039, 0.898039, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_turretshot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-10, -10, 20, 20)

[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]

=====================================
FILE: ./src/projectiles/boss_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cxnmr7yrvchve"]

[ext_resource type="Script" path="res://src/projectiles/boss_shot.gd" id="1_4qgog"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossshot"]
size = Vector2(60, 60)

[node name="BossShot" type="Area2D"]
collision_layer = 16
collision_mask = 65
script = ExtResource("1_4qgog")
metadata/pool_name = &"boss_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.8, 0.4, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossshot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-30, -30, 60, 60)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]

=====================================
FILE: ./src/projectiles/turret_shot.gd
=====================================
# src/projectiles/turret_shot.gd
## A projectile fired by the Turret minion. Implements the [IPoolable] interface.
class_name TurretShot
extends Area2D

# --- Constants ---
const CombatUtilsScript = preload(AssetPaths.SCRIPT_COMBAT_UTILS)

# --- Node References ---
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

# --- Member Variables ---
var direction: Vector2 = Vector2.LEFT
var speed: float = 500.0
var damage: int = 1
var _object_pool: ObjectPool # Dependency

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)
	$ColorRect.color = Palette.COLOR_UI_ACCENT_PRIMARY

func _physics_process(delta: float) -> void:
	global_position += direction * speed * delta

# --- Public Methods (IPoolable Contract) ---

## Activates the projectile, making it visible and interactive.
func activate(p_dependencies: Dictionary = {}) -> void:
	self._object_pool = p_dependencies.get("object_pool")
	assert(is_instance_valid(_object_pool), "TurretShot requires an ObjectPool dependency.")
	
	visible = true
	process_mode = PROCESS_MODE_INHERIT
	collision_shape.disabled = false

## Deactivates the projectile, preparing it to be returned to the ObjectPool.
func deactivate() -> void:
	visible = false
	process_mode = PROCESS_MODE_DISABLED
	collision_shape.disabled = true
	_object_pool = null

# --- Signal Handlers ---

func _on_body_entered(body: Node) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return

	var damageable = CombatUtilsScript.find_damageable(body)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.amount = damage
		damage_info.source_node = self
		damage_info.impact_position = global_position
		damage_info.impact_normal = -direction
		damageable.apply_damage(damage_info)

	_object_pool.return_instance.call_deferred(self)

func _on_screen_exited() -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	_object_pool.return_instance.call_deferred(self)

=====================================
FILE: ./src/projectiles/player_shot.gd
=====================================
# src/projectiles/player_shot.gd
## A projectile fired by the player. Implements the [IPoolable] interface.
class_name PlayerShot
extends Area2D

# --- Constants ---
const CombatUtilsScript = preload(AssetPaths.SCRIPT_COMBAT_UTILS)

# --- Node References ---
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

# --- Member Variables ---
var direction: Vector2 = Vector2.RIGHT
var speed: float = 1000.0
var damage: int = 2
var _object_pool: ObjectPool # Dependency

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	$ColorRect.color = Palette.COLOR_PLAYER_PROJECTILE

func _physics_process(delta: float) -> void:
	global_position += direction * speed * delta

# --- Public Methods (IPoolable Contract) ---

## Activates the projectile, making it visible and interactive.
func activate(p_dependencies: Dictionary = {}) -> void:
	self._object_pool = p_dependencies.get("object_pool")
	assert(is_instance_valid(_object_pool), "PlayerShot requires an ObjectPool dependency.")
	
	visible = true
	process_mode = PROCESS_MODE_INHERIT
	collision_shape.disabled = false

## Deactivates the projectile, preparing it to be returned to the ObjectPool.
func deactivate() -> void:
	visible = false
	process_mode = PROCESS_MODE_DISABLED
	collision_shape.disabled = true
	_object_pool = null # Clear reference

# --- Signal Handlers ---

func _on_body_entered(body: Node) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	
	var damageable = CombatUtilsScript.find_damageable(body)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.amount = damage
		damage_info.source_node = self
		damage_info.impact_position = global_position
		damage_info.impact_normal = -direction
		damageable.apply_damage(damage_info)

	_object_pool.return_instance.call_deferred(self)

func _on_area_entered(area: Area2D) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		_object_pool.return_instance.call_deferred(area)
	_object_pool.return_instance.call_deferred(self)

func _on_screen_exited() -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	_object_pool.return_instance.call_deferred(self)

=====================================
FILE: ./src/projectiles/boss_shot.gd
=====================================
# src/projectiles/boss_shot.gd
## A projectile fired by the boss. Implements the [IPoolable] interface.
class_name BossShot
extends Area2D

# --- Constants ---
const CombatUtilsScript = preload(AssetPaths.SCRIPT_COMBAT_UTILS)

# --- Node References ---
@onready var collision_shape: CollisionShape2D = $CollisionShape2D

# --- Member Variables ---
var direction: Vector2 = Vector2.LEFT
var speed: float = 400.0
var damage: int = 1
var _object_pool: ObjectPool # Dependency

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	$ColorRect.color = Palette.COLOR_HAZARD_PRIMARY
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)

func _physics_process(delta: float) -> void:
	global_position += direction * speed * delta

# --- Public Methods (IPoolable Contract) ---

## Activates the projectile, making it visible and interactive.
func activate(p_dependencies: Dictionary = {}) -> void:
	self._object_pool = p_dependencies.get("object_pool")
	assert(is_instance_valid(_object_pool), "BossShot requires an ObjectPool dependency.")

	visible = true
	process_mode = PROCESS_MODE_INHERIT
	collision_shape.disabled = false

## Deactivates the projectile, preparing it to be returned to the ObjectPool.
func deactivate() -> void:
	visible = false
	process_mode = PROCESS_MODE_DISABLED
	collision_shape.disabled = true
	_object_pool = null

# --- Signal Handlers ---

func _on_body_entered(_body: Node) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	# This handles collision with the solid world.
	_object_pool.return_instance.call_deferred(self)

func _on_area_entered(area: Area2D) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	# This handles collision with the Player's Hurtbox.
	var damageable = CombatUtilsScript.find_damageable(area)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.amount = damage
		damage_info.source_node = self
		damage_info.impact_position = global_position
		damage_info.impact_normal = -direction
		damageable.apply_damage(damage_info)

	_object_pool.return_instance.call_deferred(self)

func _on_screen_exited() -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	_object_pool.return_instance.call_deferred(self)

=====================================
FILE: ./src/projectiles/homing_boss_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://homing_boss_shot_scene"]

[ext_resource type="Script" path="res://src/projectiles/homing_boss_shot.gd" id="1_homing_shot_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_homing_shot_body"]
size = Vector2(20, 20)

[node name="HomingBossShot" type="Area2D"]
collision_layer = 16
collision_mask = 65
script = ExtResource("1_homing_shot_script")

[node name="ColorRect" type="ColorRect" parent="."]
unique_name_in_owner = true
offset_left = -10.0
offset_top = -10.0
offset_right = 10.0
offset_bottom = 10.0

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
unique_name_in_owner = true
shape = SubResource("RectangleShape2D_homing_shot_body")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-10, -10, 20, 20)

[node name="LifetimeTimer" type="Timer" parent="."]
unique_name_in_owner = true
one_shot = true

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]
[connection signal="timeout" from="LifetimeTimer" to="." method="_on_lifetime_timer_timeout"]

=====================================
FILE: ./src/projectiles/homing_boss_shot.gd
=====================================
# src/projectiles/homing_boss_shot.gd
## A projectile that seeks the player and shrinks over time.
class_name HomingBossShot
extends Area2D

# --- Constants ---
const CombatUtilsScript = preload(AssetPaths.SCRIPT_COMBAT_UTILS)

# --- Editor Properties ---
@export var speed: float = 250.0
@export var damage: int = 1
@export var lifespan: float = 10.0

# --- Node References ---
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var visual: ColorRect = $ColorRect
@onready var lifetime_timer: Timer = $LifetimeTimer

# --- Private Member Variables ---
var _player_ref: WeakRef
var _active_tween: Tween
var _object_pool: ObjectPool # Dependency

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)
	visual.color = Palette.COLOR_HAZARD_PRIMARY

func _physics_process(delta: float) -> void:
	if not _player_ref or not _player_ref.get_ref():
		global_position += transform.x * speed * delta
		return
	
	var player_node = _player_ref.get_ref()
	var direction_to_player = (player_node.global_position - global_position).normalized()
	
	rotation = lerp_angle(rotation, direction_to_player.angle(), 0.05)
	
	global_position += transform.x * speed * delta

# --- IPoolable Contract ---

func activate(p_dependencies: Dictionary = {}) -> void:
	self._object_pool = p_dependencies.get("object_pool")
	assert(is_instance_valid(_object_pool), "HomingBossShot requires an ObjectPool dependency.")

	visible = true
	process_mode = PROCESS_MODE_INHERIT
	collision_shape.disabled = false
	
	var player_node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	_player_ref = weakref(player_node)
	
	lifetime_timer.start(lifespan)
	
	if is_instance_valid(_active_tween):
		_active_tween.kill()
		
	_active_tween = create_tween()
	_active_tween.tween_property(visual, "scale", Vector2.ZERO, lifespan)
	_active_tween.tween_property(collision_shape, "scale", Vector2.ZERO, lifespan)

func deactivate() -> void:
	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null
		
	visible = false
	process_mode = PROCESS_MODE_DISABLED
	collision_shape.disabled = true
	visual.scale = Vector2.ONE
	collision_shape.scale = Vector2.ONE
	_object_pool = null

# --- Signal Handlers ---

func _on_body_entered(_body: Node) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	_object_pool.return_instance.call_deferred(self)

func _on_area_entered(area: Area2D) -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	var damageable = CombatUtilsScript.find_damageable(area)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.amount = damage
		damage_info.source_node = self
		damage_info.impact_position = global_position
		damage_info.impact_normal = (global_position - area.global_position).normalized()
		damageable.apply_damage(damage_info)
	
	_object_pool.return_instance.call_deferred(self)

func _on_screen_exited() -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	_object_pool.return_instance.call_deferred(self)

func _on_lifetime_timer_timeout() -> void:
	if process_mode == PROCESS_MODE_DISABLED: return
	_object_pool.return_instance.call_deferred(self)


=====================================
FILE: ./src/data/dialogue/test_conversation.tres
=====================================
[gd_resource type="Resource" script_class="DialogueData" load_steps=3 format=3 uid="uid://dialogue_test_tres"]

[ext_resource type="Script" path="res://src/data/dialogue/dialogue_data.gd" id="1_dialogue_data"]

[sub_resource type="Resource" id="DialogueLine_1" script_class="DialogueLine"]
script = ExtResource("1_dialogue_data")
character_name = "Narrator"
text = "This is the first line of a test conversation."

[resource]
script = ExtResource("1_dialogue_data")
conversation = Array[ExtResource("1_dialogue_data")]([SubResource("DialogueLine_1")])

=====================================
FILE: ./src/data/dialogue/dialogue_data.gd
=====================================
# src/data/dialogue/dialogue_data.gd
@tool
## A custom Resource that holds the data for a single line of dialogue or a full conversation.
class_name DialogueData
extends Resource

## A container for a single line of dialogue text.
class DialogueLine extends Resource:
	@export var character_name: String = ""
	@export_multiline var text: String = ""
	# TODO: Add exports for character portraits, voice clips, etc.

# --- Editor Properties ---
@export var conversation: Array[DialogueLine] = []

=====================================
FILE: ./src/data/audio/sfx_player_footsteps.tres
=====================================
[gd_resource type="AudioStreamRandomizer" load_steps=2 format=3]

# TODO: Add footstep audio samples and configure randomization.


=====================================
FILE: ./src/data/audio/sfx_player_impact.tres
=====================================
[gd_resource type="AudioStreamRandomizer" load_steps=2 format=3]

# TODO: Add impact audio samples and configure randomization.


=====================================
FILE: ./src/data/combat_config.tres
=====================================
[gd_resource type="Resource" script_class="CombatConfig" load_steps=4 format=3 uid="uid://kov03lmcorvh"]

[ext_resource type="Script" uid="uid://bhpg5eaxemkw1" path="res://src/core/data/config/combat_config.gd" id="1_config"]
[ext_resource type="Shape2D" uid="uid://c1b2d3e4f5g6h" path="res://src/entities/player/data/forward_attack_shape.tres" id="2_forward_shape"]
[ext_resource type="Shape2D" uid="uid://c0dt7jqwtnbr" path="res://src/entities/player/data/upward_attack_shape.tres" id="3_upward_shape"]

[resource]
script = ExtResource("1_config")
player_max_health = 5
player_max_healing_charges = 1
player_heal_duration = 2.0
player_determination_per_charge = 10
player_invincibility_duration = 1.5
player_speed = 450.0
player_jump_force = 680.0
player_jump_release_dampener = 0.4
player_coyote_time = 0.1
player_jump_buffer = 0.1
player_fast_fall_gravity_multiplier = 1.4
player_max_air_jumps = 1
player_wall_slide_speed = 120.0
player_wall_coyote_time = 0.05
player_wall_jump_force_x = 1650.0
player_wall_jump_force_y = 680.0
player_dash_speed = 1400.0
player_dash_duration = 0.15
player_dash_cooldown = 0.5
player_forward_attack_shape = ExtResource("2_forward_shape")
player_upward_attack_shape = ExtResource("3_upward_shape")
player_attack_cooldown = 0.12
player_attack_duration = 0.1
player_attack_friction = 2000.0
player_charge_time = 0.35
player_pogo_force = 450.0
player_knockback_speed = 400.0
player_knockback_duration = 0.1
player_hazard_knockback_speed = 400.0
player_close_range_threshold = 75.0
boss_health = 30
boss_patrol_speed = 100.0
boss_invincibility_duration = 0.1
boss_lunge_speed = 1200.0
turret_fire_rate = 2.0
turret_detection_radius = 400.0
homing_shot_damage = 1
homing_shot_speed = 250.0
homing_shot_lifespan = 10.0
gravity = 1200.0
player_melee_close_range_hit_stop_duration = 0.025
player_damage_taken_hit_stop_duration = 0.04
boss_phase_change_hit_stop_duration = 0.1
boss_death_hit_stop_duration = 0.2

=====================================
FILE: ./src/data/layouts/level_layout.gd
=====================================
# src/data/layouts/level_layout.gd
@tool
## A custom Resource that holds the terrain data for a level.
##
## Includes a custom configuration warning to ensure that all rows in the
## terrain data array have the same length for valid parsing.
class_name LevelLayout
extends Resource

# --- Editor Properties ---
@export var terrain_data: PackedStringArray = []:
	set(value):
		terrain_data = value
		# Tell the editor to refresh its property list, which re-runs the warning check.
		notify_property_list_changed()

# --- Godot Lifecycle Methods ---

func _get_configuration_warnings() -> PackedStringArray:
	var warnings = PackedStringArray()
	if terrain_data.is_empty():
		warnings.append("Terrain Data is empty. The level will be blank.")
		return warnings

	var first_row_length = -1
	if not terrain_data[0].is_empty():
		first_row_length = terrain_data[0].length()
	else: # Handle case where the first row is empty
		warnings.append("The first row of terrain data cannot be empty.")
		return warnings

	for i in range(1, terrain_data.size()):
		if terrain_data[i].length() != first_row_length:
			var msg = "Row %d (length %d) has a different length than the first row (length %d)."
			warnings.append(msg % [i + 1, terrain_data[i].length(), first_row_length])
			break # Only show the first error found

	return warnings


=====================================
FILE: ./src/data/layouts/layout_00.tres
=====================================
[gd_resource type="Resource" script_class="LevelLayout" load_steps=2 format=3 uid="uid://bst2lw60wetic"]

[ext_resource type="Script" uid="uid://c01s26irlgw56" path="res://src/data/layouts/level_layout.gd" id="1_layout"]

[resource]
script = ExtResource("1_layout")
terrain_data = PackedStringArray("####################", "#..................#", "#....@.............#", "#............&.....#", "#.........#--#.....#", "#.........#..#.....#", "#.........#--#.....#", "#.........#..#.....#", "#..T......#..#.....#", "#.........#..#.....#", "#..................#", "#..................#", "#.........####.....#", "#.........####.....#", "#.........####.....#", "####......####.....#", "####......####..T..#", "####...............#", "#..................#", "###############^^^##")


=====================================
FILE: ./src/data/encounters/encounter_00.tres
=====================================
[gd_resource type="Resource" script_class="EncounterData" load_steps=5 format=3 uid="uid://4lptu40or7m1"]

[ext_resource type="Script" uid="uid://co2urq51qk44e" path="res://src/data/encounters/encounter_data.gd" id="1_encounter"]
[ext_resource type="PackedScene" uid="uid://dmej4a7ykn2q0" path="res://src/entities/boss/base_boss.tscn" id="2_boss_scene"]
[ext_resource type="Resource" uid="uid://bst2lw60wetic" path="res://src/data/layouts/layout_00.tres" id="2_x64bm"]
[ext_resource type="PackedScene" uid="uid://c7d8faf0g1h2i" path="res://src/entities/minions/turret.tscn" id="3_turret_scene"]

[resource]
script = ExtResource("1_encounter")

; --- Layout & Spawning ---
level_layout = ExtResource("2_x64bm")
player_spawn_marker = "@"
boss_spawn_marker = "&"

; --- Boss ---
boss_scene = ExtResource("2_boss_scene")

; --- Minions ---
minion_spawns = {
"T": ExtResource("3_turret_scene")
}

=====================================
FILE: ./src/data/encounters/encounter_data.gd
=====================================
# src/data/encounters/encounter_data.gd
@tool
## A custom Resource that defines a complete encounter or stage.
##
## This allows designers to create new levels by combining a [LevelLayout],
## a boss scene, and minion definitions without writing any code.
class_name EncounterData
extends Resource

# --- Editor Properties ---
@export_group("Layout")
@export var level_layout: LevelLayout
@export var player_spawn_marker: String = "@"

@export_group("Boss")
@export var boss_scene: PackedScene
@export var boss_spawn_marker: String = "&"

@export_group("Minions")
## The key is the character marker in the layout file (e.g., "T").
## The value is the PackedScene for that minion.
@export var minion_spawns: Dictionary = {}

=====================================
FILE: ./src/data/effects/entity_hit_flash_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://entity_hit_flash_effect"]

[ext_resource type="Script" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="ShaderMaterial" uid="uid://entity_hit_flash_mat" path="res://materials/entity_hit_flash_material.tres" id="2_material"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_material")
duration = 0.12
target_scope = 0

=====================================
FILE: ./src/entities/base_entity.gd
=====================================
# src/entities/base_entity.gd
@tool
## The generic base class for all component-based entities in the game.
class_name BaseEntity
extends CharacterBody2D

# --- Editor Properties ---
@export var archetype: EntityArchetype

# --- Public Member Variables ---
var health_component: HealthComponent
var combat_component: CombatComponent
var input_component: InputComponent
var state_machine: BaseStateMachine
var physics_component: PlayerPhysicsComponent
var ability_component: PlayerAbilityComponent
var resource_component: PlayerResourceComponent
var fx_component: FXComponent

# --- Private Member Variables ---
var _components_initialized: bool = false

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	if Engine.is_editor_hint(): return
	_build_from_archetype()

# --- Public Methods ---

func teardown() -> void:
	for child in get_children():
		if child is IComponent:
			child.teardown()

## Initializes all attached components after dependencies have been injected.
func setup_components(shared_dependencies: Dictionary = {}, per_component_dependencies: Dictionary = {}) -> void:
	if _components_initialized: return

	for child in get_children():
		if not (child is IComponent): continue
		
		var merged_deps := shared_dependencies.duplicate()

		if per_component_dependencies.has(child):
			merged_deps.merge(per_component_dependencies[child])
		
		var class_key: String = child.get_script().get_global_name()
		if per_component_dependencies.has(class_key):
			merged_deps.merge(per_component_dependencies[class_key])
		
		if child.has_method("setup"):
			child.setup(self, merged_deps)

	_components_initialized = true

# --- Private Methods ---

func _build_from_archetype() -> void:
	if not is_instance_valid(archetype):
		push_error("Entity '%s' is missing its Archetype resource." % name)
		return

	for component_scene in archetype.components:
		if is_instance_valid(component_scene):
			var component_instance = component_scene.instantiate()
			add_child(component_instance)
		else:
			push_warning("Archetype for '%s' contains an invalid component scene." % name)

	_cache_components_by_type()

func _cache_components_by_type() -> void:
	for child in get_children():
		if not child is IComponent: continue

		if child is HealthComponent: health_component = child
		elif child is CombatComponent: combat_component = child
		elif child is InputComponent: input_component = child
		elif child is BaseStateMachine: state_machine = child
		elif child is PlayerPhysicsComponent: physics_component = child
		elif child is PlayerAbilityComponent: ability_component = child
		elif child is PlayerResourceComponent: resource_component = child
		elif child is FXComponent: fx_component = child
		else: push_warning("Unbound component on '%s': %s" % [name, child.get_class()])


=====================================
FILE: ./src/entities/archetypes/player_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=10 format=3 uid="uid://player_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://b1x2y3z4a5b6" path="res://src/entities/components/combat_component.tscn" id="3_combat"]
[ext_resource type="PackedScene" uid="uid://c7d8e9f0g1h2" path="res://src/entities/components/input_component.tscn" id="4_input"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/components/base_state_machine.tscn" id="5_fsm"]
[ext_resource type="PackedScene" uid="uid://o9p0q1r2s3t4" path="res://src/entities/player/components/player_physics_component.tscn" id="6_phys"]
[ext_resource type="PackedScene" uid="uid://u5v6w7x8y9z0" path="res://src/entities/player/components/player_ability_component.tscn" id="7_abil"]
[ext_resource type="PackedScene" uid="uid://a1b2c3d4e5f6" path="res://src/entities/player/components/player_resource_component.tscn" id="8_res"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/components/fx_component.tscn" id="9_fx"]

[resource]
script = ExtResource("1_archetype")
components = [
	; --- Core Components ---
	ExtResource("2_health"), 
	ExtResource("3_combat"), 
	ExtResource("4_input"), 
	ExtResource("5_fsm"), 
	ExtResource("9_fx"), 
	
	; --- Player-Specific Components ---
	ExtResource("6_phys"), 
	ExtResource("7_abil"), 
	ExtResource("8_res")
]

=====================================
FILE: ./src/entities/archetypes/turret_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=5 format=3 uid="uid://turret_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/components/base_state_machine.tscn" id="3_fsm"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/components/fx_component.tscn" id="4_fx"]

[resource]
script = ExtResource("1_archetype")

; --- Core Components ---
components = [ExtResource("2_health"), ExtResource("3_fsm"), ExtResource("4_fx")]

=====================================
FILE: ./src/entities/archetypes/boss_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=5 format=3 uid="uid://boss_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/components/base_state_machine.tscn" id="3_fsm"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/components/fx_component.tscn" id="4_fx"]

[resource]
script = ExtResource("1_archetype")

; --- Core Components ---
components = [ExtResource("2_health"), ExtResource("3_fsm"), ExtResource("4_fx")]

=====================================
FILE: ./src/entities/archetypes/entity_archetype.gd
=====================================
# src/entities/archetypes/entity_archetype.gd
@tool
## A data resource that defines the component-based structure of an entity.
##
## This acts as a blueprint, telling a BaseEntity which components to instance
## and attach to itself at runtime.
class_name EntityArchetype
extends Resource

## An array of PackedScene files, where each scene is a component
## (e.g., HealthComponent.tscn, InputComponent.tscn).
@export var components: Array[PackedScene] = []

=====================================
FILE: ./src/entities/boss/attack_patterns/lunge_logic.gd
=====================================
# src/entities/boss/attack_patterns/lunge_logic.gd
@tool
## Concrete AttackLogic for executing a high-speed, invulnerable dash.
class_name LungeLogic
extends AttackLogic

func get_telegraph_info(owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	var lunge_width = 800.0
	var owner_width = owner.get_node("CollisionShape2D").shape.size.x
	var x_offset = (lunge_width / 2.0) + (owner_width / 2.0)
	
	return {
		"size": Vector2(lunge_width, 60),
		"offset": Vector2(x_offset, 0)
	}

func execute(owner: BaseBoss, pattern: AttackPattern) -> Callable:
	var lunge_params = {"pattern": pattern}
	return owner.state_machine.change_state.bind(owner.State.LUNGE, lunge_params)

=====================================
FILE: ./src/entities/boss/attack_patterns/lunge_attack.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://y6g5o6f7h8i9"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/lunge_logic.tres" id="2_lunge_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.8
attack_duration = 0.5
cooldown = 2.0

; --- Logic-Specific Data ---
logic = ExtResource("2_lunge_logic")
projectile_count = 0
volley_delay = 0.0

=====================================
FILE: ./src/entities/boss/attack_patterns/homing_omni_burst_pattern.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://homing_omni_burst_tres"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://homing_logic_tres" path="res://src/entities/boss/attack_patterns/homing_omni_burst_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 1.2
attack_duration = 1.0
cooldown = 3.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 30
volley_delay = 0.0

=====================================
FILE: ./src/entities/boss/attack_patterns/volley_3_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://k3dglh3t1b4a"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/volley_shot_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.7
attack_duration = 0.6
cooldown = 2.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 3
volley_delay = 0.2

=====================================
FILE: ./src/entities/boss/attack_patterns/volley_5_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://z1x2y3a4b5c6"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/volley_shot_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.6
attack_duration = 1.0
cooldown = 2.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 5
volley_delay = 0.15

=====================================
FILE: ./src/entities/boss/attack_patterns/projectile_logic.gd
=====================================
# src/entities/boss/attack_patterns/projectile_logic.gd
@tool
## Concrete AttackLogic for firing one or more projectiles.
class_name ProjectileLogic
extends AttackLogic

func get_telegraph_info(_owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	return {
		"size": Vector2(150, 150),
		"offset": Vector2(100, 0)
	}

func execute(owner: BaseBoss, pattern: AttackPattern) -> Callable:
	if pattern.projectile_count <= 1:
		return owner.fire_shot_at_player.bind()
	else:
		return owner.fire_volley.bind(pattern.projectile_count, pattern.volley_delay)

=====================================
FILE: ./src/entities/boss/attack_patterns/volley_shot_logic.tres
=====================================
[gd_resource type="Resource" script_class="ProjectileLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/projectile_logic.gd" id="1_projectile_logic"]

[resource]
script = ExtResource("1_projectile_logic")
projectile_count = 3
volley_delay = 0.2


=====================================
FILE: ./src/entities/boss/attack_patterns/attack_pattern.gd
=====================================
# src/entities/boss/attack_patterns/attack_pattern.gd
@tool
## A data resource that defines the properties of a single boss attack.
##
## This combines timing data with a swappable "AttackLogic" resource that
## contains the actual execution code for the attack (Strategy Pattern).
class_name AttackPattern
extends Resource

# --- Editor Properties ---
@export var logic: AttackLogic ## The script that defines HOW this attack behaves.
@export var telegraph_duration: float = 0.5
@export var attack_duration: float = 0.1
@export var cooldown: float = 1.5

@export_group("Attack-Specific Data")
# --- ProjectileLogic Data ---
@export var projectile_count: int = 1
@export var volley_delay: float = 0.2

=====================================
FILE: ./src/entities/boss/attack_patterns/lunge_logic.tres
=====================================
[gd_resource type="Resource" script_class="LungeLogic" load_steps=2 format=3 uid="uid://lunge_logic_tres_id"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/lunge_logic.gd" id="1_lunge_logic"]

[resource]
script = ExtResource("1_lunge_logic")


=====================================
FILE: ./src/entities/boss/attack_patterns/single_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://bve7t5ucr1k"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/single_shot_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.5
attack_duration = 0.1
cooldown = 1.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 1
volley_delay = 0.2

=====================================
FILE: ./src/entities/boss/attack_patterns/homing_omni_burst_logic.tres
=====================================
[gd_resource type="Resource" script_class="HomingOmniBurstLogic" load_steps=2 format=3 uid="uid://homing_logic_tres"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/homing_omni_burst_logic.gd" id="1_logic_script"]

[resource]
script = ExtResource("1_logic_script")
projectile_count = 30
projectile_speed = 250.0

=====================================
FILE: ./src/entities/boss/attack_patterns/single_shot_logic.tres
=====================================
[gd_resource type="Resource" script_class="ProjectileLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/projectile_logic.gd" id="1_projectile_logic"]

[resource]
script = ExtResource("1_projectile_logic")
projectile_count = 1
volley_delay = 0.2


=====================================
FILE: ./src/entities/boss/attack_patterns/attack_logic.gd
=====================================
# src/entities/boss/attack_patterns/attack_logic.gd
@tool
## The abstract base class for all boss attack execution logic.
## This implements the Strategy Pattern for boss attacks.
class_name AttackLogic
extends Resource

## Returns the visual information for this attack's telegraph.
## The dictionary should contain: { "size": Vector2, "offset": Vector2 }
## "offset" is the local position relative to the boss.
func get_telegraph_info(_owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	# Default to a simple square
	return {
		"size": Vector2(150, 150),
		"offset": Vector2(_owner.entity_data.facing_direction * 100, 0)
	}

## Prepares and returns the attack action as a Callable.
## This is the core of the Command Pattern implementation.
func execute(_owner: BaseBoss, _pattern: AttackPattern) -> Callable:
	push_warning("AttackLogic.execute() was called but not overridden.")
	return Callable() # Return an empty, safe callable

=====================================
FILE: ./src/entities/boss/attack_patterns/homing_omni_burst_logic.gd
=====================================
# src/entities/boss/attack_patterns/homing_omni_burst_logic.gd
@tool
## Concrete AttackLogic for a complex, multi-projectile homing attack.
class_name HomingOmniBurstLogic
extends AttackLogic

@export var projectile_count: int = 30

func get_telegraph_info(_owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	return { "size": Vector2(600, 600), "offset": Vector2.ZERO }

func execute(owner: BaseBoss, _pattern: AttackPattern) -> Callable:
	return Callable(self, "_fire_omni_burst").bind(owner)

# --- Private Helper for Execution ---
func _fire_omni_burst(owner: BaseBoss) -> void:
	if not is_instance_valid(owner): return
	
	print("Executing Homing Omni Burst!")
	
	var angle_step = TAU / projectile_count
	for i in range(projectile_count):
		var shot: HomingBossShot = ObjectPool.get_instance(Identifiers.Pools.HOMING_BOSS_SHOTS)
		if not is_instance_valid(shot): continue
		
		# Configure the projectile from the central config
		shot.damage = owner.entity_data.config.homing_shot_damage
		shot.speed = owner.entity_data.config.homing_shot_speed
		shot.lifespan = owner.entity_data.config.homing_shot_lifespan
		
		var angle = i * angle_step
		shot.rotation = angle
		shot.global_position = owner.global_position
		shot.activate({"object_pool": ObjectPool})

=====================================
FILE: ./src/entities/boss/boss_state_data.gd
=====================================
# src/entities/boss/boss_state_data.gd
## A Resource that holds all shared runtime state data for the Boss.
class_name BossStateData
extends Resource

# --- Configuration Reference ---
var config: CombatConfig

# --- Health & Combat ---
var max_health: int = 30
var health: int = 30:
	set(value):
		health = clamp(value, 0, max_health)

# --- Physics & Movement ---
var facing_direction: float = -1.0

=====================================
FILE: ./src/entities/boss/base_boss.tscn
=====================================
[gd_scene load_steps=18 format=3 uid="uid://dmej4a7ykn2q0"]

[ext_resource type="Script" path="res://src/entities/boss/base_boss.gd" id="1_26qjf"]
[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="2_30ufx"]
[ext_resource type="Resource" uid="uid://bve7t5ucr1k" path="res://src/entities/boss/attack_patterns/single_shot.tres" id="3_pattern_single"]
[ext_resource type="Resource" uid="uid://k3dglh3t1b4a" path="res://src/entities/boss/attack_patterns/volley_3_shot.tres" id="4_pattern_volley"]
[ext_resource type="Resource" uid="uid://y6g5o6f7h8i9" path="res://src/entities/boss/attack_patterns/lunge_attack.tres" id="5_pattern_lunge"]
[ext_resource type="Resource" uid="uid://z1x2y3a4b5c6" path="res://src/entities/boss/attack_patterns/volley_5_shot.tres" id="6_pattern_volley_p3"]
[ext_resource type="Resource" uid="uid://boss_phase_change_shake_tres" path="res://src/core/data/effects/boss_phase_change_shake.tres" id="7_phase_shake"]
[ext_resource type="Resource" uid="uid://boss_death_shake_tres" path="res://src/core/data/effects/boss_death_shake.tres" id="8_death_shake"]
[ext_resource type="Resource" uid="uid://player_hit_spark_tres" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="9_hit_spark_effect"]
[ext_resource type="Resource" uid="uid://boss_archetype_resource" path="res://src/entities/archetypes/boss_archetype.tres" id="10_archetype"]
[ext_resource type="Resource" uid="uid://homing_omni_burst_tres" path="res://src/entities/boss/attack_patterns/homing_omni_burst_pattern.tres" id="11_pattern_homing"]
[ext_resource type="Script" path="res://src/entities/boss/states/state_boss_idle.gd" id="12_state_idle"]
[ext_resource type="Script" path="res://src/entities/boss/states/state_boss_attack.gd" id="13_state_attack"]
[ext_resource type="Script" path="res://src/entities/boss/states/state_boss_cooldown.gd" id="14_state_cooldown"]
[ext_resource type="Script" path="res://src/entities/boss/states/state_boss_patrol.gd" id="15_state_patrol"]
[ext_resource type="Script" path="res://src/entities/boss/states/state_boss_lunge.gd" id="16_state_lunge"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossbody"]
size = Vector2(60, 60)

[node name="BaseBoss" type="CharacterBody2D"]
collision_layer = 12
collision_mask = 131
script = ExtResource("1_26qjf")
archetype = ExtResource("10_archetype")

; Phase Configuration
phase_1_patterns = Array[ExtResource("2_30ufx")]([ExtResource("3_pattern_single")])
phase_2_patterns = Array[ExtResource("2_30ufx")]([ExtResource("4_pattern_volley"), ExtResource("5_pattern_lunge")])
phase_3_patterns = Array[ExtResource("2_30ufx")]([ExtResource("6_pattern_volley_p3"), ExtResource("5_pattern_lunge"), ExtResource("11_pattern_homing")])

; Juice & Feedback
phase_change_shake_effect = ExtResource("7_phase_shake")
death_shake_effect = ExtResource("8_death_shake")
hit_spark_effect = ExtResource("9_hit_spark_effect")

; State Scripts
state_idle_script = ExtResource("12_state_idle")
state_attack_script = ExtResource("13_state_attack")
state_cooldown_script = ExtResource("14_state_cooldown")
state_patrol_script = ExtResource("15_state_patrol")
state_lunge_script = ExtResource("16_state_lunge")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.6, 0.6, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossbody")

[node name="CooldownTimer" type="Timer" parent="."]
wait_time = 1.5
one_shot = true

[node name="PatrolTimer" type="Timer" parent="."]
wait_time = 3.0
one_shot = true

[connection signal="timeout" from="CooldownTimer" to="." method="_on_cooldown_timer_timeout"]
[connection signal="timeout" from="PatrolTimer" to="." method="_on_patrol_timer_timeout"]

=====================================
FILE: ./src/entities/boss/states/state_boss_idle.gd
=====================================
# src/entities/boss/states/state_boss_idle.gd
## A transient state that immediately selects the next attack pattern.
class_name BossStateIdle
extends BaseState

func enter(_msg := {}) -> void:
	owner.velocity.x = 0

	if owner.current_attack_patterns.is_empty():
		push_warning("BossStateIdle: No attack patterns defined for current phase. Defaulting to Cooldown.")
		state_machine.change_state(owner.State.COOLDOWN)
		return

	var chosen_pattern: AttackPattern = owner.current_attack_patterns.pick_random()
	state_machine.change_state(owner.State.ATTACK, {"pattern": chosen_pattern})


=====================================
FILE: ./src/entities/boss/states/state_boss_lunge.gd
=====================================
# src/entities/boss/states/state_boss_lunge.gd
## Executes a high-speed, invulnerable dash attack across the arena.
extends BaseState
class_name BossStateLunge

# --- Private Member Variables ---
var _boss: BaseBoss
var _lunge_duration: float
var _invincibility_token: int

# --- State Lifecycle ---

func enter(msg := {}) -> void:
	self._boss = owner as BaseBoss
	if not _boss: return

	var pattern: AttackPattern = msg.get("pattern")
	_lunge_duration = pattern.attack_duration if pattern else 0.5

	_invincibility_token = _boss.health_component.grant_invincibility(self)
	_boss.velocity = Vector2(state_data.facing_direction * state_data.config.boss_lunge_speed, 0)

func exit() -> void:
	if is_instance_valid(_boss) and is_instance_valid(_boss.health_component):
		_boss.health_component.release_invincibility(_invincibility_token)

func process_physics(delta: float) -> void:
	_lunge_duration -= delta
	if _lunge_duration <= 0:
		state_machine.change_state(_boss.State.COOLDOWN)

=====================================
FILE: ./src/entities/boss/states/state_boss_cooldown.gd
=====================================
# src/entities/boss/states/state_boss_cooldown.gd
## The state for when the boss is waiting after completing an attack.
extends BaseState
class_name BossStateCooldown

func enter(_msg := {}) -> void:
	owner.velocity.x = 0
	owner.cooldown_timer.start()


=====================================
FILE: ./src/entities/boss/states/state_boss_attack.gd
=====================================
# src/entities/boss/states/state_boss_attack.gd
## Handles the telegraph and execution of the boss's attacks.
class_name BossStateAttack
extends BaseState

# --- Constants ---
const TelegraphScene = preload(AssetPaths.SCENE_TELEGRAPH_COMPONENT)

# --- Private Member Variables ---
var _current_pattern: AttackPattern
var _boss: BaseBoss

# --- State Lifecycle ---

func enter(msg := {}) -> void:
	self._boss = owner as BaseBoss
	if not _boss:
		push_error("BossStateAttack: Owner is not a BaseBoss. Aborting.")
		state_machine.change_state(_boss.State.COOLDOWN)
		return

	if not msg.has("pattern") or not msg.pattern is AttackPattern:
		push_error("BossStateAttack: No valid 'pattern' provided. Aborting.")
		state_machine.change_state(_boss.State.COOLDOWN)
		return

	_current_pattern = msg.get("pattern")
	_start_telegraph_and_attack()

# --- Private Methods ---

func _start_telegraph_and_attack() -> void:
	if not is_instance_valid(_current_pattern.logic):
		push_warning("AttackPattern is missing its 'logic' resource.")
		state_machine.change_state(_boss.State.COOLDOWN)
		return

	var telegraph = TelegraphScene.instantiate()
	_boss.add_child(telegraph)
	
	var telegraph_info = _current_pattern.logic.get_telegraph_info(_boss, _current_pattern)
	var telegraph_size = telegraph_info.get("size", Vector2.ONE * 100)
	var relative_offset = telegraph_info.get("offset", Vector2.ZERO)
	
	var directional_offset = Vector2(relative_offset.x * _boss.entity_data.facing_direction, relative_offset.y)
	var telegraph_position = _boss.global_position + directional_offset
	
	telegraph.start_telegraph(
		_current_pattern.telegraph_duration,
		telegraph_size,
		telegraph_position,
		Palette.COLOR_HAZARD_PRIMARY
	)
	await telegraph.telegraph_finished

	# THE FIX: Get the command and execute it.
	var attack_command: Callable = _current_pattern.logic.execute(_boss, _current_pattern)
	if attack_command.is_valid():
		attack_command.call()
	
	if state_machine.current_state == self:
		_boss.cooldown_timer.wait_time = _current_pattern.cooldown
		state_machine.change_state(_boss.State.COOLDOWN)

=====================================
FILE: ./src/entities/boss/states/state_boss_patrol.gd
=====================================
# src/entities/boss/states/state_boss_patrol.gd
## A simple state for moving the boss back and forth between attacks.
extends BaseState
class_name BossStatePatrol

func enter(_msg := {}) -> void:
	owner.patrol_timer.start()

func process_physics(_delta: float) -> void:
	owner.velocity.x = state_data.facing_direction * state_data.config.boss_patrol_speed


=====================================
FILE: ./src/entities/boss/base_boss.gd
=====================================
# src/entities/boss/base_boss.gd
@tool
class_name BaseBoss
extends BaseEntity

# --- Constants ---
const COMBAT_CONFIG = preload("res://src/data/combat_config.tres")
const HIT_FLASH_EFFECT = preload("res://src/data/effects/entity_hit_flash_effect.tres")

# --- Enums ---
enum State { IDLE, ATTACK, COOLDOWN, PATROL, LUNGE }

# --- Editor Configuration ---
@export_group("Phase Configuration")
@export_range(0.0, 1.0, 0.01) var phase_2_threshold: float = 0.7
@export_range(0.0, 1.0, 0.01) var phase_3_threshold: float = 0.4
@export_group("Attack Patterns")
@export var phase_1_patterns: Array[AttackPattern] = []
@export var phase_2_patterns: Array[AttackPattern] = []
@export var phase_3_patterns: Array[AttackPattern] = []
@export_group("Juice & Feedback")
@export var intro_shake_effect: ScreenShakeEffect
@export var phase_change_shake_effect: ScreenShakeEffect
@export var death_shake_effect: ScreenShakeEffect
@export var hit_spark_effect: VFXEffect
@export_group("State Scripts")
@export var state_idle_script: Script
@export var state_attack_script: Script
@export var state_cooldown_script: Script
@export var state_patrol_script: Script
@export var state_lunge_script: Script

# --- Node References ---
@onready var visual_sprite: ColorRect = $ColorRect
@onready var cooldown_timer: Timer = $CooldownTimer
@onready var patrol_timer: Timer = $PatrolTimer

# --- Public Member Variables ---
var current_attack_patterns: Array[AttackPattern] = []
var phases_remaining: int = 3
var entity_data: BossStateData

# --- Private Member Variables ---
var _player: CharacterBody2D = null
var _active_attack_tween: Tween
var _is_dead: bool = false

# --- Godot Lifecycle Methods ---

func _get_configuration_warnings() -> PackedStringArray:
	var warnings = PackedStringArray()
	if not archetype:
		warnings.append("This node requires an EntityArchetype resource.")
		return warnings
	if phase_1_patterns.is_empty():
		warnings.append("Phase 1 has no attack patterns assigned.")
	return warnings

func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint(): return
	
	_initialize_data()
	_initialize_and_setup_components()
	_connect_signals()
	_player = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	
	if is_instance_valid(intro_shake_effect):
		FXManager.request_screen_shake(intro_shake_effect)

func _exit_tree() -> void:
	teardown()

func _physics_process(delta: float) -> void:
	if Engine.is_editor_hint(): return
	if not is_on_floor(): velocity.y += entity_data.config.gravity * delta
	move_and_slide()
	if state_machine.current_state == state_machine.states[State.PATROL] and is_on_wall():
		entity_data.facing_direction *= -1.0

# --- Public Methods ---

func teardown() -> void:
	set_physics_process(false)
	if is_instance_valid(health_component):
		if health_component.health_changed.is_connected(_on_health_component_health_changed):
			health_component.health_changed.disconnect(_on_health_component_health_changed)
		if health_component.died.is_connected(_on_health_component_died):
			health_component.died.disconnect(_on_health_component_died)
		if health_component.health_threshold_reached.is_connected(_on_health_threshold_reached):
			health_component.health_threshold_reached.disconnect(_on_health_threshold_reached)
	
	super.teardown()
	entity_data = null

func get_health_thresholds() -> Array[float]:
	return [phase_2_threshold, phase_3_threshold]

func fire_volley(shot_count: int, delay: float) -> void:
	if is_instance_valid(_active_attack_tween): _active_attack_tween.kill()
	_active_attack_tween = get_tree().create_tween()
	for i in range(shot_count):
		_active_attack_tween.tween_callback(fire_shot_at_player)
		if i < shot_count - 1: _active_attack_tween.tween_interval(delay)

func fire_shot_at_player() -> void:
	if _is_dead or not is_instance_valid(_player): return
	var shot = ObjectPool.get_instance(Identifiers.Pools.BOSS_SHOTS)
	if not shot: return
	_update_player_tracking()
	shot.direction = (_player.global_position - global_position).normalized()
	shot.global_position = global_position
	shot.activate({"object_pool": ObjectPool})

# --- Private Methods ---

func _die() -> void:
	if _is_dead: return
	if is_instance_valid(death_shake_effect):
		FXManager.request_screen_shake(death_shake_effect)
	FXManager.request_hit_stop(entity_data.config.boss_death_hit_stop_duration)
	_is_dead = true
	if is_instance_valid(_active_attack_tween): _active_attack_tween.kill()
	set_physics_process(false)
	hide()
	EventBus.emit(EventCatalog.BOSS_DIED, {"boss_node": self})

func _initialize_data() -> void:
	add_to_group(Identifiers.Groups.ENEMY)
	visual_sprite.color = Palette.COLOR_BOSS_PRIMARY
	current_attack_patterns = phase_1_patterns
	entity_data = BossStateData.new()
	entity_data.config = COMBAT_CONFIG

func _initialize_and_setup_components() -> void:
	var shared_deps := {
		"data_resource": entity_data,
		"config": entity_data.config
	}
	
	var states = {
		State.IDLE: state_idle_script.new(self, state_machine, entity_data),
		State.ATTACK: state_attack_script.new(self, state_machine, entity_data),
		State.COOLDOWN: state_cooldown_script.new(self, state_machine, entity_data),
		State.PATROL: state_patrol_script.new(self, state_machine, entity_data),
		State.LUNGE: state_lunge_script.new(self, state_machine, entity_data),
	}
	
	var per_component_deps := {
		state_machine: {"states": states, "initial_state_key": State.COOLDOWN},
		fx_component: {"visual_node": visual_sprite, "health_component": health_component, "hit_effect": HIT_FLASH_EFFECT}
	}
	
	setup_components(shared_deps, per_component_deps)

func _connect_signals() -> void:
	health_component.health_changed.connect(_on_health_component_health_changed)
	health_component.died.connect(_on_health_component_died)
	health_component.health_threshold_reached.connect(_on_health_threshold_reached)

func _update_player_tracking() -> void:
	if is_instance_valid(_player):
		var dir_to_player = _player.global_position.x - global_position.x
		if not is_zero_approx(dir_to_player):
			entity_data.facing_direction = sign(dir_to_player)
	self.scale.x = entity_data.facing_direction

# --- Signal Handlers ---

func _on_health_threshold_reached(health_percentage: float) -> void:
	var new_phases_remaining = phases_remaining
	if health_percentage <= phase_3_threshold and phases_remaining > 1:
		new_phases_remaining = 1
	elif health_percentage <= phase_2_threshold and phases_remaining > 2:
		new_phases_remaining = 2
	if new_phases_remaining != phases_remaining:
		phases_remaining = new_phases_remaining
		match phases_remaining:
			2: current_attack_patterns = phase_2_patterns
			1: current_attack_patterns = phase_3_patterns
		if is_instance_valid(phase_change_shake_effect):
			FXManager.request_screen_shake(phase_change_shake_effect)
		FXManager.request_hit_stop(entity_data.config.boss_phase_change_hit_stop_duration)
		EventBus.emit(EventCatalog.BOSS_PHASE_CHANGED, {"phases_remaining": phases_remaining})

func _on_cooldown_timer_timeout() -> void:
	if state_machine.current_state == state_machine.states[State.COOLDOWN]:
		state_machine.change_state(State.PATROL)
func _on_patrol_timer_timeout() -> void:
	if state_machine.current_state == state_machine.states[State.PATROL]:
		state_machine.change_state(State.IDLE)
func _on_health_component_health_changed(current: int, max_val: int) -> void:
	var ev = BossHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	EventBus.emit(EventCatalog.BOSS_HEALTH_CHANGED, ev)
func _on_health_component_died() -> void:
	_die()

=====================================
FILE: ./src/entities/README.md
=====================================
Entities: how to add components & states
=======================================

Purpose
-------
Explain the minimal conventions for adding new components and states to the entity system.

Component contract (example)
----------------------------
Create components by extending the ComponentInterface base. Keep them small and single-purpose.

Example components (GDScript):

# res://src/entities/ComponentInterface.gd
extends Node2D
class_name ComponentInterface

# Called once when the entity or builder attaches the component.
func setup(config: Dictionary) -> void:
    pass

# Called when the component or entity is being destroyed / swapped.
func teardown() -> void:
    pass

# Example concrete component: HealthComponent
# res://src/entities/components/HealthComponent.gd
extends ComponentInterface
class_name HealthComponent

@export var max_hp: int = 100
var hp: int = 100

func setup(config: Dictionary) -> void:
    if config.has("max_hp"):
        max_hp = int(config["max_hp"])
    hp = max_hp

func receive_damage(amount: int) -> void:
    hp -= amount
    if hp <= 0:
        _on_dead()

func _on_dead() -> void:
    # notify EventBus / play death FX via ObjectPool
    EventBus.emit("entity_dead", { "entity": get_parent() })
    queue_free()

State machine (example)
-----------------------
BaseState provides enter/exit and processing hooks. States are swapped by the entity's BaseStateMachine.

# res://src/core/BaseState.gd
extends Node
class_name BaseState

func enter(data = null) -> void: pass
func exit() -> void: pass
func physics_process(delta: float) -> void: pass

# res://src/core/BaseStateMachine.gd
extends Node
class_name BaseStateMachine

var current_state: BaseState = null

func change_state(new_state: BaseState, data = null) -> void:
    if current_state:
        current_state.exit()
        current_state.queue_free() # if state is a node instance
    current_state = new_state
    add_child(current_state)
    current_state.enter(data)

Best practices
--------------
- Keep state logic deterministic; side-effects should be limited and explicit.
- Components must clean themselves up in `teardown()` (disconnect signals, stop timers).
- Use the `EventBus` for cross-system signals rather than global references.
- Store tunable numbers in `.tres` resources and refer to them in `setup()`.

Example workflow to add a component
----------------------------------
1. Create `res://src/entities/components/MyComponent.gd` extending `ComponentInterface`.
2. Expose tuning via `@export` variables or read from a provided config dictionary in `setup()`.
3. Add the component as a child to the entity scene or let entity builder attach it at spawn time.
4. Ensure `teardown()` reverses all runtime connections.



=====================================
FILE: ./src/entities/components/base_state_machine.gd
=====================================
# src/entities/components/base_state_machine.gd
@tool
## A reusable, node-based state machine that conforms to the IComponent interface.
class_name BaseStateMachine
extends IComponent

## This signal is used by the Player states to request actions (like enabling
## a hitbox) from the Player node, decoupling the states from the Player's
## specific methods. The warning is ignored because the signal is emitted by
## the state objects, not this script directly.
@warning_ignore("unused_signal")
signal action_requested(command: Callable)

const MAX_HISTORY_SIZE = 5
var states: Dictionary = {}
var current_state: BaseState
var owner_node: Node
var state_history: Array[String] = []

func _ready() -> void:
	owner_node = get_parent()

func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

func _unhandled_input(event: InputEvent) -> void:
	if current_state:
		current_state.process_input(event)

func _physics_process(delta: float) -> void:
	if current_state:
		current_state.process_physics(delta)

func _exit_tree() -> void:
	teardown()

func setup(_p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	assert(p_dependencies.has("states"), "StateMachine setup requires a 'states' dictionary.")
	assert(p_dependencies.has("initial_state_key"), "StateMachine setup requires an 'initial_state_key'.")
	self.states = p_dependencies["states"]
	var initial_state_key = p_dependencies["initial_state_key"]
	change_state(initial_state_key)

func teardown() -> void:
	if current_state:
		current_state.exit()
	
	for state in states.values():
		if is_instance_valid(state):
			state.teardown()
			state.free()
			
	states.clear()
	state_history.clear()
	current_state = null

func change_state(new_state_key, msg := {}) -> void:
	if not states.has(new_state_key):
		push_warning("StateMachine: Attempted to change to unknown state '%s'." % new_state_key)
		return
	if current_state == states.get(new_state_key):
		return
	if current_state:
		current_state.exit()
	current_state = states[new_state_key]
	current_state.enter(msg)
	if is_instance_valid(current_state) and is_instance_valid(current_state.get_script()):
		var state_name = current_state.get_script().resource_path.get_file()
		state_history.push_front(state_name)
		if state_history.size() > MAX_HISTORY_SIZE:
			state_history.pop_back()


=====================================
FILE: ./src/entities/components/health_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dpl3w8xqyq1a2"]

[ext_resource type="Script" path="res://src/entities/components/health_component.gd" id="1_health"]

[node name="HealthComponent" type="Node"]
script = ExtResource("1_health")

=====================================
FILE: ./src/entities/components/telegraph_component.gd
=====================================
# src/entities/components/telegraph_component.gd
@tool
## A self-contained, reusable component for displaying attack telegraphs.
##
## It shows a visual warning for a set duration, then emits a signal
## and automatically frees itself from the scene tree.
class_name TelegraphComponent
extends Node2D

# --- Signals ---
## Emitted when the telegraph's duration has finished.
signal telegraph_finished

# --- Node References ---
@onready var visual: ColorRect = $Visual

# --- Public Methods ---

## Configures and starts the telegraph visual and timer.
func start_telegraph(duration: float, p_size: Vector2, p_position: Vector2, p_color: Color) -> void:
	self.global_position = p_position
	visual.size = p_size
	visual.color = p_color
	# Center the ColorRect on the component's position.
	visual.position = -p_size / 2.0

	var tween = create_tween()
	await tween.tween_interval(duration).finished

	if is_instance_valid(self):
		telegraph_finished.emit()
		queue_free()

=====================================
FILE: ./src/entities/components/fx_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://g7h8i9j0k1l2"]

[ext_resource type="Script" path="res://src/entities/components/fx_component.gd" id="1_fx"]

[node name="FXComponent" type="Node"]
script = ExtResource("1_fx")

=====================================
FILE: ./src/entities/components/combat_component.gd
=====================================
# src/entities/components/combat_component.gd
@tool
## Centralizes all player combat logic, such as firing projectiles and pogo attacks.
class_name CombatComponent
extends IComponent

# --- Signals ---
## Emitted when this component successfully deals damage.
signal damage_dealt
## Emitted to request a pogo bounce from the owner.
signal pogo_bounce_requested

# --- Constants ---
const CombatUtilsScript = preload(AssetPaths.SCRIPT_COMBAT_UTILS)

# --- Member Variables ---
var owner_node: CharacterBody2D
var p_data: PlayerStateData
var _object_pool: ObjectPool # Dependency

# --- Public Methods ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.p_data = p_dependencies.get("data_resource")
	self._object_pool = p_dependencies.get("object_pool")
	assert(is_instance_valid(_object_pool), "CombatComponent requires an ObjectPool dependency.")

func teardown() -> void:
	owner_node = null
	p_data = null
	_object_pool = null

## Fires a player projectile from the object pool.
func fire_shot() -> void:
	p_data.attack_cooldown_timer = p_data.config.player_attack_cooldown

	var shot = _object_pool.get_instance(Identifiers.Pools.PLAYER_SHOTS)
	if not shot: return

	var shot_dir = Vector2(p_data.facing_direction, 0)
	if Input.is_action_pressed("ui_up"): shot_dir = Vector2.UP
	elif Input.is_action_pressed("ui_down"): shot_dir = Vector2.DOWN

	shot.direction = shot_dir
	shot.global_position = owner_node.global_position + (shot_dir * 60)
	shot.activate({"object_pool": _object_pool})

## Attempts to perform a pogo action on a target.
func trigger_pogo(pogo_target: Node) -> bool:
	if not p_data.is_pogo_attack: return false
	if not is_instance_valid(pogo_target): return false

	var should_bounce = false

	if pogo_target.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		should_bounce = true
		_object_pool.return_instance.call_deferred(pogo_target)

	var damageable = CombatUtilsScript.find_damageable(pogo_target)
	if is_instance_valid(damageable):
		should_bounce = true
		var damage_info = DamageInfo.new()
		damage_info.amount = 1
		damage_info.source_node = owner_node
		damage_info.bypass_invincibility = true
		damage_info.impact_position = pogo_target.global_position
		damage_info.impact_normal = Vector2.UP # Pogo impact is always from above.
		var damage_result = damageable.apply_damage(damage_info)
		if damage_result.was_damaged:
			damage_dealt.emit()

	if pogo_target is StaticBody2D and pogo_target.is_in_group(Identifiers.Groups.WORLD):
		should_bounce = true

	if should_bounce:
		pogo_bounce_requested.emit()
		return true

	return false

=====================================
FILE: ./src/entities/components/telegraph_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1i2c3d4e5f6g"]

[ext_resource type="Script" path="res://src/entities/components/telegraph_component.gd" id="1_telegraph_script"]

[node name="TelegraphComponent" type="Node2D"]
script = ExtResource("1_telegraph_script")

[node name="Visual" type="ColorRect" parent="."]
offset_right = 40.0
offset_bottom = 40.0
color = Color(1, 1, 1, 0.392157)


=====================================
FILE: ./src/entities/components/input_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://c7d8e9f0g1h2"]

[ext_resource type="Script" path="res://src/entities/components/input_component.gd" id="1_input"]

[node name="InputComponent" type="Node"]
script = ExtResource("1_input")

=====================================
FILE: ./src/entities/components/health_component.gd
=====================================
# src/entities/components/health_component.gd
@tool
## Manages all health, damage, and invincibility logic for an entity.
class_name HealthComponent
extends IComponent

# --- Signals ---
signal health_changed(current_health: int, max_health: int)
signal died
signal health_threshold_reached(health_percentage: float)
signal took_damage(damage_info: DamageInfo, damage_result: DamageResult)

# --- Member Variables ---
var entity_data: Resource
var owner_node: CharacterBody2D

var _max_health: int
var _invincibility_duration: float
var _knockback_speed: float
var _hazard_knockback_speed: float
var _invincibility_tokens: Dictionary = {}
var _next_token_id: int = 1

# --- Godot Lifecycle Methods ---

func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

# --- Public Methods ---

func is_invincible() -> bool:
	return not _invincibility_tokens.is_empty()

func grant_invincibility(requester: Object) -> int:
	var token_id = _next_token_id
	_next_token_id += 1
	_invincibility_tokens[token_id] = requester.get_instance_id()
	return token_id

func release_invincibility(token: int) -> void:
	if _invincibility_tokens.has(token):
		_invincibility_tokens.erase(token)

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.entity_data = p_dependencies.get("data_resource")
	var cfg: CombatConfig = p_dependencies.get("config")

	if not entity_data or not cfg:
		push_error("HealthComponent.setup: Missing required dependencies.")
		return

	_max_health = entity_data.max_health
	if owner_node.is_in_group(Identifiers.Groups.PLAYER):
		_invincibility_duration = cfg.player_invincibility_duration
		_knockback_speed = cfg.player_knockback_speed
		_hazard_knockback_speed = cfg.player_hazard_knockback_speed
	else: # Assumes Enemy/Boss
		_invincibility_duration = cfg.boss_invincibility_duration
		_knockback_speed = 0
		_hazard_knockback_speed = 0

	entity_data.health = _max_health
	health_changed.emit(entity_data.health, _max_health)

func teardown() -> void:
	entity_data = null
	owner_node = null

func apply_damage(damage_info: DamageInfo) -> DamageResult:
	var result = DamageResult.new()
	if is_invincible() and not damage_info.bypass_invincibility:
		return result

	var health_before_damage = entity_data.health
	entity_data.health -= damage_info.amount
	health_changed.emit(entity_data.health, _max_health)

	var post_hit_token = grant_invincibility(self)
	get_tree().create_timer(_invincibility_duration).timeout.connect(release_invincibility.bind(post_hit_token))

	result.knockback_velocity = _calculate_knockback(damage_info.source_node)
	_check_for_threshold_crossing(health_before_damage, entity_data.health)

	result.was_damaged = true
	took_damage.emit(damage_info, result)

	if entity_data.health <= 0:
		died.emit()

	return result

# --- Private Methods ---
func _check_for_threshold_crossing(health_before: int, health_after: int) -> void:
	if not owner_node.has_method("get_health_thresholds"): return
	var thresholds: Array[float] = owner_node.get_health_thresholds()
	var old_percent = float(health_before) / _max_health
	var new_percent = float(health_after) / _max_health
	for threshold in thresholds:
		if old_percent > threshold and new_percent <= threshold:
			health_threshold_reached.emit(threshold)
func _calculate_knockback(source: Node) -> Vector2:
	if _knockback_speed == 0 or not is_instance_valid(source): return Vector2.ZERO
	var knockback_dir = (owner_node.global_position - source.global_position).normalized()
	var speed = _knockback_speed
	if source.is_in_group(Identifiers.Groups.HAZARD):
		speed = _hazard_knockback_speed
	return (knockback_dir + Vector2.UP * 0.5).normalized() * speed

=====================================
FILE: ./src/entities/components/base_state_machine.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://i3j4k5l6m7n8"]

[ext_resource type="Script" path="res://src/entities/components/base_state_machine.gd" id="1_fsm"]

[node name="StateMachine" type="Node"]
script = ExtResource("1_fsm")

=====================================
FILE: ./src/entities/components/input_component.gd
=====================================
# src/entities/components/input_component.gd
@tool
## A component that centralizes all raw input polling.
##
## It reads from Godot's Input singleton each frame and populates a buffer
## dictionary. Other components and states read from this buffer, decoupling
## them from the global Input singleton.
class_name InputComponent
extends IComponent

# --- Member Variables ---
var owner_node: CharacterBody2D
var p_data: PlayerStateData
var state_machine: BaseStateMachine
var _config: CombatConfig # Internal reference to the injected config

## A buffer dictionary populated each frame with the current input state.
var buffer: Dictionary = {}

# --- Godot Lifecycle Methods ---

func _physics_process(_delta: float) -> void:
	if not is_instance_valid(owner_node): return # Guard against post-teardown calls
	
	# 1. Clear the buffer at the start of the frame.
	buffer.clear()

	# 2. Populate the buffer with the current input state.
	buffer["move_axis"] = Input.get_axis("ui_left", "ui_right")

	buffer["up"] = Input.is_action_pressed("ui_up")
	buffer["down"] = Input.is_action_pressed("ui_down")

	buffer["jump_just_pressed"] = Input.is_action_just_pressed("ui_jump")
	buffer["jump_held"] = Input.is_action_pressed("ui_jump")
	buffer["jump_released"] = Input.is_action_just_released("ui_jump")

	buffer["attack_pressed"] = Input.is_action_pressed("ui_attack")
	buffer["attack_just_pressed"] = Input.is_action_just_pressed("ui_attack")
	buffer["attack_released"] = Input.is_action_just_released("ui_attack")

	buffer["dash_pressed"] = Input.is_action_just_pressed("ui_dash")

# --- Public Methods ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.p_data = p_dependencies.get("data_resource")
	self.state_machine = p_dependencies.get("state_machine")
	self._config = p_dependencies.get("config")

	if not p_data or not _config:
		push_error("InputComponent.setup: Missing one or more required dependencies.")
		return

func teardown() -> void:
	set_physics_process(false) # Immediately stop processing
	owner_node = null
	p_data = null
	state_machine = null
	_config = null
	buffer.clear()

=====================================
FILE: ./src/entities/components/combat_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1x2y3z4a5b6"]

[ext_resource type="Script" path="res://src/entities/components/combat_component.gd" id="1_combat"]

[node name="CombatComponent" type="Node"]
script = ExtResource("1_combat")

=====================================
FILE: ./src/entities/components/base_state.gd
=====================================
# src/entities/components/base_state.gd
## The abstract base class for all entity states.
##
## Defines the lifecycle methods that every state must implement. States are
## responsible for handling logic for a specific entity behavior (e.g., moving,
## attacking, dashing).
class_name BaseState
extends Object

# --- Member Variables ---
var owner: Node
var state_machine: Node
var state_data: Resource

# --- Constructor ---

func _init(p_owner: Node, p_state_machine: Node, p_state_data: Resource) -> void:
	self.owner = p_owner
	self.state_machine = p_state_machine
	self.state_data = p_state_data

# --- Public Methods ---

## Called by the state machine upon exiting to break cyclic references.
func teardown() -> void:
	owner = null
	state_machine = null
	state_data = null

# --- Virtual Lifecycle Methods ---

## Called once when the state machine enters this state.
func enter(_msg := {}) -> void:
	pass

## Called once when the state machine exits this state.
func exit() -> void:
	pass

## Called every physics frame. Used for movement and physics-based logic.
func process_physics(_delta: float) -> void:
	pass

## Called during the `_unhandled_input` cycle. Used for immediate input reactions.
func process_input(_event: InputEvent) -> void:
	pass

=====================================
FILE: ./src/entities/components/fx_component.gd
=====================================
# src/entities/components/fx_component.gd
@tool
## A dedicated component for managing all entity-specific visual effects.
##
## CONTRACT: This component requires a "visual_node" dependency and optionally
## accepts a "health_component" to auto-trigger damage effects.
class_name FXComponent
extends IComponent

# --- Editor Properties ---
## An optional, default effect to play on damage. Can be overridden by dependencies.
@export var default_hit_effect: ShaderEffect

# --- Member Variables ---
var _owner: Node
var _visual_node: CanvasItem
var _health_component: HealthComponent
var _original_material: Material
var _current_effect_name: String = "None"

var _active_tween: Tween
var _material_instance: ShaderMaterial

# --- Private Member Variables ---
# OPTIMIZATION: Cache uniform lists per shader to avoid re-querying every frame.
var _shader_uniform_cache: Dictionary = {}

# A proxy property for the tween to animate.
var _progress: float = 0.0:
	set(value):
		_progress = value
		if is_instance_valid(_material_instance):
			_material_instance.set_shader_parameter("fx_progress", _progress)

# --- Godot Lifecycle Methods ---
func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self._owner = p_owner
	
	assert(p_dependencies.has("visual_node"), "FXComponent requires a 'visual_node' dependency.")
	_visual_node = p_dependencies.get("visual_node")
	assert(is_instance_valid(_visual_node) and _visual_node is CanvasItem, "'visual_node' must be a valid CanvasItem.")
	
	_original_material = _visual_node.material

	_health_component = p_dependencies.get("health_component", null)
	if is_instance_valid(_health_component):
		_health_component.took_damage.connect(_on_owner_took_damage)

	var injected_effect = p_dependencies.get("hit_effect", null)
	if is_instance_valid(injected_effect):
		default_hit_effect = injected_effect

	# OPTIMIZATION: Create one reusable material instance.
	if is_instance_valid(_original_material) and _original_material is ShaderMaterial:
		_material_instance = _original_material.duplicate(true) as ShaderMaterial
	else:
		_material_instance = ShaderMaterial.new()

func teardown() -> void:
	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null

	if is_instance_valid(_health_component) and _health_component.took_damage.is_connected(_on_owner_took_damage):
		_health_component.took_damage.disconnect(_on_owner_took_damage)

	if is_instance_valid(_visual_node):
		_visual_node.material = _original_material

	_visual_node = null
	_owner = null
	_health_component = null
	_material_instance = null

# --- Public API ---

## Plays a configured ShaderEffect resource on the visual_node.
func play_effect(effect: ShaderEffect) -> void:
	if not is_instance_valid(effect) or not is_instance_valid(effect.material):
		push_error("FXComponent: play_effect called with an invalid effect or material.")
		return
		
	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null
	
	_current_effect_name = effect.resource_path.get_file()

	var src_material := effect.material as ShaderMaterial
	if not is_instance_valid(src_material):
		push_error("FXComponent: effect.material is not a ShaderMaterial.")
		return

	var shader_res := src_material.shader
	_material_instance.shader = shader_res

	if is_instance_valid(shader_res):
		var uniform_list: Array
		if _shader_uniform_cache.has(shader_res):
			uniform_list = _shader_uniform_cache[shader_res]
		else:
			uniform_list = shader_res.get_shader_uniform_list()
			_shader_uniform_cache[shader_res] = uniform_list

		for param_info in uniform_list:
			var param_name: String = param_info.get("name", "")
			var usage := int(param_info.get("usage", 0))
			
			var is_sampler = not (usage & PROPERTY_USAGE_DEFAULT)
			if not is_sampler and param_name != "fx_progress" and param_name != "":
				var value = src_material.get_shader_parameter(param_name)
				_material_instance.set_shader_parameter(param_name, value)
	
	_visual_node.material = _material_instance
	self._progress = 0.0
	
	_active_tween = create_tween()
	_active_tween.finished.connect(_on_effect_finished, CONNECT_ONE_SHOT)
	_active_tween.tween_property(self, "_progress", 1.0, effect.duration)

## Returns the filename of the currently playing effect.
func get_current_effect_name() -> String:
	return _current_effect_name

# --- Signal Handlers ---

func _on_owner_took_damage(_damage_info: DamageInfo, _damage_result: DamageResult) -> void:
	if is_instance_valid(default_hit_effect):
		play_effect(default_hit_effect)
	else:
		push_warning("FXComponent on '%s' received took_damage, but has no default_hit_effect assigned." % [_owner.name])

func _on_effect_finished() -> void:
	if is_instance_valid(_visual_node):
		_visual_node.material = _original_material
	_current_effect_name = "None"
	_active_tween = null


=====================================
FILE: ./src/entities/minions/turret.gd
=====================================
# src/entities/minions/turret.gd
@tool
## A stationary enemy that detects and fires projectiles at the player.
class_name Turret
extends BaseEntity

# --- Enums ---
enum State { IDLE, ATTACK }

# --- Constants ---
const COMBAT_CONFIG = preload("res://src/data/combat_config.tres")
const HIT_FLASH_EFFECT = preload("res://src/data/effects/entity_hit_flash_effect.tres")

# --- Editor Configuration ---
@export var hit_spark_effect: VFXEffect

# --- Node References ---
@onready var visual: Polygon2D = $Visual
@onready var attack_timer: Timer = $AttackTimer
@onready var range_detector_shape: CollisionShape2D = $RangeDetector/CollisionShape2D

# --- Public Member Variables ---
var entity_data: TurretStateData

# --- Private Member Variables ---
var _player: CharacterBody2D

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint(): return

	_initialize_data()
	_initialize_and_setup_components()
	_connect_signals()

	_player = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)

func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

# --- Public Methods ---

func teardown() -> void:
	if is_instance_valid(health_component):
		if health_component.died.is_connected(_on_health_component_died):
			health_component.died.disconnect(_on_health_component_died)
	
	super.teardown()
	entity_data = null

func deactivate() -> void:
	if is_instance_valid(state_machine):
		state_machine.teardown()
	if is_instance_valid(attack_timer):
		attack_timer.stop()

	set_physics_process(false)
	$RangeDetector.monitoring = false

# --- Private Methods ---

func _fire_at_player() -> void:
	if not is_instance_valid(_player): return

	var shot = ObjectPool.get_instance(Identifiers.Pools.TURRET_SHOTS)
	if not is_instance_valid(shot): return

	shot.direction = (self._player.global_position - self.global_position).normalized()
	shot.global_position = self.global_position
	shot.activate({"object_pool": ObjectPool})

func _die() -> void:
	queue_free()

func _initialize_data() -> void:
	add_to_group(Identifiers.Groups.ENEMY)
	visual.color = Palette.COLOR_TERRAIN_SECONDARY
	entity_data = TurretStateData.new()
	entity_data.config = COMBAT_CONFIG

func _initialize_and_setup_components() -> void:
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = entity_data.config.turret_detection_radius
	range_detector_shape.shape = circle_shape
	
	attack_timer.wait_time = entity_data.config.turret_fire_rate

	var shared_deps := {
		"data_resource": entity_data,
		"config": entity_data.config
	}
	
	var states = {
		State.IDLE: load("res://src/entities/minions/states/state_turret_idle.gd").new(self, state_machine, entity_data),
		State.ATTACK: load("res://src/entities/minions/states/state_turret_attack.gd").new(self, state_machine, entity_data)
	}
	
	var per_component_deps := {
		state_machine: {"states": states, "initial_state_key": State.IDLE},
		fx_component: {"visual_node": visual, "health_component": health_component, "hit_effect": HIT_FLASH_EFFECT}
	}

	setup_components(shared_deps, per_component_deps)

func _connect_signals() -> void:
	health_component.died.connect(_on_health_component_died)

# --- Signal Handlers ---

func _on_range_detector_body_entered(body: Node) -> void:
	if not entity_data: return
	if body.is_in_group(Identifiers.Groups.PLAYER):
		entity_data.is_player_in_range = true

func _on_range_detector_body_exited(body: Node) -> void:
	if not entity_data: return
	if body.is_in_group(Identifiers.Groups.PLAYER):
		entity_data.is_player_in_range = false
		
func _on_health_component_died() -> void:
	_die()

=====================================
FILE: ./src/entities/minions/turret_state_data.gd
=====================================
# src/entities/minions/turret_state_data.gd
## A Resource that holds all shared runtime state data for the Turret minion.
class_name TurretStateData
extends Resource

# --- Configuration Reference ---
var config: CombatConfig

# --- Health & Combat ---
var max_health: int = 3
var health: int = 3:
	set(value):
		health = clamp(value, 0, max_health)

var is_invincible: bool = false

# --- Targeting ---
var is_player_in_range: bool = false

=====================================
FILE: ./src/entities/minions/states/state_turret_attack.gd
=====================================
# src/entities/minions/states/state_turret_attack.gd
## The state for when the turret is actively firing at the player.
extends BaseState
class_name TurretStateAttack

# --- Private Member Variables ---
var _turret: Turret

# --- State Lifecycle ---

func enter(_msg := {}) -> void:
	self._turret = owner as Turret
	if not is_instance_valid(_turret): return

	_turret._fire_at_player()
	_turret.attack_timer.start(state_data.config.turret_fire_rate)

func process_physics(_delta: float) -> void:
	if not is_instance_valid(_turret): return

	if not state_data.is_player_in_range:
		state_machine.change_state(_turret.State.IDLE)
		return

	if _turret.attack_timer.is_stopped():
		_turret._fire_at_player()
		_turret.attack_timer.start(state_data.config.turret_fire_rate)

=====================================
FILE: ./src/entities/minions/states/state_turret_idle.gd
=====================================
# src/entities/minions/states/state_turret_idle.gd
## The state for when the turret is inactive and waiting for the player.
extends BaseState
class_name TurretStateIdle

# --- Private Member Variables ---
var _turret: Turret

# --- State Lifecycle ---

func enter(_msg := {}) -> void:
	self._turret = owner as Turret

func exit() -> void:
	if is_instance_valid(_turret):
		_turret.attack_timer.stop()

func process_physics(_delta: float) -> void:
	if not is_instance_valid(_turret): return

	if state_data.is_player_in_range:
		state_machine.change_state(_turret.State.ATTACK)


=====================================
FILE: ./src/entities/minions/turret.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://c7d8faf0g1h2i"]

[ext_resource type="Script" path="res://src/entities/minions/turret.gd" id="1_turret_script"]
[ext_resource type="Resource" uid="uid://player_hit_spark_tres" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="2_hit_spark_effect"]
[ext_resource type="Resource" uid="uid://turret_archetype_resource" path="res://src/entities/archetypes/turret_archetype.tres" id="3_archetype"]
[ext_resource type="Script" path="res://src/entities/minions/states/state_turret_idle.gd" id="4_state_idle"]
[ext_resource type="Script" path="res://src/entities/minions/states/state_turret_attack.gd" id="5_state_attack"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_turretbody"]
size = Vector2(50, 50)

[node name="Turret" type="CharacterBody2D" groups=["enemy"]]
collision_layer = 4
collision_mask = 131
script = ExtResource("1_turret_script")
archetype = ExtResource("3_archetype")
hit_spark_effect = ExtResource("2_hit_spark_effect")

; State Scripts
state_idle_script = ExtResource("4_state_idle")
state_attack_script = ExtResource("5_state_attack")

[node name="Visual" type="Polygon2D" parent="."]
color = Color(0.490196, 0.490196, 0.490196, 1)
polygon = PackedVector2Array(-25, -25, 25, -25, 25, 25, -25, 25)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_turretbody")

[node name="AttackTimer" type="Timer" parent="."]
wait_time = 2.0
one_shot = true

[node name="RangeDetector" type="Area2D" parent="."]
collision_layer = 0
collision_mask = 1

[node name="CollisionShape2D" type="CollisionShape2D" parent="RangeDetector"]

[connection signal="body_entered" from="RangeDetector" to="." method="_on_range_detector_body_entered"]
[connection signal="body_exited" from="RangeDetector" to="." method="_on_range_detector_body_exited"]

=====================================
FILE: ./src/entities/player/player.tscn
=====================================
[gd_scene load_steps=15 format=3 uid="uid://c6vknl71ea1bo"]

[ext_resource type="Script" path="res://src/entities/player/player.gd" id="1_4d1td"]
[ext_resource type="Resource" uid="uid://player_archetype_resource" path="res://src/entities/archetypes/player_archetype.tres" id="2_archetype"]
[ext_resource type="Resource" uid="uid://player_damage_shake_tres" path="res://src/core/data/effects/player_damage_shake.tres" id="3_shake_effect"]
[ext_resource type="Resource" uid="uid://player_hit_spark_tres" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="4_hit_spark_effect"]
[ext_resource type="Script" path="res://src/entities/player/states/state_move.gd" id="5_state_move"]
[ext_resource type="Script" path="res://src/entities/player/states/state_jump.gd" id="6_state_jump"]
[ext_resource type="Script" path="res://src/entities/player/states/state_fall.gd" id="7_state_fall"]
[ext_resource type="Script" path="res://src/entities/player/states/state_dash.gd" id="8_state_dash"]
[ext_resource type="Script" path="res://src/entities/player/states/state_wall_slide.gd" id="9_state_wall_slide"]
[ext_resource type="Script" path="res://src/entities/player/states/state_attack.gd" id="10_state_attack"]
[ext_resource type="Script" path="res://src/entities/player/states/state_hurt.gd" id="11_state_hurt"]
[ext_resource type="Script" path="res://src/entities/player/states/state_heal.gd" id="12_state_heal"]
[ext_resource type="Script" path="res://src/entities/player/states/state_pogo.gd" id="13_state_pogo"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerbody"]
size = Vector2(40, 40)

[node name="Player" type="CharacterBody2D"]
collision_layer = 1
collision_mask = 142
script = ExtResource("1_4d1td")
archetype = ExtResource("2_archetype")
damage_shake_effect = ExtResource("3_shake_effect")
hit_spark_effect = ExtResource("4_hit_spark_effect")

; State Scripts
state_move_script = ExtResource("5_state_move")
state_jump_script = ExtResource("6_state_jump")
state_fall_script = ExtResource("7_state_fall")
state_dash_script = ExtResource("8_state_dash")
state_wall_slide_script = ExtResource("9_state_wall_slide")
state_attack_script = ExtResource("10_state_attack")
state_hurt_script = ExtResource("11_state_hurt")
state_heal_script = ExtResource("12_state_heal")
state_pogo_script = ExtResource("13_state_pogo")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.941176, 0.941176, 0.941176, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playerbody")

[node name="MeleeHitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 148

[node name="CollisionShape2D" type="CollisionShape2D" parent="MeleeHitbox"]
position = Vector2(60, 0)
shape = SubResource("RectangleShape2D_playerbody")
disabled = true

[node name="PogoHitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 150

[node name="CollisionShape2D" type="CollisionShape2D" parent="PogoHitbox"]
shape = SubResource("RectangleShape2D_playerbody")
disabled = true

[node name="Hurtbox" type="Area2D" parent="."]
collision_layer = 64
collision_mask = 28

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hurtbox"]
shape = SubResource("RectangleShape2D_playerbody")

[node name="HealingTimer" type="Timer" parent="."]
one_shot = true

[connection signal="timeout" from="HealingTimer" to="." method="_on_healing_timer_timeout"]

=====================================
FILE: ./src/entities/player/player.gd
=====================================
# src/entities/player/player.gd
@tool
class_name Player
extends BaseEntity

# --- Signals ---
signal health_changed(current_health, max_health)
signal died

# --- Enums ---
enum State {MOVE, JUMP, FALL, DASH, WALL_SLIDE, ATTACK, HURT, HEAL, POGO}

# --- Constants ---
const ACTION_ALLOWED_STATES = [State.MOVE, State.FALL, State.JUMP, State.WALL_SLIDE]
const CombatUtilsScript = preload(AssetPaths.SCRIPT_COMBAT_UTILS)
const COMBAT_CONFIG = preload("res://src/data/combat_config.tres")
const HIT_FLASH_EFFECT = preload("res://src/data/effects/entity_hit_flash_effect.tres")

# --- Editor Properties ---
@export_group("Juice & Feedback")
@export var damage_shake_effect: ScreenShakeEffect
@export var hit_spark_effect: VFXEffect
@export_group("State Scripts")
@export var state_move_script: Script
@export var state_jump_script: Script
@export var state_fall_script: Script
@export var state_dash_script: Script
@export var state_wall_slide_script: Script
@export var state_attack_script: Script
@export var state_hurt_script: Script
@export var state_heal_script: Script
@export var state_pogo_script: Script

# --- Node References ---
@onready var visual_sprite: ColorRect = $ColorRect
@onready var hurtbox: Area2D = $Hurtbox
@onready var healing_timer: Timer = $HealingTimer
@onready var melee_hitbox: Area2D = $MeleeHitbox
@onready var pogo_hitbox: Area2D = $PogoHitbox

# --- Data ---
var entity_data: PlayerStateData

# --- Private Member Variables ---
var _object_pool: ObjectPool

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint(): return

	add_to_group(Identifiers.Groups.PLAYER)
	_initialize_and_setup_components()
	_connect_signals()

	visual_sprite.color = Palette.COLOR_PLAYER
	# TODO: This is a temporary fix to initialize the UI. Should be event driven.
	resource_component.on_damage_dealt()
	entity_data.determination_counter = 0

func _physics_process(delta: float) -> void:
	_update_timers(delta)

# --- Public Methods ---

func teardown() -> void:
	# Disconnect signals that THIS script is listening to.
	if is_instance_valid(health_component):
		if health_component.health_changed.is_connected(_on_health_component_health_changed):
			health_component.health_changed.disconnect(_on_health_component_health_changed)
		if health_component.died.is_connected(_on_health_component_died):
			health_component.died.disconnect(_on_health_component_died)
	if is_instance_valid(combat_component):
		if combat_component.damage_dealt.is_connected(resource_component.on_damage_dealt):
			combat_component.damage_dealt.disconnect(resource_component.on_damage_dealt)
		if combat_component.pogo_bounce_requested.is_connected(_on_pogo_bounce_requested):
			combat_component.pogo_bounce_requested.disconnect(_on_pogo_bounce_requested)
	if is_instance_valid(state_machine):
		if state_machine.action_requested.is_connected(_on_state_machine_action_requested):
			state_machine.action_requested.disconnect(_on_state_machine_action_requested)

	super.teardown()
	entity_data = null

# --- Private Methods ---

func _enable_melee_hitbox(is_enabled: bool, is_up_attack: bool = false) -> void:
	var shape_node: CollisionShape2D = melee_hitbox.get_node("CollisionShape2D")
	if is_enabled:
		if is_up_attack:
			shape_node.shape = entity_data.config.player_upward_attack_shape
			shape_node.position = Vector2(0, -40)
		else:
			shape_node.shape = entity_data.config.player_forward_attack_shape
			shape_node.position = Vector2(entity_data.facing_direction * 60, 0)
	shape_node.disabled = not is_enabled

func _enable_pogo_hitbox(is_enabled: bool) -> void:
	var shape_node: CollisionShape2D = pogo_hitbox.get_node("CollisionShape2D")
	shape_node.position = Vector2(0, 40)
	shape_node.disabled = not is_enabled

func _initialize_and_setup_components() -> void:
	entity_data = PlayerStateData.new()
	entity_data.config = COMBAT_CONFIG
	_object_pool = ObjectPool
	
	var shared_deps := {
		"data_resource": entity_data,
		"config": entity_data.config,
		"health_component": health_component,
		"object_pool": _object_pool,
		"event_bus": EventBus
	}
	
	var states = {
		State.MOVE: state_move_script.new(self, state_machine, entity_data),
		State.FALL: state_fall_script.new(self, state_machine, entity_data),
		State.JUMP: state_jump_script.new(self, state_machine, entity_data),
		State.DASH: state_dash_script.new(self, state_machine, entity_data),
		State.WALL_SLIDE: state_wall_slide_script.new(self, state_machine, entity_data),
		State.ATTACK: state_attack_script.new(self, state_machine, entity_data),
		State.HURT: state_hurt_script.new(self, state_machine, entity_data),
		State.HEAL: state_heal_script.new(self, state_machine, entity_data),
		State.POGO: state_pogo_script.new(self, state_machine, entity_data),
	}
	
	var per_component_deps := {
		state_machine: {"states": states, "initial_state_key": State.FALL},
		input_component: {"state_machine": state_machine},
		ability_component: {"state_machine": state_machine, "input_component": input_component},
		fx_component: {"visual_node": visual_sprite, "health_component": health_component, "hit_effect": HIT_FLASH_EFFECT}
	}
	
	setup_components(shared_deps, per_component_deps)


func _connect_signals() -> void:
	melee_hitbox.body_entered.connect(_on_melee_hitbox_body_entered)
	pogo_hitbox.body_entered.connect(_on_pogo_hitbox_body_entered)
	melee_hitbox.area_entered.connect(_on_hitbox_area_entered)
	pogo_hitbox.area_entered.connect(_on_hitbox_area_entered)
	hurtbox.area_entered.connect(_on_hurtbox_area_entered)
	health_component.health_changed.connect(_on_health_component_health_changed)
	health_component.died.connect(_on_health_component_died)
	combat_component.damage_dealt.connect(resource_component.on_damage_dealt)
	combat_component.pogo_bounce_requested.connect(_on_pogo_bounce_requested)
	state_machine.action_requested.connect(_on_state_machine_action_requested)

func _update_timers(delta: float) -> void:
	if not is_instance_valid(entity_data): return

	entity_data.coyote_timer = max(0.0, entity_data.coyote_timer - delta)
	entity_data.wall_coyote_timer = max(0.0, entity_data.wall_coyote_timer - delta)
	entity_data.dash_cooldown_timer = max(0.0, entity_data.dash_cooldown_timer - delta)
	entity_data.dash_duration_timer = max(0.0, entity_data.dash_duration_timer - delta)
	entity_data.attack_duration_timer = max(0.0, entity_data.attack_duration_timer - delta)
	entity_data.attack_cooldown_timer = max(0.0, entity_data.attack_cooldown_timer - delta)
	entity_data.knockback_timer = max(0.0, entity_data.knockback_timer - delta)
	entity_data.pogo_fall_prevention_timer = max(0.0, entity_data.pogo_fall_prevention_timer - delta)
	if entity_data.is_charging and input_component.buffer.get("attack_pressed"):
		entity_data.charge_timer += delta

# --- Signal Handlers ---

func _on_state_machine_action_requested(command: Callable) -> void:
	if command.is_valid():
		command.call()

func _on_melee_hitbox_body_entered(body: Node) -> void:
	var target_id = body.get_instance_id()
	if entity_data.hit_targets_this_swing.has(target_id): return
	entity_data.hit_targets_this_swing[target_id] = true
	var damageable = CombatUtilsScript.find_damageable(body)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.source_node = self
		var distance = self.global_position.distance_to(body.global_position)
		var is_close_range = distance <= entity_data.config.player_close_range_threshold
		damage_info.amount = 5 if is_close_range else 1
		damage_info.impact_position = body.global_position
		damage_info.impact_normal = (body.global_position - global_position).normalized()
		var damage_result = damageable.apply_damage(damage_info)
		if damage_result.was_damaged:
			resource_component.on_damage_dealt()
			if is_close_range:
				FXManager.request_hit_stop(entity_data.config.player_melee_close_range_hit_stop_duration)
func _on_pogo_hitbox_body_entered(body: Node) -> void:
	combat_component.trigger_pogo(body)
func _on_hitbox_area_entered(area: Area2D) -> void:
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		if entity_data.is_pogo_attack:
			combat_component.trigger_pogo(area)
		else:
			_object_pool.return_instance.call_deferred(area)
func _on_hurtbox_area_entered(area: Area2D) -> void:
	if health_component.is_invincible(): return
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		var damage_info = DamageInfo.new()
		damage_info.amount = 1
		damage_info.source_node = area
		damage_info.impact_position = global_position
		damage_info.impact_normal = (global_position - area.global_position).normalized()
		var damage_result = health_component.apply_damage(damage_info)
		
		if not is_instance_valid(entity_data): return
		
		if damage_result.was_damaged and entity_data.health > 0:
			self.velocity = damage_result.knockback_velocity
			state_machine.change_state(State.HURT)
		_object_pool.return_instance.call_deferred(area)
func _on_healing_timer_timeout() -> void:
	if state_machine.current_state == state_machine.states[State.HEAL]:
		entity_data.health += 1
		resource_component.consume_healing_charge()
		_on_health_component_health_changed(entity_data.health, entity_data.max_health)
		state_machine.change_state(State.MOVE)
func _on_health_component_health_changed(current: int, max_val: int) -> void:
	var ev = PlayerHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	EventBus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev)
	health_changed.emit(current, max_val)
func _on_health_component_died() -> void:
	died.emit()
func _on_pogo_bounce_requested() -> void:
	velocity.y = -entity_data.config.player_pogo_force
	position.y -= 1
	entity_data.can_dash = true
	entity_data.air_jumps_left = entity_data.config.player_max_air_jumps
	state_machine.change_state(State.FALL)
func _cancel_heal() -> void:
	if healing_timer.is_stopped(): return
	healing_timer.stop()


=====================================
FILE: ./src/entities/player/components/player_resource_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://a1b2c3d4e5f6"]

[ext_resource type="Script" path="res://src/entities/player/components/player_resource_component.gd" id="1_res"]

[node name="PlayerResourceComponent" type="Node"]
script = ExtResource("1_res")

=====================================
FILE: ./src/entities/player/components/player_ability_component.gd
=====================================
# src/entities/player/components/player_ability_component.gd
@tool
## Governs the activation logic for player abilities.
##
## Reads the input buffer and game state to determine if an action (like
## dashing or healing) can be performed, then instructs the StateMachine.
class_name PlayerAbilityComponent
extends IComponent

# --- Member Variables ---
var owner_node: BaseEntity
var p_data: PlayerStateData
var state_machine: BaseStateMachine
var input_component: InputComponent

# --- Godot Lifecycle Methods ---

func _physics_process(_delta: float) -> void:
	if not is_instance_valid(owner_node): return

	var current_state_key = state_machine.states.find_key(state_machine.current_state)

	# --- Heal Logic (Highest Priority) ---
	var can_try_heal = owner_node.is_on_floor() and \
		input_component.buffer.get("down") and \
		input_component.buffer.get("jump_held") and \
		p_data.healing_charges > 0 and \
		is_zero_approx(owner_node.velocity.x)
	
	if can_try_heal:
		state_machine.change_state(Player.State.HEAL)
		return

	# --- Action State Logic ---
	if not current_state_key in Player.ACTION_ALLOWED_STATES:
		return

	# --- Attack / Charge Shot Logic ---
	if input_component.buffer.get("attack_just_pressed") and p_data.attack_cooldown_timer <= 0:
		p_data.is_charging = true
		p_data.charge_timer = 0.0

	if input_component.buffer.get("attack_released"):
		if p_data.is_charging:
			if p_data.charge_timer >= p_data.config.player_charge_time:
				(owner_node as Player).combat_component.fire_shot()
			elif input_component.buffer.get("down"):
				state_machine.change_state(Player.State.POGO)
			else:
				state_machine.change_state(Player.State.ATTACK)
			p_data.is_charging = false

	# --- Dash Logic ---
	if input_component.buffer.get("dash_pressed") and p_data.can_dash and p_data.dash_cooldown_timer <= 0:
		state_machine.change_state(Player.State.DASH)


# --- Public Methods ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as BaseEntity
	self.p_data = p_dependencies.get("data_resource")
	self.state_machine = p_dependencies.get("state_machine")
	self.input_component = p_dependencies.get("input_component")

func teardown() -> void:
	set_physics_process(false)
	owner_node = null
	p_data = null
	state_machine = null
	input_component = null

=====================================
FILE: ./src/entities/player/components/player_physics_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://o9p0q1r2s3t4"]

[ext_resource type="Script" path="res://src/entities/player/components/player_physics_component.gd" id="1_phys"]

[node name="PlayerPhysicsComponent" type="Node"]
script = ExtResource("1_phys")

=====================================
FILE: ./src/entities/player/components/player_physics_component.gd
=====================================
# src/entities/player/components/player_physics_component.gd
@tool
## Manages all direct physics interactions for the player character.
##
## Handles gravity, movement, collision detection, and applying velocity via
## move_and_slide(). It serves as the single point of contact with the
## Godot physics engine for the player.
class_name PlayerPhysicsComponent
extends IComponent

# --- Member Variables ---
var owner_node: Player
var p_data: PlayerStateData
var health_component: HealthComponent

# --- Godot Lifecycle Methods ---

func _physics_process(_delta: float) -> void:
	if not is_instance_valid(owner_node): return # Guard against post-teardown calls

	owner_node.move_and_slide()
	_check_for_contact_damage()

	# GUARD: The owner may have been freed by the contact damage check.
	if not is_instance_valid(owner_node): return

	if owner_node.is_on_wall() and not owner_node.is_on_floor():
		p_data.wall_coyote_timer = p_data.config.player_wall_coyote_time
		p_data.last_wall_normal = owner_node.get_wall_normal()

# --- Public Methods ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as Player
	self.p_data = p_dependencies.get("data_resource")
	self.health_component = p_dependencies.get("health_component")

func teardown() -> void:
	set_physics_process(false)
	owner_node = null
	p_data = null
	health_component = null

func apply_horizontal_movement() -> void:
	var move_axis = owner_node.input_component.buffer.get("move_axis", 0.0)
	owner_node.velocity.x = move_axis * p_data.config.player_speed
	if not is_zero_approx(move_axis):
		p_data.facing_direction = sign(move_axis)

func apply_gravity(delta: float, multiplier: float = 1.0) -> void:
	owner_node.velocity.y += p_data.config.gravity * multiplier * delta

# --- Private Methods ---

func _check_for_contact_damage() -> void:
	if health_component.is_invincible(): return

	for i in range(owner_node.get_slide_collision_count()):
		var col = owner_node.get_slide_collision(i)
		if not col: continue

		var collider = col.get_collider()
		var is_damage_source = is_instance_valid(collider) and \
			(collider.is_in_group(Identifiers.Groups.ENEMY) or collider.is_in_group(Identifiers.Groups.HAZARD))

		if not is_damage_source: continue

		var damage_info = DamageInfo.new()
		damage_info.amount = 1
		damage_info.source_node = collider
		damage_info.impact_position = col.get_position()
		damage_info.impact_normal = col.get_normal()
		var damage_result = owner_node.health_component.apply_damage(damage_info)

		# GUARD: The owner may have been freed by the apply_damage call.
		if not is_instance_valid(owner_node): return

		# THE FIX: Do not change to HURT state if the damage was lethal.
		if damage_result.was_damaged and p_data.health > 0:
			owner_node.velocity = damage_result.knockback_velocity
			owner_node.state_machine.change_state(owner_node.State.HURT)
		break


=====================================
FILE: ./src/entities/player/components/player_ability_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://u5v6w7x8y9z0"]

[ext_resource type="Script" path="res://src/entities/player/components/player_ability_component.gd" id="1_abil"]

[node name="PlayerAbilityComponent" type="Node"]
script = ExtResource("1_abil")

=====================================
FILE: ./src/entities/player/components/player_resource_component.gd
=====================================
# src/entities/player/components/player_resource_component.gd
@tool
## Manages the player's resource economy (Determination and Healing).
class_name PlayerResourceComponent
extends IComponent

# --- Member Variables ---
var owner_node: BaseEntity
var p_data: PlayerStateData
var _event_bus: Node # Dependency

# --- Public Methods ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as BaseEntity
	self.p_data = p_dependencies.get("data_resource")
	self._event_bus = p_dependencies.get("event_bus")
	assert(is_instance_valid(_event_bus), "PlayerResourceComponent requires an EventBus dependency.")

func teardown() -> void:
	owner_node = null
	p_data = null
	_event_bus = null

## Called when the player successfully deals damage to an enemy.
func on_damage_dealt() -> void:
	if p_data.healing_charges >= p_data.config.player_max_healing_charges: return

	p_data.determination_counter += 1
	if p_data.determination_counter >= p_data.config.player_determination_per_charge:
		p_data.determination_counter = 0
		p_data.healing_charges += 1
		_emit_healing_charges_changed_event()

## Consumes one healing charge.
func consume_healing_charge() -> void:
	if p_data.healing_charges > 0:
		p_data.healing_charges -= 1
		_emit_healing_charges_changed_event()

# --- Private Methods ---

func _emit_healing_charges_changed_event() -> void:
	var ev = PlayerHealingChargesChangedEvent.new()
	ev.current_charges = p_data.healing_charges
	_event_bus.emit(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, ev)

=====================================
FILE: ./src/entities/player/states/state_jump.gd
=====================================
# src/entities/player/states/state_jump.gd
## Handles the player's upward movement (jump).
extends BaseState

func enter(msg := {}) -> void:
	# THE FIX: If this state was entered via an air jump, consume the resource.
	if msg.get("is_air_jump", false):
		state_data.air_jumps_left -= 1

	owner.velocity.y = -state_data.config.player_jump_force
	state_data.coyote_timer = 0

func process_physics(delta: float) -> void:
	owner.physics_component.apply_horizontal_movement()

	# --- Air Jump Logic ---
	# Allow spending an air jump while ascending.
	if owner.input_component.buffer.get("jump_just_pressed"):
		if state_data.air_jumps_left > 0:
			_perform_air_jump()
			# No return here; we still need to apply gravity and other checks.

	if owner.input_component.buffer.get("jump_released") and owner.velocity.y < 0:
		owner.velocity.y *= state_data.config.player_jump_release_dampener

	_apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(owner.State.MOVE)
		return

	_check_for_wall_slide()

func _apply_gravity(delta: float) -> void:
	owner.physics_component.apply_gravity(delta)
	if owner.velocity.y > 0.0:
		state_machine.change_state(owner.State.FALL)

func _check_for_wall_slide() -> void:
	var move_axis = owner.input_component.buffer.get("move_axis", 0.0)
	var can_wall_slide = state_data.wall_coyote_timer > 0 and \
		not owner.is_on_floor() and move_axis != 0 and \
		sign(move_axis) == -state_data.last_wall_normal.x
		
	if can_wall_slide:
		state_machine.change_state(owner.State.WALL_SLIDE)

func _perform_air_jump() -> void:
	state_data.air_jumps_left -= 1
	# Reset vertical velocity to perform the air jump.
	owner.velocity.y = -state_data.config.player_jump_force

=====================================
FILE: ./src/entities/player/states/state_dash.gd
=====================================
# src/entities/player/states/state_dash.gd
extends BaseState

var _dash_direction: Vector2
var _invincibility_token: int

func enter(_msg := {}):
	state_data.can_dash = false
	state_data.dash_duration_timer = state_data.config.player_dash_duration
	state_data.dash_cooldown_timer = state_data.config.player_dash_cooldown
	
	_invincibility_token = owner.health_component.grant_invincibility(self)
	
	_dash_direction = _get_dash_direction()
	owner.velocity = _dash_direction * state_data.config.player_dash_speed

func exit():
	if is_instance_valid(owner) and is_instance_valid(owner.health_component):
		owner.health_component.release_invincibility(_invincibility_token)
	
	if _dash_direction.y != 0:
		owner.velocity.y = 0.0
	if _dash_direction.x != 0:
		owner.velocity.x = 0.0

func process_physics(_delta: float):
	if state_data.dash_duration_timer <= 0:
		state_machine.change_state(owner.State.FALL)

func _get_dash_direction():
	if Input.is_action_pressed("ui_up"): return Vector2.UP
	if Input.is_action_pressed("ui_down"): return Vector2.DOWN
	return Vector2(state_data.facing_direction, 0)

=====================================
FILE: ./src/entities/player/states/state_heal.gd
=====================================
# src/entities/player/states/state_heal.gd
# Handles the player's healing state.
extends BaseState

func enter(_msg := {}):
	owner.velocity = Vector2.ZERO
	owner.healing_timer.start(state_data.config.player_heal_duration)

func exit():
	owner._cancel_heal()

func process_physics(_delta: float):
	if not Input.is_action_pressed("ui_down") or not Input.is_action_pressed("ui_jump") or not is_zero_approx(owner.velocity.x) or not owner.is_on_floor():
		state_machine.change_state(owner.State.MOVE)

=====================================
FILE: ./src/entities/player/states/state_wall_slide.gd
=====================================
# src/entities/player/states/state_wall_slide.gd
# Handles the player's wall sliding state.
extends BaseState

func enter(_msg := {}):
	state_data.can_dash = true
	state_data.air_jumps_left = state_data.config.player_max_air_jumps

func exit():
	if state_data.last_wall_normal != Vector2.ZERO:
		state_data.facing_direction = sign(state_data.last_wall_normal.x)

func process_physics(delta: float):
	var gravity = state_data.config.gravity
	var wall_slide_speed = state_data.config.player_wall_slide_speed
	owner.velocity.y = min(owner.velocity.y + gravity * delta, wall_slide_speed)
	
	state_data.facing_direction = sign(-state_data.last_wall_normal.x)
	
	if owner.input_component.buffer.get("jump_just_pressed"):
		_perform_wall_jump()
		return
	
	var move_axis = owner.input_component.buffer.get("move_axis", 0.0)
	if move_axis * -state_data.last_wall_normal.x < 0.8:
		state_machine.change_state(owner.State.FALL)
		return
		
	if state_data.wall_coyote_timer <= 0:
		state_machine.change_state(owner.State.FALL)
		return

	if owner.is_on_floor():
		state_machine.change_state(owner.State.MOVE)
		return

func _perform_wall_jump():
	owner.velocity.y = -state_data.config.player_wall_jump_force_y
	owner.velocity.x = state_data.last_wall_normal.x * state_data.config.player_wall_jump_force_x
	state_data.coyote_timer = 0
	state_data.wall_coyote_timer = 0
	state_machine.change_state(owner.State.JUMP)

=====================================
FILE: ./src/entities/player/states/state_attack.gd
=====================================
# src/entities/player/states/state_attack.gd
## This state handles the player's melee attack.
class_name PlayerStateAttack
extends BaseState

# --- State Lifecycle ---

func enter(_msg := {}) -> void:
	state_data.hit_targets_this_swing.clear()
	state_data.attack_duration_timer = state_data.config.player_attack_duration
	state_data.attack_cooldown_timer = state_data.config.player_attack_cooldown
	var is_up_attack = owner.input_component.buffer.get("up", false)
	owner._enable_melee_hitbox(true, is_up_attack)

func exit() -> void:
	owner.call_deferred("_enable_melee_hitbox", false)
	state_data.hit_targets_this_swing.clear()

func process_physics(delta: float) -> void:
	var friction = state_data.config.player_attack_friction
	owner.velocity = owner.velocity.move_toward(Vector2.ZERO, friction * delta)

	if state_data.attack_duration_timer <= 0:
		state_machine.change_state(owner.State.FALL)

=====================================
FILE: ./src/entities/player/states/state_pogo.gd
=====================================
# src/entities/player/states/state_pogo.gd
## Handles the player's downward pogo attack state.
class_name PlayerStatePogo
extends BaseState

# --- State Lifecycle ---

func enter(_msg := {}) -> void:
	state_data.is_pogo_attack = true
	# Use the existing attack timer to give the pogo a limited duration.
	state_data.attack_duration_timer = state_data.config.player_attack_duration
	owner._enable_pogo_hitbox(true)

func exit() -> void:
	owner.call_deferred("_enable_pogo_hitbox", false)
	state_data.is_pogo_attack = false

func process_physics(delta: float) -> void:
	owner.physics_component.apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(owner.State.MOVE)
		return

	if state_data.attack_duration_timer <= 0:
		state_machine.change_state(owner.State.FALL)


=====================================
FILE: ./src/entities/player/states/state_hurt.gd
=====================================
# src/entities/player/states/state_hurt.gd
## Handles the player's knockback and stun state after taking damage.
extends BaseState

func enter(_msg := {}) -> void:
	state_data.knockback_timer = state_data.config.player_knockback_duration
	state_data.is_charging = false
	owner._cancel_heal()

func process_physics(delta: float) -> void:
	owner.physics_component.apply_gravity(delta)
	owner.velocity.x = move_toward(owner.velocity.x, 0, 800 * delta)

	if state_data.knockback_timer <= 0:
		state_machine.change_state(owner.State.FALL)


=====================================
FILE: ./src/entities/player/states/state_fall.gd
=====================================
# src/entities/player/states/state_fall.gd
## Handles the player's falling state (downward vertical movement).
extends BaseState

func process_physics(delta: float) -> void:
	owner.physics_component.apply_horizontal_movement()
	_apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(owner.State.MOVE)
		return

	_check_for_wall_slide()

	if owner.input_component.buffer.get("jump_just_pressed"):
		if state_data.wall_coyote_timer > 0:
			_perform_wall_jump()
		elif state_data.coyote_timer > 0:
			state_machine.change_state(owner.State.JUMP)
		elif state_data.air_jumps_left > 0:
			state_data.air_jumps_left -= 1
			state_machine.change_state(owner.State.JUMP)

func _apply_gravity(delta: float) -> void:
	var gravity_multiplier = 1.0
	if owner.input_component.buffer.get("down"):
		gravity_multiplier = state_data.config.player_fast_fall_gravity_multiplier
	owner.physics_component.apply_gravity(delta, gravity_multiplier)

func _check_for_wall_slide() -> void:
	var move_axis = owner.input_component.buffer.get("move_axis", 0.0)
	var can_wall_slide = state_data.wall_coyote_timer > 0 and \
		not owner.is_on_floor() and move_axis != 0 and \
		sign(move_axis) == -state_data.last_wall_normal.x
		
	if can_wall_slide:
		state_machine.change_state(owner.State.WALL_SLIDE)

func _perform_air_jump() -> void:
	# THE FIX: Pass a message to the JUMP state instead of decrementing here.
	state_machine.change_state(owner.State.JUMP, {"is_air_jump": true})

func _perform_wall_jump() -> void:
	owner.velocity.y = -state_data.config.player_wall_jump_force_y
	owner.velocity.x = state_data.last_wall_normal.x * state_data.config.player_wall_jump_force_x
	state_data.coyote_timer = 0
	state_data.wall_coyote_timer = 0
	state_machine.change_state(owner.State.JUMP)

=====================================
FILE: ./src/entities/player/states/state_move.gd
=====================================
# src/entities/player/states/state_move.gd
## Handles the player's grounded movement state.
extends BaseState

func enter(_msg := {}) -> void:
	state_data.air_jumps_left = state_data.config.player_max_air_jumps
	state_data.can_dash = true

func process_physics(delta: float) -> void:
	state_data.coyote_timer = state_data.config.player_coyote_time

	owner.physics_component.apply_gravity(delta)
	owner.physics_component.apply_horizontal_movement()

	if owner.input_component.buffer.get("jump_just_pressed"):
		# Check for drop-through platform
		var is_trying_drop = owner.input_component.buffer.get("down", false)
		if is_trying_drop:
			var floor_col = owner.get_last_slide_collision()
			if floor_col:
				var floor_collider = floor_col.get_collider()
				if is_instance_valid(floor_collider) and floor_collider.is_in_group(Identifiers.Groups.ONEWAY_PLATFORMS):
					owner.position.y += 2
					state_machine.change_state(owner.State.FALL)
					return

		# If not dropping, then it's a ground jump
		state_machine.change_state(owner.State.JUMP)
		return

	if not owner.is_on_floor():
		state_machine.change_state(owner.State.FALL)
		return

=====================================
FILE: ./src/entities/player/data/player_state_data.gd
=====================================
# src/entities/player/data/player_state_data.gd
@tool
## A Resource that holds all shared runtime state data for the Player.
class_name PlayerStateData
extends Resource

# --- Configuration Reference ---
var config: CombatConfig

# --- Health & Combat ---
var max_health: int = 5
var max_healing_charges: int = 1
var health: int = 5:
	set(value):
		health = clamp(value, 0, max_health)
var healing_charges: int = 0:
	set(value):
		healing_charges = clamp(value, 0, max_healing_charges)
var determination_counter: int = 0
var hit_targets_this_swing: Dictionary = {}

# --- Physics & Movement ---
var air_jumps_left: int = 0
var facing_direction: int = 1
var last_wall_normal: Vector2 = Vector2.ZERO
var can_dash: bool = true
var pogo_fall_prevention_timer: float = 0.0

# --- Timers ---
var coyote_timer: float = 0.0
var wall_coyote_timer: float = 0.0
var dash_duration_timer: float = 0.0
var dash_cooldown_timer: float = 0.0
var attack_duration_timer: float = 0.0
var attack_cooldown_timer: float = 0.0
var knockback_timer: float = 0.0

# --- State Flags ---
var is_charging: bool = false
var charge_timer: float = 0.0
var is_pogo_attack: bool = false

=====================================
FILE: ./src/entities/player/data/upward_attack_shape.tres
=====================================
[gd_resource type="RectangleShape2D" load_steps=0 format=3 uid="uid://c0dt7jqwtnbr"]

[resource]
size = Vector2(40, 40)


=====================================
FILE: ./src/entities/player/data/forward_attack_shape.tres
=====================================
[gd_resource type="RectangleShape2D" load_steps=0 format=3 uid="uid://c1b2d3e4f5g6h"]

[resource]
size = Vector2(80, 40)


