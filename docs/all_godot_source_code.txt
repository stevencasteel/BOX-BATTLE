+---------------------------------+
|       B O X  B A T T L E        |
|  Godot Project Source Context   |
+---------------------------------+
Generated on: Fri Nov 21 13:34:25 CST 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
├── LICENSE
├── README.md
├── assets
│   ├── audio
│   │   ├── audio-license.txt
│   │   ├── music
│   │   │   └── music_menu_loop.mp3
│   │   └── sfx
│   │       ├── sfx_game_start.mp3
│   │       ├── sfx_ui_back.mp3
│   │       ├── sfx_ui_error.mp3
│   │       ├── sfx_ui_move.mp3
│   │       ├── sfx_ui_select.mp3
│   │       └── sfx_ui_slider_tick.mp3
│   ├── fonts
│   │   ├── MPLUSRounded1c-ExtraBold.ttf
│   │   ├── MPLUSRounded1c-Light.ttf
│   │   ├── MPLUSRounded1c-Medium.ttf
│   │   ├── MPLUSRounded1c-Thin.ttf
│   │   ├── OFL.txt
│   │   ├── font_main_black.ttf
│   │   ├── font_main_bold.ttf
│   │   └── font_main_regular.ttf
│   ├── sprites
│   │   └── ui
│   │       ├── checkbox
│   │       │   ├── checkbox-checked.png
│   │       │   └── checkbox-unchecked.png
│   │       ├── cursors
│   │       │   ├── cursor-default-black.svg
│   │       │   ├── cursor_default_white.svg
│   │       │   ├── cursor_default_white_filled.svg
│   │       │   ├── sprite_cursor_default.png
│   │       │   └── sprite_cursor_pointer.png
│   │       ├── icons
│   │       │   ├── icon-sound-off-black.svg
│   │       │   ├── icon-sound-off-white.svg
│   │       │   ├── icon-sound-on-black.svg
│   │       │   ├── icon-sound-on-white.svg
│   │       │   ├── icon_ui_sound_off.png
│   │       │   └── icon_ui_sound_on.png
│   │       ├── logos
│   │       │   ├── godot_logo.png
│   │       │   ├── itch_logo.png
│   │       │   ├── newgrounds_logo.png
│   │       │   └── unorganized
│   │       │       ├── logo_vertical_color_dark.svg
│   │       │       └── logo_vertical_color_light.svg
│   │       ├── menu
│   │       │   └── menu-item-options.png
│   │       ├── slider
│   │       │   ├── slider-knob.png
│   │       │   └── slider-track.png
│   │       └── title
│   │           └── sprite_title_main.png
│   ├── textures
│   │   └── noise_texture.tres
│   └── vfx
│       └── particles
│           └── README.md
├── default_bus_layout.tres
├── docs
│   ├── ARCHITECTURE.txt
│   ├── ASSETS.txt
│   ├── BUGS.txt
│   ├── CHANGELOG.txt
│   ├── DESIGN.txt
│   ├── HOW_TO_ADD_AN_EFFECT.md
│   ├── TODO.txt
│   ├── all_godot_source_code.txt
│   ├── create_all_addons_collector.sh
│   ├── create_all_godot_source_code_txt.command
│   ├── create_all_godot_source_code_txt.sh
│   ├── last_commit_command.txt
│   └── standards
│       ├── ADR-001_Service_Locator.md
│       ├── ADR-002_Communication.md
│       └── STYLE-001_GDScript.md
├── export_presets.cfg
├── icon.svg
├── misc
│   └── Mega Man X - Sprites
│       └── PlayStation - Mega Man X4 - Playable Characters - X.png
├── pico.save
├── progess
│   └── progress_001-1.jpg
├── project.godot
├── run_tests.sh
├── shaders
└── src
    ├── arenas
    ├── content
    │   ├── levels
    │   │   └── level_00.tscn
    │   ├── materials
    │   │   ├── chromatic_material.tres
    │   │   ├── dissolve_material.tres
    │   │   ├── entity_hit_flash_material.tres
    │   │   ├── shockwave_material.tres
    │   │   └── vignette_material.tres
    │   ├── shaders
    │   │   ├── entity
    │   │   │   ├── dissolve.gdshader
    │   │   │   ├── red_hit_flash_test.gdshader
    │   │   │   └── red_hit_flash_test.gdshader.save
    │   │   ├── fullscreen
    │   │   │   ├── chromatic_aberration.gdshader
    │   │   │   ├── shockwave.gdshader
    │   │   │   └── vignette.gdshader
    │   │   ├── includes
    │   │   │   ├── color.gdshaderinc
    │   │   │   ├── common_math.gdshaderinc
    │   │   │   ├── fx_blend.gdshaderinc
    │   │   │   └── noise.gdshaderinc
    │   │   └── ui
    │   └── vfx
    │       ├── aura_charge_green.tscn
    │       ├── aura_heal_purple.tscn
    │       ├── hit_spark.gd
    │       ├── hit_spark.tscn
    │       ├── melee_slash.gd
    │       ├── melee_slash.tscn
    │       ├── splash_charge_green.tscn
    │       ├── splash_heal_purple.tscn
    │       ├── splash_impact_red.tscn
    │       └── splash_impact_red_large.tscn
    ├── core
    │   ├── DEPRECATION.md
    │   ├── README.md
    │   ├── boot
    │   │   ├── boot_manager.gd
    │   │   └── global_preloader.gd
    │   ├── data
    │   │   ├── audio
    │   │   │   └── audio_cue.gd
    │   │   ├── base_entity_data.gd
    │   │   ├── config
    │   │   │   ├── damage_response_config.gd
    │   │   │   ├── enemy_config.gd
    │   │   │   ├── player_config.gd
    │   │   │   ├── settings.gd
    │   │   │   ├── state_definition.gd
    │   │   │   ├── state_machine_config.gd
    │   │   │   └── world_config.gd
    │   │   ├── effects
    │   │   │   ├── boss_death_shake.tres
    │   │   │   ├── boss_phase_change_shake.tres
    │   │   │   ├── boss_spawn_shake.tres
    │   │   │   ├── dissolve_effect.tres
    │   │   │   ├── player_damage_shake.tres
    │   │   │   ├── player_hit_spark_effect.tres
    │   │   │   ├── screen_shake_effect.gd
    │   │   │   ├── shader_effect.gd
    │   │   │   └── vfx_effect.gd
    │   │   ├── game_state_data.gd
    │   │   └── save_data.gd
    │   ├── events
    │   │   ├── event_bus.gd
    │   │   ├── event_catalog.gd
    │   │   └── typed_events
    │   │       ├── boss_died_event.gd
    │   │       ├── boss_health_changed_event.gd
    │   │       ├── boss_phase_changed_event.gd
    │   │       ├── player_healing_charges_changed_event.gd
    │   │       └── player_health_changed_event.gd
    │   ├── sequencing
    │   │   ├── sequence_handle.gd
    │   │   ├── sequence_step.gd
    │   │   ├── sequencer.gd
    │   │   └── steps
    │   │       ├── callable_step.gd
    │   │       ├── emit_step.gd
    │   │       └── wait_step.gd
    │   ├── systems
    │   │   ├── audio_manager.gd
    │   │   ├── cursor_manager.gd
    │   │   ├── dialogue_manager.gd
    │   │   ├── game_manager.gd
    │   │   ├── input
    │   │   │   └── standard_input_provider.gd
    │   │   ├── object_pool.gd
    │   │   ├── pool_bindings
    │   │   │   └── object_pool_adapter.gd
    │   │   ├── pooling
    │   │   │   ├── pool_definition.gd
    │   │   │   └── pool_manifest.gd
    │   │   ├── save_manager.gd
    │   │   ├── scene_manager.gd
    │   │   └── targeting_system.gd
    │   └── util
    │       ├── asset_paths.gd
    │       ├── combat_utils.gd
    │       ├── constants.gd
    │       ├── dependency_validator.gd
    │       ├── grid_utils.gd
    │       ├── identifiers.gd
    │       ├── palette.gd
    │       ├── physics_layers.gd
    │       ├── scene_validator.gd
    │       └── service_locator.gd
    ├── data
    │   ├── audio
    │   │   ├── sfx_player_footsteps.tres
    │   │   └── sfx_player_impact.tres
    │   ├── combat
    │   │   └── attacks
    │   │       ├── boss_lunge_melee.tres
    │   │       ├── boss_quick_swipe.tres
    │   │       └── lancer_poke.tres
    │   ├── default_pool_manifest.tres
    │   ├── dialogue
    │   │   ├── dialogue_data.gd
    │   │   ├── dialogue_line.gd
    │   │   └── test_conversation.tres
    │   ├── effects
    │   │   ├── boss_shockwave_effect.tres
    │   │   ├── entity_hit_flash_effect.tres
    │   │   ├── green_splash_vfx.tres
    │   │   ├── heavy_impact_chromatic.tres
    │   │   ├── red_splash_large_vfx.tres
    │   │   └── red_splash_vfx.tres
    │   ├── encounters
    │   │   ├── encounter_00.tres
    │   │   └── encounter_data.gd
    │   ├── enemy_config.tres
    │   ├── player_config.tres
    │   └── world_config.tres
    ├── entities
    │   ├── README.md
    │   ├── _base
    │   │   ├── components
    │   │   │   ├── base_state_machine.gd
    │   │   │   ├── base_state_machine.tscn
    │   │   │   ├── combat_component.gd
    │   │   │   ├── combat_component.tscn
    │   │   │   ├── fx_component.gd
    │   │   │   ├── fx_component.tscn
    │   │   │   ├── health_component.gd
    │   │   │   ├── health_component.tscn
    │   │   │   ├── hitbox_component.gd
    │   │   │   ├── hurtbox_component.gd
    │   │   │   ├── input_component.gd
    │   │   │   ├── input_component.tscn
    │   │   │   ├── melee_component.gd
    │   │   │   ├── melee_component.tscn
    │   │   │   ├── projectile_shooter_component.gd
    │   │   │   ├── projectile_shooter_component.tscn
    │   │   │   ├── sensor_component.gd
    │   │   │   ├── status_effect_component.gd
    │   │   │   ├── status_effect_component.tscn
    │   │   │   ├── telegraph_component.gd
    │   │   │   ├── telegraph_component.tscn
    │   │   │   ├── visual_component.gd
    │   │   │   └── visual_component.tscn
    │   │   ├── scripts
    │   │   │   ├── base_entity.gd
    │   │   │   └── base_state.gd
    │   │   └── states
    │   │       ├── state_entity_fall.gd
    │   │       ├── state_entity_idle.gd
    │   │       └── state_entity_patrol.gd
    │   ├── archetypes
    │   │   ├── boss_archetype.tres
    │   │   ├── entity_archetype.gd
    │   │   ├── minion_archetype.tres
    │   │   └── player_archetype.tres
    │   ├── builders
    │   ├── enemies
    │   │   ├── bosses
    │   │   │   ├── attack_patterns
    │   │   │   │   ├── attack_pattern.gd
    │   │   │   │   ├── homing_omni_burst_pattern.tres
    │   │   │   │   ├── lunge_attack.tres
    │   │   │   │   ├── single_shot.tres
    │   │   │   │   ├── volley_3_shot.tres
    │   │   │   │   └── volley_5_shot.tres
    │   │   │   ├── base_boss.gd
    │   │   │   ├── base_boss.tscn
    │   │   │   ├── boss_state_data.gd
    │   │   │   ├── data
    │   │   │   │   ├── boss_behavior.gd
    │   │   │   │   ├── boss_patrol_movement.tres
    │   │   │   │   ├── boss_state_machine_config.tres
    │   │   │   │   └── default_boss_behavior.tres
    │   │   │   └── states
    │   │   │       ├── state_boss_attack.gd
    │   │   │       ├── state_boss_cooldown.gd
    │   │   │       ├── state_boss_idle.gd
    │   │   │       ├── state_boss_lunge.gd
    │   │   │       ├── state_boss_melee.gd
    │   │   │       └── state_boss_patrol.gd
    │   │   ├── minions
    │   │   │   ├── data
    │   │   │   │   ├── flying_patroller_behavior.tres
    │   │   │   │   ├── minion_behavior.gd
    │   │   │   │   ├── minion_state_machine_config.tres
    │   │   │   │   ├── patrolling_lancer_behavior.tres
    │   │   │   │   └── turret_behavior.tres
    │   │   │   ├── flying_patroller.tscn
    │   │   │   ├── minion.gd
    │   │   │   ├── minion_state_data.gd
    │   │   │   ├── movement_logic
    │   │   │   │   ├── flying_patrol.tres
    │   │   │   │   ├── flying_patrol_movement_logic.gd
    │   │   │   │   ├── movement_logic.gd
    │   │   │   │   ├── patrol_movement.tres
    │   │   │   │   ├── patrol_movement_logic.gd
    │   │   │   │   ├── stationary_movement.tres
    │   │   │   │   └── stationary_movement_logic.gd
    │   │   │   ├── patrolling_lancer.tscn
    │   │   │   ├── states
    │   │   │   │   ├── state_minion_attack.gd
    │   │   │   │   ├── state_minion_idle.gd
    │   │   │   │   ├── state_minion_melee.gd
    │   │   │   │   └── state_minion_patrol.gd
    │   │   │   └── turret.tscn
    │   │   └── spawners
    │   │       ├── patrolling_lancer_spawner.tscn
    │   │       ├── spawner.gd
    │   │       └── spawner.tscn
    │   └── player
    │       ├── components
    │       │   ├── charge_attack_component.gd
    │       │   ├── charge_attack_component.tscn
    │       │   ├── dash_component.gd
    │       │   ├── dash_component.tscn
    │       │   ├── heal_component.gd
    │       │   ├── heal_component.tscn
    │       │   ├── jump_component.gd
    │       │   ├── jump_component.tscn
    │       │   ├── player_jump_helper.gd
    │       │   ├── player_physics_component.gd
    │       │   ├── player_physics_component.tscn
    │       │   ├── player_resource_component.gd
    │       │   ├── player_resource_component.tscn
    │       │   ├── pogo_component.gd
    │       │   └── pogo_component.tscn
    │       ├── data
    │       │   ├── forward_attack_shape.tres
    │       │   ├── player_combat_data.gd
    │       │   ├── player_physics_data.gd
    │       │   ├── player_state_data.gd
    │       │   ├── player_state_machine_config.tres
    │       │   └── upward_attack_shape.tres
    │       ├── player.gd
    │       ├── player.tscn
    │       └── states
    │           ├── state_attack.gd
    │           ├── state_dash.gd
    │           ├── state_fall.gd
    │           ├── state_heal.gd
    │           ├── state_hurt.gd
    │           ├── state_jump.gd
    │           ├── state_move.gd
    │           ├── state_pogo.gd
    │           └── state_wall_slide.gd
    ├── game
    │   ├── combat
    │   │   └── attack_logic
    │   │       ├── attack_logic.gd
    │   │       ├── homing_omni_burst_logic.gd
    │   │       ├── homing_omni_burst_logic.tres
    │   │       ├── lunge_logic.gd
    │   │       ├── lunge_logic.tres
    │   │       ├── minion_volley_3_shot.tres
    │   │       ├── projectile_logic.gd
    │   │       ├── projectile_logic.tres
    │   │       └── volley_logic.tres
    │   ├── level_gen
    │   │   ├── arena_builder.gd
    │   │   └── level_build_data.gd
    │   └── vfx
    │       ├── bindings
    │       │   └── fx_manager_adapter.gd
    │       ├── camera_manager.gd
    │       ├── camera_shaker.gd
    │       ├── camera_shaker.tscn
    │       └── fx_manager.gd
    ├── projectiles
    │   ├── base_projectile.gd
    │   ├── boss_shot.gd
    │   ├── boss_shot.tscn
    │   ├── homing_boss_shot.gd
    │   ├── homing_boss_shot.tscn
    │   ├── player_shot.gd
    │   ├── player_shot.tscn
    │   ├── turret_shot.gd
    │   └── turret_shot.tscn
    ├── scenes
    │   ├── game
    │   │   ├── encounter_scene.gd
    │   │   ├── encounter_scene.tscn
    │   │   ├── post_process_manager.gd
    │   │   ├── viewport_cabinet.gd
    │   │   └── viewport_cabinet.tscn
    │   ├── game_over
    │   │   ├── game_over_screen.gd
    │   │   └── game_over_screen.tscn
    │   ├── loading
    │   │   ├── loading_screen.gd
    │   │   └── loading_screen.tscn
    │   ├── main
    │   │   ├── main.gd
    │   │   └── main.tscn
    │   ├── menus
    │   │   ├── base_menu_screen.gd
    │   │   ├── controls_screen.gd
    │   │   ├── controls_screen.tscn
    │   │   ├── credits_screen.gd
    │   │   ├── credits_screen.tscn
    │   │   ├── options_screen.gd
    │   │   ├── options_screen.tscn
    │   │   ├── save_select_screen.gd
    │   │   ├── save_select_screen.tscn
    │   │   ├── sound_screen.gd
    │   │   ├── sound_screen.tscn
    │   │   ├── title_screen.gd
    │   │   └── title_screen.tscn
    │   └── victory
    │       ├── victory_screen.gd
    │       └── victory_screen.tscn
    ├── shared
    │   ├── interfaces
    │   │   ├── IComponent.gd
    │   │   ├── IDamageable.gd
    │   │   ├── IFXManager.gd
    │   │   ├── IInputProvider.gd
    │   │   ├── IObjectPool.gd
    │   │   ├── IPoolable.gd
    │   │   └── ISceneController.gd
    │   ├── status_effects
    │   │   ├── invincibility_effect.gd
    │   │   └── status_effect.gd
    │   └── types
    │       ├── damage_info.gd
    │       ├── damage_result.gd
    │       ├── input_frame.gd
    │       └── melee_attack_data.gd
    ├── tests
    │   ├── fakes
    │   │   ├── fake_damageable.gd
    │   │   ├── fake_event_bus.gd
    │   │   ├── fake_input_provider.gd
    │   │   └── fake_service_locator.gd
    │   ├── integration
    │   ├── isolation
    │   └── unit
    │       ├── test_combat_utils.gd
    │       ├── test_health_component.gd
    │       ├── test_idamageable_contract.gd
    │       ├── test_input_component.gd
    │       └── test_player_resource_component.gd
    └── ui
        ├── components
        │   ├── control_setting_row
        │   │   ├── control_setting_row.gd
        │   │   └── control_setting_row.tscn
        │   ├── custom_slider
        │   │   ├── custom_slider.gd
        │   │   └── custom_slider.tscn
        │   ├── logo_display
        │   │   ├── logo_display.gd
        │   │   └── logo_display.tscn
        │   ├── mute_button
        │   │   ├── mute_button.gd
        │   │   └── mute_button.tscn
        │   ├── save_slot_button
        │   │   ├── save_slot_button.gd
        │   │   └── save_slot_button.tscn
        │   ├── sound_setting_row
        │   │   ├── sound_setting_row.gd
        │   │   └── sound_setting_row.tscn
        │   └── styled_menu_item
        │       ├── styled_menu_item.gd
        │       └── styled_menu_item.tscn
        ├── dev
        │   ├── debug_overlay.gd
        │   └── debug_overlay.tscn
        ├── dialogue
        │   ├── dialogue_box.gd
        │   └── dialogue_box.tscn
        ├── game_hud
        │   ├── game_hud.gd
        │   └── game_hud.tscn
        ├── menu_manager
        │   └── menu_manager.gd
        └── themes
            └── main_theme.tres

116 directories, 373 files


=====================================
FILE: ./.gutconfig.json
=====================================
{
    "dirs": [
        "res://src/tests"
    ],
    "include_subdirs": true
}

=====================================
FILE: ./docs/TODO.txt
=====================================
╔═════════════════════════════════════════════════════════════════════════════════╗
║   ████████╗ ██████╗ ██████╗  ██████╗                                            ║
║   ╚══██╔══╝██╔═══██╗██╔══██╗██╔═══██╗                                           ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                           ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                           ║
║      ██║   ╚██████╔╝██████╔╝╚██████╔╝                                           ║
║      ╚═╝    ╚═════╝ ╚═════╝  ╚═════╝                                            ║
╔═════════════════════════════════════════════════════════════════════════════════╗
║                        Strategic Development Plan & Backlog                     ║
╚═════════════════════════════════════════════════════════════════════════════════╝

║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  EDITOR WORKFLOW & PRESENTATION                      ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║

   □  1. Arena Expansion
      - Resize Viewport Cabinet from 1000x1000 to target size (e.g. 1300x1300).
      - Update 'level_00.tscn' geometry to fill the new space.
      - Tune Camera Zoom or Character Speed if the new size affects pacing.

   □  2. High-Fidelity Character Art
      - Replace 'ColorRect' with 'AnimatedSprite2D'.
      - Implement 'State Animation Mapping' in 'VisualComponent'.
      - Configure Texture Import settings for crisp High-Res assets (Linear Filter).
      - Adjust Physics/Hurtboxes to match new sprite pivots (Bottom-Center).

   □  3. Reactive UI & Portraits
      - Create 'PortraitController' system.
      - Implement large animated character frames on left/right of Arena.
      - Wire 'EventBus' signals (Health/Phase) to Portrait emotions.

║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                           BACKLOG                                    ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║

   □  Audio Polish:
      - Add specific SFX for different surface materials (footsteps).
      - Implement dynamic music mixing (low pass filter on pause/low health).

   □  Visual Polish:
      - Add "Ghost Trail" effect for the Dash mechanic.


=====================================
FILE: ./docs/last_commit_command.txt
=====================================
git reset --hard origin/main

=====================================
FILE: ./docs/DESIGN.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ███████╗███████╗██╗ ██████╗ ███╗   ██╗                             ║
║   ██╔══██╗██╔════╝██╔════╝██║██╔════╝ ████╗  ██║                             ║
║   ██║  ██║█████╗  ███████╗██║██║  ███╗██╔██╗ ██║                             ║
║   ██║  ██║██╔══╝  ╚════██║██║██║   ██║██║╚██╗██║                             ║
║   ██████╔╝███████╗███████║██║╚██████╔╝██║ ╚████║                             ║
║   ╚═════╝ ╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝                             ║
║                                                                              ║
║      The official documentation for game mechanics and design philosophy.    ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣

# CORE GAMEPLAY DESIGN RULES

## Movement Mechanics
*   **Jump:** Variable height (button release dampening).
*   **Coyote Time:** 0.1s window to jump after leaving ledge.
*   **Jump Buffer:** 0.1s window to queue jump input before landing.
*   **Wall Interaction:** Wall slide (reduced gravity) + Wall Jump (X/Y force).

## Combat Mechanics
*   **Hit Detection:** Damage routed through `CombatUtils.apply_damage(target, info)`.
*   **Pogo:** Down-attack on enemy/projectile/hazard.
    *   *Result:* Refreshes Dash + Double Jump. Bounces player up.
*   **Healing (Determination):**
    *   Dealing damage fills `determination_counter`.
    *   Full counter = +1 Healing Charge.
    *   Input `Down + Jump` (grounded) to consume charge and heal.

## Entity Rules
*   **Invincibility:** Token-based system in `HealthComponent`.
*   **Contact Damage:** Enemies/Hazards deal damage on touch unless Player is Invincible or Dashing (if upgraded).

=====================================
FILE: ./docs/BUGS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ██████╗ ██╗   ██╗ ██████╗ ███████╗                                         ║
║   ██╔══██╗██║   ██║██╔════╝ ██╔════╝                                         ║
║   ██████╔╝██║   ██║██║  ███╗███████╗                                         ║
║   ██╔══██╗██║   ██║██║   ██║╚════██║                                         ║
║   ██████╔╝╚██████╔╝╚██████╔╝███████║                                         ║
║   ╚═════╝  ╚═════╝  ╚═════╝ ╚══════╝                                         ║
║                                                                              ║
║             A tracker for all known issues, their status, and solutions.     ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                             OPEN ISSUES                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                             FIXED ISSUES                             ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   ■  [BUG-MEM001] ObjectDB instances leaked on exit.                         ║
║      ░  FIXED: 2025-08-18                                                    ║
║      ░  SOLUTION: Implemented a formal `scene_exiting()` contract via an     ║
║      ░  `ISceneController` interface. The `SceneManager` now calls this      ║
║      ░  method on the outgoing scene, allowing entities like Player and      ║
║      ░  Boss to run their explicit `teardown()` logic. This breaks the       ║
║      ░  dangling references held by global singletons (e.g., EventBus)       ║
║      ░  that were preventing garbage collection.                             ║
║                                                                              ║
║   ■  [BUG-F007] Intermittent major hitch on first run or debug mode toggle.  ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Implemented a shader pre-warming system in `LoadingScreen`.║
║                                                                              ║
║   ■  [BUG-F006] Significant stutter/hitch occurred on arena load.            ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Replaced synchronous level generation with a new asynchronous║
║      ░  system in `ArenaBuilder.gd`.                                         ║
║                                                                              ║
║   ■  [BUG-F005] Player death caused a physics crash.                         ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Scene changes now use `call_deferred()` to prevent deleting║
║      ░  a physics body during a physics callback.                            ║
║                                                                              ║
║   ■  [BUG-F004] Hazard tiles did not deal contact damage.                    ║
║      ░  FIXED: 2025-08-07                                                    ║
║      ░  SOLUTION: Corrected collision layer and group setup in `ArenaBuilder`.║
║                                                                              ║
║   ■  [BUG-F003] Drop-through platforms ("-") were not functioning.           ║
║      ░  FIXED: 2025-08-06                                                    ║
║      ░  SOLUTION: Re-implemented Down+Jump logic in `state_move`.            ║
║                                                                              ║
║   ■  [BUG-F002] Player pogo attack was not working correctly on all surfaces.║
║      ░  FIXED: 2025-08-05                                                    ║
║      ░  SOLUTION: Re-implemented the physics query to handle all surfaces.   ║
║                                                                              ║
║   ■  [BUG-F001] Player was not taking contact damage from boss/hazards.      ║
║      ░  FIXED: 2025-08-05                                                    ║
║      ░  SOLUTION: Corrected the player's `collision_mask` in `player.tscn`.  ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/ARCHITECTURE.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                  ║
║  █████╗ ██████╗  ██████╗██╗  ██╗██╗████████╗███████╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗   ║
║ ██╔══██╗██╔══██╗██╔════╝██║  ██║██║╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝██║   ██║██╔══██╗██╔════╝   ║
║ ███████║██████╔╝██║     ███████║██║   ██║   █████╗  ██║        ██║   ██║   ██║██████╔╝█████╗     ║
║ ██╔══██╗██╔══██╗██║     ██╔══██║██║   ██║   ██╔══╝  ██║        ██║   ██║   ██║██╔══██╗██╔══╝     ║
║ ██║  ██║██║  ██║╚██████╗██║  ██║██║   ██║   ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║███████╗   ║
║ ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝   ║
║                                                                                                  ║
║                     A high-level summary of the project's technical patterns.                    ║
║                                                                                                  ║
╠══════════════════════════════════════════════════════════════════════════════════════════════════╣

# 1. CORE PATTERNS

## Service Locator & Dependency Injection
*   **Pattern:** Global access is managed via a `ServiceLocator` autoload.
*   **Injection:** Entities/Components DO NOT access Autoloads directly.
    *   **Entities:** Receive the locator via `build_entity()` or Spawners.
    *   **Components:** Receive dependencies via `setup(owner, dependencies)`.
*   **Benefit:** Allows easy swapping of systems (e.g., `FakeEventBus`) during Unit Testing.

## Entity-Component (ECS-Lite)
*   **BaseEntity:** The physical shell (`CharacterBody2D`). Handles strictly physics execution (`move_and_slide`).
*   **Archetype:** A Resource defining which component scenes to instantiate.
*   **Components:** Logic containers (Health, Input, Combat). They manipulate data/state, but the Entity applies the result.

## Strategy & Command
*   **Logic as Data:** Complex behaviors are Resources, not hardcoded scripts.
    *   `AttackLogic`: Defines *how* an attack executes.
    *   `MovementLogic`: Defines *how* an enemy moves.
*   **Benefit:** "Programming in the Inspector." New enemies can be created by mixing and matching existing logic resources.

---

# 2. KEY SYSTEMS

## Viewport Cabinet (Resolution Management)
*   **Problem:** Pixel art games need integer scaling, but modern UI needs high-res (1440p).
*   **Solution:**
    *   **Root Window:** 2560x1440 (QHD). Handles UI and Post-Process Shaders.
    *   **SubViewport:** 1000x1000 (Logical Arena). Handles Gameplay.
    *   **Coordinate Mapping:** `ViewportCabinet.world_to_screen_pos()` maps game coordinates to screen UVs for shaders (Shockwave, etc).

## Safety Hooks (Memory Management)
*   **Problem:** Godot objects can leave dangling references in global singletons (EventBus) when scenes change.
*   **Solution:** `ISceneController` interface.
    *   **Contract:** Scenes must implement `scene_exiting()`.
    *   **Flow:** `SceneManager` calls `scene_exiting()` -> Entities call `teardown()` -> Components disconnect signals -> Scene changes.

## Input Abstraction
*   **Interface:** `IInputProvider`.
*   **Implementation:** `StandardInputProvider` wraps Godot's `Input` singleton.
*   **Benefit:** Unit tests use `FakeInputProvider` to simulate key presses frame-by-frame without needing OS-level input simulation.

---

# 3. DATA & CONFIGURATION

## Resource-Driven Tuning
*   **Config Resources:** All magic numbers (speed, damage, cooldowns) live in `PlayerConfig.tres` or `EnemyConfig.tres`.
*   **State Resources:** Runtime data lives in `PlayerStateData` or `BossStateData`, passed between components. Components are stateless logic processors; Resources hold the state.

## VFX & Shader Management
*   **Object Pooling:** `HitSpark` and Projectiles are pooled to prevent GC stutter.
*   **Shader Pre-warming:** A Loading Screen renders hidden instances of heavy shaders to force compilation before gameplay starts, preventing the "first-hit stutter."

---

# 4. COMMUNICATION RULES

## Local (Signal)
*   **Scope:** Inside a single scene file (Parent <-> Child).
*   **Usage:** Component emits `health_changed`, Entity owner reacts.

## Global (EventBus)
*   **Scope:** System to System (Entity <-> HUD, Encounter <-> Music).
*   **Usage:** Player emits `player_died` -> EventBus -> HUD shows Game Over.
*   **Rule:** If the sender doesn't know the receiver exists, use EventBus.


=====================================
FILE: ./docs/ASSETS.txt
=====================================
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    █████╗ ███████╗███████╗███████╗████████╗███████╗                          ║
║   ██╔══██╗██╔════╝██╔════╝██╔════╝╚══██╔══╝██╔════╝                          ║
║   ███████║███████╗███████╗███████╗   ██║   ███████╗                          ║
║   ██╔══██║╚════██║╚════██║██╔════╝   ██║   ╚════██║                          ║
║   ██║  ██║███████║███████║███████╗   ██║   ███████║                          ║
║   ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝   ╚═╝   ╚══════╝                          ║
║                                                                              ║
║        A registry for asset sources, licenses, and style guidelines.         ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                            STYLE GUIDE                               ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Visual Style                                                            ║
║      ░  Overall: Clean, minimalist, and geometric.                           ║
║      ░  Color Palette: High-contrast grayscale for placeholders.             ║
║      ░  Shape Language: A strict adherence to square-based geometry.         ║
║      ░  Rectangles are only permitted for static environmental elements.     ║
║                                                                              ║
║   █  Audio Style                                                             ║
║      ░  Music: Chiptune-inspired, melodic, and loopable tracks.              ║
║      ░  Sound Effects: Crisp, digital, and immediately recognizable SFX.     ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                           ASSET SOURCES                              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   █  Graphics                                                                ║
║      ░  Source: All current visual assets (sprites, icons) are original      ║
║      ░  creations for this project.                                          ║
║      ░  License: N/A (Internal)                                              ║
║                                                                              ║
║   █  Audio                                                                   ║
║      ░  Source: All audio assets were generated by the project creator using ║
║      ░  paid subscriptions to ElevenLabs (SFX) and Udio (Music).             ║
║      ░  License: CC0 1.0 Universal (Public Domain).                          ║
║                                                                              ║
║   █  Fonts                                                                   ║
║      ░  Source: "M PLUS Rounded 1c" by the M+ FONTS PROJECT.                 ║
║      ░  License: SIL Open Font License (OFL).                                ║
║      ░  Source Link: `https://fonts.google.com/specimen/M+PLUS+Rounded+1c`   ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                      ATTRIBUTION REQUIREMENTS                        ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Per the CC0 license for audio and original creation for graphics, no       ║
║   attribution is required for any asset. It is good practice to keep the     ║
║   OFL.txt for the font with the project files.                               ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/CHANGELOG.txt
=====================================
╔════════════════════════════════════════════════════════════════════════════════╗
║                                                                                ║
║   ██████╗██╗  ██╗ █████╗ ███╗   ██╗ ██████╗ ███████╗██╗      ██████╗  ██████╗  ║
║  ██╔════╝██║  ██║██╔══██╗████╗  ██║██╔════╝ ██╔════╝██║     ██╔═══██╗██╔════╝  ║
║  ██║     ███████║███████║██╔██╗ ██║██║  ███╗█████╗  ██║     ██║   ██║██║  ███╗ ║
║  ██║     ██╔══██║██╔══██║██║╚██╗██║██║   ██║██╔══╝  ██║     ██║   ██║██║   ██║ ║
║  ╚██████╗██║  ██║██║  ██║██║ ╚████║╚██████╔╝███████╗███████╗╚██████╔╝╚██████╔╝ ║
║   ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝╚══════╝ ╚═════╝  ╚═════╝  ║
║                                                                                ║
║                  A log of all notable changes to the project.                  ║
║                                                                                ║
╠════════════════════════════════════════════════════════════════════════════════╣





║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██           [0.32.0] - PRESENT - 11/21/2025                            ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║











║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██           [0.31.0] - 1440P EXPANSION & TALLER PLAYER - 11/21/2025    ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Level Design & Presentation                                               ║
║      ░ ■ Arena Expansion: Expanded gameplay area to full 2560x1440 (QHD).      ║
║      ░ ■ Level Layout: Redesigned 'level_00' into "The Divided Ground".        ║
║      ░   - Features a central spike pit, high perches, and floating bridges.   ║
║      ░   - Forces verticality and parkour during boss encounters.              ║
║      ░ ■ Viewport: Updated Cabinet logic to handle the 26x52 tile grid.        ║
║                                                                                ║
║   █  Player Update                                                             ║
║      ░ ■ Form Factor: Player size doubled vertically (40x80).                  ║
║      ░ ■ Combat Range: Attack hitboxes extended to match new reach.            ║
║      ░ ■ Visuals: Added procedural Green Gradient Swipe FX for all melee       ║
║      ░   attacks (Side, Up, Pogo) to clearly visualize hitbox area.            ║
║      ░ ■ VFX: Resized Charge and Heal auras to fit the taller body.            ║
║                                                                                ║
║   █  Combat Polish                                                             ║
║      ░ ■ Tuning: Reduced Level 2 Charge time to 1.12s for snappier combat.     ║
║      ░ ■ Projectile Interaction: Player Melee and Pogo now destroy enemy       ║
║      ░   projectiles on contact, triggering a Red Splash (Enemy death) AND     ║
║      ░   a Green Spark (Player hit).                                           ║
║      ░ ■ Visual Clarity: Standardized Enemy projectiles/impacts to Red,        ║
║      ░   Player effects to Green.                                              ║

║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██       [0.30.0] - ARCHITECTURAL POLISH & GAMEPLAY FEEL - 11/21/2025   ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Architectural Refactor                                                    ║
║      ░ ■ Visual Consolidation: 'VisualComponent' is now the sole authority on  ║
║      ░   Entity appearance. Decoupled Entity scripts from visual nodes.        ║
║      ░ ■ Component Autonomy: 'HealComponent' fully manages its own input,      ║
║      ░   timers, and state. Removed legacy bloat from 'Player.gd'.             ║
║      ░ ■ Boss Standardization: Migrated Cooldown/Patrol timers from SceneNodes ║
║      ░   to pure State logic.                                                  ║
║                                                                                ║
║   █  Gameplay & Combat                                                         ║
║      ░ ■ Projectile Clash: Implemented generic 'destroy_with_impact' API.      ║
║      ░   - Player shots (Green) now correctly clash with Enemy shots (Red).    ║
║      ░   - Pogo attacks now correctly destroy projectiles + trigger bounce.    ║
║      ░ ■ Healing Risk: Taking damage while healing now consumes the charge     ║
║      ░   without granting health (Punishment mechanic).                        ║
║      ░ ■ Tuning: Reduced Level 2 Charge time to 1.12s (-30% + -20%).           ║
║                                                                                ║
║   █  Visuals & Feedback                                                        ║
║      ░ ■ Melee Visuals: Added procedural Green Gradient swipes for Side, Up,   ║
║      ░   and Pogo attacks matching hitbox size.                                ║
║      ░ ■ Enemy Visuals: Standardized Enemy projectiles/splashes to Red.        ║
║      ░   - Added Large Red Splash for Boss Heavy Projectiles.                  ║
║      ░ ■ Hitbox Polish: Debug shapes now sync facing direction instantly.      ║
║                                                                                ║
║   █  Stability                                                                 ║
║      ░ ■ ObjectPool: Hardened against "invalid previously freed instance".     ║
║      ░ ■ Crash Fixes: Resolved race conditions in Hurtbox/Health/Player logic  ║
║      ░   during scene transitions and death sequences.                         ║
║                                                                                ║





║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██    [0.29.0] - EDITOR WORKFLOW MIGRATION & VIEWPORT CABINET ARCHITECTURE - 11/20/2025   ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Level Architecture                                                        ║
║      ░ ■ Deprecated ASCII-based Level Generation.                              ║
║      ░ ■ Implemented 'LevelExporter' tool to bake legacy layouts into Scenes.  ║
║      ░ ■ Created 'level_00.tscn' as the new source of truth for the arena.     ║
║      ░ ■ Refactored 'ArenaBuilder' to instantiate scenes and inject            ║
║      ░   dependencies dynamically, rather than constructing geometry.          ║
║      ░ ■ Fixed physics bug regarding one-way platform drop-through logic.      ║
║                                                                                ║
║   █  Presentation Overhaul (1440p)                                             ║
║      ░ ■ Updated Window Resolution to 2560x1440 (QHD).                         ║
║      ░ ■ Implemented 'ViewportCabinet' scene to center the gameplay area       ║
║      ░   within the larger window, preserving the 1:1 aspect ratio.            ║
║      ░ ■ Retrofitted all Menus (Title, Options, etc.) to center correctly      ║
║      ░   within the new widescreen layout.                                     ║
║                                                                                ║
║   █  Engine & Systems                                                          ║
║      ░ ■ Refactored 'ObjectPool' to support reparenting active objects into    ║
║      ░   specific World Containers (fixing invisible projectiles in Viewports).║
║      ░ ■ Updated 'EncounterScene' to run inside the SubViewport.               ║
║      ░ ■ Fixed Shockwave shader positioning to map World Coordinates to        ║
║      ░   Screen UVs correctly across nested viewports.                         ║
║      ░ ■ Fixed VFX (Heal/Charge Splashes) parenting logic.                     ║
║                                                                                ║

   █  Optimization & Refactoring                                      
      ░ ■ Level Architecture: Consolidated thousands of tile blocks in 'level_00'
      ░   into optimized collision rectangles, significantly reducing scene size.
      ░ ■ Physics Authority: Centralized 'move_and_slide()' execution in         
      ░   'BaseEntity'. Subclasses (Player, Boss, Minion) now delegate movement  
      ░   logic to the base class via 'super._physics_process()'.                
      ░ ■ Testing: Refactored GUT test suite to support new Dependency Injection 
      ░   requirements (EventBus, StatusEffectComponent). All 18 tests passing.  
      ░ ■ Documentation: Updated ARCHITECTURE.txt to reflect current patterns.


║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██           [0.28.0] - ARCHITECTURAL REFACTOR - 11/19/2025             ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Structural Overhaul                                                       ║
║      ░ ■ Implemented Domain-Driven Directory Structure.                        ║
║      ░ ■ Created 'src/shared' for Interfaces (DIP) and Data Types.             ║
║      ░ ■ Created 'src/game' for Gameplay Systems (Combat, LevelGen, VFX).      ║
║      ░ ■ Created 'src/content' for Art/Tech-Art Assets (Shaders, Particles).   ║
║      ░ ■ Standardized Entities:                                                ║
║      ░   - Moved Components/Scripts to 'src/entities/_base'.                   ║
║      ░   - Grouped Bosses and Minions under 'src/entities/enemies'.            ║
║      ░ ■ Cleaned up Root Directory: Moved Materials and Shaders to content.    ║
║   █  Player Physics                                                            ║
║      ░ ■ Fixed gravity suspension bug during aerial attacks.                   ║
║      ░   - Previously, attacking in mid-air halted all velocity (X and Y).     ║
║      ░   - Now, attacking only applies friction to Horizontal (X) movement.    ║
║      ░   - Gravity continues to apply normally during the attack animation.    ║

║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██           [0.27.0] - PHYSICS & GAME FEEL POLISH - 11/19/2025         ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Physics & Controls                                                        ║
║      ░ ■ Standardized Physics: Player entity now drives 'move_and_slide',      ║
║      ░   resolving execution order issues with components.                     ║
║      ░ ■ Jump Buffering: Added 0.1s input buffer for smoother landing jumps.   ║
║                                                                                ║
║   █  Visual Effects & Juice                                                    ║
║      ░ ■ Added 'Super Saiyan' style charging auras (Green for Attack,          ║
║      ░   Purple for Heal) with crackling turbulence and ramp-up.               ║
║      ░ ■ Added splash VFX for Fireball release and Heal completion.            ║
║      ░ ■ Implemented 0.15s delay on Charge Aura to prevent flashing on taps.   ║
║                                                                                ║
║   █  Balance & Tuning                                                          ║
║      ░ ■ Reduced Healing Charge cost: Determination required lowered from      ║
║      ░   10 hits to 5 hits.                                                    ║
║                                                                                ║
║   █  UI & Audio Polish                                                         ║
║      ░ ■ Added tactile 'Tick' SFX to volume sliders in the Options Menu.       ║
║      ░   - Ticks only occur on intervals of 5 (5, 10, 15...) to reduce fatigue.║
║      ░   - Logic handles drag events vs clicks intelligently.                  ║

║   █  Architecture & Design Principles                                          ║
║      ░ ■ Applied Liskov Substitution Principle (LSP) to BaseEntity.            ║
║      ░   - Enforced 'get_health_thresholds()' contract in the base class.      ║
║      ░   - Removed duck-typing/has_method checks in HealthComponent.           ║
║      ░ ■ Applied Dependency Inversion Principle (DIP) to Visual Assets.        ║
║      ░   - Removed hardcoded 'preload' paths for VFX in Player scripts.        ║
║      ░   - VFX scenes (Auras, Splashes) are now injected via 'PlayerConfig'.   ║
║      ░ ■ Applied Single Responsibility Principle (SRP) to Visual Logic.        ║
║      ░   - Extracted 'VisualComponent' to handle sprite color and death FX.    ║
║      ░   - Player.gd is now purely an orchestrator, delegating visuals.        ║
║                                                                                ║
   █  Polish & Tuning
      ░ ■ Tuned Charge Attack: Increased aura visual delay to 0.25s to prevent
      ░   flickering on melee taps.
      ░ ■ Responsiveness: Removed cooldown check for starting a Charge Attack,
      ░   allowing immediate charging after firing.
      ░ ■ Code Cleanliness: Removed unused variables in ChargeComponent.

         █  Combat Depth
      ░ ■ Implemented Durability System for Charged Shots:
      ░   - Level 2 Fireballs now have Health equal to their Damage (3).
      ░   - Hitting enemy projectiles consumes Health but allows the fireball
      ░     to persist if it has remaining damage potential.
      ░   - Enables "beam struggle" style mechanics where powerful shots
      ░     cleave through weaker enemy fire.

║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██           [0.26.0] - VISUAL JUICE & FX & MULTI-SLOT SAVE SYSTEM - 11/19/2025                               ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║

║                                                                                ║
║   █  Visual Effects (Shaders)                                                  ║
║      ░ ■ Implemented 'PostProcessManager' to handle stacked fullscreen effects.║
║      ░ ■ Added 'Shockwave' distortion shader for Boss death.                   ║
║      ░ ■ Added 'Chromatic Aberration' glitch effect for Boss phase changes.    ║
║      ░ ■ Added pulsing 'Red Vignette' for low health (1 HP) state.             ║
║                                                                                ║
║   █  Polish                                                                    ║
║      ░ ■ Refactored Player Projectile: Now uses a Green Fireball visual with   ║
║      ░   a non-duplicating particle trail and green impact sparks.              ║
║      ░ ■ Added 'Slow Motion' (Time Scale) effects on Player Death and Victory. ║
║      ░ ■ Fixed 'FXPlayground' to support testing of fullscreen shaders.        ║
║                                                                                ║
║                                                                                ║
║   █  Persistence Upgrade                                                       ║
║      ░ ■ Refactored 'SaveManager' to support 3 distinct save slots.            ║
║      ░ ■ Implemented File Operations: Create, Load, Copy, and Erase slots.     ║
║      ░ ■ Added file path management using 'take_over_path' for safe duplication.║
║                                                                                ║
║   █  UI & Meta-Game                                                            ║
║      ░ ■ Created 'SaveSelectScreen': A hub for managing game data before play. ║
║      ░ ■ Created 'SaveSlotButton': Reusable component displaying Wins/Losses.  ║
║      ░ ■ Implemented "Copy Mode" and "Erase Mode" UI logic.                    ║
║      ░ ■ Updated 'TitleScreen' navigation flow.                                ║
║                                                                                ║
║   █  Developer Tools                                                           ║
║      ░ ■ Added TAB shortcut in Main Menu to instantly start a fresh run in     ║
║      ░   Slot 0 for rapid iteration.                                           ║


║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██     [0.25.0] - SYSTEM HARDENING & DECOUPLING & PERSISTENCE LAYER & INPUT REMAPPING & ACCESSIBILITY - 11/19/2025      ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║


║   █  Architecture & Decoupling                                                 ║
║      ░ ■ Implemented 'TargetingSystem': A centralized service for entities to  ║
║      ░   register/find targets, removing brittle 'get_tree()' group lookups.   ║
║      ░ ■ Centralized Input Identifiers: Created 'Identifiers.Actions' to       ║
║      ░   replace magic strings ("ui_left") throughout the codebase.            ║
║      ░ ■ Resolved Cyclic Dependencies: Removed strict static typing in         ║
║      ░   Component and State scripts referencing their owners. Replaced with   ║
║      ░   runtime checks to prevent parser lock-ups in the Editor.              ║
║                                                                                ║
║   █  Code Quality                                                              ║
║      ░ ■ Refactored 'BaseEntity' initialization to ensure Archetypes build     ║
║      ░   components before configuration injection occurs.                     ║
║      ░ ■ Updated 'InputComponent' and 'MenuManager' to use the new identifiers.║
║      ░ ■ Hardened 'ArenaBuilder' to prevent type errors during hot-reloads.    ║
║                                                                                ║
║   █  New Systems                                                               ║
║      ░ ■ Implemented 'SaveManager': Handles serialization of gameplay stats    ║
║      ░   (Wins/Losses) to 'user://save_data.tres'.                             ║
║      ░ ■ Upgraded 'Settings': Audio preferences (Volume/Mute) now persist to   ║
║      ░   'user://options.cfg'.                                                 ║
║                                                                                ║
║   █  UI & Gameplay Integration                                                 ║
║      ░ ■ Debug Overlay: Added persistent Wins/Losses tracker to the HUD.       ║
║      ░ ■ EncounterScene: Now automatically records match results to disk upon  ║
║      ░   Player death or Boss defeat.                                          ║
║      ░ ■ Hardened 'ServiceLocator' to expose the new SaveManager.              ║
║                                                                                ║
║                                                                                ║
║   █  Input System                                                              ║
║      ░ ■ Implemented runtime Input Remapping backend in 'Settings'.            ║
║      ░ ■ Added 'Input Presets' system:                                         ║
║      ░   - Default 1 (ZXC + Arrows/WASD)                                       ║
║      ░   - Default 2 (.,/ + WASD)                                              ║
║      ░   - Custom (Automatically set on manual rebind)                         ║
║      ░ ■ Input configuration is now serialized to 'user://options.cfg'.        ║
║                                                                                ║
║   █  User Interface                                                            ║
║      ░ ■ Created 'ControlsScreen' with dynamic binding rows.                   ║
║      ░ ■ Created 'ControlSettingRow' component with "Press any key" detection. ║
║      ░ ■ Added visual/audio feedback (Cursors, SFX) to all control UI elements.║
║      ░ ■ Added "Fixed Controls" reference panel for hardcoded inputs.          ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██           [0.24.0] - LSP & OCP ENTITY REFACTOR & DRY DAMAGE REFACTOR & AUDIO & PHYSICS HARDENING - 11/19/2025          ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Architecture & SOLID                                                      ║
║      ░ ■ Applied Liskov Substitution Principle (LSP) to Entity Data.           ║
║      ░ ■ Created `BaseEntityData` resource. `PlayerStateData`, `BossStateData`,║
║      ░   and `MinionStateData` now inherit from this base class.               ║
║      ░ ■ Enforced strong typing in `MovementLogic`, removing "duck typing".    ║
║      ░ ■ Applied Open/Closed Principle (OCP) to State Machine construction.    ║
║      ░ ■ Created `StateMachineConfig` resource to map state keys to scripts.   ║
║      ░ ■ Entities now build their FSM dynamically from resources, removing     ║
║      ░   hardcoded state lists from source code.                               ║
║      ░ ■ Fixed bug where entities defaulted to 1 HP due to uninitialized       ║
║      ░   base data values.                                                     ║
║                                                                                ║                                                                                ║
║   █  Architecture & Code Quality                                               ║
║      ░ ■ Applied "Don't Repeat Yourself" (DRY) to Damage Logic.                ║
║      ░ ■ Implemented `CombatUtils.create_damage_info()` factory method to      ║
║      ░   centralize the creation of damage payloads.                           ║
║      ░ ■ Refactored `MeleeComponent`, `PogoComponent`, `HurtboxComponent`,     ║
║      ░   and `BaseProjectile` to use the factory, removing boilerplate code.   ║
║                                                                                ║                                                                                ║
║   █  Systems Upgrade                                                           ║
║      ░ ■ Implemented `AudioCue` resource system.                               ║
║      ░   - Allows designers to define pitch randomization, volume variance,    ║
║      ░     and bus routing in the Inspector.                                   ║
║      ░   - Updated `AudioManager` to accept Cues instead of raw paths.         ║
║      ░ ■ Integrated Audio Cues into the `DamageResponseConfig`, enabling       ║
║      ░   automatic impact sounds for any entity using the system.              ║
║   █  Code Quality & Stability                                                  ║
║      ░ ■ Physics Cleanup: Removed hardcoded collision layer overrides in       ║
║      ░   `BaseBoss` and `HurtboxComponent`. Physics layers are now strictly    ║
║      ░   controlled by the Scene/Inspector settings (OCP).                     ║
║      ░ ■ Fixed a crash in `HurtboxComponent` where it attempted to process     ║
║      ░   collisions after the owner entity had been destroyed in the same      ║
║      ░   frame.                                                                ║
║                                                                                ║║                                                                                ║
║   █  Systems Architecture                                                      ║
║      ░ ■ Implemented `StatusEffect` system (Open/Closed Principle).            ║
║      ░   - Created `StatusEffectComponent` to manage buffs/debuffs.            ║
║      ░   - Refactored `HealthComponent` to use `InvincibilityEffect` instead   ║
║      ░     of hardcoded tokens.                                                ║
║      ░ ■ Hardened Audio System (Dependency Inversion).                         ║
║      ░   - Fixed cyclic dependency issues with `AudioCue` resource loading.    ║
║      ░   - Renamed `AudioCue` constant in `AudioManager` to avoid shadowing.   ║
║                                                                                ║

║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██               [0.23.0] - SRP POGO REFACTOR & ISP INJECTION REFACTOR & DIP CONFIG REFACTOR & OCP TELEGRAPH REFACTOR - 11/19/2025              ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Architecture & SOLID                                                      ║
║      ░ ■ Applied Single Responsibility Principle (SRP) to `CombatComponent`.   ║
║      ░ ■ Extracted `PogoComponent` to handle all downward strike and bounce    ║
║      ░   mechanics separately from projectile/melee logic.                     ║
║      ░ ■ Updated `PlayerArchetype` and `Player.gd` to include and wire the     ║
║      ░   new component.                                                        ║
║      ░ ■ Cleaned `CombatComponent`, removing legacy pogo detection code.       ║
║                                                                                ║
║                                                                                ║
║   █  Architecture & SOLID                                                      ║
║      ░ ■ Applied Interface Segregation Principle (ISP) to Entity composition.  ║
║      ░ ■ Refactored `BaseEntity` to deconstruct the `ServiceLocator` into      ║
║      ░   discrete dependencies (`object_pool`, `fx_manager`, etc.) before      ║
║      ░   passing them to components.                                           ║
║      ░ ■ Updated `CombatComponent`, `MeleeComponent`, `PogoComponent`, and     ║
║      ░   `ProjectileShooterComponent` to request specific interfaces instead   ║
║      ░   of the monolithic Service Locator.                                    ║
║                                                                                ║
║                                                                                ║
║   █  Architecture & SOLID                                                      ║
║      ░ ■ Applied Dependency Inversion Principle (DIP) to Health Configuration. ║
║      ░ ■ Created `DamageResponseConfig` resource to standardize how entities   ║
║      ░   react to damage (Invincibility, Knockback).                           ║
║      ░ ■ Refactored `HealthComponent` to depend on this abstract config        ║
║      ░   instead of checking concrete entity groups (Player/Enemy).            ║
║      ░ ■ Updated `BaseEntity` to automatically extract and inject this config  ║
║      ░   during the build process.                                             ║
║      ░ ■ Migrated `PlayerConfig` and `EnemyConfig` to use the new sub-resource.║
║                                                                                ║
║                                                                                ║
║   █  Architecture & SOLID                                                      ║
║      ░ ■ Applied Open/Closed Principle (OCP) to Combat Telegraphs.             ║
║      ░ ■ Removed hardcoded scene preloads from `MeleeComponent`,               ║
║      ░   `BossStateAttack`, and `MinionStateAttack`.                           ║
║      ░ ■ Updated `MeleeAttackData` and `AttackPattern` resources to accept     ║
║      ░   custom `telegraph_scene` references, enabling visual customization    ║
║      ░   without code modification.                                            ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██             [0.22.0] - PLAYER LOGIC DECENTRALIZATION - 11/18/2025    ██.  ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Refactoring                                                               ║
║      ░ ■ Decentralized timer management from `Player.gd` to components.        ║
║      ░ ■ `PlayerPhysicsComponent`: Manages coyote and wall coyote timers.      ║
║      ░ ■ `DashComponent`: Manages dash duration and cooldown timers.           ║
║      ░ ■ `CombatComponent`: Manages attack duration, cooldown, and pogo timers.║
║      ░ ■ `ChargeAttackComponent`: Manages charge duration timer.               ║
║      ░ ■ Reduced `Player.gd` responsibility significantly (SRP).               ║
║   █  Architecture & Code Quality                                               ║
║      ░ ■ Created `ProjectileShooterComponent` to handle all projectile firing. ║
║      ░ ■ Refactored `BaseEntity` to remove legacy shooting methods (LSP Fix).  ║
║      ░ ■ Updated `Boss` and `Minion` archetypes to use the new component.      ║
║      ░ ■ Updated `ProjectileLogic` (Attack Strategy) to use the new component. ║
║      ░ ■ Cleaned up unused tween references in entity classes.                 ║
║   █  Data Architecture                                                         ║
║      ░ ■ Segregated `PlayerStateData` into `PlayerPhysicsData` and             ║
║      ░   `PlayerCombatData` sub-resources.                                     ║
║      ░ ■ Updated all Player States and Components to use the new data paths.   ║
║      ░ ■ Enforced Interface Segregation Principle for Player data.             ║
║   █  Gameplay Logic                                                            ║
║      ░ ■ Fixed Pogo attack not bouncing when performed while standing on the   ║
║      ░   ground. Implemented immediate PhysicsShapeQuery in `StatePogo` to     ║
║      ░   handle frame-perfect ground detection.                                ║
║      ░ ■ Fixed error where `StatePogo` attempted to check overlaps before      ║
║      ░   monitoring was active.                                                ║


║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██   [0.21.0] - PLAYER & SENSOR REFACTOR & PHYSICS & FSM CLEANUP- 11/18/2025  ██  ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Architecture                                                              ║
║      ░ ■ Extracted `HurtboxComponent` to handle contact damage detection.      ║
║      ░ ■ Extracted `HitboxComponent` to handle attack collision detection.     ║
║      ░ ■ Refactored `Player.gd` to delegate physics polling to these components.║
║      ░ ■ Updated `CombatComponent` to subscribe directly to hitbox signals.    ║
║      ░ ■ Removed manual collision wiring from `Player.gd`.                     ║
║      ░ ■ Decoupled Hurtbox state changes via `hurt_response_state` export.     ║

║      ░ ■ Extracted `SensorComponent` to handle target detection areas.         ║
║      ░ ■ Refactored `Minion` and `BaseBoss` to use `SensorComponent`.          ║
║      ░ ■ Removed boilerplate signal handling for player detection in entities. ║
║      ░ ■ Sensors now auto-update entity state data via property reflection.    ║

║      ░ ■ Centralized physics authority in `PlayerPhysicsComponent` API.        ║
║      ░ ■ Refactored Player States (`Jump`, `Dash`, `Hurt`) to use Physics API  ║
║      ░   instead of manipulating velocity directly.                            ║
║      ░ ■ Removed specific combat signals from generic `BaseStateMachine`.      ║
║      ░ ■ States now access and actuate Hitbox components directly.             ║
║      ░ ■ Fixed physics threading issues in `HitboxComponent` (set_deferred).   ║

║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ║
║  ██                  [0.20.0] - CONFIG DECOUPLING - 11/XX/2025           ██    ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ║
║                                                                                ║
║   █  Architecture                                                              ║
║      ░ ■ Dismantled the monolithic `CombatConfig`.                             ║
║      ░ ■ Implemented granular `PlayerConfig`, `EnemyConfig`, and `WorldConfig`.║
║      ░ ■ Refactored all Entities and Systems to use specific config injection. ║
║      ░ ■ Removed `EntityBuilder`. Entities now self-assemble via `build_entity()`.║
║      ░ ■ Genericized States: Created `StateEntityPatrol` and `StateEntityIdle` base classes.║
║      ░ ■ Split `PlayerAbilityComponent` into atomic Jump/Dash/Heal/Charge components.║
║      ░ ■ Enforced typed events for Boss Death and Phase Changes (removed dictionary payloads).║
║      ░ ■ Replaced magic state strings ("melee", "patrol") with `Identifiers.CommonStates`.║
║      ░ ■ Deduplicated entity lifecycle: `BaseEntity` auto-wires Health signals.      ║
║      ░ ■ Implemented `PoolManifest`: Object pooling is now fully data-driven.        ║
║      ░ ■ Physics Overhaul: Disabled physical collision between Player and Enemies.   ║
║      ░ ■ Refactored Player contact damage to use Hurtbox signals + continuous polling.║
║      ░ ■ Fixed bug where Player could get stuck inside or push heavy enemies.        ║
       ░ ■ clean up InputComponent.gd to remove the unused configuration dependency.

║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.19.0] - CONTEXT HYGIENE - 11/18/2025             ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Documentation Refactor                                                    ║
║      ░ ■ Archived legacy logs and creative docs to `docs/archive/`.            ║
║      ░ ■ Abridged `CHANGELOG`, `TODO`, and `ARCHITECTURE` for token limits.    ║
║      ░ ■ Fixed source code generator to exclude archive/addons.                ║
║                                                                                ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.18.0] - SYSTEM HARDENING - 08/26/2025            ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Projectile & Sensor Architecture                                          ║
║      ░ ■ Implemented `BaseProjectile` inheritance for all shot types.          ║
║      ░ ■ Added `SENSORS` physics layer to prevent AI detection zones from      ║
║      ░   blocking shots.                                                       ║
║      ░ ■ Resolved `class_name` conflict in `ServiceLocator`.                   ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.17.0] - MINION INTELLIGENCE - 08/25/2025         ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  AI & Behaviors                                                            ║
║      ░ ■ Added `FlyingPatroller` enemy with gravity-defying movement logic.    ║
║      ░ ■ Implemented reactive Melee attacks for Patrolling Lancers.            ║
║      ░ ■ Refactored Minion FSM to support concurrent movement and combat.      ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.16.0] - SPAWNERS & GRAVITY - 08/24/2025          ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Entity Systems                                                            ║
║      ░ ■ Created generic `Spawner` system for infinite enemy waves.            ║
║      ░ ■ Unified gravity logic into `StateEntityFall` for all non-player units.║
║      ░ ■ Fixed physics bugs regarding stationary minions getting pushed.       ║
║                                                                                ║
║.  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.15.0] - UNIT TESTING - 08/23/2025                ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Quality Assurance                                                         ║
║      ░ ■ Integrated GUT framework. Added tests for Input, Health, and Resource ║
║      ░   components.                                                           ║
║      ░ ■ Implemented "Autoload Swapping" pattern for safe singleton testing.   ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.14.0] - SERVICE LOCATOR - 08/22/2025             ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Architecture                                                              ║
║      ░ ■ Implemented `ServiceLocator` to centralize global dependencies.       ║
║      ░ ■ Refactored UI menus into reusable, self-contained Components.         ║
║      ░ ■ Centralized jump logic into `PlayerJumpHelper`.                       ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.13.0] - DISSOLVE & SHADERS - 08/21/2025          ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Visual Effects                                                            ║
║      ░ ■ Added procedural `Dissolve` shader for entity death.                  ║
║      ░ ■ Refactored `FXManager` to be fully data-driven via `ShaderEffect`     ║
║      ░   resources.                                                            ║
║      ░ ■ Added `HomingBossShot` with complex tweening behavior.                ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.12.0] - ENTITY ARCHETYPES - 08/20/2025           ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Entity Architecture                                                       ║
║      ░ ■ Created `BaseEntity` to unify Player, Boss, and Minions.              ║
║      ░ ■ Implemented `EntityArchetype` resources to define component composition.║
║      ░ ■ Added robust `DependencyValidator` for component requirements.        ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.11.0] - VFX POOLING - 08/18/2025                 ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Performance & Juice                                                       ║
║      ░ ■ Implemented pooling for VFX particles (`HitSpark`).                   ║
║      ░ ■ Added `ScreenShakeEffect` resource and `CameraShaker` system.         ║
║      ░ ■ Hardened scene teardown to prevent memory leaks.                      ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.10.0] - CI/CD & AUTOMATION - 08/18/2025          ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  DevOps                                                                    ║
║      ░ ■ Setup GitHub Actions for automated cross-platform builds.             ║
║      ░ ■ Created initial integration test suite.                               ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.9.0] - STANDARDIZATION - 08/15/2025              ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Code Quality                                                              ║
║      ░ ■ Enforced `gdformat` and strict script headers project-wide.           ║
║      ░ ■ Decoupled `Input` singleton via `InputComponent` buffering.           ║
║      ░ ■ Added in-game Debug Overlay (F1).                                     ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.8.0] - UI OVERHAUL - 08/14/2025                  ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  User Interface                                                            ║
║      ░ ■ Migrated UI to scene-based architecture (no procedural generation).   ║
║      ░ ■ Created `MenuManager` for keyboard/mouse navigation.                  ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.7.0] - DATA DRIVEN CONFIG - 08/13/2025           ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Systems                                                                   ║
║      ░ ■ Consolidated tuning into `CombatConfig` resource.                     ║
║      ░ ■ Implemented distance-based melee damage logic.                        ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║.  ██                  [0.6.0] - DYNAMIC ENCOUNTERS - 08/11/2025           ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Gameplay                                                                  ║
║      ░ ■ Implemented Multi-Phase Boss Logic.                                   ║
║      ░ ■ Added first Minion type (`Turret`).                                   ║
║      ░ ■ Updated display to 16:9 Widescreen.                                   ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.5.0] - UNIFICATION - 08/10/2025                  ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Architecture                                                              ║
║      ░ ■ Unified Player and Boss under `BaseStateMachine`.                     ║
║      ░ ■ Defined `IDamageable` and `IComponent` contracts.                     ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.4.0] - COMPONENT REFACTOR - 08/09/2025           ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Refactor                                                                  ║
║      ░ ■ Broke Player into `Health`, `Combat`, and `Input` components.         ║
║      ░ ■ Implemented `ObjectPool` for projectiles.                             ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.3.0] - VISUAL FOUNDATION - 08/08/2025            ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Core Systems                                                              ║
║      ░ ■ Added `EventBus`, `Palette`, `Sequencer`.                             ║
║      ░ ■ Implemented `GameHUD` driven by events.                               ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.2.0] - ARCHITECTURAL REFACTOR - 08/07/2025       ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Optimization                                                              ║
║      ░ ■ Async Level Loading in `ArenaBuilder`.                                ║
║      ░ ■ Shader Pre-warming to prevent hitching.                               ║
║                                                                                ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║   ██                  [0.1.0] - MIGRATION - 08/05/2025                    ██   ║
║   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓   ║
║                                                                                ║
║   █  Initial Commit                                                            ║
║      ░ ■ Migrated logic from Kaplay prototype to Godot.                        ║
║      ░ ■ Basic Player controller, Boss FSM, and Tilemap.                       ║
║                                                                                ║
╚════════════════════════════════════════════════════════════════════════════════╝

=====================================
FILE: ./docs/HOW_TO_ADD_AN_EFFECT.md
=====================================
# How to Add a New Effect

## TODO: Write a step-by-step guide for designers.
1. Create a new ShaderEffect resource...
2. Configure the shader and parameters...
3. Link it to an event in FXManager...


=====================================
FILE: ./docs/standards/ADR-002_Communication.md
=====================================
# ADR-002: Communication Patterns

**Decision:** Strict separation between Local (Signal) and Global (EventBus) communication.

## 1. Local: Godot Signals
**Scope:** Inside a single scene (`.tscn`) or Parent-Child relationship.
*   **Child -> Parent:** Component emits signal (`hit_confirmed`), Parent listens.
*   **Parent -> Child:** Parent calls method on Child (`component.activate()`).
*   **Rule:** If they share a scene file, use Signals.

## 2. Global: EventBus
**Scope:** Between decoupled systems that should not reference each other.
*   **Entity -> UI:** Player emits `health_changed`, HUD listens.
*   **System -> System:** Encounter emits `boss_spawned`, MusicManager listens.
*   **Rule:** If the sender doesn't know the receiver exists, use EventBus.

## Litmus Test
*   Is `node_a` a child of `node_b`? -> **Signal/Method Call**.
*   Is `node_a` communicating with a singleton or a totally different scene? -> **EventBus**.

=====================================
FILE: ./docs/standards/ADR-001_Service_Locator.md
=====================================
# ADR-001: Global Service Access

**Decision:** Use Godot **Autoloads** as a Service Locator for global systems.

## The Pattern
1.  **Global Registry:** Core systems (`EventBus`, `ObjectPool`, `FXManager`) are registered as Autoloads in `project.godot`.
2.  **Central Access:** A `ServiceLocator` autoload provides typed access to these systems.
3.  **Injection:** Entities and Components **MUST NOT** call autoloads directly (e.g., `EventBus.emit`).
    *   **Entities** receive the `ServiceLocator` via `EntityBuilder` or `Spawner`.
    *   **Components** receive dependencies via `setup(owner, dependencies)`.

## Rationale
*   **Pros:** Idiomatic to Godot, performant, avoids complex DI frameworks.
*   **Cons:** Hidden dependencies if not injected.
*   **Mitigation:** Strict adherence to the "Owner-Driven Injection" pattern.

=====================================
FILE: ./docs/standards/STYLE-001_GDScript.md
=====================================
# STYLE-001: GDScript Style Guide

**Decision:** Strict adherence to Godot Style Guide + Static Typing + Docstrings.

## File Structure
1.  **Header:** `# res://path/to/script.gd`
2.  **Docstring:** `## High-level purpose of class.`
3.  **Definition:** `class_name MyClass extends BaseClass`
4.  **Members:**
    *   Signals
    *   Enums
    *   Constants (`UPPER_SNAKE_CASE`)
    *   Export Vars (`@export_group` required)
    *   Public Vars
    *   Private Vars (`_snake_case`)
5.  **Methods:**
    *   `_init` / `_ready` / `_process`
    *   Public Methods (`snake_case`)
    *   Private Methods (`_snake_case`)
    *   Signal Handlers (`_on_signal_name`)

## Rules
1.  **Static Typing:** ALL variables and functions must have types.
    *   `func my_func(a: int) -> void:`
    *   `var health: int = 10`
2.  **Private Prefix:** Internal variables/functions must start with `_`.
3.  **Documentation:** Use `##` for class and public function documentation (Tooltip support).
4.  **No Magic Numbers:** Move literals to `CombatConfig` or `Constants`.

=====================================
FILE: ./README.md
=====================================

```
          ██████╗  ██████╗ ██╗  ██╗    ██████╗  █████╗ ████████╗████████╗██╗     ███████╗
          ██╔══██╗██╔═══██╗ ██╗██╔╝    ██╔══██╗██╔══██╗╚══██╔══╝╚══██╔══╝██║     ██╔════╝
          ██████╔╝██║   ██║  ███╔╝     ██████╔╝███████║   ██║      ██║   ██║     █████╗  
          ██╔══██╗██║   ██║ ██╔██╗     ██╔══██╗██╔══██║   ██║      ██║   ██║     ██╔══╝  
          ██████╔╝╚██████╔╝██╔╝ ██╗    ██████╔╝██║  ██║   ██║      ██║   ███████╗███████╗
          ╚═════╝  ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚══════╝
```

A combat-focused Mega Man / Hollow Knight-like Arena Battler built in Godot 4. This repository serves as a professional template for creating robust, scalable, and data-driven games, showcasing modern design patterns and a clean, testable architecture.

**Current Status:** Architecturally Stable & Feature-Rich.

---

<!-- TODO: Add a high-quality gameplay GIF here -->

## ■ Core Philosophy & Architectural Highlights

This project is built on a foundation of professional software design patterns, adapted for the Godot engine. The goal is a codebase that is easy to understand, maintain, and extend.

-   **Component-Based Entities:** All game entities (Player, Boss, Minions) are lean `BaseEntity` nodes that compose their functionality from small, single-responsibility components (`HealthComponent`, `PlayerPhysicsComponent`, etc.).

-   **Data-Driven Design:** Entity behavior is not hard-coded. It is defined in `Resource` files (`.tres`). `BossBehavior` and `MinionBehavior` resources act as "character sheets" that dictate stats, movement, and attack patterns, allowing designers to create new enemies without writing any code.

-   **Strategy Pattern for Logic:** Core behaviors like movement (`MovementLogic`) and attacks (`AttackLogic`) are implemented as interchangeable `Resource`-based strategies. This allows for complex combinations (e.g., a flying minion that uses a lunge attack) by simply linking different data files.

-   **Decoupled Systems via Service Locator & EventBus:** A central `ServiceLocator` provides safe, typed access to core singletons (`FXManager`, `ObjectPool`, etc.), while a global `EventBus` handles communication between systems, preventing tight coupling.

-   **Robust & Testable:** The architecture emphasizes testability, with a suite of unit tests, fakes for core systems (`FakeEventBus`), and a clear dependency injection pattern that makes components easy to test in isolation.

## ■ Getting Started

1.  **Install Godot 4.4** or newer.
2.  **Clone** this repository.
3.  Open the project in Godot and run the main scene: `res://src/scenes/main/main.tscn`.

## ■ Controls

The controls are designed for keyboard and mouse, reflecting the in-game controls menu.

-   **Movement:** Arrow Keys / WASD
-   **Primary Action (Jump/Confirm):** X / . / Space / Left-Click
-   **Secondary Action (Attack/Pogo):** C / , / Shift / Right-Click
-   **Tertiary Action (Dash):** Z / / / Ctrl / Middle-Click
-   **Heal:** Down + Jump (on ground)
-   **Pause / Menu:** Enter / P / Escape

## ■ Project Structure

The repository is organized to separate engine code, game logic, and data, making it easy to navigate.

-   `addons/` - Contains the GUT (Godot Unit Test) framework.
-   `docs/` - High-level design documents, architectural decision records (ADRs), and style guides.
-   `src/` - All core game source code.
    -   `api/` - "Interface" contracts (`IComponent`, `IDamageable`) and data transfer objects (`DamageInfo`).
    -   `arenas/` - (Placeholder for future arena-specific scenes/logic).
    -   `combat/` - Shared, reusable combat logic, such as `AttackLogic` resources.
    -   `core/` - Global systems, autoloaded singletons, and core utilities (`EventBus`, `ObjectPool`, `SceneManager`).
    -   `data/` - Global, game-wide data resources like the master `CombatConfig` and dialogue files.
    -   `entities/` - The heart of the gameplay, containing the Player, Boss, and Minion scenes, components, states, and behavior resources.
    -   `projectiles/` - Scenes and scripts for all projectiles.
    -   `scenes/` - The main game flow scenes (main menu, loading screen, encounter, game over).
    -   `shaders/` - All GLSL shader code.
    -   `tests/` - The complete suite of GUT unit and integration tests.
    -   `ui/` - All UI-related scenes and components (HUD, menus, debug overlay).
    -   `vfx/` - Visual effect scenes, like `hit_spark.tscn`.

## ■ Key Systems Overview

The game's architecture is managed by a suite of decoupled, autoloaded singletons.

-   `GameManager`: Manages the high-level game state.
-   `SceneManager`: Handles all scene transitions and ensures proper cleanup.
-   `EventBus`: A global message bus for loosely-coupled communication between systems.
-   `ObjectPool`: Manages pools of reusable nodes (projectiles, VFX) to prevent stuttering.
-   `ArenaBuilder`: Procedurally constructs the game level from `EncounterData` and `LevelLayout` resources.
-   `ServiceLocator`: Provides a central, type-safe access point to all other core systems.

For a deeper dive into the architecture, please see the documents in the `docs/` folder, especially `docs/ARCHITECTURE.txt`.

## ■ License

This project is licensed under the terms of the license agreement. Please see the `LICENSE` file for full details.

=====================================
FILE: ./default_bus_layout.tres
=====================================
[gd_resource type="AudioBusLayout" format=3 uid="uid://c65ja7dwrkbrc"]

[resource]
bus/1/name = &"Music"
bus/1/solo = false
bus/1/mute = false
bus/1/bypass_fx = false
bus/1/volume_db = 0.0
bus/1/send = &"Master"
bus/2/name = &"SFX"
bus/2/solo = false
bus/2/mute = false
bus/2/bypass_fx = false
bus/2/volume_db = 0.0
bus/2/send = &"Master"

=====================================
FILE: ./.github/scripts/get_version.gd
=====================================
# .github/scripts/get_version.gd
# This script runs in the CI environment to get the version
# from project.godot and print it to the command line.
extends SceneTree


func _init():
	var version = ProjectSettings.get_setting("application/config/version")
	print(version)
	quit()


=====================================
FILE: ./.github/scripts/lint_shaders.gd
=====================================
# .github/scripts/lint_shaders.gd
## A command-line script to lint all .gdshader files in the project.
## It enforces project-specific best practices for shader development.
extends SceneTree

var _shader_files: Array[String] = []
var _error_count: int = 0


func _init() -> void:
	print("--- Running Shader Linter ---")
	_find_all_shaders("res://")
	_lint_files()

	if _error_count > 0:
		print("\nLinter FAILED: Found %d error(s)." % _error_count)
		quit(1)
	else:
		print("\nLinter PASSED: All shader files are compliant.")
		quit(0)


## Recursively finds all .gdshader files in the project.
func _find_all_shaders(path: String) -> void:
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			var full_path = path.path_join(file_name)
			if dir.current_is_dir() and file_name != "." and file_name != "..":
				_find_all_shaders(full_path)
			elif file_name.ends_with(".gdshader"):
				_shader_files.append(full_path)
			file_name = dir.get_next()


## Iterates through found shader files and applies linting rules.
func _lint_files() -> void:
	for file_path in _shader_files:
		var file = FileAccess.open(file_path, FileAccess.READ)
		if not is_instance_valid(file):
			_report_error(file_path, -1, "Could not open file.")
			continue

		var content = file.get_as_text()
		var lines = content.split("\n")

		_check_shader_type_present(file_path, content)
		_check_source_color_hints(file_path, lines)


## Linter Rule 1: Ensure 'shader_type' is declared.
func _check_shader_type_present(file_path: String, content: String) -> void:
	if not content.contains("shader_type"):
		_report_error(file_path, 1, "Missing required 'shader_type' declaration.")


## Linter Rule 2: Ensure color uniforms have ': source_color'.
func _check_source_color_hints(file_path: String, lines: Array[String]) -> void:
	for i in range(lines.size()):
		var line = lines[i].strip_edges()
		if line.begins_with("uniform vec4") and "color" in line.to_lower():
			if not line.contains(": source_color"):
				_report_error(
					file_path,
					i + 1,
					"Color uniform is missing ': source_color' hint. Line: '%s'" % line
				)


## Reports a formatted error message to the console.
func _report_error(file_path: String, line_num: int, message: String) -> void:
	_error_count += 1
	var line_str = "L%d" % line_num if line_num > 0 else "FILE"
	print("ERROR: %s:%s - %s" % [file_path, line_str, message])


=====================================
FILE: ./project.godot
=====================================
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="BOX BATTLE"
config/version="0.28.0"
run/main_scene="res://src/scenes/main/main.tscn"
config/features=PackedStringArray("4.4", "Mobile")
config/icon="res://icon.svg"

[autoload]

GameManager="*res://src/core/systems/game_manager.gd"
SceneManager="*res://src/core/systems/scene_manager.gd"
AudioManager="*res://src/core/systems/audio_manager.gd"
FXManager="*res://src/game/vfx/fx_manager.gd"
CameraManager="*res://src/game/vfx/camera_manager.gd"
CursorManager="*res://src/core/systems/cursor_manager.gd"
DialogueManager="*res://src/core/systems/dialogue_manager.gd"
ObjectPool="*res://src/core/systems/object_pool.gd"
EventBus="*res://src/core/events/event_bus.gd"
Sequencer="*res://src/core/sequencing/sequencer.gd"
ArenaBuilder="*res://src/game/level_gen/arena_builder.gd"
Settings="*res://src/core/data/config/settings.gd"
GlobalPreloader="*res://src/core/boot/global_preloader.gd"
ServiceLocator="*res://src/core/util/service_locator.gd"
AssetPaths="*res://src/core/util/asset_paths.gd"
Constants="*res://src/core/util/constants.gd"
GridUtils="*res://src/core/util/grid_utils.gd"
CombatUtils="*res://src/core/util/combat_utils.gd"
Identifiers="*res://src/core/util/identifiers.gd"
Palette="*res://src/core/util/palette.gd"
PhysicsLayers="*res://src/core/util/physics_layers.gd"
FXManagerAdapter="*res://src/game/vfx/bindings/fx_manager_adapter.gd"
ObjectPoolAdapter="*res://src/core/systems/pool_bindings/object_pool_adapter.gd"
TargetingSystem="*res://src/core/systems/targeting_system.gd"
SaveManager="*res://src/core/systems/save_manager.gd"

[display]

window/size/viewport_width=2560
window/size/viewport_height=1440
window/stretch/mode="canvas_items"
window/stretch/aspect="expand"

[editor_plugins]

enabled=PackedStringArray("res://addons/gut/plugin.cfg")

[input]

ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194319,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
]
}
ui_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194321,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
]
}
ui_up={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194320,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
]
}
ui_down={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194322,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
]
}
ui_jump={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":32,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":88,"physical_keycode":88,"key_label":0,"unicode":120,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":46,"physical_keycode":46,"key_label":0,"unicode":46,"location":0,"echo":false,"script":null)
]
}
ui_attack={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":67,"physical_keycode":67,"key_label":0,"unicode":99,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":44,"physical_keycode":44,"key_label":0,"unicode":44,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":true,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777218,"physical_keycode":16777218,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":2,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
ui_dash={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":90,"physical_keycode":90,"key_label":0,"unicode":122,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":47,"physical_keycode":47,"key_label":0,"unicode":47,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":true,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777217,"physical_keycode":16777217,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":3,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
debug_toggle_overlay={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":89,"key_label":0,"unicode":121,"location":0,"echo":false,"script":null)
]
}
debug_cycle_target={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":85,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
]
}
debug_dialogue={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":72,"key_label":0,"unicode":104,"location":0,"echo":false,"script":null)
]
}
debug_toggle_collision={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":79,"key_label":0,"unicode":111,"location":0,"echo":false,"script":null)
]
}
debug_pause_game={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":80,"key_label":0,"unicode":112,"location":0,"echo":false,"script":null)
]
}
debug_toggle_invincibility={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":76,"key_label":0,"unicode":108,"location":0,"echo":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="player"
2d_physics/layer_2="platforms"
2d_physics/layer_3="enemy"
2d_physics/layer_4="hazard"
2d_physics/layer_5="enemy_projectile"
2d_physics/layer_6="player_hitbox"
2d_physics/layer_7="player_hurtbox"
2d_physics/layer_8="solid_world"
2d_physics/layer_9="hitbox"
2d_physics/layer_10="sensors"
2d_physics/layer_11="player_projectile"

[rendering]

renderer/rendering_method="mobile"
textures/vram_compression/import_etc2_astc=true
environment/defaults/default_clear_color=Color(0, 0, 0, 1)

[shader_globals]

fx_global_time={
"type": "float",
"value": 0.0
}
vignette_intensity={
"type": "float",
"value": 0.0
}
desat_amount={
"type": "float",
"value": 0.0
}
pal_index={
"type": "int",
"value": 0
}


=====================================
FILE: ./.vscode/settings.json
=====================================
{
    "godotTools.editorPath.godot4": "/Applications/Godot.app"
}

=====================================
FILE: ./assets/textures/noise_texture.tres
=====================================
[gd_resource type="NoiseTexture2D" load_steps=2 format=3 uid="uid://07p7ttqtioqu"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_1"]
noise_type = 3
frequency = 0.4
fractal_type = 0

[resource]
seamless = true
noise = SubResource("FastNoiseLite_1")


=====================================
FILE: ./assets/vfx/particles/README.md
=====================================
# Particle Effects

This directory will contain all `GPUParticles2D` node scenes used for visual effects like hit-sparks, explosions, and trails.

=====================================
FILE: ./assets/audio/audio-license.txt
=====================================
Audio Assets License
===================

All sound effects and music in this project were created by Steven Casteel using paid subscription services that grant full commercial usage rights:

- Sound Effects: Generated using ElevenLabs paid tier
- Music: Generated using Udio paid subscription

Under the terms of both services' paid plans, the creator retains full ownership and distribution rights to the generated content. 

These audio assets are hereby released under CC0 1.0 Universal, dedicating them to the public domain alongside the rest of this project.

You may use these audio files for any purpose, including commercial use, without attribution or permission.

=====================================
FILE: ./src/ui/game_hud/game_hud.gd
=====================================
# src/ui/game_hud/game_hud.gd
## Manages the in-game heads-up display.
extends CanvasLayer

# --- Constants ---
const PLAYER_CONFIG = preload("res://src/data/player_config.tres")
const ENEMY_CONFIG = preload("res://src/data/enemy_config.tres")

# --- Node References ---
@onready var player_info: VBoxContainer = %PlayerInfo
@onready var player_health_value: Label = %PlayerHealthValue
@onready var player_heal_charges_value: Label = %PlayerHealChargesValue
@onready var boss_health_bar: ProgressBar = %BossHealthBar
@onready var phase_indicators: HBoxContainer = %PhaseIndicators

# --- Private Member Variables ---
var _phase_squares: Array[Panel] = []
var _total_phases: int = 3
var _player_health_token: int
var _player_charges_token: int
var _boss_health_token: int
var _boss_phase_token: int
var _boss_died_token: int

var _filled_phase_style: StyleBoxFlat
var _empty_phase_style: StyleBoxFlat


# --- Godot Lifecycle Methods ---
func _ready() -> void:
	_subscribe_to_events()
	_initialize_ui_state()


func _exit_tree() -> void:
	_unsubscribe_from_events()


# --- Private Methods ---
func _subscribe_to_events() -> void:
	_player_health_token = EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, on_player_health_changed)
	_player_charges_token = EventBus.on(
		EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, on_player_healing_charges_changed
	)
	_boss_health_token = EventBus.on(EventCatalog.BOSS_HEALTH_CHANGED, on_boss_health_changed)
	_boss_phase_token = EventBus.on(EventCatalog.BOSS_PHASE_CHANGED, on_boss_phase_changed)
	_boss_died_token = EventBus.on(EventCatalog.BOSS_DIED, on_boss_died)


func _unsubscribe_from_events() -> void:
	EventBus.off(_player_health_token)
	EventBus.off(_player_charges_token)
	EventBus.off(_boss_health_token)
	EventBus.off(_boss_phase_token)
	EventBus.off(_boss_died_token)


func _initialize_ui_state() -> void:
	# --- Create StyleBoxes for Phase Indicators ---
	_filled_phase_style = StyleBoxFlat.new()
	_filled_phase_style.bg_color = Color.WHITE

	_empty_phase_style = StyleBoxFlat.new()
	_empty_phase_style.bg_color = Color.TRANSPARENT
	_empty_phase_style.border_width_left = 2
	_empty_phase_style.border_width_top = 2
	_empty_phase_style.border_width_right = 2
	_empty_phase_style.border_width_bottom = 2
	_empty_phase_style.border_color = Color.WHITE
	
	# --- Initialize Rest of UI ---
	var max_health = PLAYER_CONFIG.max_health
	player_health_value.text = "%d / %d" % [max_health, max_health]
	player_heal_charges_value.text = "0"

	var health_bar_style = boss_health_bar.get_theme_stylebox("fill").duplicate()
	health_bar_style.bg_color = Palette.COLOR_PLAYER_PROJECTILE
	boss_health_bar.add_theme_stylebox_override("fill", health_bar_style)

	boss_health_bar.max_value = ENEMY_CONFIG.boss_health
	boss_health_bar.value = boss_health_bar.max_value

	phase_indicators.add_theme_constant_override("separation", 5)
	_create_phase_indicators()


func _create_phase_indicators() -> void:
	for i in range(_total_phases):
		# Use Panel nodes instead of ColorRects to allow for custom styling.
		var square = Panel.new()
		square.custom_minimum_size = Vector2(40, 40)
		phase_indicators.add_child(square)
		_phase_squares.append(square)
	_update_phase_visuals(_total_phases)


func _update_phase_visuals(phases_remaining: int) -> void:
	for i in range(_phase_squares.size()):
		var square: Panel = _phase_squares[i]
		
		# Apply the appropriate style based on whether the phase is remaining or depleted.
		if i < phases_remaining:
			square.add_theme_stylebox_override("panel", _filled_phase_style)
		else:
			square.add_theme_stylebox_override("panel", _empty_phase_style)


# --- EventBus Callbacks ---
func on_player_health_changed(payload: PlayerHealthChangedEvent) -> void:
	player_health_value.text = str(payload.current_health) + " / " + str(payload.max_health)


func on_player_healing_charges_changed(payload: PlayerHealingChargesChangedEvent) -> void:
	player_heal_charges_value.text = str(payload.current_charges)


func on_boss_health_changed(payload: BossHealthChangedEvent) -> void:
	boss_health_bar.max_value = payload.max_health
	boss_health_bar.value = payload.current_health


func on_boss_phase_changed(payload: BossPhaseChangedEvent) -> void:
	# UPDATE: Typed property access
	_update_phase_visuals(payload.phases_remaining)


func on_boss_died(_payload) -> void:
	_update_phase_visuals(0)


=====================================
FILE: ./src/ui/game_hud/game_hud.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://c1qkhw0snj226"]

[ext_resource type="Script" path="res://src/ui/game_hud/game_hud.gd" id="1_3f8wa"]
[ext_resource type="Theme" uid="uid://b7yeo6jg078gl" path="res://src/ui/themes/main_theme.tres" id="2_main_theme"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_1"]
bg_color = Color(0.262745, 0.262745, 0.262745, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_2"]
bg_color = Color(0.92549, 0.92549, 0.92549, 1)

[node name="GameHUD" type="CanvasLayer"]
script = ExtResource("1_3f8wa")

[node name="ThemeContainer" type="Control" parent="."]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme = ExtResource("2_main_theme")

[node name="PlayerInfo" type="VBoxContainer" parent="ThemeContainer"]
unique_name_in_owner = true
offset_left = 60.0
offset_top = 60.0
offset_right = 280.0
offset_bottom = 140.0

[node name="PlayerHealthHBox" type="HBoxContainer" parent="ThemeContainer/PlayerInfo"]
layout_mode = 2

[node name="PlayerHealthLabel" type="Label" parent="ThemeContainer/PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Health:"

[node name="PlayerHealthValue" type="Label" parent="ThemeContainer/PlayerInfo/PlayerHealthHBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "5 / 5"

[node name="PlayerHealChargesHBox" type="HBoxContainer" parent="ThemeContainer/PlayerInfo"]
layout_mode = 2

[node name="PlayerHealChargesLabel" type="Label" parent="ThemeContainer/PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Heal Charges:"

[node name="PlayerHealChargesValue" type="Label" parent="ThemeContainer/PlayerInfo/PlayerHealChargesHBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"

[node name="BossHealthBar" type="ProgressBar" parent="ThemeContainer"]
unique_name_in_owner = true
anchors_preset = 10
anchor_right = 1.0
offset_left = 50.0
offset_top = 20.0
offset_right = -50.0
offset_bottom = 50.0
grow_horizontal = 2
theme_override_styles/background = SubResource("StyleBoxFlat_1")
theme_override_styles/fill = SubResource("StyleBoxFlat_2")
max_value = 30.0
step = 1.0
value = 30.0
show_percentage = false

[node name="PhaseIndicators" type="HBoxContainer" parent="ThemeContainer"]
unique_name_in_owner = true
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -190.0
offset_top = 60.0
offset_right = -60.0
offset_bottom = 100.0
grow_horizontal = 0
alignment = 2

=====================================
FILE: ./src/ui/menu_manager/menu_manager.gd
=====================================
# src/ui/menu_manager/menu_manager.gd
## A helper node that manages keyboard navigation and cursor display for a menu.
##
## This is intended to be instanced by a menu scene at runtime. It handles
## focus changes and draws selection cursors next to the focused item.
extends Node

# --- Signals ---
## Emitted when the selection changes via keyboard input.
signal selection_changed

# --- Member Variables ---
var menu_items: Array[Control] = []
var current_selection_index: int = 0

var _cursor_left: ColorRect
var _cursor_right: ColorRect

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_cursor_left = ColorRect.new()
	_cursor_left.size = Vector2(20, 20)
	_cursor_left.color = Palette.COLOR_UI_ACCENT_PRIMARY
	_cursor_left.visible = false
	add_child(_cursor_left)

	_cursor_right = ColorRect.new()
	_cursor_right.size = Vector2(20, 20)
	_cursor_right.color = Palette.COLOR_UI_ACCENT_PRIMARY
	_cursor_right.visible = false
	add_child(_cursor_right)


func _unhandled_input(event: InputEvent) -> void:
	if menu_items.is_empty():
		return

	if event.is_action_pressed(Identifiers.Actions.MOVE_DOWN):
		_change_selection(1)
		get_viewport().set_input_as_handled()
	elif event.is_action_pressed(Identifiers.Actions.MOVE_UP):
		_change_selection(-1)
		get_viewport().set_input_as_handled()


# --- Public Methods ---


## Initializes the manager with a list of menu items to control.
func setup_menu(items: Array[Control]) -> void:
	if items.is_empty():
		return
	self.menu_items = items

	for item in menu_items:
		item.focus_entered.connect(_on_item_focused.bind(item))


# --- Private Methods ---


func _change_selection(amount: int) -> void:
	if menu_items.size() <= 1:
		return

	var new_selection = (current_selection_index + amount + menu_items.size()) % menu_items.size()
	menu_items[new_selection].grab_focus()


func _update_cursors(selected_item: Control) -> void:
	await get_tree().process_frame  # Wait for layout to settle

	if not is_instance_valid(selected_item):
		return

	var item_pos = selected_item.global_position
	var item_size = selected_item.size
	var cursor_padding = 40.0

	_cursor_left.global_position.y = item_pos.y + (item_size.y - _cursor_left.size.y) / 2.0
	_cursor_left.global_position.x = item_pos.x - cursor_padding - _cursor_left.size.x

	_cursor_right.global_position.y = item_pos.y + (item_size.y - _cursor_right.size.y) / 2.0
	_cursor_right.global_position.x = item_pos.x + item_size.x + cursor_padding

	_cursor_left.visible = true
	_cursor_right.visible = true


# --- Signal Handlers ---


func _on_item_focused(focused_item: Control) -> void:
	var index = menu_items.find(focused_item)
	if index != -1:
		current_selection_index = index

	_update_cursors(focused_item)
	selection_changed.emit()


=====================================
FILE: ./src/ui/dialogue/dialogue_box.gd
=====================================
# src/ui/dialogue/dialogue_box.gd
## The UI scene responsible for displaying dialogue text.
##
## It receives data from the [DialogueManager] and handles the visual
## presentation, including animated text effects.
class_name DialogueBox
extends Control

signal advance_requested
signal typing_finished

# --- Node References ---
@onready var name_label: Label = %NameLabel
@onready var text_label: RichTextLabel = %TextLabel

# --- Private Member Variables ---
var _typing_tween: Tween
var _is_typing: bool = false
var _typing_speed_chars_per_second: float = 60.0


# --- Godot Lifecycle Methods ---
func _unhandled_input(event: InputEvent) -> void:
	if not visible:
		return
	if event.is_action_pressed("ui_accept"):
		get_viewport().set_input_as_handled()
		_skip_or_advance()


# --- Public Methods ---


## Displays a single line of dialogue.
func display_line(line_data: DialogueLine) -> void:
	name_label.text = line_data.speaker
	text_label.bbcode_enabled = true
	text_label.text = line_data.text

	if is_instance_valid(_typing_tween):
		_typing_tween.kill()

	text_label.visible_ratio = 0.0
	_is_typing = true

	var parsed_text = text_label.get_parsed_text()
	var chars = parsed_text.length()
	var duration = max(0.1, float(chars) / _typing_speed_chars_per_second)

	_typing_tween = create_tween().set_trans(Tween.TRANS_LINEAR).set_ease(Tween.EASE_IN_OUT)
	_typing_tween.tween_property(text_label, "visible_ratio", 1.0, duration)
	_typing_tween.finished.connect(_on_typing_finished, CONNECT_ONE_SHOT)


# --- Private Methods ---
func _skip_or_advance() -> void:
	if _is_typing:
		if is_instance_valid(_typing_tween):
			_typing_tween.kill()
		text_label.visible_ratio = 1.0
		_on_typing_finished()
	else:
		advance_requested.emit()


func _on_typing_finished() -> void:
	_is_typing = false
	_typing_tween = null
	typing_finished.emit()


=====================================
FILE: ./src/ui/dialogue/dialogue_box.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dialogue_box_tscn"]

[ext_resource type="Script" path="res://src/ui/dialogue/dialogue_box.gd" id="1_dialogue_box_script"]

[node name="DialogueBox" type="Control"]
layout_mode = 3
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -250.0
grow_horizontal = 2
grow_vertical = 0
script = ExtResource("1_dialogue_box_script")

[node name="Panel" type="Panel" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2

[node name="NameLabel" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Character Name"

[node name="TextLabel" type="RichTextLabel" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 28
bbcode_enabled = true
text = "This is where the dialogue text will appear, animating one character at a time..."

=====================================
FILE: ./src/ui/components/mute_button/mute_button.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://d1g2h3i4j5k6l"]

[ext_resource type="Texture2D" uid="uid://dmdfbw1txq0nf" path="res://assets/sprites/ui/icons/icon_ui_sound_off.png" id="1_g0pcd"]
[ext_resource type="Script" uid="uid://cotrj67gsvbw8" path="res://src/ui/components/mute_button/mute_button.gd" id="1_mute_button_script"]

[node name="MuteButton" type="TextureButton"]
focus_mode = 0
texture_normal = ExtResource("1_g0pcd")
script = ExtResource("1_mute_button_script")


=====================================
FILE: ./src/ui/components/mute_button/mute_button.gd
=====================================
# src/ui/components/mute_button/mute_button.gd
@tool
## A reusable UI component for toggling the game's music mute state.
##
## It automatically syncs its icon with the global [Settings] resource.
class_name MuteButton
extends TextureButton

# --- Constants ---
const ICON_SOUND_ON = preload(AssetPaths.ICON_UI_SOUND_ON)
const ICON_SOUND_OFF = preload(AssetPaths.ICON_UI_SOUND_OFF)

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	if not Engine.is_editor_hint():
		# This component is now fully self-managing.
		self.pressed.connect(_on_pressed)
		Settings.audio_settings_changed.connect(_on_audio_settings_changed)
		self.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		self.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))
		_on_audio_settings_changed()  # Sync icon on ready


func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if self.pressed.is_connected(_on_pressed):
			self.pressed.disconnect(_on_pressed)
		if Settings.audio_settings_changed.is_connected(_on_audio_settings_changed):
			Settings.audio_settings_changed.disconnect(_on_audio_settings_changed)
		if self.mouse_entered.is_connected(CursorManager.set_pointer_state.bind(true)):
			self.mouse_entered.disconnect(CursorManager.set_pointer_state.bind(true))
		if self.mouse_exited.is_connected(CursorManager.set_pointer_state.bind(false)):
			self.mouse_exited.disconnect(CursorManager.set_pointer_state.bind(false))


# --- Public Methods ---


## Updates the button's icon based on the current global mute state.
func update_icon() -> void:
	if Settings.music_muted:
		self.texture_normal = ICON_SOUND_OFF
	else:
		self.texture_normal = ICON_SOUND_ON


# --- Signal Handlers ---


func _on_pressed() -> void:
	# When pressed, this button directly modifies the global setting.
	Settings.music_muted = not Settings.music_muted
	# Play sound feedback
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)


func _on_audio_settings_changed() -> void:
	update_icon()


=====================================
FILE: ./src/ui/components/control_setting_row/control_setting_row.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cgt6j1h2w3k4m"]

[ext_resource type="Script" uid="uid://cl6kmmhf3qt04" path="res://src/ui/components/control_setting_row/control_setting_row.gd" id="1_control_row_script"]
[ext_resource type="FontFile" uid="uid://hypwi2d6bj7t" path="res://assets/fonts/font_main_bold.ttf" id="2_font_bold"]

[node name="ControlSettingRow" type="HBoxContainer"]
custom_minimum_size = Vector2(900, 60)
offset_right = 900.0
offset_bottom = 60.0
theme_override_constants/separation = 20
alignment = 1
script = ExtResource("1_control_row_script")

[node name="ActionLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(400, 0)
layout_mode = 2
size_flags_vertical = 1
theme_override_fonts/font = ExtResource("2_font_bold")
theme_override_font_sizes/font_size = 32
text = "Action Name"
horizontal_alignment = 2
vertical_alignment = 1

[node name="RebindButton" type="Button" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(400, 50)
layout_mode = 2
focus_mode = 0
theme_override_font_sizes/font_size = 28
text = "Key"

[connection signal="pressed" from="RebindButton" to="." method="_on_rebind_button_pressed"]


=====================================
FILE: ./src/ui/components/control_setting_row/control_setting_row.gd
=====================================
# src/ui/components/control_setting_row/control_setting_row.gd
@tool
## A UI component representing a single remappable action.
## Handles listening for input and updating the Settings singleton.
class_name ControlSettingRow
extends HBoxContainer

# --- Node References ---
@onready var action_label: Label = %ActionLabel
@onready var rebind_button: Button = %RebindButton

# --- Private Variables ---
var _action_name: String = ""
var _is_listening: bool = false

# --- Godot Lifecycle ---

func _ready() -> void:
	# Ensure visual state matches current settings on load
	if not _action_name.is_empty():
		_update_display()
	
	if not Engine.is_editor_hint():
		rebind_button.mouse_entered.connect(_on_hover_started)
		rebind_button.mouse_exited.connect(_on_hover_ended)

func _input(event: InputEvent) -> void:
	if not _is_listening:
		return
		
	# Filter out non-input events (like mouse movement)
	if event is InputEventMouseMotion:
		return

	# Allow canceling with Escape (if it's not the key being bound)
	if event.is_action_pressed("ui_cancel"):
		_is_listening = false
		_update_display()
		get_viewport().set_input_as_handled()
		return

	# Accept Key or Mouse Button
	if event is InputEventKey or event is InputEventMouseButton:
		if event.is_pressed():
			_apply_rebind(event)
			get_viewport().set_input_as_handled()


# --- Public API ---

func setup(action: String, display_name: String) -> void:
	_action_name = action
	if is_instance_valid(action_label):
		action_label.text = display_name
	_update_display()


# --- Private Logic ---

func _update_display() -> void:
	if not is_instance_valid(rebind_button):
		return
		
	if _is_listening:
		rebind_button.text = "Press any key..."
	else:
		rebind_button.text = Settings.get_input_label(_action_name)


func _apply_rebind(event: InputEvent) -> void:
	Settings.remap_action(_action_name, event)
	_is_listening = false
	_update_display()


# --- Signal Handlers ---

func _on_rebind_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
	_is_listening = true
	_update_display()


func _on_hover_started() -> void:
	CursorManager.set_pointer_state(true)
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_hover_ended() -> void:
	CursorManager.set_pointer_state(false)


=====================================
FILE: ./src/ui/components/styled_menu_item/styled_menu_item.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cgt63w7k4w5gq"]

[ext_resource type="Script" path="res://src/ui/components/styled_menu_item/styled_menu_item.gd" id="1_menu_item_script"]

[node name="StyledMenuItem" type="Control"]
custom_minimum_size = Vector2(400, 80)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_menu_item_script")

=====================================
FILE: ./src/ui/components/styled_menu_item/styled_menu_item.gd
=====================================
# src/ui/components/styled_menu_item/styled_menu_item.gd
@tool
## A reusable, procedurally-drawn menu item component.
##
## Handles its own drawing, state changes (hover, press, focus), input,
## and animations for a self-contained, highly configurable button.
class_name StyledMenuItem
extends Control

# --- Signals ---
## Emitted when the menu item is clicked or activated via keyboard.
signal pressed

# --- Editor Properties ---
@export var text: String = "Menu Item":
	set = set_text
@export var font_size: int = 48:
	set = set_font_size
@export var glow_size: float = 0.0:
	set = set_glow_size
@export var glow_alpha: float = 0.0:
	set = set_glow_alpha

# --- Member Variables ---
var is_hovered: bool = false
var is_pressed: bool = false
var is_selected: bool = false

# --- Private Member Variables ---
var _font: Font
var _active_tween: Tween

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	_font = load(AssetPaths.FONT_MAIN_BOLD)
	focus_mode = FOCUS_ALL
	mouse_filter = MOUSE_FILTER_STOP

	# This component now manages its own cursor state.
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	resized.connect(queue_redraw)
	focus_entered.connect(_on_focus_entered)
	focus_exited.connect(_on_focus_exited)


func _gui_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_accept") and has_focus():
		get_viewport().set_input_as_handled()
		emit_signal("pressed")
		_show_keyboard_press_feedback()
		return

	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.is_pressed():
			is_pressed = true
			queue_redraw()
		elif is_pressed:  # On release
			emit_signal("pressed")
			is_pressed = false
			queue_redraw()


func _draw() -> void:
	var bg_color: Color
	var text_color: Color
	var border_color: Color
	var border_width: float = 3.0

	if is_pressed:
		bg_color = Palette.get_color(2)
		text_color = Palette.COLOR_TEXT_PRIMARY
		border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	elif is_hovered or is_selected:
		bg_color = Palette.COLOR_UI_ACCENT_PRIMARY
		text_color = Palette.COLOR_BACKGROUND
		border_color = Palette.get_color(4)
	else:
		bg_color = Palette.COLOR_UI_PANEL_BG
		text_color = Palette.COLOR_TEXT_PRIMARY
		border_color = Palette.COLOR_UI_ACCENT_PRIMARY

	if (is_hovered or is_selected) and glow_size > 0.0 and glow_alpha > 0.0:
		var glow_base_color = Palette.COLOR_UI_GLOW
		var final_glow_color = Color(
			glow_base_color.r, glow_base_color.g, glow_base_color.b, glow_alpha
		)
		var glow_rect = Rect2(Vector2.ZERO, size).grow(glow_size)
		draw_rect(glow_rect, final_glow_color)

	draw_rect(Rect2(Vector2.ZERO, size), bg_color)
	draw_rect(Rect2(Vector2.ZERO, size), border_color, false, border_width)

	var text_width = _font.get_string_size(text, HORIZONTAL_ALIGNMENT_CENTER, -1, font_size).x
	var text_pos_x = (size.x - text_width) / 2.0
	var text_pos_y = (size.y / 2.0) + (font_size / 3.0)
	draw_string(
		_font,
		Vector2(text_pos_x, text_pos_y),
		text,
		HORIZONTAL_ALIGNMENT_LEFT,
		-1,
		font_size,
		text_color
	)


# --- Public Setters ---
func set_text(new_text: String) -> void:
	if text != new_text:
		text = new_text
		queue_redraw()


func set_font_size(new_size: int) -> void:
	if font_size != new_size:
		font_size = new_size
		queue_redraw()


func set_glow_size(value: float) -> void:
	glow_size = value
	queue_redraw()


func set_glow_alpha(value: float) -> void:
	glow_alpha = value
	queue_redraw()


# --- Private Methods ---
func _show_keyboard_press_feedback() -> void:
	is_pressed = true
	queue_redraw()
	await get_tree().create_timer(0.1).timeout
	if is_instance_valid(self):
		is_pressed = false
		queue_redraw()


func _animate_selection(p_is_selected: bool) -> void:
	if _active_tween and _active_tween.is_valid():
		_active_tween.kill()

	_active_tween = create_tween().set_parallel(true)
	var target_glow_size = 28.0 if p_is_selected else 0.0
	var target_glow_alpha = 0.2 if p_is_selected else 0.0
	var duration = 0.3 if p_is_selected else 0.2

	(
		_active_tween
		. tween_property(self, "glow_size", target_glow_size, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)
	(
		_active_tween
		. tween_property(self, "glow_alpha", target_glow_alpha, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)


# --- Signal Handlers ---
func _on_mouse_entered() -> void:
	is_hovered = true
	grab_focus()
	if not Engine.is_editor_hint():
		CursorManager.set_pointer_state(true)


func _on_mouse_exited() -> void:
	is_hovered = false
	if is_pressed:
		is_pressed = false
		queue_redraw()
	if not Engine.is_editor_hint():
		CursorManager.set_pointer_state(false)


func _on_focus_entered() -> void:
	is_selected = true
	_animate_selection(true)
	queue_redraw()


func _on_focus_exited() -> void:
	is_selected = false
	_animate_selection(false)
	queue_redraw()

=====================================
FILE: ./src/ui/components/sound_setting_row/sound_setting_row.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cgt6j1h2w3k4l"]

[ext_resource type="Script" uid="uid://ch4xi7qr5btc" path="res://src/ui/components/sound_setting_row/sound_setting_row.gd" id="1_sound_row_script"]
[ext_resource type="PackedScene" uid="uid://bvyus5a6b7c8d" path="res://src/ui/components/custom_slider/custom_slider.tscn" id="2_custom_slider"]

[node name="SoundSettingRow" type="HBoxContainer"]
theme_override_constants/separation = 20
alignment = 1
script = ExtResource("1_sound_row_script")

[node name="NameLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(220, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 48
text = "SETTING"

[node name="ValueSlider" parent="." instance=ExtResource("2_custom_slider")]
unique_name_in_owner = true
layout_mode = 2

[node name="ValueLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(120, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 48
text = "100"
horizontal_alignment = 1

[node name="MuteCheckbox" type="TextureButton" parent="."]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 4


=====================================
FILE: ./src/ui/components/sound_setting_row/sound_setting_row.gd
=====================================
# src/ui/components/sound_setting_row/sound_setting_row.gd
@tool
## A self-contained UI component for a single audio setting row.
## Manages its own visuals and emits signals when its values are changed by the user.
class_name SoundSettingRow
extends HBoxContainer

# --- Signals ---
signal value_changed(value: float)
signal mute_toggled(is_muted: bool)

# --- Node References ---
@onready var name_label: Label = %NameLabel
@onready var value_slider: TextureRect = %ValueSlider
@onready var value_label: Label = %ValueLabel
@onready var mute_checkbox: TextureButton = %MuteCheckbox

# --- Public Properties ---
@export var setting_name: String = "SETTING":
	set(value):
		setting_name = value
		if is_instance_valid(name_label):
			name_label.text = setting_name

var is_muted: bool = false
var _last_percent_value: int = -1

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	if is_instance_valid(name_label):
		name_label.text = setting_name
	if not Engine.is_editor_hint():
		value_slider.value_changed.connect(_on_slider_value_changed)
		mute_checkbox.pressed.connect(_on_mute_button_pressed)

		mute_checkbox.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		mute_checkbox.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))
		mute_checkbox.mouse_entered.connect(func(): AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE))


# --- Public Methods ---
## Sets the visual state of the slider without emitting a signal.
func set_slider_value(value: float) -> void:
	if is_instance_valid(value_slider):
		value_slider.set_value(value)
	
	# Initialize tracking variable
	_last_percent_value = int(value * 100)
	
	if is_instance_valid(value_label):
		value_label.text = str(_last_percent_value)


## Sets the visual state of the checkbox without emitting a signal.
func set_mute_state(p_is_muted: bool) -> void:
	is_muted = p_is_muted
	var new_texture = (
		load(AssetPaths.SPRITE_CHECKBOX_UNCHECKED)
		if not is_muted
		else load(AssetPaths.SPRITE_CHECKBOX_CHECKED)
	)
	if is_instance_valid(mute_checkbox) and mute_checkbox.texture_normal != new_texture:
		mute_checkbox.texture_normal = new_texture


# --- Signal Handlers ---
func _on_slider_value_changed(value: float) -> void:
	var current_percent = int(value * 100)
	
	if is_instance_valid(value_label):
		value_label.text = str(current_percent)
	
	# AUDIO LOGIC (Before Emit)
	if not Engine.is_editor_hint():
		# If initialized and value actually changed
		if _last_percent_value != -1 and current_percent != _last_percent_value:
			# Only play sound on intervals of 5 (0, 5, 10, 15...)
			if current_percent % 5 == 0:
				AudioManager.play_sfx(AssetPaths.SFX_UI_SLIDER_TICK)
		
		# Update local tracker immediately
		_last_percent_value = current_percent

	# EMIT SIGNAL (After Audio)
	value_changed.emit(value)


func _on_mute_button_pressed() -> void:
	is_muted = not is_muted
	set_mute_state(is_muted)
	mute_toggled.emit(is_muted)


=====================================
FILE: ./src/ui/components/save_slot_button/save_slot_button.gd
=====================================
# src/ui/components/save_slot_button/save_slot_button.gd
@tool
class_name SaveSlotButton
extends Control

# Emitted for generic UI feedback (Sound) - 0 arguments
signal pressed
# Emitted for logic - 1 argument
signal slot_chosen(slot_index)

@export var slot_index: int = 0

@onready var slot_label: Label = %SlotLabel
@onready var info_label: Label = %InfoLabel

var is_hovered: bool = false
var is_selected: bool = false
var _data_summary: Dictionary = {}

func _ready() -> void:
	focus_mode = FOCUS_ALL
	mouse_filter = MOUSE_FILTER_STOP
	
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	focus_entered.connect(_on_focus_entered)
	focus_exited.connect(_on_focus_exited)
	
	refresh()

func refresh() -> void:
	if not is_instance_valid(slot_label): return
	
	slot_label.text = "SLOT %d" % (slot_index + 1)
	
	if Engine.is_editor_hint():
		return
		
	_data_summary = SaveManager.get_slot_summary(slot_index)
	if _data_summary.get("empty"):
		info_label.text = "NEW GAME"
		info_label.modulate = Palette.COLOR_TEXT_DISABLED
	else:
		info_label.text = "WINS: %d  |  LOSSES: %d" % [_data_summary.wins, _data_summary.losses]
		info_label.modulate = Palette.COLOR_TEXT_PRIMARY
	
	queue_redraw()

func _gui_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_accept") and has_focus():
		get_viewport().set_input_as_handled()
		_trigger_press()
		return

	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.is_pressed():
		_trigger_press()

func _trigger_press() -> void:
	pressed.emit()
	slot_chosen.emit(slot_index)

func _draw() -> void:
	var bg_color = Palette.COLOR_UI_PANEL_BG
	var border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	var border_width = 3.0

	if is_hovered or is_selected or has_focus():
		bg_color = Palette.COLOR_UI_ACCENT_PRIMARY
		border_color = Palette.get_color(4)
		info_label.modulate = Palette.COLOR_BACKGROUND
		slot_label.modulate = Palette.COLOR_BACKGROUND
		
		var glow_rect = Rect2(Vector2.ZERO, size).grow(10)
		draw_rect(glow_rect, Color(Palette.COLOR_UI_GLOW.r, Palette.COLOR_UI_GLOW.g, Palette.COLOR_UI_GLOW.b, 0.2))
	else:
		slot_label.modulate = Palette.COLOR_TEXT_PRIMARY
		if _data_summary.get("empty", true):
			info_label.modulate = Palette.COLOR_TEXT_DISABLED
		else:
			info_label.modulate = Palette.COLOR_TEXT_PRIMARY

	draw_rect(Rect2(Vector2.ZERO, size), bg_color)
	draw_rect(Rect2(Vector2.ZERO, size), border_color, false, border_width)

func _on_mouse_entered() -> void:
	is_hovered = true
	grab_focus()
	CursorManager.set_pointer_state(true)
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)
	queue_redraw()

func _on_mouse_exited() -> void:
	is_hovered = false
	CursorManager.set_pointer_state(false)
	queue_redraw()

func _on_focus_entered() -> void:
	queue_redraw()

func _on_focus_exited() -> void:
	queue_redraw()


=====================================
FILE: ./src/ui/components/save_slot_button/save_slot_button.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://save_slot_button_scene"]

[ext_resource type="Script" path="res://src/ui/components/save_slot_button/save_slot_button.gd" id="1_script"]
[ext_resource type="FontFile" uid="uid://hypwi2d6bj7t" path="res://assets/fonts/font_main_bold.ttf" id="2_font"]

[node name="SaveSlotButton" type="Control"]
custom_minimum_size = Vector2(600, 100)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_script")

[node name="SlotLabel" type="Label" parent="."]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 4
anchor_top = 0.5
anchor_bottom = 0.5
offset_left = 30.0
offset_top = -25.0
offset_right = 200.0
offset_bottom = 25.0
grow_vertical = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 32
text = "SLOT 1"

[node name="InfoLabel" type="Label" parent="."]
unique_name_in_owner = true
layout_mode = 1
anchors_preset = 6
anchor_left = 1.0
anchor_top = 0.5
anchor_right = 1.0
anchor_bottom = 0.5
offset_left = -300.0
offset_top = -20.0
offset_right = -30.0
offset_bottom = 20.0
grow_horizontal = 0
grow_vertical = 2
theme_override_font_sizes/font_size = 24
text = "EMPTY"
horizontal_alignment = 2


=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://bvyus5a6b7c8d"]

[ext_resource type="Script" uid="uid://8lrojyn5k5fq" path="res://src/ui/components/custom_slider/custom_slider.gd" id="1_custom_slider_script"]
[ext_resource type="Texture2D" uid="uid://dhh5eeyqf7l6f" path="res://assets/sprites/ui/slider/slider-track.png" id="1_puy0r"]

[node name="CustomSlider" type="TextureRect"]
custom_minimum_size = Vector2(400, 30)
offset_right = 400.0
offset_bottom = 30.0
size_flags_vertical = 4
texture = ExtResource("1_puy0r")
script = ExtResource("1_custom_slider_script")


=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.gd
=====================================
# src/ui/components/custom_slider/custom_slider.gd
@tool
## A self-contained, reusable custom slider component.
extends TextureRect

# --- Signals ---
## Emitted when the slider's value changes.
signal value_changed(value: float)

# --- Member Variables ---
var knob: TextureRect
var is_dragging: bool = false
var min_x_pos: float = 0.0
var max_x_pos: float = 0.0
var drag_offset: float = 0.0
var _initial_value: float = -1.0  # Used to set value before node is ready

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	self.texture = load(AssetPaths.SPRITE_SLIDER_TRACK)

	knob = TextureRect.new()
	knob.texture = load(AssetPaths.SPRITE_SLIDER_KNOB)
	add_child(knob)

	knob.mouse_entered.connect(_on_knob_mouse_entered)
	knob.mouse_exited.connect(_on_knob_mouse_exited)

	# Wait for the next frame to ensure parent containers have arranged children.
	await get_tree().process_frame

	knob.position.y = (size.y - knob.size.y) / 2.0
	min_x_pos = global_position.x
	max_x_pos = global_position.x + size.x - knob.size.x

	if _initial_value >= 0.0:
		var new_x_pos = min_x_pos + (max_x_pos - min_x_pos) * _initial_value
		knob.global_position.x = clamp(new_x_pos, min_x_pos, max_x_pos)


func _process(_delta: float) -> void:
	if is_dragging:
		var global_mouse_pos = get_global_mouse_position()
		knob.global_position.x = clamp(global_mouse_pos.x - drag_offset, min_x_pos, max_x_pos)

		if (max_x_pos - min_x_pos) > 0:
			var current_value = (knob.global_position.x - min_x_pos) / (max_x_pos - min_x_pos)
			emit_signal("value_changed", current_value)


func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		var knob_rect = knob.get_global_rect()

		if event.is_pressed():
			if knob_rect.has_point(event.global_position):
				is_dragging = true
				drag_offset = event.global_position.x - knob.global_position.x
		else:
			is_dragging = false
			if not knob_rect.has_point(get_global_mouse_position()):
				CursorManager.set_pointer_state(false)
			drag_offset = 0.0


# --- Public Methods ---


## Sets the initial value of the slider.
func set_value(initial_value: float) -> void:
	_initial_value = initial_value


# --- Signal Handlers ---


func _on_knob_mouse_entered() -> void:
	CursorManager.set_pointer_state(true)


func _on_knob_mouse_exited() -> void:
	if not is_dragging:
		CursorManager.set_pointer_state(false)


=====================================
FILE: ./src/ui/components/logo_display/logo_display.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1c2d3e4f5g6h"]

[ext_resource type="Script" path="res://src/ui/components/logo_display/logo_display.gd" id="1_logo_script"]

[node name="LogoDisplay" type="Control"]
custom_minimum_size = Vector2(200, 200)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_logo_script")

[node name="TextureRect" type="TextureRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
expand_mode = 1
stretch_mode = 5

=====================================
FILE: ./src/ui/components/logo_display/logo_display.gd
=====================================
# src/ui/components/logo_display/logo_display.gd
@tool
## A reusable UI component for displaying an interactive logo.
##
## Provides visual feedback on hover and emits a signal when pressed.
class_name LogoDisplay
extends Control

# --- Signals ---
## Emitted when the logo is clicked, passing its [member logo_name].
signal pressed(logo_name: String)

# --- Node References ---
@onready var texture_rect: TextureRect = $TextureRect

# --- Editor Properties ---
@export var texture: Texture2D:
	set(value):
		texture = value
		if is_instance_valid(texture_rect):
			texture_rect.texture = texture

@export var logo_name: String = "Logo"
@export var glow_size: float = 0.0:
	set = set_glow_size
@export var glow_alpha: float = 0.0:
	set = set_glow_alpha

# --- Member Variables ---
var is_hovered: bool = false
var is_pressed: bool = false

# --- Private Member Variables ---
var _active_tween: Tween

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	mouse_filter = MOUSE_FILTER_STOP

	if is_instance_valid(texture_rect) and texture:
		texture_rect.texture = texture

	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)


func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.is_pressed():
			is_pressed = true
			queue_redraw()
		elif is_pressed:  # On release
			emit_signal("pressed", logo_name)
			is_pressed = false
			queue_redraw()


func _draw() -> void:
	if is_hovered and glow_size > 0.0 and glow_alpha > 0.0:
		var glow_base_color = Palette.COLOR_UI_GLOW
		var final_glow_color = Color(
			glow_base_color.r, glow_base_color.g, glow_base_color.b, glow_alpha
		)
		var glow_rect = Rect2(Vector2.ZERO, size).grow(glow_size)
		draw_rect(glow_rect, final_glow_color)


# --- Public Setters ---


func set_glow_size(value: float) -> void:
	glow_size = value
	queue_redraw()


func set_glow_alpha(value: float) -> void:
	glow_alpha = value
	queue_redraw()


# --- Private Methods ---


func _animate_hover(p_is_hovered: bool) -> void:
	if _active_tween and _active_tween.is_valid():
		_active_tween.kill()

	_active_tween = create_tween().set_parallel(true)
	var target_glow_size = 20.0 if p_is_hovered else 0.0
	var target_glow_alpha = 0.2 if p_is_hovered else 0.0
	var duration = 0.3 if p_is_hovered else 0.2

	(
		_active_tween
		. tween_property(self, "glow_size", target_glow_size, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)
	(
		_active_tween
		. tween_property(self, "glow_alpha", target_glow_alpha, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)


# --- Signal Handlers ---


func _on_mouse_entered() -> void:
	is_hovered = true
	_animate_hover(true)
	if not Engine.is_editor_hint():
		CursorManager.set_pointer_state(true)
		AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_mouse_exited() -> void:
	is_hovered = false
	if is_pressed:
		is_pressed = false
		queue_redraw()
	_animate_hover(false)
	if not Engine.is_editor_hint():
		CursorManager.set_pointer_state(false)


=====================================
FILE: ./src/ui/dev/debug_overlay.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://debug_overlay_scene_id"]

[ext_resource type="Script" path="res://src/ui/dev/debug_overlay.gd" id="1_debug_script"]
[ext_resource type="FontFile" path="res://addons/gut/fonts/AnonymousPro-Regular.ttf" id="2_font"]

[node name="DebugOverlay" type="CanvasLayer"]
layer = 100
script = ExtResource("1_debug_script")

[node name="MainMargin" type="MarginContainer" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="HBox" type="HBoxContainer" parent="MainMargin"]
layout_mode = 2
theme_override_constants/separation = 10

[node name="EntityPanel" type="PanelContainer" parent="MainMargin/HBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(450, 0)
layout_mode = 2
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="MainMargin/HBox/EntityPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="EntityInfoVBox" type="VBoxContainer" parent="MainMargin/HBox/EntityPanel/Margin"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="TargetLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Target: NONE"

[node name="PositionLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Position:"

[node name="VelocityLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Velocity:"

[node name="HealthLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Health:"

[node name="StateLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "State:"

[node name="FlagsLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Flags:"
autowrap_mode = 3

[node name="TimersLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Timers:"
autowrap_mode = 3

[node name="InputBufferLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Input:"
autowrap_mode = 3

[node name="StateHistoryLabel" type="Label" parent="MainMargin/HBox/EntityPanel/Margin/EntityInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "History:"
autowrap_mode = 3

[node name="GlobalPanel" type="PanelContainer" parent="MainMargin/HBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3

[node name="Margin" type="MarginContainer" parent="MainMargin/HBox/GlobalPanel"]
layout_mode = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="GlobalInfoVBox" type="VBoxContainer" parent="MainMargin/HBox/GlobalPanel/Margin"]
layout_mode = 2
theme_override_constants/separation = 8

[node name="FPSLabel" type="Label" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "FPS:"

[node name="FXLabel" type="Label" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "FX:"

[node name="HSeparator" type="HSeparator" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
layout_mode = 2

[node name="PoolsLabel" type="Label" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font")
theme_override_font_sizes/font_size = 20
text = "Object Pools:"

[node name="PoolsScroll" type="ScrollContainer" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 200)
layout_mode = 2
size_flags_vertical = 3

[node name="PoolsVBox" type="VBoxContainer" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/PoolsScroll"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3

[node name="HSeparator2" type="HSeparator" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
layout_mode = 2

[node name="ButtonsGrid" type="GridContainer" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox"]
layout_mode = 2
columns = 2

[node name="ToggleCollisionButton" type="Button" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/ButtonsGrid"]
unique_name_in_owner = true
layout_mode = 2
focus_mode = 0
toggle_mode = true
text = "Shapes (O)"

[node name="ToggleInvincibilityButton" type="Button" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/ButtonsGrid"]
unique_name_in_owner = true
layout_mode = 2
focus_mode = 0
toggle_mode = true
text = "Player God (L)"

[node name="PauseButton" type="Button" parent="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/ButtonsGrid"]
unique_name_in_owner = true
layout_mode = 2
focus_mode = 0
toggle_mode = true
text = "Pause (P)"

[connection signal="toggled" from="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/ButtonsGrid/ToggleCollisionButton" to="." method="_on_toggle_collision_toggled"]
[connection signal="toggled" from="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/ButtonsGrid/ToggleInvincibilityButton" to="." method="_on_toggle_invincibility_toggled"]
[connection signal="toggled" from="MainMargin/HBox/GlobalPanel/Margin/GlobalInfoVBox/ButtonsGrid/PauseButton" to="." method="_on_pause_toggled"]

=====================================
FILE: ./src/ui/dev/debug_overlay.gd
=====================================
# src/ui/dev/debug_overlay.gd
## A toggleable overlay for displaying real-time developer debug information.
extends CanvasLayer

# --- Node References ---
@onready var entity_panel: PanelContainer = %EntityPanel
@onready var global_panel: PanelContainer = %GlobalPanel
@onready var target_label: Label = %TargetLabel
@onready var position_label: Label = %PositionLabel
@onready var velocity_label: Label = %VelocityLabel
@onready var health_label: Label = %HealthLabel
@onready var state_label: Label = %StateLabel
@onready var flags_label: Label = %FlagsLabel
@onready var timers_label: Label = %TimersLabel
@onready var input_buffer_label: Label = %InputBufferLabel
@onready var state_history_label: Label = %StateHistoryLabel
@onready var fps_label: Label = %FPSLabel
@onready var fx_label: Label = %FXLabel
@onready var pools_vbox: VBoxContainer = %PoolsVBox
@onready var toggle_collision_button: Button = %ToggleCollisionButton
@onready var pause_button: Button = %PauseButton
@onready var toggle_invincibility_button: Button = %ToggleInvincibilityButton

# --- Private Member Variables ---
var _target_entity: Node = null
var _services: ServiceLocator
var _pool_labels: Dictionary = {}
var _invincibility_debug_token: int = 0
var _stats_label: Label = null

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# This node must always process so it can handle unpausing the game.
	process_mode = Node.PROCESS_MODE_ALWAYS
	
	var panel_style = StyleBoxFlat.new()
	panel_style.bg_color = Color(0.1, 0.1, 0.1, 0.8)
	panel_style.border_width_left = 1
	panel_style.border_width_top = 1
	panel_style.border_width_right = 1
	panel_style.border_width_bottom = 1
	panel_style.border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	entity_panel.add_theme_stylebox_override("panel", panel_style)
	global_panel.add_theme_stylebox_override("panel", panel_style)

	# Dynamically add a Stats label to the global panel
	var global_vbox = global_panel.get_node("Margin/GlobalInfoVBox")
	_stats_label = Label.new()
	_stats_label.add_theme_font_override("font", load("res://addons/gut/fonts/AnonymousPro-Regular.ttf"))
	_stats_label.add_theme_font_size_override("font_size", 20)
	# Insert it after FPS label
	global_vbox.add_child(_stats_label)
	global_vbox.move_child(_stats_label, 1)


func _process(_delta: float) -> void:
	_update_global_info()
	_update_entity_info()


func _input(event: InputEvent) -> void:
	if event.is_action_pressed(Identifiers.Actions.DEBUG_COLLISION):
		toggle_collision_button.button_pressed = not toggle_collision_button.button_pressed
	
	if event.is_action_pressed(Identifiers.Actions.DEBUG_INVINCIBILITY):
		toggle_invincibility_button.button_pressed = not toggle_invincibility_button.button_pressed

	if event.is_action_pressed(Identifiers.Actions.PAUSE):
		pause_button.button_pressed = not pause_button.button_pressed


# --- Public Methods ---
func set_target(entity: Node) -> void:
	_target_entity = entity


func inject_dependencies(p_services: ServiceLocator) -> void:
	_services = p_services


# --- Private Update Methods ---
func _update_global_info() -> void:
	fps_label.text = "FPS: %d" % Engine.get_frames_per_second()

	if is_instance_valid(_services):
		var fx_stats = _services.fx_manager.get_debug_stats()
		fx_label.text = "FX: Shaders[%d] VFX[%d]" % [fx_stats.active_shaders, fx_stats.active_vfx]

		# Update persistent stats
		if _services.save_manager and _services.save_manager.current_save:
			var save = _services.save_manager.current_save
			if is_instance_valid(_stats_label):
				_stats_label.text = "Stats: Wins[%d] Losses[%d]" % [save.total_wins, save.total_losses]

		var pool_stats: Dictionary = _services.object_pool.get_pool_stats()
		for pool_name in pool_stats:
			if not _pool_labels.has(pool_name):
				var new_label = Label.new()
				new_label.add_theme_font_override("font", load("res://addons/gut/fonts/AnonymousPro-Regular.ttf"))
				new_label.add_theme_font_size_override("font_size", 20)
				pools_vbox.add_child(new_label)
				_pool_labels[pool_name] = new_label
			
			var stats = pool_stats[pool_name]
			_pool_labels[pool_name].text = "- %s [%d/%d]" % [pool_name, stats.active, stats.total]


func _update_entity_info() -> void:
	if not is_instance_valid(_target_entity) or not _target_entity.has_method("get_component"):
		target_label.text = "Target: NONE"
		position_label.text = "Position:"
		velocity_label.text = "Velocity:"
		health_label.text = "Health:"
		state_label.text = "State:"
		flags_label.text = "Flags:"
		timers_label.text = "Timers:"
		input_buffer_label.text = "Input:"
		state_history_label.text = "History:"
		return

	target_label.text = "Target: %s (%s)" % [_target_entity.name, _target_entity.get_class()]
	position_label.text = "Position: %s" % _target_entity.global_position.round()
	velocity_label.text = "Velocity: %s" % _target_entity.velocity.round()

	var state_machine: BaseStateMachine = _target_entity.get_component(BaseStateMachine)
	var current_state_name = "N/A"
	if is_instance_valid(state_machine) and is_instance_valid(state_machine.current_state):
		current_state_name = state_machine.current_state.get_script().resource_path.get_file().trim_suffix(".gd")
	state_label.text = "State: %s" % current_state_name
	
	var health_comp: HealthComponent = _target_entity.get_component(HealthComponent)
	if is_instance_valid(health_comp):
		health_label.text = "Health: %d / %d" % [health_comp.entity_data.health, health_comp.entity_data.max_health]
		var is_invincible_str = str(health_comp.is_invincible())
		flags_label.text = "Flags: OnFloor(%s) Invincible(%s)" % [str(_target_entity.is_on_floor()), is_invincible_str]
	
	if is_instance_valid(state_machine):
		state_history_label.text = "History: %s" % ", ".join(state_machine.state_history)

	if _target_entity.is_in_group(Identifiers.Groups.PLAYER):
		_update_player_specific_info()
	else:
		timers_label.text = "Timers:"
		input_buffer_label.text = "Input:"


func _update_player_specific_info() -> void:
	var p_data = _target_entity.entity_data
	var timers_text = "Timers: DashCD[%.2f] AtkCD[%.2f]" % [p_data.physics.dash_cooldown_timer, p_data.combat.attack_cooldown_timer]
	timers_label.text = timers_text
	
	var input_comp: InputComponent = _target_entity.get_component(InputComponent)
	if is_instance_valid(input_comp):
		# REFACTOR: Read properties from InputFrame instead of iterating dictionary keys
		var frame: InputFrame = input_comp.input
		var parts: Array[String] = []
		if frame.move_axis != 0.0: parts.append("Move:%.1f" % frame.move_axis)
		if frame.jump_just_pressed: parts.append("Jump(JP)")
		if frame.jump_pressed: parts.append("Jump(H)")
		if frame.attack_just_pressed: parts.append("Atk(JP)")
		if frame.dash_pressed: parts.append("Dash(JP)")
		
		input_buffer_label.text = "Input: %s" % ", ".join(parts)


# --- Signal Handlers ---
func _on_toggle_collision_toggled(button_pressed: bool) -> void:
	get_tree().debug_collisions_hint = button_pressed


func _on_toggle_invincibility_toggled(button_pressed: bool) -> void:
	if not is_instance_valid(_services) or not is_instance_valid(_services.targeting_system):
		return
		
	var player = _services.targeting_system.get_first(Identifiers.Groups.PLAYER)
	if not is_instance_valid(player):
		return

	var health_comp: HealthComponent = player.get_component(HealthComponent)
	if not is_instance_valid(health_comp):
		return

	if button_pressed:
		if _invincibility_debug_token == 0:
			_invincibility_debug_token = health_comp.grant_invincibility(self)
	else:
		if _invincibility_debug_token != 0:
			health_comp.release_invincibility(_invincibility_debug_token)
			_invincibility_debug_token = 0


func _on_pause_toggled(button_pressed: bool) -> void:
	get_tree().paused = button_pressed


=====================================
FILE: ./src/ui/themes/main_theme.tres
=====================================
[gd_resource type="Theme" load_steps=3 format=3 uid="uid://b7yeo6jg078gl"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_k2v2l"]
bg_color = Color(1, 1, 1, 1)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.258824, 0.258824, 0.258824, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_86yr2"]
bg_color = Color(0, 0, 0, 1)
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.909804, 0.909804, 0.909804, 1)

[resource]
Panel/PhaseIndicatorEmpty = SubResource("StyleBoxFlat_86yr2")
Panel/PhaseIndicatorFilled = SubResource("StyleBoxFlat_k2v2l")

=====================================
FILE: ./src/scenes/loading/loading_screen.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://loading_screen_scene_id"]

[ext_resource type="Script" path="res://src/scenes/loading/loading_screen.gd" id="1_loading_script"]

[node name="LoadingScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_loading_script")

[node name="ColorRect" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="Label" type="Label" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -75.0
offset_top = -16.5
offset_right = 75.0
offset_bottom = 16.5
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 30
text = "Loading..."
horizontal_alignment = 1
vertical_alignment = 1

[node name="ShaderPrewarmViewport" type="SubViewportContainer" parent="."]
custom_minimum_size = Vector2(1, 1)
layout_mode = 0
offset_left = -10.0
offset_top = -10.0
offset_right = -9.0
offset_bottom = -9.0
stretch = true

[node name="SubViewport" type="SubViewport" parent="ShaderPrewarmViewport"]
handle_input_locally = false
size = Vector2i(1, 1)
render_target_update_mode = 4

=====================================
FILE: ./src/scenes/loading/loading_screen.gd
=====================================
# src/scenes/loading/loading_screen.gd
## Handles asynchronous level building and shader pre-warming.
##
## This scene acts as an intermediary to prevent stuttering. It first builds
## the level in batches, then pre-instantiates key entities in an off-screen
## viewport to force shader compilation before transitioning to the game scene.
extends Control

# --- Constants ---
const SHADER_PREWARM_SCENES = [
	AssetPaths.SCENE_PLAYER,
	AssetPaths.SCENE_BASE_BOSS,
	AssetPaths.SCENE_PLAYER_SHOT,
	AssetPaths.SCENE_BOSS_SHOT,
	AssetPaths.SCENE_MINION_SHOT,
	AssetPaths.SCENE_HOMING_BOSS_SHOT,
]

# --- Node References ---
@onready var prewarm_viewport: SubViewport = $ShaderPrewarmViewport/SubViewport

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	if GameManager.state.current_encounter_path.is_empty():
		print("ERROR: No encounter script specified in GameManager. Returning to title.")
		SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)
		return

	_load_level()


# --- Private Methods ---


## The main loading and pre-warming sequence.
func _load_level() -> void:
	await get_tree().process_frame

	await _prewarm_shaders()

	var effects_to_prewarm: Array[ShaderEffect] = [
		load("res://src/data/effects/entity_hit_flash_effect.tres"),
		load("res://src/core/data/effects/dissolve_effect.tres"),
	]
	await FXManager.prewarm_shaders_async(effects_to_prewarm, prewarm_viewport)

	GameManager.state.prebuilt_level = await ArenaBuilder.build_level_async()

	await get_tree().process_frame

	SceneManager.go_to_scene(AssetPaths.SCENE_ENCOUNTER)


## Instantiates scenes off-screen to compile their shaders.
func _prewarm_shaders() -> void:
	print("Starting shader pre-warming...")
	for scene_path in SHADER_PREWARM_SCENES:
		if not FileAccess.file_exists(scene_path):
			continue
		var instance = load(scene_path).instantiate()

		if instance.has_method("inject_dependencies"):
			# Pass the ServiceLocator singleton directly.
			instance.inject_dependencies(ServiceLocator)

		prewarm_viewport.add_child(instance)

		# Use Group checks instead of static type checks to prevent parser cycles
		if instance.is_in_group(Identifiers.Groups.PLAYER):
			instance.velocity.x = 100
			var sm: BaseStateMachine = instance.get_component(BaseStateMachine)
			if is_instance_valid(sm) and sm.has_method("change_state"):
				sm.change_state(Identifiers.PlayerStates.ATTACK)
		elif instance.is_in_group(Identifiers.Groups.ENEMY):
			if "velocity" in instance:
				instance.velocity.x = 100

		await get_tree().process_frame
		instance.queue_free()
	print("Shader pre-warming complete.")


=====================================
FILE: ./src/scenes/game/viewport_cabinet.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://viewport_cabinet"]

[ext_resource type="Script" path="res://src/scenes/game/viewport_cabinet.gd" id="1_script"]

[node name="ViewportCabinet" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="BackgroundLayer" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.05, 0.05, 0.05, 1)

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="Border" type="ColorRect" parent="CenterContainer"]
custom_minimum_size = Vector2(2564, 1444)
layout_mode = 2
color = Color(0.3, 0.3, 0.3, 1)

[node name="SubViewportContainer" type="SubViewportContainer" parent="CenterContainer/Border"]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -1280.0
offset_top = -720.0
offset_right = 1280.0
offset_bottom = 720.0
grow_horizontal = 2
grow_vertical = 2

[node name="SubViewport" type="SubViewport" parent="CenterContainer/Border/SubViewportContainer"]
unique_name_in_owner = true
handle_input_locally = false
size = Vector2i(2560, 1440)
render_target_update_mode = 4

[node name="GameCamera" type="Camera2D" parent="CenterContainer/Border/SubViewportContainer/SubViewport"]
unique_name_in_owner = true
position = Vector2(1280, 720)


=====================================
FILE: ./src/scenes/game/encounter_scene.tscn
=====================================
[gd_scene load_steps=8 format=3 uid="uid://game_scene_unique_id"]

[ext_resource type="Script" path="res://src/scenes/game/encounter_scene.gd" id="1_game_script"]
[ext_resource type="Resource" uid="uid://boss_shockwave_effect" path="res://src/data/effects/boss_shockwave_effect.tres" id="2_shockwave"]
[ext_resource type="Script" path="res://src/scenes/game/post_process_manager.gd" id="3_post_process"]
[ext_resource type="Resource" uid="uid://heavy_impact_chromatic" path="res://src/data/effects/heavy_impact_chromatic.tres" id="4_chromatic_res"]

[sub_resource type="ShaderMaterial" id="ShaderMaterial_shock"]
resource_local_to_scene = true

[sub_resource type="ShaderMaterial" id="ShaderMaterial_chrom"]
resource_local_to_scene = true

[sub_resource type="ShaderMaterial" id="ShaderMaterial_vig"]
resource_local_to_scene = true

[node name="EncounterScene" type="Node"]
script = ExtResource("1_game_script")
_boss_death_shockwave = ExtResource("2_shockwave")

[node name="PostProcessLayer" type="CanvasLayer" parent="."]
layer = 100
script = ExtResource("3_post_process")
chromatic_resource = ExtResource("4_chromatic_res")

[node name="BackBufferCopy1" type="BackBufferCopy" parent="PostProcessLayer"]
copy_mode = 2

[node name="ShockwaveRect" type="ColorRect" parent="PostProcessLayer"]
unique_name_in_owner = true
material = SubResource("ShaderMaterial_shock")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 1, 1, 0)

[node name="BackBufferCopy2" type="BackBufferCopy" parent="PostProcessLayer"]
copy_mode = 2

[node name="ChromaticRect" type="ColorRect" parent="PostProcessLayer"]
unique_name_in_owner = true
material = SubResource("ShaderMaterial_chrom")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 1, 1, 0)

[node name="VignetteRect" type="ColorRect" parent="PostProcessLayer"]
unique_name_in_owner = true
material = SubResource("ShaderMaterial_vig")
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
color = Color(1, 1, 1, 0)


=====================================
FILE: ./src/scenes/game/encounter_scene.gd
=====================================
# src/scenes/game/encounter_scene.gd
## The main game scene controller.
class_name EncounterScene
extends ISceneController

# --- Editor Properties ---
@export var _boss_death_shockwave: ShaderEffect

# --- Constants ---
const ViewportCabinetScene = preload("res://src/scenes/game/viewport_cabinet.tscn")
const TestConversation = preload("res://src/data/dialogue/test_conversation.tres")

# --- Node References ---
@onready var post_process_manager = $PostProcessLayer

# --- Private Member Variables ---
var _cabinet: ViewportCabinet = null
var _level_container: Node = null
var _debug_overlay: CanvasLayer = null
var _boss_died_token: int = 0
var _spawn_boss_token: int = 0
var _sequence_handle: SequenceHandle
var _camera_shaker: CameraShaker = null

# --- Debug Inspector ---
var _inspectable_entities: Array[Node] = []
var _current_inspect_index: int = 0

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	_boss_died_token = EventBus.on(EventCatalog.BOSS_DIED, _on_boss_died)
	_spawn_boss_token = EventBus.on(EventCatalog.SPAWN_BOSS_REQUESTED, _on_spawn_boss_requested)

	# 1. Setup Cabinet
	_cabinet = ViewportCabinetScene.instantiate()
	add_child(_cabinet)
	move_child(_cabinet, 0)

	# 2. Load Level
	if is_instance_valid(GameManager.state.prebuilt_level):
		_level_container = GameManager.state.prebuilt_level
		GameManager.state.prebuilt_level = null
	else:
		_level_container = await ArenaBuilder.build_level_async()

	if not is_instance_valid(_level_container):
		push_error("EncounterScene: Failed to get a valid level container.")
		return
		
	# 3. Place Level in Cabinet Viewport
	_cabinet.add_level(_level_container)
	ObjectPool.register_world_container(_level_container)
	
	await get_tree().process_frame

	var build_data: LevelBuildData = _level_container.get_meta("build_data")
	if build_data:
		var cam = _cabinet.get_camera()
		CameraManager.center_camera_on_arena(cam, build_data.dimensions_tiles)
		
		if not build_data.encounter_data_resource.intro_sequence.is_empty():
			_sequence_handle = Sequencer.run_sequence(build_data.encounter_data_resource.intro_sequence)
			await _sequence_handle.finished

	_initialize_camera_shaker()
	_initialize_debug_inspector()

	var player_node: Node = ServiceLocator.targeting_system.get_first(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node):
		player_node.died.connect(_on_player_died)


func _unhandled_input(_event: InputEvent) -> void:
	if Input.is_action_just_pressed(Identifiers.Actions.DEBUG_OVERLAY):
		if is_instance_valid(_debug_overlay):
			_debug_overlay.visible = not _debug_overlay.visible

	if Input.is_action_just_pressed(Identifiers.Actions.DEBUG_DIALOGUE):
		if DialogueManager.is_conversation_active():
			DialogueManager.end_conversation()
		else:
			DialogueManager.start_conversation(TestConversation)

	if Input.is_action_just_pressed(Identifiers.Actions.DEBUG_CYCLE_TARGET):
		if is_instance_valid(_debug_overlay) and _debug_overlay.visible:
			_cycle_debug_target()


func _exit_tree() -> void:
	_cleanup_entities()
	EventBus.off(_boss_died_token)
	EventBus.off(_spawn_boss_token)
	FXManager.unregister_camera_shaker()
	if is_instance_valid(_sequence_handle):
		_sequence_handle.cancel()
	
	var cam = _cabinet.get_camera() if is_instance_valid(_cabinet) else null
	if is_instance_valid(cam):
		cam.offset = Vector2.ZERO
		
	get_tree().paused = false
	ObjectPool.register_world_container(null)


# --- Public Methods ---
func scene_exiting() -> void:
	_cleanup_entities()


# --- Private Methods ---
func _cleanup_entities() -> void:
	var player_node = ServiceLocator.targeting_system.get_first(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node) and player_node.has_method("teardown"):
		player_node.teardown()

	var enemy_nodes: Array = ServiceLocator.targeting_system.get_all(Identifiers.Groups.ENEMY)
	for enemy in enemy_nodes:
		if is_instance_valid(enemy) and enemy.has_method("teardown"):
			enemy.teardown()


func _initialize_camera_shaker() -> void:
	var shaker_scene: PackedScene = load("res://src/game/vfx/camera_shaker.tscn")
	if shaker_scene:
		_camera_shaker = shaker_scene.instantiate() as CameraShaker
		add_child(_camera_shaker)
		_camera_shaker.target_camera = _cabinet.get_camera()
		FXManager.register_camera_shaker(_camera_shaker)


func _initialize_debug_inspector() -> void:
	_debug_overlay = load(AssetPaths.SCENE_DEBUG_OVERLAY).instantiate()
	_debug_overlay.inject_dependencies(ServiceLocator)
	add_child(_debug_overlay)
	_debug_overlay.visible = false

	_inspectable_entities.append(ServiceLocator.targeting_system.get_first(Identifiers.Groups.PLAYER))
	_inspectable_entities.append_array(ServiceLocator.targeting_system.get_all(Identifiers.Groups.ENEMY))

	if not _inspectable_entities.is_empty():
		_debug_overlay.set_target(_inspectable_entities[0])


func _cycle_debug_target() -> void:
	_inspectable_entities.clear()
	_inspectable_entities.append(ServiceLocator.targeting_system.get_first(Identifiers.Groups.PLAYER))
	_inspectable_entities.append_array(ServiceLocator.targeting_system.get_all(Identifiers.Groups.ENEMY))
	_inspectable_entities = _inspectable_entities.filter(func(e): return is_instance_valid(e))

	if _inspectable_entities.is_empty():
		_debug_overlay.set_target(null)
		return

	_current_inspect_index = (_current_inspect_index + 1) % _inspectable_entities.size()
	var new_target: Node = _inspectable_entities[_current_inspect_index]
	_debug_overlay.set_target(new_target)


func _deactivate_all_minions() -> void:
	var minions = ServiceLocator.targeting_system.get_all(Identifiers.Groups.ENEMY)
	for minion in minions:
		if minion.has_method("deactivate"):
			minion.deactivate()


# --- Signal Handlers ---

func _on_spawn_boss_requested(_payload) -> void:
	ArenaBuilder.spawn_boss_async()


func _on_player_died() -> void:
	SaveManager.record_loss()
	Engine.time_scale = 0.2
	await get_tree().create_timer(0.5, true, false, true).timeout
	SceneManager.go_to_game_over()


func _on_boss_died(payload: BossDiedEvent) -> void:
	var player_node = ServiceLocator.targeting_system.get_first(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node):
		player_node.set_physics_process(false)
	
	var boss_node: Node = payload.boss_node
	var rect = post_process_manager.get_shockwave_rect()

	if is_instance_valid(_boss_death_shockwave) and is_instance_valid(boss_node) and is_instance_valid(rect):
		# Correctly calculate position using Cabinet helper
		var screen_pos = _cabinet.world_to_screen_pos(boss_node.global_position)
		var viewport_size = get_viewport().get_visible_rect().size # Main Window Size (2560x1440)
		var uv_center = screen_pos / viewport_size
		
		FXManager.apply_shader_effect(
			rect, 
			_boss_death_shockwave, 
			{"center": uv_center},
			{}
		)

	Engine.time_scale = 0.15
	
	_deactivate_all_minions()

	await get_tree().create_timer(1.0, true, false, true).timeout 
	
	if is_instance_valid(boss_node):
		boss_node.queue_free()

	Engine.time_scale = 1.0
	SaveManager.record_win()
	SceneManager.go_to_victory()


=====================================
FILE: ./src/scenes/game/viewport_cabinet.gd
=====================================
# src/scenes/game/viewport_cabinet.gd
class_name ViewportCabinet
extends Control

@onready var sub_viewport: SubViewport = %SubViewport
@onready var game_camera: Camera2D = %GameCamera
@onready var sub_viewport_container: SubViewportContainer = $CenterContainer/Border/SubViewportContainer

func add_level(level_node: Node) -> void:
	sub_viewport.add_child(level_node)

func get_camera() -> Camera2D:
	return game_camera

## Converts a position in the game world to global screen coordinates (Root Viewport).
func world_to_screen_pos(world_pos: Vector2) -> Vector2:
	# 1. Get position relative to the Game Camera (Viewport Center)
	var camera_pos = game_camera.global_position
	var viewport_size = Vector2(sub_viewport.size)
	var pos_in_viewport = (world_pos - camera_pos) + (viewport_size / 2.0)
	
	# 2. Get where the Viewport Container is on the main screen
	# (SubViewportContainer's global position is its top-left corner in the root window)
	var container_screen_pos = sub_viewport_container.global_position
	
	return container_screen_pos + pos_in_viewport


=====================================
FILE: ./src/scenes/game/post_process_manager.gd
=====================================
# src/scenes/game/post_process_manager.gd
## Manages the stack of fullscreen shaders (Shockwave, Chromatic, Vignette).
extends Node

# --- Node References ---
@onready var shockwave_rect: ColorRect = %ShockwaveRect
@onready var chromatic_rect: ColorRect = %ChromaticRect
@onready var vignette_rect: ColorRect = %VignetteRect

# --- State ---
var _is_low_health: bool = false
var _player_health_token: int = 0
var _boss_phase_token: int = 0

# --- Lifecycle ---

func _ready() -> void:
	# Load Materials
	shockwave_rect.material = load("res://src/content/materials/shockwave_material.tres").duplicate()
	chromatic_rect.material = load("res://src/content/materials/chromatic_material.tres").duplicate()
	
	if FileAccess.file_exists("res://src/content/materials/vignette_material.tres"):
		vignette_rect.material = load("res://src/content/materials/vignette_material.tres").duplicate()
	else:
		var mat = ShaderMaterial.new()
		mat.shader = load("res://src/content/shaders/fullscreen/vignette.gdshader")
		vignette_rect.material = mat

	# Reset
	vignette_rect.visible = false
	chromatic_rect.material.set_shader_parameter("fx_progress", 0.0)
	shockwave_rect.material.set_shader_parameter("fx_progress", 0.0)
	
	_player_health_token = EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, _on_player_health_changed)
	_boss_phase_token = EventBus.on(EventCatalog.BOSS_PHASE_CHANGED, _on_boss_phase_changed)
	
	# Initial check
	await get_tree().process_frame
	_check_low_health_status()

func _exit_tree() -> void:
	EventBus.off(_player_health_token)
	EventBus.off(_boss_phase_token)

# --- Event Handlers ---

func _on_player_health_changed(payload: PlayerHealthChangedEvent) -> void:
	var is_crit = payload.current_health <= 1
	
	if is_crit != _is_low_health:
		_is_low_health = is_crit
		_update_vignette_state()
	
	# FIX: Removed chromatic aberration trigger from here.
	# It will now only happen on Boss Phase Change.

func _on_boss_phase_changed(_payload: BossPhaseChangedEvent) -> void:
	# Trigger heavy glitch on phase change
	_trigger_chromatic_pulse(0.6) 

func _check_low_health_status() -> void:
	if not ServiceLocator.targeting_system: return
	
	var player = ServiceLocator.targeting_system.get_first(Identifiers.Groups.PLAYER)
	if is_instance_valid(player) and player.entity_data:
		var hp = player.entity_data.health
		if hp <= 1:
			_is_low_health = true
			_update_vignette_state()

func _update_vignette_state() -> void:
	if _is_low_health:
		vignette_rect.visible = true
		var mat = vignette_rect.material as ShaderMaterial
		# FIX: Increased intensity to 1.0 (max) for stronger effect
		mat.set_shader_parameter("intensity", 1.0)
	else:
		vignette_rect.visible = false

func _trigger_chromatic_pulse(duration: float = 0.3) -> void:
	var mat = chromatic_rect.material as ShaderMaterial
	var tween = create_tween()
	
	var attack_dur = min(0.05, duration * 0.2)
	var decay_dur = duration - attack_dur
	
	tween.tween_property(mat, "shader_parameter/fx_progress", 1.0, attack_dur).from(0.0).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_QUINT)
	tween.tween_property(mat, "shader_parameter/fx_progress", 0.0, decay_dur).set_ease(Tween.EASE_IN_OUT).set_trans(Tween.TRANS_SINE)

# --- Public API for EncounterScene ---
func get_shockwave_rect() -> ColorRect:
	return shockwave_rect


=====================================
FILE: ./src/scenes/menus/options_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://cuiywha4vccw"]

[ext_resource type="Script" uid="uid://c7ggk7djqvf53" path="res://src/scenes/menus/options_screen.gd" id="1_options_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="OptionsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_options_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "OPTIONS"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="SoundButton" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ControlsButton" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="CreditsButton" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExpandSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
font_size = 64

[node name="BottomSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 40

[node name="MuteButton" parent="MenuRoot/ContentFrame/MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/title_screen.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://beattfyix2423"]

[ext_resource type="Script" uid="uid://d0pxln7nldjne" path="res://src/scenes/menus/title_screen.gd" id="1_title_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="PackedScene" uid="uid://b1c2d3e4f5g6h" path="res://src/ui/components/logo_display/logo_display.tscn" id="3_logo_display"]
[ext_resource type="Texture2D" uid="uid://t2u26wkw02xm" path="res://assets/sprites/ui/logos/newgrounds_logo.png" id="4_logo_ng"]
[ext_resource type="Texture2D" uid="uid://2gqa4m05wd20" path="res://assets/sprites/ui/logos/godot_logo.png" id="5_logo_godot"]
[ext_resource type="Texture2D" uid="uid://d0fuu548hoouq" path="res://assets/sprites/ui/logos/itch_logo.png" id="6_logo_itch"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="7_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="8_mute_button"]

[node name="TitleScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_title_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("7_font_black")
theme_override_font_sizes/font_size = 128
text = "BOX BATTLE"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 30)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="StartButton" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="OptionsButton" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExitButton" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExpandSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="FooterHBox" type="HBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 50
alignment = 1

[node name="NewgroundsLogo" parent="MenuRoot/ContentFrame/MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("4_logo_ng")
logo_name = "Newgrounds"

[node name="GodotLogo" parent="MenuRoot/ContentFrame/MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("5_logo_godot")
logo_name = "Godot"

[node name="ItchLogo" parent="MenuRoot/ContentFrame/MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("6_logo_itch")
logo_name = "Itch"

[node name="BottomSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 40

[node name="MuteButton" parent="MenuRoot/ContentFrame/MuteButtonContainer" instance=ExtResource("8_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/title_screen.gd
=====================================
# src/scenes/menus/title_screen.gd
## The controller for the main title screen scene.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Node References ---
@onready var background_color: ColorRect = $BackgroundColor
@onready var start_button: StyledMenuItem = %StartButton
@onready var options_button: StyledMenuItem = %OptionsButton
@onready var exit_button: StyledMenuItem = %ExitButton
@onready var newgrounds_logo: LogoDisplay = %NewgroundsLogo
@onready var godot_logo: LogoDisplay = %GodotLogo
@onready var itch_logo: LogoDisplay = %ItchLogo

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	background_color.color = Palette.COLOR_BACKGROUND

	start_button.text = "START GAME"
	options_button.text = "OPTIONS"
	exit_button.text = "EXIT"

	if not Engine.is_editor_hint():
		start_button.pressed.connect(_on_start_button_pressed)
		options_button.pressed.connect(_on_options_button_pressed)
		exit_button.pressed.connect(_on_exit_button_pressed)
		newgrounds_logo.pressed.connect(_on_logo_pressed)
		godot_logo.pressed.connect(_on_logo_pressed)
		itch_logo.pressed.connect(_on_logo_pressed)

		var focusable_items: Array[Control] = [start_button, options_button, exit_button]
		var all_items: Array[Control] = [
			start_button, options_button, exit_button, 
			newgrounds_logo, godot_logo, itch_logo
		]
		setup_menu_navigation(focusable_items, all_items)

		await get_tree().process_frame
		start_button.grab_focus()

func _input(event: InputEvent) -> void:
	if Engine.is_editor_hint(): return
	
	if event is InputEventKey and event.pressed and event.keycode == KEY_TAB:
		get_viewport().set_input_as_handled() 
		SaveManager.create_new_slot(0)
		SceneManager.start_game(AssetPaths.ENCOUNTER_00)

func _on_start_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_SAVE_SELECT_SCREEN)

func _on_options_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)

func _on_exit_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	await get_tree().create_timer(0.2).timeout
	get_tree().quit()

func _on_logo_pressed(logo_name: String) -> void:
	print("%s Pressed" % logo_name)


=====================================
FILE: ./src/scenes/menus/base_menu_screen.gd
=====================================
# src/scenes/menus/base_menu_screen.gd
## A base class for all menu screens to inherit from.
##
## It provides a standardized way to set up keyboard navigation via the
## MenuManager and handles common audio feedback for UI interactions.
class_name BaseMenuScreen
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Protected Methods (for child classes to use) ---

## Initializes the menu manager and connects common feedback signals.
## [param focusable_items]: An array of Controls that can be navigated with the keyboard.
## [param all_interactive_items]: An array of all Controls that should provide audio feedback.
func setup_menu_navigation(focusable_items: Array[Control], all_interactive_items: Array[Control]) -> void:
	if not Engine.is_editor_hint():
		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu(focusable_items)
		menu_manager.selection_changed.connect(_on_any_item_focused)

		for item in all_interactive_items:
			if item.has_signal("pressed"):
				item.pressed.connect(_on_any_item_pressed)
			
			if item.has_signal("mouse_entered"):
				item.mouse_entered.connect(_on_any_item_focused)

		var credits_label: RichTextLabel = find_child("CreditsLabel", true, false)
		if is_instance_valid(credits_label):
			credits_label.meta_hover_started.connect(func(_meta): CursorManager.set_pointer_state(true))
			credits_label.meta_hover_ended.connect(func(_meta): CursorManager.set_pointer_state(false))
			credits_label.meta_clicked.connect(func(_meta): _on_any_item_pressed())
			# Use a lambda to absorb the 'meta' argument before calling the sound handler.
			credits_label.meta_hover_started.connect(func(_meta): _on_any_item_focused())

# --- Private Signal Handlers ---

func _on_any_item_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)

func _on_any_item_focused() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


=====================================
FILE: ./src/scenes/menus/credits_screen.gd
=====================================
# src/scenes/menus/credits_screen.gd
## The controller for the credits screen.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Constants ---
const CREDITS_BBCODE = """
[center]A Game By Steven Casteel[/center]
[center][url=https://www.stevencasteel.com/]www.stevencasteel.com[/url][/center]

[center]Built with the [url=https://godotengine.org/]Godot Engine[/url][/center]
[center]AI-Assisted by [url=https://gemini.google.com/]Gemini[/url][/center]

[center]Find me on [url=https://www.youtube.com/@stevencasteel]YouTube[/url] and [url=http://github.com/stevencasteel]GitHub[/url][/center]
"""

# --- Node References ---
@onready var credits_label_container: Control = %CreditsLabelContainer
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	for c in credits_label_container.get_children():
		c.queue_free()

	var credits_label = RichTextLabel.new()
	credits_label.name = "CreditsLabel" # Name for the base class to find it
	credits_label.set_anchors_preset(Control.PRESET_FULL_RECT)
	credits_label.bbcode_enabled = true
	credits_label.mouse_filter = MOUSE_FILTER_PASS
	credits_label.add_theme_font_override("normal_font", load(AssetPaths.FONT_MAIN_REGULAR))
	credits_label.add_theme_font_size_override("normal_font_size", 38)
	credits_label.add_theme_color_override("default_color", Color.WHITE)
	credits_label.text = CREDITS_BBCODE
	credits_label_container.add_child(credits_label)

	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		# --- Connect Unique Action Signals ---
		back_button.pressed.connect(_on_back_button_pressed)
		credits_label.meta_clicked.connect(_on_meta_clicked)

		# --- Initialize Common Navigation & Feedback ---
		setup_menu_navigation([back_button], [back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Unique Signal Handlers ---
func _on_meta_clicked(meta) -> void:
	OS.shell_open(str(meta))

func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)

=====================================
FILE: ./src/scenes/menus/sound_screen.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://dsvv7o1v1j8t1"]

[ext_resource type="Script" uid="uid://451xh65eo2eo" path="res://src/scenes/menus/sound_screen.gd" id="1_sound_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]
[ext_resource type="PackedScene" uid="uid://cgt6j1h2w3k4l" path="res://src/ui/components/sound_setting_row/sound_setting_row.tscn" id="5_sound_row"]

[node name="SoundScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_sound_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "SOUND"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 90)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="MasterRow" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("5_sound_row")]
unique_name_in_owner = true
layout_mode = 2
setting_name = "MASTER"

[node name="MusicRow" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("5_sound_row")]
unique_name_in_owner = true
layout_mode = 2
setting_name = "MUSIC"

[node name="SfxRow" parent="MenuRoot/ContentFrame/MainVBox/MenuItemsVBox" instance=ExtResource("5_sound_row")]
unique_name_in_owner = true
layout_mode = 2
setting_name = "SFX"

[node name="ExpandSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 40

[node name="MuteButton" parent="MenuRoot/ContentFrame/MuteButtonContainer" instance=ExtResource("4_mute_button")]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/credits_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://c5v6x7y81aa0b"]

[ext_resource type="Script" uid="uid://b5n30r8nhclsb" path="res://src/scenes/menus/credits_screen.gd" id="1_credits_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="CreditsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_credits_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "CREDITS"
horizontal_alignment = 1

[node name="CreditsLabelContainer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 450)
layout_mode = 2

[node name="ExpandSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 40

[node name="MuteButton" parent="MenuRoot/ContentFrame/MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/save_select_screen.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://save_select_screen"]

[ext_resource type="Script" path="res://src/scenes/menus/save_select_screen.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_btn"]
[ext_resource type="PackedScene" uid="uid://save_slot_button_scene" path="res://src/ui/components/save_slot_button/save_slot_button.tscn" id="3_slot"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="4_font"]
[ext_resource type="FontFile" uid="uid://hypwi2d6bj7t" path="res://assets/fonts/font_main_bold.ttf" id="5_font_bold"]

[node name="SaveSelectScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 20
alignment = 1

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_fonts/font = ExtResource("4_font")
theme_override_font_sizes/font_size = 64
text = "SELECT DATA"
horizontal_alignment = 1

[node name="ModeLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.8, 0.8, 1)
theme_override_fonts/font = ExtResource("5_font_bold")
theme_override_font_sizes/font_size = 24
text = " "
horizontal_alignment = 1

[node name="Spacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 10)
layout_mode = 2

[node name="SlotsVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 20

[node name="Slot0" parent="MenuRoot/ContentFrame/MainVBox/SlotsVBox" instance=ExtResource("3_slot")]
layout_mode = 2
slot_index = 0

[node name="Slot1" parent="MenuRoot/ContentFrame/MainVBox/SlotsVBox" instance=ExtResource("3_slot")]
layout_mode = 2
slot_index = 1

[node name="Slot2" parent="MenuRoot/ContentFrame/MainVBox/SlotsVBox" instance=ExtResource("3_slot")]
layout_mode = 2
slot_index = 2

[node name="Spacer2" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 30)
layout_mode = 2

[node name="UtilityHBox" type="HBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="BtnCopy" parent="MenuRoot/ContentFrame/MainVBox/UtilityHBox" instance=ExtResource("2_btn")]
unique_name_in_owner = true
custom_minimum_size = Vector2(250, 60)
layout_mode = 2
text = "COPY"
font_size = 32

[node name="BtnErase" parent="MenuRoot/ContentFrame/MainVBox/UtilityHBox" instance=ExtResource("2_btn")]
unique_name_in_owner = true
custom_minimum_size = Vector2(250, 60)
layout_mode = 2
text = "ERASE"
font_size = 32

[node name="Spacer3" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
custom_minimum_size = Vector2(0, 20)

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_btn")]
unique_name_in_owner = true
custom_minimum_size = Vector2(600, 80)
layout_mode = 2
size_flags_horizontal = 4
text = "BACK"
font_size = 48


=====================================
FILE: ./src/scenes/menus/options_screen.gd
=====================================
# src/scenes/menus/options_screen.gd
## The controller for the main options menu scene.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Node References ---
@onready var sound_button: StyledMenuItem = %SoundButton
@onready var controls_button: StyledMenuItem = %ControlsButton
@onready var credits_button: StyledMenuItem = %CreditsButton
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	sound_button.text = "SOUND"
	controls_button.text = "CONTROLS"
	credits_button.text = "CREDITS"
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		# --- Connect Unique Action Signals ---
		sound_button.pressed.connect(_on_sound_button_pressed)
		controls_button.pressed.connect(_on_controls_button_pressed)
		credits_button.pressed.connect(_on_credits_button_pressed)
		back_button.pressed.connect(_on_back_button_pressed)

		# --- Initialize Common Navigation & Feedback ---
		var all_items: Array[Control] = [
			sound_button, controls_button, credits_button, back_button
		]
		setup_menu_navigation(all_items, all_items)

		await get_tree().process_frame
		sound_button.grab_focus()

# --- Unique Signal Handlers ---
func _on_sound_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_SOUND_SCREEN)

func _on_controls_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_CONTROLS_SCREEN)

func _on_credits_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_CREDITS_SCREEN)

func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/scenes/menus/save_select_screen.gd
=====================================
# src/scenes/menus/save_select_screen.gd
extends "res://src/scenes/menus/base_menu_screen.gd"

@onready var slots_vbox: VBoxContainer = %SlotsVBox
@onready var back_button: StyledMenuItem = %BackButton
@onready var btn_copy: StyledMenuItem = %BtnCopy
@onready var btn_erase: StyledMenuItem = %BtnErase
@onready var title_label: Label = %TitleLabel
@onready var mode_label: Label = %ModeLabel

# States
enum Mode { NORMAL, COPY_SELECT_SOURCE, COPY_SELECT_DEST, ERASE }
var _current_mode: Mode = Mode.NORMAL
var _copy_source_index: int = -1

func _ready() -> void:
	# Connect Slot Signals
	for child in slots_vbox.get_children():
		if child is SaveSlotButton:
			child.slot_chosen.connect(_on_slot_chosen)

	btn_copy.pressed.connect(_on_copy_mode_pressed)
	btn_erase.pressed.connect(_on_erase_mode_pressed)
	back_button.pressed.connect(_on_back_pressed)
	
	# Setup Nav
	var nav_items: Array[Control] = []
	for child in slots_vbox.get_children():
		nav_items.append(child)
	nav_items.append(btn_copy)
	nav_items.append(btn_erase)
	nav_items.append(back_button)
	
	setup_menu_navigation(nav_items, nav_items)
	
	_set_mode(Mode.NORMAL)
	
	# Focus first slot
	await get_tree().process_frame
	if slots_vbox.get_child_count() > 0:
		slots_vbox.get_child(0).grab_focus()

func _refresh_slots() -> void:
	for child in slots_vbox.get_children():
		if child is SaveSlotButton:
			child.refresh()

func _set_mode(mode: Mode) -> void:
	_current_mode = mode
	
	# FIX: Moved reset logic inside the match block.
	# We do NOT want to reset _copy_source_index when entering COPY_SELECT_DEST.
	
	match _current_mode:
		Mode.NORMAL:
			_copy_source_index = -1
			title_label.text = "SELECT DATA"
			title_label.add_theme_color_override("font_color", Color.WHITE)
			mode_label.text = " "
			btn_copy.text = "COPY"
			btn_erase.text = "ERASE"
		
		Mode.COPY_SELECT_SOURCE:
			_copy_source_index = -1
			title_label.text = "COPY DATA"
			title_label.add_theme_color_override("font_color", Color(0.4, 0.8, 1.0))
			mode_label.text = "Select SOURCE Slot"
			btn_copy.text = "CANCEL"
			btn_erase.text = "ERASE"

		Mode.COPY_SELECT_DEST:
			# Do not reset _copy_source_index here!
			mode_label.text = "Select DESTINATION Slot"
			
		Mode.ERASE:
			_copy_source_index = -1
			title_label.text = "ERASE DATA"
			title_label.add_theme_color_override("font_color", Color(1.0, 0.4, 0.4))
			mode_label.text = "Select Slot to DELETE"
			btn_copy.text = "COPY"
			btn_erase.text = "CANCEL"

func _on_slot_chosen(index: int) -> void:
	# Sound is played by SaveSlotButton 'pressed' signal for generic feedback,
	# but we play specific success/fail sounds here.
	
	match _current_mode:
		Mode.NORMAL:
			# Play
			var summary = SaveManager.get_slot_summary(index)
			if summary.get("empty", true):
				SaveManager.create_new_slot(index)
			else:
				SaveManager.load_slot(index)
			
			AudioManager.play_sfx(AssetPaths.SFX_GAME_START)
			SceneManager.start_game(AssetPaths.ENCOUNTER_00)

		Mode.COPY_SELECT_SOURCE:
			var summary = SaveManager.get_slot_summary(index)
			if summary.get("empty", true):
				# Cannot copy empty slot
				AudioManager.play_sfx(AssetPaths.SFX_UI_ERROR)
				return
			
			_copy_source_index = index
			_set_mode(Mode.COPY_SELECT_DEST) # Update UI text
			AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)

		Mode.COPY_SELECT_DEST:
			if index == _copy_source_index:
				AudioManager.play_sfx(AssetPaths.SFX_UI_ERROR)
				return
				
			var success = SaveManager.copy_slot(_copy_source_index, index)
			if success:
				AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
				_refresh_slots()
				_set_mode(Mode.NORMAL)
			else:
				AudioManager.play_sfx(AssetPaths.SFX_UI_ERROR)

		Mode.ERASE:
			SaveManager.erase_slot(index)
			AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
			_refresh_slots()
			_set_mode(Mode.NORMAL)

func _on_copy_mode_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
	if _current_mode == Mode.COPY_SELECT_SOURCE or _current_mode == Mode.COPY_SELECT_DEST:
		_set_mode(Mode.NORMAL) # Toggle Off
	else:
		_set_mode(Mode.COPY_SELECT_SOURCE)

func _on_erase_mode_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
	if _current_mode == Mode.ERASE:
		_set_mode(Mode.NORMAL) # Toggle Off
	else:
		_set_mode(Mode.ERASE)

func _on_back_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	if _current_mode != Mode.NORMAL:
		_set_mode(Mode.NORMAL)
	else:
		SceneManager.go_to_title_screen()


=====================================
FILE: ./src/scenes/menus/sound_screen.gd
=====================================
# src/scenes/menus/sound_screen.gd
## The controller for the sound options menu.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Node References ---
@onready var master_row: SoundSettingRow = %MasterRow
@onready var music_row: SoundSettingRow = %MusicRow
@onready var sfx_row: SoundSettingRow = %SfxRow
@onready var back_button: StyledMenuItem = %BackButton
# Update: Use Unique Name for stability
@onready var mute_button: MuteButton = %MuteButton

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		master_row.value_changed.connect(func(val): Settings.master_volume = val)
		master_row.mute_toggled.connect(func(val): Settings.master_muted = val)
		music_row.value_changed.connect(func(val): Settings.music_volume = val)
		music_row.mute_toggled.connect(func(val): Settings.music_muted = val)
		sfx_row.value_changed.connect(func(val): Settings.sfx_volume = val)
		sfx_row.mute_toggled.connect(func(val): Settings.sfx_muted = val)

		Settings.audio_settings_changed.connect(_update_ui_from_settings)
		_update_ui_from_settings() 

		back_button.pressed.connect(_on_back_button_pressed)

		var focusable_items: Array[Control] = [back_button]
		var all_items: Array[Control] = [back_button, mute_button] 
		setup_menu_navigation(focusable_items, all_items)

		await get_tree().process_frame
		back_button.grab_focus()


func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if Settings.audio_settings_changed.is_connected(_update_ui_from_settings):
			Settings.audio_settings_changed.disconnect(_update_ui_from_settings)

# --- Private Methods ---
func _update_ui_from_settings() -> void:
	if is_instance_valid(master_row):
		master_row.set_slider_value(Settings.master_volume)
		master_row.set_mute_state(Settings.master_muted)
	if is_instance_valid(music_row):
		music_row.set_slider_value(Settings.music_volume)
		music_row.set_mute_state(Settings.music_muted)
	if is_instance_valid(sfx_row):
		sfx_row.set_slider_value(Settings.sfx_volume)
		sfx_row.set_mute_state(Settings.sfx_muted)

# --- Signal Handlers ---
func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)


=====================================
FILE: ./src/scenes/menus/controls_screen.gd
=====================================
# src/scenes/menus/controls_screen.gd
## The controller for the controls configuration screen.
## Dynamically populates the list based on Settings.remappable_actions.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Constants ---
const ROW_SCENE = preload("res://src/ui/components/control_setting_row/control_setting_row.tscn")

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton
@onready var controls_vbox: VBoxContainer = %ControlsVBox
@onready var preset_button: Button = %PresetButton

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		_update_preset_display()
		_populate_controls_list()
		
		# --- Connect Unique Action Signals ---
		back_button.pressed.connect(_on_back_button_pressed)
		
		# Connect Preset Button Hover (Cursor Logic)
		preset_button.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		preset_button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))
		
		# Listen for settings changes to update UI
		Settings.input_settings_changed.connect(_on_settings_changed)

		setup_menu_navigation([back_button], [back_button, preset_button])

		await get_tree().process_frame
		back_button.grab_focus()

func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if Settings.input_settings_changed.is_connected(_on_settings_changed):
			Settings.input_settings_changed.disconnect(_on_settings_changed)
		
		# Disconnect signals to be safe (though not strictly necessary on exit)
		if is_instance_valid(preset_button):
			if preset_button.mouse_entered.is_connected(CursorManager.set_pointer_state):
				preset_button.mouse_entered.disconnect(CursorManager.set_pointer_state)
			if preset_button.mouse_exited.is_connected(CursorManager.set_pointer_state):
				preset_button.mouse_exited.disconnect(CursorManager.set_pointer_state)


# --- Private Methods ---

func _populate_controls_list() -> void:
	if not is_instance_valid(controls_vbox):
		return

	# Clear existing rows
	for child in controls_vbox.get_children():
		child.queue_free()
	
	# Generate rows from Settings
	for action in Settings.remappable_actions:
		var row = ROW_SCENE.instantiate()
		controls_vbox.add_child(row)
		
		var display_name = _get_friendly_name(action)
		row.setup(action, display_name)


func _get_friendly_name(action: String) -> String:
	var clean = action.replace("ui_", "").replace("debug_", "")
	return clean.capitalize()


func _update_preset_display() -> void:
	if is_instance_valid(preset_button):
		preset_button.text = Settings.current_input_preset


# --- Signal Handlers ---

func _on_settings_changed() -> void:
	_update_preset_display()
	# Re-populate to show new keys
	_populate_controls_list()


func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)


func _on_preset_button_pressed() -> void:
	var presets = Settings.get_available_presets()
	var current = Settings.current_input_preset
	var idx = presets.find(current)
	
	# Cycle to next preset
	var next_idx = (idx + 1) % presets.size()
	var next_preset = presets[next_idx]
	
	# Skip "Custom" in the cycle if we are manually cycling
	if next_preset == "Custom":
		next_idx = (next_idx + 1) % presets.size()
		next_preset = presets[next_idx]
		
	Settings.apply_preset(next_preset)
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)


=====================================
FILE: ./src/scenes/menus/controls_screen.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://df5wylg5n16f"]

[ext_resource type="Script" uid="uid://bm6noor4pxywc" path="res://src/scenes/menus/controls_screen.gd" id="1_controls_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]
[ext_resource type="FontFile" uid="uid://hypwi2d6bj7t" path="res://assets/fonts/font_main_bold.ttf" id="5_font_bold"]

[node name="ControlsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_controls_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 40)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 64
text = "CONTROLS"
horizontal_alignment = 1

[node name="Spacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 20)
layout_mode = 2

[node name="PresetContainer" type="HBoxContainer" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
alignment = 1
theme_override_constants/separation = 20

[node name="PresetLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox/PresetContainer"]
layout_mode = 2
theme_override_fonts/font = ExtResource("5_font_bold")
theme_override_font_sizes/font_size = 32
text = "Preset:"

[node name="PresetButton" type="Button" parent="MenuRoot/ContentFrame/MainVBox/PresetContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(300, 50)
layout_mode = 2
focus_mode = 0
theme_override_font_sizes/font_size = 28
text = "Default"

[node name="Spacer2" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 10)
layout_mode = 2

[node name="ScrollContainer" type="ScrollContainer" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_vertical = 3
horizontal_scroll_mode = 0

[node name="ControlsVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame/MainVBox/ScrollContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 10
alignment = 1

[node name="Spacer3" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
custom_minimum_size = Vector2(0, 20)

[node name="FixedControlsPanel" type="PanelContainer" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_styles/panel = null

[node name="FixedControlsVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame/MainVBox/FixedControlsPanel"]
layout_mode = 2
theme_override_constants/separation = 5

[node name="Label" type="Label" parent="MenuRoot/ContentFrame/MainVBox/FixedControlsPanel/FixedControlsVBox"]
layout_mode = 2
theme_override_fonts/font = ExtResource("5_font_bold")
theme_override_font_sizes/font_size = 24
text = "FIXED CONTROLS"
horizontal_alignment = 1

[node name="InfoLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox/FixedControlsPanel/FixedControlsVBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Heal: Down + Jump (Ground)  |  Charge: Hold Attack
Debug: Y  |  Pause: Enter / P / Esc"
horizontal_alignment = 1

[node name="Spacer4" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
custom_minimum_size = Vector2(0, 50)

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 80)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 48

[node name="BottomSpacer" type="Control" parent="MenuRoot/ContentFrame/MainVBox"]
custom_minimum_size = Vector2(0, 30)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 40

[node name="MuteButton" parent="MenuRoot/ContentFrame/MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0

[connection signal="pressed" from="MenuRoot/ContentFrame/MainVBox/PresetContainer/PresetButton" to="." method="_on_preset_button_pressed"]


=====================================
FILE: ./src/scenes/game_over/game_over_screen.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://dnlf14n0wfxm1"]

[ext_resource type="Script" uid="uid://dnkj277olbn3c" path="res://src/scenes/game_over/game_over_screen.gd" id="1_goscr"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]

[node name="GameOverScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_goscr")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.2, 0.2, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "GAME OVER"
horizontal_alignment = 1

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64


=====================================
FILE: ./src/scenes/game_over/game_over_screen.gd
=====================================
# src/scenes/game_over/game_over_screen.gd
## The controller for the "Game Over" screen.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	back_button.text = "BACK TO TITLE"

	if not Engine.is_editor_hint():
		# --- Connect Unique Action Signals ---
		back_button.pressed.connect(_on_back_button_pressed)

		# --- Initialize Common Navigation & Feedback ---
		setup_menu_navigation([back_button], [back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Unique Signal Handlers ---
func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/scenes/main/main.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bt1c5p8wphc4a"]

[ext_resource type="Script" uid="uid://cu5lshffdfr4h" path="res://src/scenes/main/main.gd" id="1_main_script"]

[node name="Main" type="Node"]
script = ExtResource("1_main_script")


=====================================
FILE: ./src/scenes/main/main.gd
=====================================
# src/scenes/main/main.gd
## The main entry point for the entire application.
extends Node


func _ready() -> void:
	if OS.is_debug_build():
		AssetPaths.validate_all_paths()

	# Call the static method directly on the global class name.
	BootManager.initialize_systems()

	AudioManager.play_music(AssetPaths.MUSIC_MENU_LOOP)

	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/scenes/victory/victory_screen.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://cx6i2wt2j05y4"]

[ext_resource type="Script" uid="uid://d030qowpraecr" path="res://src/scenes/victory/victory_screen.gd" id="1_vsscr"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]

[node name="VictoryScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_vsscr")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MenuRoot" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="ContentFrame" type="Control" parent="MenuRoot"]
custom_minimum_size = Vector2(1000, 1000)
layout_mode = 2

[node name="MainVBox" type="VBoxContainer" parent="MenuRoot/ContentFrame"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="MenuRoot/ContentFrame/MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.2, 0.8, 0.2, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "VICTORY"
horizontal_alignment = 1

[node name="BackButton" parent="MenuRoot/ContentFrame/MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64


=====================================
FILE: ./src/scenes/victory/victory_screen.gd
=====================================
# src/scenes/victory/victory_screen.gd
## The controller for the "Victory" screen.
@tool
extends "res://src/scenes/menus/base_menu_screen.gd"

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	back_button.text = "BACK TO TITLE"

	if not Engine.is_editor_hint():
		# --- Connect Unique Action Signals ---
		back_button.pressed.connect(_on_back_button_pressed)

		# --- Initialize Common Navigation & Feedback ---
		setup_menu_navigation([back_button], [back_button])

		await get_tree().process_frame
		back_button.grab_focus()

# --- Unique Signal Handlers ---
func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)

=====================================
FILE: ./src/core/sequencing/sequence_step.gd
=====================================
# src/core/sequencing/sequence_step.gd
@tool
## The abstract base class for all steps in a sequence.
##
## It defines the contract that all steps must follow: an `execute` method.
class_name SequenceStep
extends Resource

# --- Virtual Methods ---


## This method is implemented by all concrete step classes. It contains the
## logic for what the step does. It can return a [Signal] or [Coroutine]
## to make the [Sequencer] pause execution.
func execute(_sequencer_node: Node) -> Variant:
	return null


=====================================
FILE: ./src/core/sequencing/sequence_handle.gd
=====================================
# src/core/sequencing/sequence_handle.gd
## A handle representing a running sequence.
##
## Allows for safe cancellation and emits a signal when the sequence is
## completed or cancelled.
class_name SequenceHandle
extends RefCounted

# --- Signals ---
## Emitted when the sequence finishes or is cancelled.
signal finished

# --- Member Variables ---
var is_running: bool = true

# --- Public Methods ---


## Cancels the execution of the associated sequence.
func cancel() -> void:
	if is_running:
		is_running = false
		finished.emit()


=====================================
FILE: ./src/core/sequencing/sequencer.gd
=====================================
# src/core/sequencing/sequencer.gd
## An autoloaded singleton that runs linear sequences of timed events.
##
## It is used for cinematic moments like boss intros. It tracks all active
## sequences and can safely cancel them, preventing errors during scene transitions.
extends Node

# --- Private Member Variables ---
var _active_handles: Array[SequenceHandle] = []

# --- Public Methods ---


## Executes a series of [SequenceStep] resources and returns a handle.
func run_sequence(steps: Array[SequenceStep]) -> SequenceHandle:
	var handle = SequenceHandle.new()
	_active_handles.append(handle)
	handle.finished.connect(_on_sequence_finished.bind(handle))

	_execute_sequence(steps, handle)
	return handle


## Immediately cancels all running sequences.
func cancel_all() -> void:
	# Iterate over a copy, as cancelling a handle modifies the original array.
	for handle in _active_handles.duplicate():
		handle.cancel()


# --- Private Methods ---


## The core async function that executes the sequence steps.
func _execute_sequence(steps: Array[SequenceStep], handle: SequenceHandle) -> void:
	if steps.is_empty():
		if handle.is_running:
			handle.is_running = false
			handle.finished.emit()
		return

	for step in steps:
		if not handle.is_running:
			return  # Stop if cancelled

		if not step is SequenceStep:
			push_warning("Sequencer: Invalid step found. Skipping.")
			continue

		var awaitable = await step.execute(self)
		if awaitable:
			await awaitable

	if handle.is_running:
		handle.is_running = false
		handle.finished.emit()


# --- Signal Handlers ---


## Cleans up a finished or cancelled sequence from the tracking array.
func _on_sequence_finished(handle_to_remove: SequenceHandle) -> void:
	var index = _active_handles.find(handle_to_remove)
	if index != -1:
		_active_handles.remove_at(index)


=====================================
FILE: ./src/core/sequencing/steps/emit_step.gd
=====================================
# src/core/sequencing/steps/emit_step.gd
@tool
## A sequence step that emits an event on the global [EventBus].
class_name EmitStep
extends SequenceStep

# --- Editor Properties ---
@export var event_name: StringName = &""
@export var payload: Variant = null

# --- Virtual Methods ---


func execute(_sequencer_node: Node) -> Variant:
	if event_name == &"":
		push_warning("EmitStep: 'event_name' is not set.")
		return null
	EventBus.emit(event_name, payload)
	return null


=====================================
FILE: ./src/core/sequencing/steps/callable_step.gd
=====================================
# src/core/sequencing/steps/callable_step.gd
@tool
## A sequence step that executes a [Callable].
class_name CallableStep
extends SequenceStep

# --- Editor Properties ---
@export var callable: Callable

# --- Virtual Methods ---


func execute(_sequencer_node: Node) -> Variant:
	if callable.is_valid():
		# Await the result of the call. If the function is async, this will
		# pause the sequence until it completes.
		var result = await callable.call()
		# If the function itself returns ANOTHER awaitable (like a Signal),
		# return it to the sequencer to be awaited as well.
		if result is Signal or (typeof(result) == TYPE_OBJECT and result.has_method("is_valid")):
			return result
	else:
		push_warning("CallableStep: 'callable' is not set or is invalid.")

	return null


=====================================
FILE: ./src/core/sequencing/steps/wait_step.gd
=====================================
# src/core/sequencing/steps/wait_step.gd
@tool
## A sequence step that pauses execution for a set duration.
class_name WaitStep
extends SequenceStep

# --- Editor Properties ---
@export var duration: float = 1.0

# --- Virtual Methods ---


func execute(sequencer_node: Node) -> Variant:
	if duration > 0.0:
		# Return the timer's 'timeout' signal for the sequencer to await.
		return sequencer_node.get_tree().create_timer(duration).timeout
	return null


=====================================
FILE: ./src/core/boot/boot_manager.gd
=====================================
# src/core/boot/boot_manager.gd
## A stateless utility responsible for orchestrating the initialization of
## core game systems in a predictable order.
class_name BootManager
extends RefCounted

## Finds all necessary autoloads and calls their initialization methods.
static func initialize_systems() -> void:
	var scene_tree: SceneTree = Engine.get_main_loop() as SceneTree
	if not is_instance_valid(scene_tree):
		push_error("BootManager: Could not get valid SceneTree.")
		return

	var root_node: Node = scene_tree.root
	if not is_instance_valid(root_node):
		push_error("BootManager: Could not get SceneTree's root node.")
		return

	# Tell the ObjectPool to create all its initial instances.
	var object_pool: Node = root_node.get_node("/root/ObjectPool")
	if is_instance_valid(object_pool) and object_pool.has_method("initialize"):
		object_pool.initialize()

	# TODO: Add other systems here as needed (e.g., pre-caching assets).


=====================================
FILE: ./src/core/boot/global_preloader.gd
=====================================
# src/core/boot/global_preloader.gd
## A central autoload script whose sole purpose is to preload all interface
## and critical base class scripts in the project. This ensures their 'class_name'
## is registered with Godot's ScriptServer before any other script tries to use them,
## resolving parse order errors.
extends Node

func _ready() -> void:
	# Preload all interfaces and critical base classes to register them globally.
	preload("res://src/shared/interfaces/IComponent.gd")
	preload("res://src/shared/interfaces/IDamageable.gd")
	preload("res://src/shared/interfaces/IPoolable.gd")
	preload("res://src/shared/interfaces/ISceneController.gd")
	preload("res://src/shared/interfaces/IFXManager.gd")
	preload("res://src/shared/interfaces/IObjectPool.gd")
	
	# Input System (DIP)
	preload("res://src/shared/interfaces/IInputProvider.gd")
	preload("res://src/core/systems/input/standard_input_provider.gd")

	preload("res://src/entities/_base/scripts/base_entity.gd")
	preload("res://src/entities/_base/components/hurtbox_component.gd")
	preload("res://src/entities/_base/components/hitbox_component.gd")
	preload("res://src/entities/_base/components/sensor_component.gd")
	preload("res://src/core/data/audio/audio_cue.gd")


=====================================
FILE: ./src/core/util/combat_utils.gd
=====================================
# src/core/util/combat_utils.gd
## An autoloaded singleton containing static helper functions for combat logic.
extends Node

## Traverses up the scene tree from a given node to find its root BaseEntity.
func find_entity_root(from_node: Node) -> BaseEntity:
	if not is_instance_valid(from_node):
		return null
	
	var current_node = from_node
	while is_instance_valid(current_node):
		if current_node is BaseEntity:
			return current_node
		current_node = current_node.get_parent()
		
	return null


## Finds the IDamageable component on a target node by first finding the
## target's entity root, then asking for the component.
func find_damageable(from_node: Node) -> IDamageable:
	if not is_instance_valid(from_node):
		return null
	
	# If the collision starts on a sensor, we should never treat it as damageable.
	# This prevents projectiles that pass through a sensor from damaging the owner.
	if from_node.is_in_group(Identifiers.Groups.SENSORS):
		return null

	var entity: BaseEntity = find_entity_root(from_node)
	if is_instance_valid(entity):
		return entity.get_component(IDamageable)
	
	# Fallback for non-entity damageable nodes (e.g., a simple damageable prop)
	if from_node is IDamageable:
		return from_node
		
	return null


## Factory method to create a standard DamageInfo resource.
func create_damage_info(
	amount: int, 
	source: Node, 
	position: Vector2 = Vector2.ZERO, 
	normal: Vector2 = Vector2.ZERO,
	bypass_iframe: bool = false
) -> DamageInfo:
	var info = DamageInfo.new()
	info.amount = amount
	info.source_node = source
	info.impact_position = position
	info.impact_normal = normal
	info.bypass_invincibility = bypass_iframe
	return info


=====================================
FILE: ./src/core/util/service_locator.gd
=====================================
# src/core/util/service_locator.gd
## A central, autoloaded singleton that provides clean, type-safe access
## to all other core systems (services).
extends Node

# --- Constants ---
const PLAYER_CONFIG = preload("res://src/data/player_config.tres")
const ENEMY_CONFIG = preload("res://src/data/enemy_config.tres")
const WORLD_CONFIG = preload("res://src/data/world_config.tres")

# --- Service References ---
@onready var fx_manager: IFXManager = get_node("/root/FXManagerAdapter")
@onready var object_pool: IObjectPool = get_node("/root/ObjectPoolAdapter")
@onready var targeting_system = get_node("/root/TargetingSystem")
@onready var save_manager = get_node("/root/SaveManager")
@onready var event_bus = get_node("/root/EventBus")
@onready var sequencer = get_node("/root/Sequencer")
@onready var combat_utils = get_node("/root/CombatUtils")
@onready var grid_utils = get_node("/root/GridUtils")

# --- Non-Node Services (RefCounted) ---
var input_provider: IInputProvider

# --- Public Properties ---
var player_config: PlayerConfig = PLAYER_CONFIG
var enemy_config: EnemyConfig = ENEMY_CONFIG
var world_config: WorldConfig = WORLD_CONFIG

func _ready() -> void:
	# Default to the standard input wrapper for runtime
	input_provider = StandardInputProvider.new()


=====================================
FILE: ./src/core/util/grid_utils.gd
=====================================
# src/core/util/grid_utils.gd
## An autoloaded singleton providing a single source of truth for all conversions
## between the logical tile grid and world-space pixel coordinates.
extends Node

## Converts a grid coordinate (e.g., [Vector2i(2, 3)]) to a world position.
func grid_to_world(tile_pos: Vector2i, tile_size: int = Constants.TILE_SIZE) -> Vector2:
	var half_tile = tile_size / 2.0
	return Vector2(tile_pos.x * tile_size + half_tile, tile_pos.y * tile_size + half_tile)


## Converts a world position (in pixels) to its corresponding grid coordinate.
func world_to_grid(world_pos: Vector2, tile_size: int = Constants.TILE_SIZE) -> Vector2i:
	return Vector2i(floor(world_pos.x / tile_size), floor(world_pos.y / tile_size))

=====================================
FILE: ./src/core/util/dependency_validator.gd
=====================================
# src/core/util/dependency_validator.gd
## A stateless utility for validating component dependencies at runtime.
class_name DependencyValidator
extends RefCounted

## Validates that a dictionary of dependencies contains a set of required keys.
## If a key is missing, it pushes a descriptive error.
## Returns 'true' if validation passes, 'false' otherwise.
static func validate(component: IComponent, dependencies: Dictionary, required_keys: Array[String]) -> bool:
	var component_script_path = component.get_script().resource_path
	var component_name = component_script_path.get_file()

	for key in required_keys:
		if not dependencies.has(key):
			var error_msg = "Component '%s' is missing required dependency: '%s'" % [component_name, key]
			push_error(error_msg)
			return false
	return true


=====================================
FILE: ./src/core/util/physics_layers.gd
=====================================
# src/core/util/physics_layers.gd
## An autoloaded singleton that provides named constants for the 2D physics
## layers defined in the project settings.
##
## This prevents the use of "magic numbers" for collision layers and masks.
extends Node

# --- Layer Constants ---
const PLAYER = 1  # Layer 1
const PLATFORMS = 2  # Layer 2
const ENEMY = 4  # Layer 3
const HAZARD = 8  # Layer 4
const ENEMY_PROJECTILE = 16  # Layer 5
const PLAYER_HITBOX = 32  # Layer 6
const PLAYER_HURTBOX = 64  # Layer 7
const SOLID_WORLD = 128  # Layer 8
const HITBOX = 256 # Layer 9

=====================================
FILE: ./src/core/util/scene_validator.gd
=====================================
# src/core/util/scene_validator.gd
@tool
## A central utility for validating scene configurations in the editor.
##
## Its functions are static, allowing them to be called from any @tool script
## to provide configuration warnings in the Godot editor.
class_name SceneValidator
extends Object

# --- Static Validation Functions ---


## Validates a node to ensure it meets the BaseBoss contract.
static func validate_boss_scene(node: Node) -> PackedStringArray:
	var warnings = PackedStringArray()

	if not node.has_node("HealthComponent"):
		warnings.append("A HealthComponent node is required.")
	if not node.has_node("StateMachine"):
		warnings.append("A StateMachine node is required.")
	if not node.has_node("ArmorComponent"):
		warnings.append("An ArmorComponent node is required.")

	if node.get("phase_1_patterns") == null or node.get("phase_1_patterns").is_empty():
		warnings.append(
			"Phase 1 has no attack patterns assigned. The boss will be unable to attack."
		)

	return warnings


=====================================
FILE: ./src/core/util/palette.gd
=====================================
# src/core/util/palette.gd
## An autoloaded singleton that holds the project's master color palette.
##
## It establishes a single source of truth for all visual elements, ensuring a
## cohesive aesthetic based on a 32-step grayscale value scale.
extends Node

# --- Private Member Variables ---
const _palette: Array[Color] = [
	Color("#000000"),
	Color("#080808"),
	Color("#101010"),
	Color("#191919"),
	Color("#212121"),
	Color("#292929"),
	Color("#313131"),
	Color("#3a3a3a"),
	Color("#424242"),
	Color("#4a4a4a"),
	Color("#525252"),
	Color("#5a5a5a"),
	Color("#636363"),
	Color("#6b6b6b"),
	Color("#737373"),
	Color("#7b7b7b"),
	Color("#848484"),
	Color("#8c8c8c"),
	Color("#949494"),
	Color("#9c9c9c"),
	Color("#a5a5a5"),
	Color("#adadad"),
	Color("#b5b5b5"),
	Color("#bdbdbd"),
	Color("#c5c5c5"),
	Color("#cecece"),
	Color("#d6d6d6"),
	Color("#dedede"),
	Color("#e6e6e6"),
	Color("#efefef"),
	Color("#f7f7f7"),
	Color("#ffffff")
]

# --- Semantic Constants ---
# Use these constants in code, not raw palette indices.
# This makes the code readable and easy to theme.

# Gameplay
const COLOR_PLAYER: Color = _palette[31]
const COLOR_BOSS_PRIMARY: Color = _palette[30]
const COLOR_PLAYER_PROJECTILE: Color = _palette[29]
const COLOR_HAZARD_PRIMARY: Color = _palette[28]  # Also Enemy Projectiles

# Environment
const COLOR_BACKGROUND: Color = _palette[0]
const COLOR_GRID: Color = _palette[2]
const COLOR_TERRAIN_PRIMARY: Color = _palette[4]
const COLOR_TERRAIN_SECONDARY: Color = _palette[6]

# UI/UX
const COLOR_TEXT_HEADER: Color = _palette[30]
const COLOR_UI_ACCENT_PRIMARY: Color = _palette[28]
const COLOR_TEXT_PRIMARY: Color = _palette[26]
const COLOR_TEXT_DISABLED: Color = _palette[16]
const COLOR_UI_GLOW: Color = _palette[20]
const COLOR_UI_PANEL_BG: Color = _palette[8]


# --- Public Methods ---
## Provides a safe way to get a color by its raw index if needed.
func get_color(index: int) -> Color:
	if index >= 0 and index < _palette.size():
		return _palette[index]
	push_warning("Palette: Invalid color index requested: %d" % index)
	return Color.MAGENTA  # Return a highly visible error color


=====================================
FILE: ./src/core/util/identifiers.gd
=====================================
# src/core/util/identifiers.gd
@tool
## An autoloaded singleton that provides a central authority for all string-based
## identifiers used in the project.
extends Node

## A container for all physics group names.
class Groups:
	const PLAYER = "player"
	const ENEMY = "enemy"
	const WORLD = "world"
	const HAZARD = "hazard"
	const ONEWAY_PLATFORMS = "oneway_platforms"
	const PLAYER_PROJECTILE = "player_projectile"
	const ENEMY_PROJECTILE = "enemy_projectile"
	const SENSORS = "sensors"
	const DAMAGEABLE = "damageable"

## A container for all ObjectPool keys.
class Pools:
	const PLAYER_SHOTS = &"player_shots"
	const BOSS_SHOTS = &"boss_shots"
	const MINION_SHOTS = &"minion_shots"
	const HOMING_BOSS_SHOTS = &"homing_boss_shots"
	const HIT_SPARKS = &"hit_sparks"

## A container for all Input Map action names.
class Actions:
	# Gameplay
	const MOVE_LEFT = "ui_left"
	const MOVE_RIGHT = "ui_right"
	const MOVE_UP = "ui_up"
	const MOVE_DOWN = "ui_down"
	const JUMP = "ui_jump"
	const ATTACK = "ui_attack"
	const DASH = "ui_dash"
	
	# UI / System
	const UI_ACCEPT = "ui_accept"
	const UI_CANCEL = "ui_cancel"
	const PAUSE = "debug_pause_game" # Often mapped to Start/Esc

	# Debug
	const DEBUG_OVERLAY = "debug_toggle_overlay"
	const DEBUG_CYCLE_TARGET = "debug_cycle_target"
	const DEBUG_DIALOGUE = "debug_dialogue"
	const DEBUG_COLLISION = "debug_toggle_collision"
	const DEBUG_INVINCIBILITY = "debug_toggle_invincibility"

## Shared state keys used by multiple entity types.
class CommonStates:
	const IDLE = &"idle"
	const PATROL = &"patrol"
	const MELEE = &"melee"
	const ATTACK = &"attack"
	const FALL = &"fall"

## Container for all Player state keys.
class PlayerStates:
	const MOVE = &"move"
	const JUMP = &"jump"
	const FALL = &"fall"
	const DASH = &"dash"
	const WALL_SLIDE = &"wall_slide"
	const ATTACK = &"attack"
	const HURT = &"hurt"
	const HEAL = &"heal"
	const POGO = &"pogo"

## Container for all Boss state keys.
class BossStates:
	const IDLE = &"idle"
	const ATTACK = &"attack"
	const COOLDOWN = &"cooldown"
	const PATROL = &"patrol"
	const LUNGE = &"lunge"
	const FALL = &"fall"

## Container for all Minion state keys.
class MinionStates:
	const IDLE = &"idle"
	const ATTACK = &"attack"
	const FALL = &"fall"


=====================================
FILE: ./src/core/util/asset_paths.gd
=====================================
# src/core/util/asset_paths.gd
## An autoloaded singleton containing verified, static paths to all critical assets.
##
## Using these constants prevents runtime errors from typos in string paths and
## provides a central place to manage asset locations. Includes a validation
## system to check for missing files at startup in debug builds.
extends Node

# --- CORE SYSTEMS ---
const SCRIPT_COMBAT_UTILS = "res://src/core/util/combat_utils.gd"
const SCENE_MAIN = "res://src/scenes/main/main.tscn"
const SCENE_ENCOUNTER = "res://src/scenes/game/encounter_scene.tscn"
const SCENE_LOADING_SCREEN = "res://src/scenes/loading/loading_screen.tscn"
const SCRIPT_MENU_MANAGER = "res://src/ui/menu_manager/menu_manager.gd"
const SCRIPT_CUSTOM_SLIDER = "res://src/ui/components/custom_slider/custom_slider.gd"

# --- DATA ---
const ENCOUNTER_00 = "res://src/data/encounters/encounter_00.tres"

# --- PLAYER & RELATED ---
const SCENE_PLAYER = "res://src/entities/player/player.tscn"
const SCENE_PLAYER_SHOT = "res://src/projectiles/player_shot.tscn"

# --- BOSS, MINIONS & RELATED ---
const SCENE_BASE_BOSS = "res://src/entities/enemies/bosses/base_boss.tscn"
const SCENE_BOSS_SHOT = "res://src/projectiles/boss_shot.tscn"
const SCENE_HOMING_BOSS_SHOT = "res://src/projectiles/homing_boss_shot.tscn"
const SCENE_TELEGRAPH_COMPONENT = "res://src/entities/_base/components/telegraph_component.tscn"
const SCENE_TURRET = "res://src/entities/enemies/minions/turret.tscn"
const SCENE_MINION_SHOT = "res://src/projectiles/turret_shot.tscn"

# --- UI & SCENES ---
const SCENE_GAME_HUD = "res://src/ui/game_hud/game_hud.tscn"
const SCENE_GAME_OVER_SCREEN = "res://src/scenes/game_over/game_over_screen.tscn"
const SCENE_VICTORY_SCREEN = "res://src/scenes/victory/victory_screen.tscn"
const SCENE_TITLE_SCREEN = "res://src/scenes/menus/title_screen.tscn"
const SCENE_OPTIONS_SCREEN = "res://src/scenes/menus/options_screen.tscn"
const SCENE_SOUND_SCREEN = "res://src/scenes/menus/sound_screen.tscn"
const SCENE_CONTROLS_SCREEN = "res://src/scenes/menus/controls_screen.tscn"
const SCENE_CREDITS_SCREEN = "res://src/scenes/menus/credits_screen.tscn"
const SCENE_SAVE_SELECT_SCREEN = "res://src/scenes/menus/save_select_screen.tscn"

# --- UI COMPONENTS ---
const SCENE_STYLED_MENU_ITEM = "res://src/ui/components/styled_menu_item/styled_menu_item.tscn"
const SCENE_LOGO_DISPLAY = "res://src/ui/components/logo_display/logo_display.tscn"
const SCENE_MUTE_BUTTON = "res://src/ui/components/mute_button/mute_button.tscn"
const SCENE_CONTROL_SETTING_ROW = "res://src/ui/components/control_setting_row/control_setting_row.tscn"

# --- DEV TOOLS ---
const SCENE_DEBUG_OVERLAY = "res://src/ui/dev/debug_overlay.tscn"

# --- VFX ---
const SCENE_HIT_SPARK = "res://src/content/vfx/hit_spark.tscn"

# --- SPRITES & ICONS ---
const SPRITE_CURSOR_DEFAULT = "res://assets/sprites/ui/cursors/sprite_cursor_default.png"
const SPRITE_CURSOR_POINTER = "res://assets/sprites/ui/cursors/sprite_cursor_pointer.png"
const SPRITE_SLIDER_TRACK = "res://assets/sprites/ui/slider/slider-track.png"
const SPRITE_SLIDER_KNOB = "res://assets/sprites/ui/slider/slider-knob.png"
const SPRITE_CHECKBOX_CHECKED = "res://assets/sprites/ui/checkbox/checkbox-checked.png"
const SPRITE_CHECKBOX_UNCHECKED = "res://assets/sprites/ui/checkbox/checkbox-unchecked.png"
const ICON_UI_SOUND_ON = "res://assets/sprites/ui/icons/icon_ui_sound_on.png"
const ICON_UI_SOUND_OFF = "res://assets/sprites/ui/icons/icon_ui_sound_off.png"

# --- FONTS ---
const FONT_MAIN_BLACK = "res://assets/fonts/font_main_black.ttf"
const FONT_MAIN_BOLD = "res://assets/fonts/font_main_bold.ttf"
const FONT_MAIN_REGULAR = "res://assets/fonts/font_main_regular.ttf"

# --- AUDIO ---
const MUSIC_MENU_LOOP = "res://assets/audio/music/music_menu_loop.mp3"
const SFX_UI_BACK = "res://assets/audio/sfx/sfx_ui_back.mp3"
const SFX_UI_ERROR = "res://assets/audio/sfx/sfx_ui_error.mp3"
const SFX_UI_MOVE = "res://assets/audio/sfx/sfx_ui_move.mp3"
const SFX_UI_SELECT = "res://assets/audio/sfx/sfx_ui_select.mp3"
const SFX_GAME_START = "res://assets/audio/sfx/sfx_game_start.mp3"
const SFX_UI_SLIDER_TICK = "res://assets/audio/sfx/sfx_ui_slider_tick.mp3"


# --- Validation System ---
## Checks all defined paths to ensure the files exist on disk.
func validate_all_paths() -> void:
	print("AssetPaths: Validating all asset paths...")
	var constants = get_script().get_script_constant_map()
	var missing_assets = false

	for key in constants:
		var value = constants[key]
		if value is String and value.begins_with("res://"):
			if not FileAccess.file_exists(value):
				push_error(
					"Asset path validation failed! File not found for '%s': %s" % [key, value]
				)
				missing_assets = true

	if not missing_assets:
		print("AssetPaths: All paths validated successfully.")


=====================================
FILE: ./src/core/util/constants.gd
=====================================
# src/core/util/constants.gd
## An autoloaded singleton for true global constants that define the
## project's foundational architecture or core system limits.
##
## GUIDELINE: Only add values here that are fundamental and unlikely to
## ever change. Gameplay tuning values belong in [CombatConfig].
extends Node

# --- Audio ---
## The number of simultaneous sound effects that can be played at once.
const NUM_SFX_PLAYERS = 8

# --- Arena Design ---
## The universal size (width and height) of a single grid tile in pixels.
const TILE_SIZE = 50


=====================================
FILE: ./src/core/README.md
=====================================
# Core Subsystem

This directory contains all of the project's global systems, singletons, and core logic that is not specific to a single entity or scene.

## Subdirectories

-   **/building**: Contains the classes responsible for procedural level generation (`ArenaBuilder`, `LevelParser`, etc.).
-   **/data**: Manages game data, including the new `Resource`-based configurations.
-   **/events**: Contains the global `EventBus` and all typed event definitions.
-   **/sequencing**: Manages the `Sequencer` for creating scripted, timed events.
-   **/systems**: Contains the primary global managers (`AudioManager`, `GameManager`, etc.).
-   **/util**: A collection of stateless utility singletons like `AssetPaths` and `Palette`.

## Autoloaded Singletons (Global Access)

The following scripts are registered as autoloads in `project.godot` and can be accessed globally:

-   `Settings`: Manages persistent game settings.
-   `AudioManager`: Controls all audio playback.
-   `CursorManager`: Manages the custom mouse cursor.
-   `Constants`: Holds engine-level constants.
-   `AssetPaths`: Provides safe, static paths to all project assets.
-   `GlobalHud`: The persistent UI layer for global elements.
-   `GameManager`: Manages game state and scene flow.
-   `ArenaBuilder`: The main entry point for level construction.
-   `EventBus`: The global event dispatcher.
-   `Sequencer`: Manages timed event sequences.
-   `Config`: Handles loading data from `Resource`-based configs.
-   `Palette`: Defines the global color scheme.
-   `ObjectPool`: Manages reusable nodes to improve performance.
-   `PhysicsLayers`: Provides named constants for physics collision layers.

## Public API

The primary public API for inter-system communication is the `EventBus`. Systems should emit events to signal state changes and listen for events to react to them, rather than calling each other directly.

=====================================
FILE: ./src/core/events/event_bus.gd
=====================================
# src/core/events/event_bus.gd
## An autoloaded singleton that provides a global event dispatch system.
##
## This allows for loosely-coupled communication between disparate parts of the
## codebase, such as between gameplay systems and the UI.
extends Node

# --- Private Member Variables ---
var _subscribers: Dictionary = {}
var _by_id: Dictionary = {}
var _next_id: int = 1

# --- Godot Lifecycle Methods ---


func _exit_tree() -> void:
	# Clear all subscriptions to break potential cyclic references on exit.
	_subscribers.clear()
	_by_id.clear()


# --- Public Methods ---


## Subscribes a callback to a specific event. Returns a token ID for unsubscribing.
func on(event_name: StringName, callback: Callable) -> int:
	assert(callback.is_valid(), "EventBus.on: callback must be a valid Callable")

	var subs: Array = _subscribers.get(event_name, [])
	var owner_node = callback.get_object()
	var weak_ref = weakref(owner_node) if owner_node is Node else null

	var entry := {
		"id": _next_id,
		"callback": callback,
		"owner_weak": weak_ref,
	}
	subs.append(entry)
	_subscribers[event_name] = subs

	_by_id[_next_id] = event_name  # Map the token ID back to the event name
	_next_id += 1
	return entry.id


## Unsubscribes from an event using the token returned by on().
func off(token: int) -> void:
	if not _by_id.has(token):
		return

	var event_name: StringName = _by_id[token]
	if _subscribers.has(event_name):
		var subs = _subscribers[event_name]
		for i in range(subs.size() - 1, -1, -1):
			if subs[i].id == token:
				subs.remove_at(i)
				break
		if subs.is_empty():
			_subscribers.erase(event_name)

	_by_id.erase(token)


## Emits an event to all subscribers.
func emit(event_name: StringName, payload = null) -> void:
	if not _subscribers.has(event_name):
		return

	var subs: Array = _subscribers[event_name]
	# Iterate backwards to safely remove dead references during the loop.
	for i in range(subs.size() - 1, -1, -1):
		var sub = subs[i]

		# Auto-prune subscriptions whose owner nodes have been freed.
		if sub.owner_weak and not sub.owner_weak.get_ref():
			_by_id.erase(sub.id)
			subs.remove_at(i)
			continue

		sub.callback.call(payload)

	if subs.is_empty():
		_subscribers.erase(event_name)


=====================================
FILE: ./src/core/events/typed_events/boss_health_changed_event.gd
=====================================
# src/core/events/typed_events/boss_health_changed_event.gd
## A typed payload for the [constant EventCatalog.BOSS_HEALTH_CHANGED] event.
class_name BossHealthChangedEvent
extends Resource

@export var current_health: int = 0
@export var max_health: int = 0


=====================================
FILE: ./src/core/events/typed_events/boss_died_event.gd
=====================================
# src/core/events/typed_events/boss_died_event.gd
class_name BossDiedEvent
extends Resource

var boss_node: Node


=====================================
FILE: ./src/core/events/typed_events/player_health_changed_event.gd
=====================================
# src/core/events/typed_events/player_health_changed_event.gd
## A typed payload for the [constant EventCatalog.PLAYER_HEALTH_CHANGED] event.
class_name PlayerHealthChangedEvent
extends Resource

@export var current_health: int = 0
@export var max_health: int = 0


=====================================
FILE: ./src/core/events/typed_events/player_healing_charges_changed_event.gd
=====================================
# src/core/events/typed_events/player_healing_charges_changed_event.gd
## A typed payload for the [constant EventCatalog.PLAYER_HEALING_CHARGES_CHANGED] event.
class_name PlayerHealingChargesChangedEvent
extends Resource

@export var current_charges: int = 0


=====================================
FILE: ./src/core/events/typed_events/boss_phase_changed_event.gd
=====================================
# src/core/events/typed_events/boss_phase_changed_event.gd
class_name BossPhaseChangedEvent
extends Resource

var phases_remaining: int = 0


=====================================
FILE: ./src/core/events/event_catalog.gd
=====================================
# src/core/events/event_catalog.gd
## A central, canonical list of all event names in the project.
##
## By using these constants instead of raw strings (e.g., [code]EventBus.emit(EventCatalog.PLAYER_DIED)[/code]),
## we gain IDE autocompletion and prevent typos that lead to silent runtime failures.
class_name EventCatalog
extends Object

# --- Player Events ---
const PLAYER_HEALTH_CHANGED = "player.health_changed"
const PLAYER_HEALING_CHARGES_CHANGED = "player.healing_charges_changed"

# --- Boss / Entity Events ---
const BOSS_HEALTH_CHANGED = "boss.health_changed"
const BOSS_DIED = "boss.died"
const BOSS_PHASE_CHANGED = "boss.phase_changed"

# --- Game State Events ---
const SCENE_TRANSITION_STARTED = "scene.transition_started"
# An event for the intro sequence to request the boss spawn.
const SPAWN_BOSS_REQUESTED = "encounter.spawn_boss_requested"

# --- UI State Events ---
const MENU_OPENED = "ui.menu_opened"
const MENU_CLOSED = "ui.menu_closed"

=====================================
FILE: ./src/core/systems/pooling/pool_definition.gd
=====================================
# src/core/systems/pooling/pool_definition.gd
@tool
class_name PoolDefinition
extends Resource

@export var pool_key: StringName
@export var scene: PackedScene
@export var initial_size: int = 10


=====================================
FILE: ./src/core/systems/pooling/pool_manifest.gd
=====================================
# src/core/systems/pooling/pool_manifest.gd
@tool
class_name PoolManifest
extends Resource

@export var pools: Array[PoolDefinition] = []


=====================================
FILE: ./src/core/systems/input/standard_input_provider.gd
=====================================
# src/core/systems/input/standard_input_provider.gd
## The concrete implementation that wraps Godot's global Input singleton.
class_name StandardInputProvider
extends IInputProvider

func get_axis(negative_action: StringName, positive_action: StringName) -> float:
	return Input.get_axis(negative_action, positive_action)

func is_action_pressed(action: StringName) -> bool:
	return Input.is_action_pressed(action)

func is_action_just_pressed(action: StringName) -> bool:
	return Input.is_action_just_pressed(action)

func is_action_just_released(action: StringName) -> bool:
	return Input.is_action_just_released(action)


=====================================
FILE: ./src/core/systems/pool_bindings/object_pool_adapter.gd
=====================================
# src/core/systems/pool_bindings/object_pool_adapter.gd
## An adapter that implements the IObjectPool interface by delegating calls
## to the real ObjectPool autoload singleton.
extends IObjectPool

# --- Private Member Variables ---
var _real_object_pool: Node

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	_real_object_pool = get_node("/root/ObjectPool")
	assert(is_instance_valid(_real_object_pool), "ObjectPoolAdapter could not find /root/ObjectPool")

# --- IObjectPool Implementation ---

func get_instance(pool_name: StringName) -> Node:
	return _real_object_pool.get_instance(pool_name)

func return_instance(instance: Node) -> void:
	_real_object_pool.return_instance(instance)

func reset() -> void:
	_real_object_pool.reset()

func get_pool_stats() -> Dictionary:
	return _real_object_pool.get_pool_stats()

=====================================
FILE: ./src/core/systems/targeting_system.gd
=====================================
# src/core/systems/targeting_system.gd
## An autoloaded singleton that acts as a registry for active game entities.
##
## This decouples logic from the SceneTree group system, allowing for faster
## lookups and easier dependency mocking in tests.
extends Node

# Map<group_id, Array[Node]>
var _targets: Dictionary = {}

# --- Public API ---

## Registers a node as a target within a specific group.
func register(node: Node, group_id: String) -> void:
	if not is_instance_valid(node):
		return
		
	if not _targets.has(group_id):
		_targets[group_id] = []
		
	if not _targets[group_id].has(node):
		_targets[group_id].append(node)


## Unregisters a node from a specific group.
func unregister(node: Node, group_id: String) -> void:
	if _targets.has(group_id):
		_targets[group_id].erase(node)


## Returns the first registered node in a group, or null if empty.
func get_first(group_id: String) -> Node:
	if _targets.has(group_id) and not _targets[group_id].is_empty():
		# Return the first valid instance
		for node in _targets[group_id]:
			if is_instance_valid(node):
				return node
	return null


## Returns all registered nodes in a group.
func get_all(group_id: String) -> Array:
	if _targets.has(group_id):
		# Filter out any invalid references on the fly
		_targets[group_id] = _targets[group_id].filter(func(n): return is_instance_valid(n))
		return _targets[group_id]
	return []


=====================================
FILE: ./src/core/systems/dialogue_manager.gd
=====================================
# src/core/systems/dialogue_manager.gd
## An autoloaded singleton for managing and displaying dialogue.
##
## It is responsible for loading [DialogueData] resources and commanding
## a UI scene to display the conversation line by line.
extends Node

signal conversation_started(dialogue_data)
signal line_shown(line_index, line: DialogueLine)
signal conversation_ended

const DialogueBoxScene = preload("res://src/ui/dialogue/dialogue_box.tscn")

var _current_data: DialogueData
var _current_index: int = -1
var _dialogue_box_instance: DialogueBox
var _ui_layer: CanvasLayer
var _scene_transition_token: int


func _ready() -> void:
	_ui_layer = CanvasLayer.new()
	_ui_layer.layer = 10
	_ui_layer.name = "DialogueUILayer"

	_dialogue_box_instance = DialogueBoxScene.instantiate()
	_dialogue_box_instance.visible = false

	_ui_layer.add_child.call_deferred(_dialogue_box_instance)
	get_tree().get_root().add_child.call_deferred(_ui_layer)

	_dialogue_box_instance.advance_requested.connect(_on_dialogue_box_advance_requested)
	_dialogue_box_instance.typing_finished.connect(_on_typing_finished)

	_scene_transition_token = EventBus.on(
		EventCatalog.SCENE_TRANSITION_STARTED, func(_payload): end_conversation()
	)


func _exit_tree() -> void:
	# Ensure we unsubscribe from the global event bus when the game closes.
	EventBus.off(_scene_transition_token)


## Checks if a conversation is currently active.
func is_conversation_active() -> bool:
	return is_instance_valid(_current_data)


## Starts a conversation using the data from a [DialogueData] resource.
func start_conversation(data: DialogueData) -> void:
	if not is_instance_valid(data) or data.lines.is_empty():
		push_error("DialogueManager: Attempted to start conversation with invalid or empty data.")
		return

	end_conversation()

	_current_data = data
	_current_index = 0

	_dialogue_box_instance.visible = true
	conversation_started.emit(data)
	_show_current_line()


## Ends the current conversation and hides the UI.
func end_conversation() -> void:
	if not is_instance_valid(_current_data):
		return

	_dialogue_box_instance.visible = false
	_current_data = null
	_current_index = -1
	conversation_ended.emit()


# --- Private Methods ---


func _show_current_line() -> void:
	if (
		not is_instance_valid(_current_data)
		or _current_index < 0
		or _current_index >= _current_data.lines.size()
	):
		end_conversation()
		return

	var line = _current_data.lines[_current_index]
	_dialogue_box_instance.display_line(line)
	line_shown.emit(_current_index, line)


func _advance_to_next_line() -> void:
	_current_index += 1
	if _current_index >= _current_data.lines.size():
		end_conversation()
	else:
		_show_current_line()


# --- Signal Handlers ---


func _on_dialogue_box_advance_requested() -> void:
	_advance_to_next_line()


func _on_typing_finished() -> void:
	# Add a guard clause to prevent crash during scene transitions.
	if not is_instance_valid(_current_data):
		return

	var line = _current_data.lines[_current_index]
	if line.wait_after > 0.0:
		await get_tree().create_timer(line.wait_after).timeout


=====================================
FILE: ./src/core/systems/game_manager.gd
=====================================
# src/core/systems/game_manager.gd
## An autoloaded singleton that manages the state of the game session.
##
## It holds a reference to a [GameStateData] resource, which acts as the
## single source of truth for all runtime session data.
extends Node

# --- Constants ---
const GameStateDataScript = preload("res://src/core/data/game_state_data.gd")

# --- Public Member Variables ---
## The active [GameStateData] resource for the current session.
var state: GameStateData = null

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# Create a new, clean instance of the game state every time the
	# GameManager is initialized at game startup.
	state = GameStateDataScript.new()


func _exit_tree() -> void:
	# Manually release our reference to the state resource. This allows
	# Godot's garbage collector to free it, preventing memory leaks on exit.
	if is_instance_valid(state):
		state = null


=====================================
FILE: ./src/core/systems/scene_manager.gd
=====================================
# src/core/systems/scene_manager.gd
## A centralized singleton for handling all scene transitions.
##
## This provides a robust, single API for navigation and ensures that
## necessary cleanup (like resetting the ObjectPool) happens automatically.
extends Node

# --- Public API ---


## Generic method to transition to any scene by its path.
func go_to_scene(path: String) -> void:
	_switch_to_scene(path)


## Transitions to the main title screen.
func go_to_title_screen() -> void:
	go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


## Starts a new game with a specific encounter.
func start_game(encounter_path: String) -> void:
	GameManager.state.current_encounter_path = encounter_path
	go_to_scene(AssetPaths.SCENE_LOADING_SCREEN)


## Transitions to the game over screen.
func go_to_game_over() -> void:
	go_to_scene(AssetPaths.SCENE_GAME_OVER_SCREEN)


## Transitions to the victory screen.
func go_to_victory() -> void:
	go_to_scene(AssetPaths.SCENE_VICTORY_SCREEN)


# --- Private Methods ---


## The core scene-switching logic.
func _switch_to_scene(path: String) -> void:
	# --- Announce Pre-Transition Cleanup ---
	EventBus.emit(EventCatalog.SCENE_TRANSITION_STARTED)
	
	# Reset time scale in case we are coming from a slow-mo death state
	Engine.time_scale = 1.0

	# 1. Call the formal teardown method on the current scene controller if it exists.
	var current_scene = get_tree().current_scene
	if is_instance_valid(current_scene) and current_scene.has_method("scene_exiting"):
		await current_scene.scene_exiting()

	# 2. Reset global systems.
	ObjectPool.reset()
	Sequencer.cancel_all()

	# 3. Change the scene.
	get_tree().call_deferred("change_scene_to_file", path)


=====================================
FILE: ./src/core/systems/object_pool.gd
=====================================
# src/core/systems/object_pool.gd
## An autoloaded singleton that manages pools of reusable nodes.
## Supports parenting active objects to a specific world node for Viewport compatibility.
extends Node

# --- Constants ---
const MANIFEST_PATH = "res://src/data/default_pool_manifest.tres"

# --- Private Member Variables ---
var _pools: Dictionary = {}
var _is_initialized: bool = false
var _active_world_container: Node = null 

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	pass

func _exit_tree() -> void:
	_cleanup_pools()

# --- Public Methods ---

func initialize() -> void:
	if _is_initialized:
		return
	
	if not FileAccess.file_exists(MANIFEST_PATH):
		push_error("ObjectPool: Manifest not found at %s" % MANIFEST_PATH)
		return
		
	var manifest: PoolManifest = load(MANIFEST_PATH)
	if not manifest:
		push_error("ObjectPool: Failed to load PoolManifest resource.")
		return
		
	for def in manifest.pools:
		if def.scene == null:
			push_warning("ObjectPool: Pool definition for '%s' has no scene." % def.pool_key)
			continue
		_create_pool_for_scene(def.pool_key, def.scene, def.initial_size)
		
	_is_initialized = true

func register_world_container(container: Node) -> void:
	_active_world_container = container

func get_pool_stats() -> Dictionary:
	var stats: Dictionary = {}
	for pool_name in _pools:
		var pool: Dictionary = _pools[pool_name]
		var inactive_count: int = pool.inactive.size()
		var total: int = pool.total_created
		# "Active" is simply the total created minus those currently sitting in the pool
		stats[pool_name] = {"active": total - inactive_count, "total": total}
	return stats

func reset() -> void:
	_active_world_container = null

func get_instance(p_pool_name: StringName) -> Node:
	if not _pools.has(p_pool_name):
		push_error("ObjectPool: Attempted to get instance from a non-existent pool: '%s'" % p_pool_name)
		return null

	var pool: Dictionary = _pools[p_pool_name]
	var instance: Node = null

	# Robust Retrieval Loop
	# Keep popping until we find a valid instance or run out.
	while not pool.inactive.is_empty():
		var candidate = pool.inactive.pop_front()
		if is_instance_valid(candidate) and not candidate.is_queued_for_deletion():
			instance = candidate
			break
		else:
			# If we found a ghost reference, we decrement total count effectively (it's gone)
			# We don't decrement total_created here to keep stats simple, or we could.
			pass

	# If no valid instance found in pool, create new
	if not is_instance_valid(instance):
		instance = pool.scene.instantiate()
		instance.set_meta("pool_name", p_pool_name)
		pool.container.add_child(instance)
		pool.total_created += 1

	# Reparenting Logic
	if is_instance_valid(_active_world_container) and not _active_world_container.is_queued_for_deletion():
		if instance.get_parent() != _active_world_container:
			# Standard reparent
			instance.reparent(_active_world_container, false) 
	
	return instance

func return_instance(p_instance: Node) -> void:
	if not is_instance_valid(p_instance):
		return

	var pool_name: StringName = p_instance.get_meta("pool_name", "")
	if pool_name == "" or not _pools.has(pool_name):
		p_instance.queue_free()
		return

	var pool: Dictionary = _pools[pool_name]
	
	# Prevent double-return
	if pool.inactive.has(p_instance):
		return

	if p_instance.has_method("deactivate"):
		p_instance.deactivate()

	# Return to pool container for storage
	if p_instance.get_parent() != pool.container:
		if is_instance_valid(pool.container):
			p_instance.reparent(pool.container, false)
		else:
			p_instance.queue_free()
			return

	pool.inactive.push_front(p_instance)

# --- Private Methods ---

func _create_pool_for_scene(
	p_pool_name: StringName, p_scene: PackedScene, p_initial_size: int
) -> void:
	if _pools.has(p_pool_name):
		return

	var pool_container := Node.new()
	pool_container.name = str(p_pool_name)
	add_child(pool_container)

	# Added 'total_created' to track stats accurately
	_pools[p_pool_name] = {
		"scene": p_scene, 
		"inactive": [], 
		"container": pool_container,
		"total_created": 0
	}

	for i in range(p_initial_size):
		var instance: Node = p_scene.instantiate()
		instance.set_meta("pool_name", p_pool_name)
		pool_container.add_child(instance)
		if instance.has_method("deactivate"):
			instance.deactivate()
		_pools[p_pool_name].inactive.append(instance)
		_pools[p_pool_name].total_created += 1

func _cleanup_pools() -> void:
	for pool_name in _pools:
		var pool = _pools[pool_name]
		for item in pool.inactive:
			if is_instance_valid(item):
				item.free()
		if is_instance_valid(pool.container):
			pool.container.free()
	_pools.clear()


=====================================
FILE: ./src/core/systems/audio_manager.gd
=====================================
# src/core/systems/audio_manager.gd
## An autoloaded singleton responsible for all audio playback.
extends Node

# --- Preloads ---
# Renamed to avoid shadowing the global class_name 'AudioCue'
const AudioCueResource = preload("res://src/core/data/audio/audio_cue.gd")

# --- Private Member Variables ---
var _sfx_players: Array[AudioStreamPlayer] = []
var _sfx_player_index: int = 0
var _music_player: AudioStreamPlayer

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	# --- Create SFX Players ---
	for i in range(Constants.NUM_SFX_PLAYERS):
		var player = AudioStreamPlayer.new()
		player.name = "SFXPlayer_%d" % i
		player.bus = "SFX"
		add_child(player)
		_sfx_players.append(player)

	# --- Create Music Player ---
	_music_player = AudioStreamPlayer.new()
	_music_player.name = "MusicPlayer"
	_music_player.bus = "Music"
	add_child(_music_player)

	# --- Connect to Settings ---
	Settings.audio_settings_changed.connect(_on_audio_settings_changed)
	_on_audio_settings_changed()  # Apply initial settings

func _notification(what: int) -> void:
	if what == NOTIFICATION_WM_CLOSE_REQUEST:
		if is_instance_valid(_music_player):
			_music_player.stop()
			_music_player.stream = null

func _exit_tree() -> void:
	if Settings.audio_settings_changed.is_connected(_on_audio_settings_changed):
		Settings.audio_settings_changed.disconnect(_on_audio_settings_changed)

	if is_instance_valid(_music_player):
		_music_player.stop()
		_music_player.stream = null

# --- Public Methods ---

## Plays a configured AudioCue resource.
func play_cue(cue: AudioCueResource) -> void:
	if not is_instance_valid(cue) or not cue.stream:
		return

	var player = _sfx_players[_sfx_player_index]
	
	player.stream = cue.stream
	player.volume_db = cue.volume_db
	player.pitch_scale = cue.get_pitch()
	player.bus = cue.bus
	
	player.play()
	_sfx_player_index = (_sfx_player_index + 1) % Constants.NUM_SFX_PLAYERS

## Plays a one-shot sound effect from a path (Legacy).
func play_sfx(sound_path: String) -> void:
	var player = _sfx_players[_sfx_player_index]
	player.stream = load(sound_path)
	player.volume_db = 0.0
	player.pitch_scale = 1.0
	player.bus = "SFX"
	
	player.play()
	_sfx_player_index = (_sfx_player_index + 1) % Constants.NUM_SFX_PLAYERS

## Plays a looping music track.
func play_music(music_path: String) -> void:
	if _music_player.stream and _music_player.stream.resource_path == music_path and _music_player.playing:
		return

	_music_player.stream = load(music_path)
	_music_player.play()

func stop_music() -> void:
	_music_player.stop()

# --- Signal Handlers ---

func _on_audio_settings_changed() -> void:
	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Master"), linear_to_db(Settings.master_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Master"), Settings.master_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Music"), linear_to_db(Settings.music_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Music"), Settings.music_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("SFX"), linear_to_db(Settings.sfx_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("SFX"), Settings.sfx_muted)


=====================================
FILE: ./src/core/systems/cursor_manager.gd
=====================================
# src/core/systems/cursor_manager.gd
## An autoloaded singleton that manages the game's custom "fake" cursor.
##
## This provides full control over the cursor's appearance and ensures it
## renders above all other UI and game elements.
extends CanvasLayer

# --- Constants ---
const CURSOR_DEFAULT = preload(AssetPaths.SPRITE_CURSOR_DEFAULT)
const CURSOR_POINTER = preload(AssetPaths.SPRITE_CURSOR_POINTER)

# --- Private Member Variables ---
var _cursor_sprite: TextureRect

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# A high layer number ensures the cursor renders above everything else.
	layer = 10
	Input.set_mouse_mode(Input.MOUSE_MODE_HIDDEN)

	_cursor_sprite = TextureRect.new()
	_cursor_sprite.texture = CURSOR_DEFAULT
	# CRITICAL: This makes the cursor "click-through," so it never blocks
	# mouse events intended for UI elements underneath it.
	_cursor_sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE
	add_child(_cursor_sprite)


func _process(_delta: float) -> void:
	# Sync the custom cursor's position to the real mouse position every frame.
	_cursor_sprite.position = get_viewport().get_mouse_position()


# --- Public Methods ---


## Sets the cursor's appearance (e.g., when hovering a button).
func set_pointer_state(is_pointing: bool) -> void:
	if is_pointing:
		_cursor_sprite.texture = CURSOR_POINTER
	else:
		_cursor_sprite.texture = CURSOR_DEFAULT


=====================================
FILE: ./src/core/systems/save_manager.gd
=====================================
# src/core/systems/save_manager.gd
## An autoloaded singleton responsible for serializing game progression.
## Manages multiple save slots (0, 1, 2).
extends Node

signal current_save_updated

const MAX_SLOTS = 3
const SAVE_FILE_TEMPLATE = "user://save_slot_%02d.tres"

var current_slot_index: int = -1
var current_save: SaveData = null

func _ready() -> void:
	pass

# --- Slot Management API ---

func get_slot_path(index: int) -> String:
	return SAVE_FILE_TEMPLATE % index

func slot_exists(index: int) -> bool:
	return FileAccess.file_exists(get_slot_path(index))

func get_slot_summary(index: int) -> Dictionary:
	if not slot_exists(index):
		return {"empty": true}
	
	# Force ignore cache to ensure we see disk changes immediately (e.g. after copy/erase)
	var data = ResourceLoader.load(get_slot_path(index), "", ResourceLoader.CACHE_MODE_IGNORE) as SaveData
	if not data:
		return {"empty": true, "corrupt": true}
	
	return {
		"empty": false,
		"wins": data.total_wins,
		"losses": data.total_losses
	}

func load_slot(index: int) -> bool:
	if not slot_exists(index):
		return false
	
	var data = ResourceLoader.load(get_slot_path(index), "", ResourceLoader.CACHE_MODE_IGNORE) as SaveData
	if data:
		current_slot_index = index
		current_save = data
		current_save_updated.emit()
		return true
	return false

func create_new_slot(index: int) -> void:
	var new_data = SaveData.new()
	# Initialize defaults here if needed
	current_slot_index = index
	current_save = new_data
	_save_to_disk()
	current_save_updated.emit()

func erase_slot(index: int) -> void:
	if slot_exists(index):
		DirAccess.remove_absolute(get_slot_path(index))
	
	if current_slot_index == index:
		current_save = null
		current_slot_index = -1

func copy_slot(from_index: int, to_index: int) -> bool:
	if not slot_exists(from_index):
		push_error("SaveManager: Source slot %d does not exist." % from_index)
		return false
	
	var source_data = ResourceLoader.load(get_slot_path(from_index), "", ResourceLoader.CACHE_MODE_IGNORE) as SaveData
	if not source_data:
		push_error("SaveManager: Failed to load source slot %d." % from_index)
		return false
		
	# Duplicate with sub-resources (true) to ensure independence
	var new_data = source_data.duplicate(true)
	
	# Critical: Tell the resource it belongs to the new path
	var dest_path = get_slot_path(to_index)
	new_data.take_over_path(dest_path)
	
	var err = ResourceSaver.save(new_data, dest_path)
	if err != OK:
		push_error("SaveManager: Failed to save copy to %s (Error %d)" % [dest_path, err])
		return false
		
	return true

# --- Runtime API ---

func record_win() -> void:
	if not current_save: return
	current_save.total_wins += 1
	_save_to_disk()

func record_loss() -> void:
	if not current_save: return
	current_save.total_losses += 1
	_save_to_disk()

func _save_to_disk() -> void:
	if current_save and current_slot_index >= 0:
		ResourceSaver.save(current_save, get_slot_path(current_slot_index))


=====================================
FILE: ./src/core/data/config/settings.gd
=====================================
# src/core/data/config/settings.gd
## An autoloaded singleton that manages persistent game settings.
## Handles Audio levels, Input remapping, and Input Presets.
extends Node

# --- Signals ---
signal audio_settings_changed
signal input_settings_changed

# --- Constants ---
const CONFIG_PATH = "user://options.cfg"

# --- Input Settings ---
var _default_inputs: Dictionary = {}
var remappable_actions: Array = []

# Tracks the active preset name. If the user manually rebinds, this becomes "Custom".
var current_input_preset: String = "Default 1"

# --- Audio Settings ---
@export var master_volume: float = 1.0:
	set(value):
		var clamped = clampf(value, 0.0, 1.0)
		if not is_equal_approx(master_volume, clamped):
			master_volume = clamped
			audio_settings_changed.emit()
			_save_config()

@export var music_volume: float = 1.0:
	set(value):
		var clamped = clampf(value, 0.0, 1.0)
		if not is_equal_approx(music_volume, clamped):
			music_volume = clamped
			audio_settings_changed.emit()
			_save_config()

@export var sfx_volume: float = 1.0:
	set(value):
		var clamped = clampf(value, 0.0, 1.0)
		if not is_equal_approx(sfx_volume, clamped):
			sfx_volume = clamped
			audio_settings_changed.emit()
			_save_config()

@export var master_muted: bool = false:
	set(value):
		if master_muted != value:
			master_muted = value
			audio_settings_changed.emit()
			_save_config()

@export var music_muted: bool = false:
	set(value):
		if music_muted != value:
			music_muted = value
			audio_settings_changed.emit()
			_save_config()

@export var sfx_muted: bool = false:
	set(value):
		if sfx_muted != value:
			sfx_muted = value
			audio_settings_changed.emit()
			_save_config()

# --- Lifecycle ---

func _ready() -> void:
	call_deferred("_initialize")

func _initialize() -> void:
	_define_remappable_actions()
	_capture_default_inputs()
	_load_config()

# --- Input Management ---

func _define_remappable_actions() -> void:
	# Order matters for the UI list
	remappable_actions = [
		Identifiers.Actions.MOVE_UP,
		Identifiers.Actions.MOVE_LEFT,
		Identifiers.Actions.MOVE_DOWN,
		Identifiers.Actions.MOVE_RIGHT,
		Identifiers.Actions.JUMP,
		Identifiers.Actions.ATTACK,
		Identifiers.Actions.DASH
	]

func _capture_default_inputs() -> void:
	for action in remappable_actions:
		_default_inputs[action] = InputMap.action_get_events(action)

func remap_action(action: String, new_event: InputEvent) -> void:
	if not remappable_actions.has(action):
		return
	
	InputMap.action_erase_events(action)
	InputMap.action_add_event(action, new_event)
	
	current_input_preset = "Custom"
	input_settings_changed.emit()
	_save_config()

func get_input_label(action: String) -> String:
	var events = InputMap.action_get_events(action)
	if events.is_empty():
		return "None"
	
	var event = events[0]
	if event is InputEventKey:
		return OS.get_keycode_string(event.physical_keycode)
	elif event is InputEventMouseButton:
		var btn_name = "Mouse " + str(event.button_index)
		if event.button_index == MOUSE_BUTTON_LEFT: btn_name = "L-Click"
		if event.button_index == MOUSE_BUTTON_RIGHT: btn_name = "R-Click"
		if event.button_index == MOUSE_BUTTON_MIDDLE: btn_name = "M-Click"
		return btn_name
	
	return "Unknown"

# --- Presets API ---

func get_available_presets() -> Array[String]:
	return ["Default 1", "Default 2", "Custom"]

func apply_preset(preset_name: String) -> void:
	var map = {}
	
	# Default 1: Arrows/WASD + ZXC
	if preset_name == "Default 1":
		map = {
			Identifiers.Actions.MOVE_UP: [_create_key(KEY_UP), _create_key(KEY_W)],
			Identifiers.Actions.MOVE_LEFT: [_create_key(KEY_LEFT), _create_key(KEY_A)],
			Identifiers.Actions.MOVE_DOWN: [_create_key(KEY_DOWN), _create_key(KEY_S)],
			Identifiers.Actions.MOVE_RIGHT: [_create_key(KEY_RIGHT), _create_key(KEY_D)],
			Identifiers.Actions.JUMP: [_create_key(KEY_X)],
			Identifiers.Actions.ATTACK: [_create_key(KEY_C)],
			Identifiers.Actions.DASH: [_create_key(KEY_Z)]
		}
		
	# Default 2: WASD + .,/
	elif preset_name == "Default 2":
		map = {
			Identifiers.Actions.MOVE_UP: [_create_key(KEY_W)],
			Identifiers.Actions.MOVE_LEFT: [_create_key(KEY_A)],
			Identifiers.Actions.MOVE_DOWN: [_create_key(KEY_S)],
			Identifiers.Actions.MOVE_RIGHT: [_create_key(KEY_D)],
			Identifiers.Actions.JUMP: [_create_key(KEY_PERIOD)],
			Identifiers.Actions.ATTACK: [_create_key(KEY_COMMA)],
			Identifiers.Actions.DASH: [_create_key(KEY_SLASH)]
		}
	
	# Custom: Fully Empty (User must bind)
	elif preset_name == "Custom":
		for action in remappable_actions:
			map[action] = []

	if map.is_empty() and preset_name != "Custom":
		return

	# Apply
	for action in remappable_actions:
		if map.has(action):
			InputMap.action_erase_events(action)
			for event in map[action]:
				InputMap.action_add_event(action, event)
	
	current_input_preset = preset_name
	input_settings_changed.emit()
	_save_config()

# --- Helper Factories ---
func _create_key(keycode: int) -> InputEventKey:
	var ev = InputEventKey.new()
	ev.physical_keycode = keycode
	return ev

# --- Persistence Logic ---

func _save_config() -> void:
	var config = ConfigFile.new()
	
	# Audio
	config.set_value("audio", "master_volume", master_volume)
	config.set_value("audio", "music_volume", music_volume)
	config.set_value("audio", "sfx_volume", sfx_volume)
	config.set_value("audio", "master_muted", master_muted)
	config.set_value("audio", "music_muted", music_muted)
	config.set_value("audio", "sfx_muted", sfx_muted)
	
	# Input Meta
	config.set_value("input", "preset", current_input_preset)
	
	# Input Bindings (Only save if Custom)
	if current_input_preset == "Custom":
		for action in remappable_actions:
			var events = InputMap.action_get_events(action)
			if not events.is_empty():
				config.set_value("input_custom", action, events[0])

	config.save(CONFIG_PATH)

func _load_config() -> void:
	var config = ConfigFile.new()
	var err = config.load(CONFIG_PATH)
	if err != OK:
		apply_preset("Default 1")
		return 

	# Audio
	master_volume = config.get_value("audio", "master_volume", 1.0)
	music_volume = config.get_value("audio", "music_volume", 1.0)
	sfx_volume = config.get_value("audio", "sfx_volume", 1.0)
	master_muted = config.get_value("audio", "master_muted", false)
	music_muted = config.get_value("audio", "music_muted", false)
	sfx_muted = config.get_value("audio", "sfx_muted", false)
	
	# Input
	var saved_preset = config.get_value("input", "preset", "Default 1")
	# Map legacy names to new ones if needed
	if saved_preset == "Default": saved_preset = "Default 1"
	if saved_preset == "Alt": saved_preset = "Default 2"
	
	if saved_preset != "Custom":
		apply_preset(saved_preset)
	else:
		current_input_preset = "Custom"
		# Clear first so we only have loaded bindings
		for action in remappable_actions:
			InputMap.action_erase_events(action)
			
		for action in remappable_actions:
			if config.has_section_key("input_custom", action):
				var saved_event = config.get_value("input_custom", action)
				if saved_event is InputEvent:
					InputMap.action_add_event(action, saved_event)
	
	audio_settings_changed.emit()
	input_settings_changed.emit()


=====================================
FILE: ./src/core/data/config/damage_response_config.gd
=====================================
# src/core/data/config/damage_response_config.gd
@tool
## A standard configuration resource defining how an entity reacts to damage.
class_name DamageResponseConfig
extends Resource

# Prevent cyclic dependency parse errors by using the raw resource type in signature if needed,
# but here we will rely on the global class_name 'AudioCue'.
@export_group("Feedback")
## The sound to play when damage is taken.
@export var audio_cue: AudioCue

@export_group("Invincibility")
@export_range(0.0, 5.0, 0.1) var invincibility_duration: float = 0.0

@export_group("Knockback")
@export_range(0.0, 2000.0, 10.0) var knockback_speed: float = 0.0
@export_range(0.0, 2000.0, 10.0) var hazard_knockback_speed: float = 0.0


=====================================
FILE: ./src/core/data/config/state_machine_config.gd
=====================================
# src/core/data/config/state_machine_config.gd
@tool
## A configuration resource defining the structure of a Finite State Machine.
## Allows states to be injected via the Inspector/Resources rather than hardcoded.
class_name StateMachineConfig
extends Resource

@export var initial_state: StringName = &"idle"
@export var states: Array[StateDefinition] = []


=====================================
FILE: ./src/core/data/config/state_definition.gd
=====================================
# src/core/data/config/state_definition.gd
@tool
## A simple mapping between a State Key (StringName) and its logic Script.
class_name StateDefinition
extends Resource

@export var key: StringName
@export var state_script: Script


=====================================
FILE: ./src/core/data/config/world_config.gd
=====================================
# src/core/data/config/world_config.gd
@tool
## A configuration resource for Global World settings (Physics, Time, Juice).
class_name WorldConfig
extends Resource

@export_group("Physics")
@export_range(500, 3000, 10) var gravity: float = 1200.0

@export_group("Juice & Feedback (Hit-Stop)")
@export_range(0.0, 0.5, 0.01) var hit_stop_player_melee_close: float = 0.025
@export_range(0.0, 0.5, 0.01) var hit_stop_player_hurt: float = 0.04
@export_range(0.0, 1.0, 0.01) var hit_stop_boss_phase_change: float = 0.1
@export_range(0.0, 1.0, 0.01) var hit_stop_boss_death: float = 0.2


=====================================
FILE: ./src/core/data/config/enemy_config.gd
=====================================
# src/core/data/config/enemy_config.gd
@tool
## A configuration resource for Enemy stats (Bosses, Minions, Projectiles).
class_name EnemyConfig
extends Resource

@export_group("Boss - General")
@export_range(10, 500, 5) var boss_health: int = 30
@export_range(50, 500, 5) var boss_patrol_speed: float = 100.0

## Configuration for how the enemy reacts to taking damage.
@export var damage_response: DamageResponseConfig

@export_group("Boss - Attacks")
@export_range(500, 3000, 50) var boss_lunge_speed: float = 1200.0

@export_group("Projectiles")
@export_range(1, 20, 1) var homing_shot_damage: int = 1
@export_range(100, 1000, 10) var homing_shot_speed: float = 250.0
@export_range(1.0, 20.0, 0.5) var homing_shot_lifespan: float = 10.0
@export var projectile_muzzle_vfx: VFXEffect


=====================================
FILE: ./src/core/data/config/player_config.gd
=====================================
# src/core/data/config/player_config.gd
@tool
## A configuration resource for Player-specific stats and tuning.
class_name PlayerConfig
extends Resource

@export_group("Health & Resources")
@export_range(1, 20, 1) var max_health: int = 5
@export_range(1, 10, 1) var max_healing_charges: int = 1
@export_range(0.1, 5.0, 0.1) var heal_duration: float = 2.0
@export_range(1, 100, 1) var determination_per_charge: int = 5

## Configuration for how the player reacts to taking damage (Invincibility, Knockback force).
@export var damage_response: DamageResponseConfig

## How long the player loses control when hurt (StateHurt duration).
@export_range(0.05, 0.5, 0.01) var knockback_duration: float = 0.1

@export_group("Movement & Physics")
@export_range(100, 1000, 5) var move_speed: float = 450.0
@export_range(200, 1500, 10) var jump_force: float = 680.0
@export_range(0.1, 1.0, 0.05) var jump_release_dampener: float = 0.4
@export_range(0.0, 0.5, 0.01) var coyote_time: float = 0.1
@export_range(0.0, 0.5, 0.01) var jump_buffer: float = 0.1
@export_range(1.0, 3.0, 0.1) var fast_fall_gravity_multiplier: float = 1.4
@export var max_air_jumps: int = 1

@export_group("Wall Interaction")
@export_range(50, 500, 5) var wall_slide_speed: float = 120.0
@export_range(0.0, 0.5, 0.01) var wall_coyote_time: float = 0.05
@export_range(500, 2500, 50) var wall_jump_force_x: float = 1650.0
@export_range(200, 1500, 10) var wall_jump_force_y: float = 680.0

@export_group("Dash")
@export_range(500, 2500, 50) var dash_speed: float = 1400.0
@export_range(0.05, 0.5, 0.01) var dash_duration: float = 0.15
@export_range(0.1, 2.0, 0.05) var dash_cooldown: float = 0.5

@export_group("Combat")
@export var forward_attack_shape: Shape2D
@export var upward_attack_shape: Shape2D
@export_range(0.05, 1.0, 0.01) var attack_cooldown: float = 0.12
@export_range(0.05, 0.5, 0.01) var attack_duration: float = 0.1
@export_range(100, 5000, 100) var attack_friction: float = 2000.0
@export_range(0.1, 1.0, 0.01) var charge_time: float = 0.35
@export_range(1.0, 5.0, 0.01) var level_2_charge_time: float = 1.12
@export var level_2_damage: int = 3
@export_range(200, 1000, 10) var pogo_force: float = 450.0
@export_range(10, 200, 5) var close_range_threshold: float = 75.0

@export_group("Visual Effects")
@export var hit_spark_effect: VFXEffect
@export var vfx_charge_aura: PackedScene
@export var vfx_charge_splash: PackedScene
@export var vfx_heal_aura: PackedScene
@export var vfx_heal_splash: PackedScene
@export var vfx_dissolve: ShaderEffect
@export var vfx_melee_slash: PackedScene


=====================================
FILE: ./src/core/data/game_state_data.gd
=====================================
# src/core/data/game_state_data.gd
## A Resource that holds all shared runtime state for the game session.
class_name GameStateData
extends Resource

# --- Member Variables ---
## The full 'res://' path to the [EncounterData] resource for the current level.
var current_encounter_path: String = ""
## A reference to the fully constructed, but currently hidden, level node.
var prebuilt_level: Node = null


=====================================
FILE: ./src/core/data/audio/audio_cue.gd
=====================================
# src/core/data/audio/audio_cue.gd
@tool
## A wrapper resource for AudioStreams that adds randomization and mixing data.
## Allows sound designers to tune pitch/volume without modifying code.
class_name AudioCue
extends Resource

@export_group("Sound Source")
## The raw audio file or Randomizer to play.
@export var stream: AudioStream

@export_group("Mixing")
## Base volume offset in decibels.
@export_range(-80.0, 24.0, 0.1) var volume_db: float = 0.0
## Base pitch scale (1.0 is normal speed).
@export_range(0.1, 4.0, 0.01) var pitch_scale: float = 1.0
## Target AudioBus (e.g., "SFX", "Music", "UI").
@export var bus: StringName = &"SFX"

@export_group("Randomization")
## Random variance applied to pitch. A value of 0.1 means +/- 0.1.
@export_range(0.0, 1.0, 0.01) var pitch_randomness: float = 0.0


## Returns the final pitch value with randomization applied.
func get_pitch() -> float:
	if pitch_randomness > 0:
		return pitch_scale + randf_range(-pitch_randomness, pitch_randomness)
	return pitch_scale


=====================================
FILE: ./src/core/data/base_entity_data.gd
=====================================
# src/core/data/base_entity_data.gd
@tool
## The base data container for all entities in the game.
## Enforces the Liskov Substitution Principle for shared logic.
class_name BaseEntityData
extends Resource

# --- Dependencies ---
var services: ServiceLocator
## The specific configuration (PlayerConfig or EnemyConfig).
var config: Resource 
var world_config: WorldConfig

# --- Core State ---
var max_health: int = 1
var health: int = 1:
	set(value):
		health = clamp(value, 0, max_health)

var facing_direction: float = 1.0


=====================================
FILE: ./src/core/data/save_data.gd
=====================================
# src/core/data/save_data.gd
@tool
## A resource container for persistent player progression stats.
class_name SaveData
extends Resource

@export var total_wins: int = 0
@export var total_losses: int = 0


=====================================
FILE: ./src/core/data/effects/player_damage_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://player_damage_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 12.0
frequency = 35.0
duration = 0.3

=====================================
FILE: ./src/core/data/effects/dissolve_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://bps1fb52qcel8"]

[ext_resource type="Script" uid="uid://dci8r65dt2cj0" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="Material" uid="uid://bkiertsatpb34" path="res://src/content/materials/dissolve_material.tres" id="2_material"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_material")
duration = 0.7
priority = 10
target_scope = 0
params = {
"border_color": Color(1, 1, 1, 1),
"border_width": 0.02
}


=====================================
FILE: ./src/core/data/effects/boss_spawn_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_spawn_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 20.0
frequency = 20.0
duration = 0.4


=====================================
FILE: ./src/core/data/effects/boss_death_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_death_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 50.0
frequency = 25.0
duration = 1.0

=====================================
FILE: ./src/core/data/effects/player_hit_spark_effect.tres
=====================================
[gd_resource type="Resource" script_class="VFXEffect" load_steps=3 format=3 uid="uid://player_hit_spark_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/vfx_effect.gd" id="1_vfx_effect"]
[ext_resource type="PackedScene" uid="uid://c8g7f6e5d4b3a" path="res://src/content/vfx/hit_spark.tscn" id="2_hit_spark_scene"]

[resource]
script = ExtResource("1_vfx_effect")

; --- Configuration ---
scene = ExtResource("2_hit_spark_scene")
pool_key = &"hit_sparks"

=====================================
FILE: ./src/core/data/effects/boss_phase_change_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_phase_change_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 25.0
frequency = 12.0
duration = 0.8

=====================================
FILE: ./src/core/data/effects/screen_shake_effect.gd
=====================================
# src/core/data/effects/screen_shake_effect.gd
@tool
## A data resource that defines the properties of a screen shake effect.
##
## This allows for the creation of reusable, designer-tunable shake assets.
class_name ScreenShakeEffect
extends Resource

## The maximum offset in pixels. Higher values create a more intense shake.
@export_range(0.0, 100.0, 1.0) var amplitude: float = 10.0

## The speed of the shake. Higher values create a more frantic shake.
@export_range(0.1, 50.0, 0.1) var frequency: float = 15.0

## The total duration of the shake effect in seconds.
@export_range(0.1, 5.0, 0.05) var duration: float = 0.5


=====================================
FILE: ./src/core/data/effects/shader_effect.gd
=====================================
# src/core/data/effects/shader_effect.gd
@tool
## A data resource that defines a "recipe" for a shader-based visual effect.
##
## This allows the FXManager to treat shaders as reusable, configurable assets,
## just like particle effects or screen shakes.
class_name ShaderEffect
extends Resource

# --- Editor Properties ---
@export_group("Configuration")
## The actual ShaderMaterial resource to be applied.
@export var material: ShaderMaterial

## The duration of the effect in seconds. A value of 0 means it runs indefinitely
## until manually stopped.
@export_range(0.0, 5.0, 0.01) var duration: float = 0.15

## A dictionary of uniform parameters to be passed to the shader.
## Example: { "intensity": 1.0, "tint_color": Color.RED }
@export var params: Dictionary = {}

@export_group("Behavior")
## A priority level to resolve conflicts if multiple effects are triggered at once.
## Higher numbers have higher priority.
@export var priority: int = 0

@export_group("Performance")
## Minimum time in seconds before this effect can be triggered again on the same target.
## A value of 0 disables coalescing.
@export_range(0.0, 1.0, 0.01) var coalesce_window: float = 0.1

=====================================
FILE: ./src/core/data/effects/vfx_effect.gd
=====================================
# src/core/data/effects/vfx_effect.gd
@tool
## A data resource that defines a "recipe" for a visual effect.
##
## It tells the FXManager which scene to retrieve from which ObjectPool.
## This allows for the creation of reusable, data-driven visual effects.
class_name VFXEffect
extends Resource

## The PackedScene of the visual effect to be instanced from the pool.
@export var scene: PackedScene

## The StringName key for the ObjectPool where this VFX scene is stored.
@export var pool_key: StringName = &""


=====================================
FILE: ./src/core/DEPRECATION.md
=====================================
# Core Subsystem Deprecation Map

This document tracks file renames and moves specifically within `src/core`.

| Old Path | New Path | Reason | Date | Migration Note |
|---|---|---|---|---|
| `res://src/core/data/Config.gd` | `res://src/core/data/config/config.gd` | Naming convention and grouping. | 2025-08-10 | Autoload path was updated in `project.godot`. |
| `res://src/core/data/settings.gd` | `res://src/core/data/config/settings.gd` | Grouped with other data configs. | 2025-08-10 | Autoload path was updated in `project.godot`. |

=====================================
FILE: ./src/tests/unit/test_input_component.gd
=====================================
# src/tests/unit/test_input_component.gd
extends GutTest

# --- Constants ---
const InputComponent = preload("res://src/entities/_base/components/input_component.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const PlayerConfig = preload("res://src/data/player_config.tres")
const FakeInputProvider = preload("res://src/tests/fakes/fake_input_provider.gd")
# FIX: Correct path to Identifiers
const Identifiers = preload("res://src/core/util/identifiers.gd")

# --- Test Internals ---
var _input_component: InputComponent
var _fake_input: FakeInputProvider
var _mock_owner: CharacterBody2D

# --- Test Lifecycle ---
func before_each():
	_mock_owner = CharacterBody2D.new()
	add_child_autofree(_mock_owner)

	_input_component = InputComponent.new()
	_mock_owner.add_child(_input_component)

	_fake_input = FakeInputProvider.new()

	var dependencies = {
		"data_resource": PlayerStateData.new(),
		"config": PlayerConfig,
		"input_provider": _fake_input
	}
	_input_component.setup(_mock_owner, dependencies)

# --- The Tests ---

func test_move_axis_is_buffered_correctly() -> void:
	# 1. Test Right
	_fake_input.set_axis(Identifiers.Actions.MOVE_LEFT, Identifiers.Actions.MOVE_RIGHT, 1.0)
	_input_component._physics_process(0.016)
	assert_eq(_input_component.input.move_axis, 1.0, "Move axis should be 1.0 for Right.")

	# 2. Test Left
	_fake_input.set_axis(Identifiers.Actions.MOVE_LEFT, Identifiers.Actions.MOVE_RIGHT, -1.0)
	_input_component._physics_process(0.016)
	assert_eq(_input_component.input.move_axis, -1.0, "Move axis should be -1.0 for Left.")

	# 3. Test Neutral
	_fake_input.set_axis(Identifiers.Actions.MOVE_LEFT, Identifiers.Actions.MOVE_RIGHT, 0.0)
	_input_component._physics_process(0.016)
	assert_eq(_input_component.input.move_axis, 0.0, "Move axis should be 0.0 when neutral.")

func test_action_just_pressed_is_buffered() -> void:
	# Press
	_fake_input.set_action_just_pressed(Identifiers.Actions.JUMP, true)
	_input_component._physics_process(0.016)
	assert_true(_input_component.input.jump_just_pressed, "jump_just_pressed should be true.")

	# Next Frame (Released)
	_fake_input.set_action_just_pressed(Identifiers.Actions.JUMP, false)
	_input_component._physics_process(0.016)
	assert_false(_input_component.input.jump_just_pressed, "jump_just_pressed should be false on next frame.")

func test_action_released_is_buffered() -> void:
	# Release
	_fake_input.set_action_just_released(Identifiers.Actions.ATTACK, true)
	_input_component._physics_process(0.016)
	assert_true(_input_component.input.attack_released, "attack_released should be true.")

	# Next Frame
	_fake_input.set_action_just_released(Identifiers.Actions.ATTACK, false)
	_input_component._physics_process(0.016)
	assert_false(_input_component.input.attack_released, "attack_released should be false on next frame.")

func test_action_held_persists_across_frames() -> void:
	# Frame 1: Pressed
	_fake_input.set_action_pressed(Identifiers.Actions.JUMP, true)
	_input_component._physics_process(0.016)
	assert_true(_input_component.input.jump_pressed, "jump_pressed should be true.")

	# Frame 2: Still Pressed
	_input_component._physics_process(0.016)
	assert_true(_input_component.input.jump_pressed, "jump_pressed should remain true.")

	# Frame 3: Released
	_fake_input.set_action_pressed(Identifiers.Actions.JUMP, false)
	_input_component._physics_process(0.016)
	assert_false(_input_component.input.jump_pressed, "jump_pressed should be false after release.")


=====================================
FILE: ./src/tests/unit/test_player_resource_component.gd
=====================================
# src/tests/unit/test_player_resource_component.gd
extends GutTest

# --- Constants ---
const PlayerResourceComponent = preload("res://src/entities/player/components/player_resource_component.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const PlayerConfig = preload("res://src/data/player_config.tres")
const EventCatalog = preload("res://src/core/events/event_catalog.gd")

# --- Test Internals ---
var _resource_component: PlayerResourceComponent
var _player_data: PlayerStateData
var _fake_event_bus # Will be created at runtime

# --- Test Lifecycle ---
func before_each():
	# 1. Instantiate fakes
	var FakeEventBusScript = load("res://src/tests/fakes/fake_event_bus.gd")
	_fake_event_bus = FakeEventBusScript.new()
	add_child_autofree(_fake_event_bus)

	var FakeServiceLocatorScript = load("res://src/tests/fakes/fake_service_locator.gd")
	var fake_services = FakeServiceLocatorScript.new()

	fake_services.mock_event_bus = _fake_event_bus
	add_child_autofree(fake_services)

	# 2. Setup test subject and its data
	var mock_owner = Node.new()
	add_child_autofree(mock_owner)
	_player_data = PlayerStateData.new()
	_player_data.config = PlayerConfig
	_player_data.combat.max_healing_charges = 3

	_resource_component = PlayerResourceComponent.new()
	mock_owner.add_child(_resource_component)

	# 3. Inject dependencies
	var dependencies = {
		"data_resource": _player_data,
		"services": fake_services,
		"event_bus": _fake_event_bus # FIX: Explicit injection required
	}
	_resource_component.setup(mock_owner, dependencies)

# --- The Tests ---
func test_on_damage_dealt_increments_determination():
	_player_data.combat.determination_counter = 0
	_resource_component.on_damage_dealt()
	assert_eq(_player_data.combat.determination_counter, 1, "Determination should increment by 1.")
	assert_false(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))

func test_healing_charge_gained_at_threshold():
	_player_data.combat.healing_charges = 0
	_player_data.combat.determination_counter = PlayerConfig.determination_per_charge - 1

	_resource_component.on_damage_dealt()

	assert_eq(_player_data.combat.healing_charges, 1, "Should gain 1 healing charge at the threshold.")
	assert_eq(_player_data.combat.determination_counter, 0, "Determination should reset to 0.")
	assert_true(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))
	var payload = _fake_event_bus.get_payload_for_event(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED)
	assert_eq(payload.current_charges, 1, "Event payload should contain the new charge count.")

func test_healing_charges_are_capped():
	_player_data.combat.healing_charges = _player_data.combat.max_healing_charges
	_player_data.combat.determination_counter = PlayerConfig.determination_per_charge - 1
	_resource_component.on_damage_dealt()

	assert_eq(_player_data.combat.healing_charges, _player_data.combat.max_healing_charges, "Charges should not exceed max.")
	assert_eq(
		_player_data.combat.determination_counter,
		PlayerConfig.determination_per_charge - 1,
		"Determination should not increment if charges are max."
	)
	assert_false(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))

func test_consume_charge_decrements_and_emits_event():
	_player_data.combat.healing_charges = _player_data.combat.max_healing_charges # Starts at 3
	_resource_component.consume_healing_charge()
	assert_eq(_player_data.combat.healing_charges, 2, "Healing charges should decrement by 1.")
	assert_true(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))
	var payload = _fake_event_bus.get_payload_for_event(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED)
	assert_eq(payload.current_charges, 2, "Event payload should contain the correct new charge count.")

func test_consume_charge_does_nothing_at_zero():
	_player_data.combat.healing_charges = 0
	_resource_component.consume_healing_charge()
	assert_eq(_player_data.combat.healing_charges, 0, "Healing charges should remain 0.")
	assert_false(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))


=====================================
FILE: ./src/tests/unit/test_health_component.gd
=====================================
# src/tests/unit/test_health_component.gd
extends GutTest

# --- Constants ---
const HealthComponent = preload("res://src/entities/_base/components/health_component.gd")
const StatusEffectComponent = preload("res://src/entities/_base/components/status_effect_component.gd") # FIX: Added
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const DamageInfo = preload("res://src/shared/types/damage_info.gd")
const PlayerConfig = preload("res://src/data/player_config.tres")
const DamageResponseConfig = preload("res://src/core/data/config/damage_response_config.gd")
const VFXEffect = preload("res://src/core/data/effects/vfx_effect.gd")
const FakeServiceLocator = preload("res://src/tests/fakes/fake_service_locator.gd")
const IFXManager = preload("res://src/shared/interfaces/IFXManager.gd")
const Identifiers = preload("res://src/core/util/identifiers.gd")

# --- Test Internals ---
var _health_component: HealthComponent
var _status_component: StatusEffectComponent # FIX: Added
var _player_data: PlayerStateData
var _mock_owner: CharacterBody2D
var _died_signal_was_emitted: bool
var _took_damage_signal_was_emitted: bool
var _fake_services: FakeServiceLocator
var _fx_manager_double

func before_each() -> void:
	_died_signal_was_emitted = false
	_took_damage_signal_was_emitted = false

	# 1. Create a double for the FXManager interface
	_fx_manager_double = double(IFXManager).new()
	stub(_fx_manager_double, "play_vfx").to_do_nothing()
	add_child_autofree(_fx_manager_double)

	# 2. Create our robust FakeServiceLocator and inject the double
	_fake_services = FakeServiceLocator.new()
	_fake_services.mock_fx_manager = _fx_manager_double
	# We also need a real (or fake) EventBus for HealthComponent
	_fake_services.mock_event_bus = preload("res://src/tests/fakes/fake_event_bus.gd").new()
	add_child_autofree(_fake_services.mock_event_bus)
	add_child_autofree(_fake_services)

	# 3. Setup test subject
	_mock_owner = CharacterBody2D.new()
	_mock_owner.add_to_group(Identifiers.Groups.PLAYER)
	add_child_autofree(_mock_owner)

	_player_data = PlayerStateData.new()
	_player_data.config = PlayerConfig
	_player_data.max_health = 10
	_player_data.health = 10

	_health_component = HealthComponent.new()
	_mock_owner.add_child(_health_component)
	
	# FIX: Add StatusEffectComponent to owner
	_status_component = StatusEffectComponent.new()
	_mock_owner.add_child(_status_component)

	var vfx = VFXEffect.new()
	vfx.pool_key = "test_hit_spark"
	
	var damage_config = DamageResponseConfig.new()
	damage_config.invincibility_duration = 1.0
	damage_config.knockback_speed = 100.0

	var dependencies = {
		"data_resource": _player_data,
		"config": PlayerConfig,
		"damage_config": damage_config,
		"services": _fake_services,
		"hit_spark_effect": vfx,
		"event_bus": _fake_services.event_bus,
		"fx_manager": _fake_services.fx_manager,
		"status_effect_component": _status_component # FIX: Inject
	}
	_health_component.setup(_mock_owner, dependencies)

	_health_component.died.connect(func(): _died_signal_was_emitted = true)
	_health_component.took_damage.connect(func(_d, _r): _took_damage_signal_was_emitted = true)


# --- The Tests ---
func test_initial_health_is_max_health():
	assert_eq(_player_data.health, 10, "Health should be max health at start.")

func test_apply_damage_reduces_health_and_emits_signal():
	var damage_info = DamageInfo.new()
	damage_info.amount = 3
	var result = _health_component.apply_damage(damage_info)

	assert_true(result.was_damaged, "Result object should indicate damage was taken.")
	assert_eq(_player_data.health, 7, "Health should be reduced by 3.")
	assert_true(_took_damage_signal_was_emitted, "'took_damage' signal should have been emitted.")

func test_cannot_take_damage_when_invincible():
	var damage_info = DamageInfo.new()
	damage_info.amount = 1
	_health_component.apply_damage(damage_info)

	assert_true(_health_component.is_invincible(), "Component should be invincible after first hit.")

	_took_damage_signal_was_emitted = false
	var result = _health_component.apply_damage(damage_info)

	assert_false(result.was_damaged, "Should not be able to take damage while invincible.")
	assert_eq(_player_data.health, 9, "Health should not have changed on second hit.")
	assert_false(_took_damage_signal_was_emitted, "'took_damage' should not be emitted when invincible.")

func test_died_signal_emitted_at_zero_health():
	var damage_info = DamageInfo.new()
	damage_info.amount = 10
	_health_component.apply_damage(damage_info)

	assert_true(_died_signal_was_emitted, "The 'died' signal should have been emitted.")
	assert_eq(_player_data.health, 0, "Health should be 0 after lethal damage.")


=====================================
FILE: ./src/tests/unit/test_idamageable_contract.gd
=====================================
# src/tests/unit/test_idamageable_contract.gd
extends GutTest

# --- Constants & Preloads ---
const HealthComponent = preload("res://src/entities/_base/components/health_component.gd")
const StatusEffectComponent = preload("res://src/entities/_base/components/status_effect_component.gd") # FIX
const FakeDamageable = preload("res://src/tests/fakes/fake_damageable.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const DamageInfo = preload("res://src/shared/types/damage_info.gd")
const FakeServiceLocator = preload("res://src/tests/fakes/fake_service_locator.gd")
const FakeEventBus = preload("res://src/tests/fakes/fake_event_bus.gd")
const IFXManager = preload("res://src/shared/interfaces/IFXManager.gd")
const DamageResponseConfig = preload("res://src/core/data/config/damage_response_config.gd")

# --- Test Internals ---
var _mock_owner: CharacterBody2D
var _fake_services: FakeServiceLocator
var _fx_manager_double

# --- Test Lifecycle ---
func before_each():
	_mock_owner = CharacterBody2D.new()
	add_child_autofree(_mock_owner)
	
	_fake_services = FakeServiceLocator.new()
	
	# FIX: Setup mocks
	_fake_services.mock_event_bus = FakeEventBus.new()
	add_child_autofree(_fake_services.mock_event_bus)
	
	_fx_manager_double = double(IFXManager).new()
	stub(_fx_manager_double, "play_vfx").to_do_nothing()
	add_child_autofree(_fx_manager_double)
	_fake_services.mock_fx_manager = _fx_manager_double
	
	add_child_autofree(_fake_services)

# --- The Contract Test Suite ---

func _run_contract_tests(damageable: IDamageable, name: String) -> void:
	# Contract Rule 1: It must return a valid DamageResult object.
	var result = damageable.apply_damage(DamageInfo.new())
	assert_is(result, DamageResult, "Contract Failure (%s): apply_damage must return a DamageResult." % name)
	
	# Contract Rule 2: It must not crash when given a null DamageInfo.
	var null_result = damageable.apply_damage(null)
	assert_is(null_result, DamageResult, "Contract Failure (%s): Must handle null DamageInfo gracefully." % name)


# --- The Tests ---

func test_health_component_fulfills_contract():
	var health_comp = HealthComponent.new()
	_mock_owner.add_child(health_comp)
	
	# FIX: Add required StatusEffectComponent
	var status_comp = StatusEffectComponent.new()
	_mock_owner.add_child(status_comp)
	
	var data = PlayerStateData.new()
	data.max_health = 10
	
	var dmg_config = DamageResponseConfig.new()
	
	var deps = {
		"data_resource": data,
		"config": preload("res://src/data/player_config.tres"),
		"services": _fake_services,
		"hit_spark_effect": preload("res://src/core/data/effects/player_hit_spark_effect.tres"),
		# FIX: Explicitly provide new required dependencies
		"fx_manager": _fake_services.fx_manager,
		"event_bus": _fake_services.event_bus,
		"damage_config": dmg_config,
		"status_effect_component": status_comp
	}
	health_comp.setup(_mock_owner, deps)
	
	_run_contract_tests(health_comp, "HealthComponent")


func test_fake_damageable_fulfills_contract():
	var fake_damageable = FakeDamageable.new()
	_mock_owner.add_child(fake_damageable)
	
	_run_contract_tests(fake_damageable, "FakeDamageable")


=====================================
FILE: ./src/tests/unit/test_combat_utils.gd
=====================================
# src/tests/unit/test_combat_utils.gd
extends GutTest

# --- Constants ---
const BaseEntity = preload("res://src/entities/_base/scripts/base_entity.gd")
const HealthComponent = preload("res://src/entities/_base/components/health_component.gd")
const IDamageable = preload("res://src/shared/interfaces/IDamageable.gd")
const EntityArchetype = preload("res://src/entities/archetypes/entity_archetype.gd")

# --- Test Internals ---
var _combat_utils
var _mock_entity: BaseEntity
var _health_component: HealthComponent
var _non_damageable_child: Node

# --- Test Lifecycle ---

func before_all():
	_combat_utils = get_node("/root/CombatUtils")


func before_each():
	# Create a scene tree: MockEntity -> HealthComponent
	#                                -> NonDamageableChild
	_mock_entity = BaseEntity.new()
	# Provide a dummy archetype to prevent errors in _ready().
	_mock_entity.archetype = EntityArchetype.new()
	add_child_autofree(_mock_entity)

	_health_component = HealthComponent.new()
	_mock_entity.add_child(_health_component)
	_mock_entity._cache_components_by_type()

	_non_damageable_child = Node2D.new()
	_mock_entity.add_child(_non_damageable_child)


# --- The Tests ---

func test_find_damageable_returns_component_when_starting_from_entity():
	var result = _combat_utils.find_damageable(_mock_entity)
	assert_same(
		result,
		_health_component,
		"Should find the IDamageable component when starting from the entity root."
	)


func test_find_damageable_returns_component_when_starting_from_child():
	var result = _combat_utils.find_damageable(_non_damageable_child)
	assert_same(
		result,
		_health_component,
		"Should traverse up to the entity root and find the component when starting from a child."
	)


func test_find_damageable_returns_null_if_no_entity_ancestor_exists():
	var standalone_node = Node2D.new()
	add_child_autofree(standalone_node)
	var result = _combat_utils.find_damageable(standalone_node)
	assert_null(result, "Should return null when no BaseEntity ancestor is found.")

=====================================
FILE: ./src/tests/fakes/fake_event_bus.gd
=====================================
# src/tests/fakes/fake_event_bus.gd
## A test-double (fake) that inherits from EventBus to satisfy type checks,
## but provides custom recording logic for use in unit tests.
class_name FakeEventBus
extends "res://src/core/events/event_bus.gd"

var _emitted_events: Array[Dictionary] = []

func _ready() -> void:
	# Override parent's _ready to be a no-op in a test environment.
	pass

## Records an emitted event for later inspection instead of dispatching it.
func emit(event_name: StringName, payload = null) -> void:
	_emitted_events.append({"name": event_name, "payload": payload})

## Clears all recorded events.
func clear() -> void:
	_emitted_events.clear()

## Checks if a specific event was emitted.
func was_event_emitted(event_name: StringName) -> bool:
	for event in _emitted_events:
		if event.name == event_name:
			return true
	return false

## Returns the payload of the first event found with the given name.
func get_payload_for_event(event_name: StringName) -> Variant:
	for event in _emitted_events:
		if event.name == event_name:
			return event.payload
	return null

=====================================
FILE: ./src/tests/fakes/fake_service_locator.gd
=====================================
# src/tests/fakes/fake_service_locator.gd
## A test-double for the ServiceLocator singleton.
## It inherits from the real ServiceLocator to satisfy type checks but overrides
## _ready() to prevent it from looking for other singletons and to allow
## injecting fakes over the real @onready properties.
class_name FakeServiceLocator
extends "res://src/core/util/service_locator.gd"

# --- Fake Service Properties ---
var mock_event_bus: Node
var mock_fx_manager: Node
var mock_object_pool: Node
var mock_combat_utils: Node


func _ready() -> void:
	# This _ready function is crucial. It overrides the parent's _ready,
	# preventing it from failing.
	
	# After the parent's @onready vars have been populated with real singletons,
	# we now overwrite them with our mocks for the test.
	if is_instance_valid(mock_event_bus):
		self.event_bus = mock_event_bus
	if is_instance_valid(mock_fx_manager):
		self.fx_manager = mock_fx_manager
	if is_instance_valid(mock_object_pool):
		self.object_pool = mock_object_pool
	if is_instance_valid(mock_combat_utils):
		self.combat_utils = mock_combat_utils

=====================================
FILE: ./src/tests/fakes/fake_input_provider.gd
=====================================
# src/tests/fakes/fake_input_provider.gd
## A test double for IInputProvider.
## Allows unit tests to manually set input state without touching the global Input singleton.
class_name FakeInputProvider
extends IInputProvider

var _pressed_actions: Dictionary = {}
var _just_pressed_actions: Dictionary = {}
var _just_released_actions: Dictionary = {}
var _axes: Dictionary = {}

# --- Setup Methods (Test API) ---

func set_action_pressed(action: StringName, pressed: bool) -> void:
	_pressed_actions[action] = pressed

func set_action_just_pressed(action: StringName, pressed: bool) -> void:
	_just_pressed_actions[action] = pressed
	if pressed:
		_pressed_actions[action] = true

func set_action_just_released(action: StringName, released: bool) -> void:
	_just_released_actions[action] = released
	if released:
		_pressed_actions[action] = false

func set_axis(negative: StringName, positive: StringName, value: float) -> void:
	var key = "%s_%s" % [negative, positive]
	_axes[key] = value

func clear() -> void:
	_pressed_actions.clear()
	_just_pressed_actions.clear()
	_just_released_actions.clear()
	_axes.clear()

# --- Interface Implementation ---

func get_axis(negative_action: StringName, positive_action: StringName) -> float:
	var key = "%s_%s" % [negative_action, positive_action]
	return _axes.get(key, 0.0)

func is_action_pressed(action: StringName) -> bool:
	return _pressed_actions.get(action, false)

func is_action_just_pressed(action: StringName) -> bool:
	return _just_pressed_actions.get(action, false)

func is_action_just_released(action: StringName) -> bool:
	return _just_released_actions.get(action, false)


=====================================
FILE: ./src/tests/fakes/fake_damageable.gd
=====================================
# src/tests/fakes/fake_damageable.gd
## A test-double (fake) that implements the IDamageable interface for use in unit tests.
## It records damage events and allows tests to inspect what happened.
class_name FakeDamageable
extends IDamageable

# --- Test Seams & Recorders ---
var was_damage_applied: bool = false
var last_damage_info: DamageInfo = null
var return_result: DamageResult = DamageResult.new() # Pre-configured result to return


func setup(_p_owner: Node, _p_dependencies: Dictionary = {}) -> void:
	# IComponent contract requires this method.
	pass


func teardown() -> void:
	# IComponent contract requires this method.
	pass


func apply_damage(damage_info: DamageInfo) -> DamageResult:
	was_damage_applied = true
	last_damage_info = damage_info
	return return_result


## Resets the state of the fake for the next test.
func reset() -> void:
	was_damage_applied = false
	last_damage_info = null
	return_result = DamageResult.new()


=====================================
FILE: ./src/content/materials/chromatic_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://chromatic_material"]

[ext_resource type="Shader" path="res://src/content/shaders/fullscreen/chromatic_aberration.gdshader" id="1_shader"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/offset_strength = 10.0
shader_parameter/fx_progress = 0.0


=====================================
FILE: ./src/content/materials/dissolve_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=3 format=3 uid="uid://bkiertsatpb34"]

[ext_resource type="Shader" uid="uid://bjx4w0wd5cbl" path="res://src/content/shaders/entity/dissolve.gdshader" id="1_shader"]
[ext_resource type="Texture2D" uid="uid://07p7ttqtioqu" path="res://assets/textures/noise_texture.tres" id="2_noise"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/noise_texture = ExtResource("2_noise")
shader_parameter/fx_progress = 0.0
shader_parameter/border_color = Color(1, 1, 1, 1)
shader_parameter/border_width = 0.02


=====================================
FILE: ./src/content/materials/vignette_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://vignette_material"]

[ext_resource type="Shader" path="res://src/content/shaders/fullscreen/vignette.gdshader" id="1_shader"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/vignette_color = Color(0.5, 0, 0, 1)
shader_parameter/intensity = 0.0
shader_parameter/pulse_speed = 3.0


=====================================
FILE: ./src/content/materials/entity_hit_flash_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://entity_hit_flash_mat"]

[ext_resource type="Shader" path="res://src/content/shaders/entity/red_hit_flash_test.gdshader" id="1_shader"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/fx_progress = 0.0
shader_parameter/tint_color = Color(1, 0, 0, 1)

=====================================
FILE: ./src/content/materials/shockwave_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://shockwave_material"]

[ext_resource type="Shader" path="res://src/content/shaders/fullscreen/shockwave.gdshader" id="1_shader"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/center = Vector2(0.5, 0.5)
shader_parameter/force = 0.02
shader_parameter/fx_progress = 0.0
shader_parameter/thickness = 0.1


=====================================
FILE: ./src/content/vfx/splash_impact_red.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://splash_impact_red"]

[ext_resource type="Script" path="res://src/content/vfx/hit_spark.gd" id="1_script"]

[sub_resource type="Gradient" id="Gradient_red"]
colors = PackedColorArray(1, 0.2, 0.2, 1, 0.8, 0, 0, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_red"]
gradient = SubResource("Gradient_red")

[sub_resource type="Curve" id="Curve_explode"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), -2.5, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_explode"]
curve = SubResource("Curve_explode")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_red_splash"]
particle_flag_disable_z = true
spread = 180.0
initial_velocity_min = 80.0
initial_velocity_max = 180.0
gravity = Vector3(0, 0, 0)
damping_min = 400.0
damping_max = 400.0
scale_min = 1.0
scale_max = 2.5
scale_curve = SubResource("CurveTexture_explode")
color_ramp = SubResource("GradientTexture1D_red")

[node name="SplashImpactRed" type="GPUParticles2D"]
emitting = false
amount = 12
process_material = SubResource("ParticleProcessMaterial_red_splash")
lifetime = 0.3
one_shot = true
explosiveness = 1.0
script = ExtResource("1_script")
metadata/pool_name = &"red_splashes"


=====================================
FILE: ./src/content/vfx/melee_slash.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://melee_slash_vfx"]

[ext_resource type="Script" path="res://src/content/vfx/melee_slash.gd" id="1_script"]

[sub_resource type="Gradient" id="Gradient_green_swipe"]
colors = PackedColorArray(0, 0.4, 0, 1, 0.4, 1, 0.4, 1)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_swipe"]
gradient = SubResource("Gradient_green_swipe")
width = 1
height = 1
fill_from = Vector2(0, 0)
fill_to = Vector2(1, 0)

[node name="MeleeSlash" type="Node2D"]
script = ExtResource("1_script")

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = SubResource("GradientTexture2D_swipe")


=====================================
FILE: ./src/content/vfx/splash_charge_green.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://splash_charge_green"]

[ext_resource type="Script" path="res://src/content/vfx/hit_spark.gd" id="1_script"]

[sub_resource type="Gradient" id="Gradient_splash"]
colors = PackedColorArray(0.5, 1, 0.5, 1, 0, 0.5, 0, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_splash"]
gradient = SubResource("Gradient_splash")

[sub_resource type="Curve" id="Curve_explode"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), -2.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_explode"]
curve = SubResource("Curve_explode")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_splash"]
particle_flag_disable_z = true
spread = 180.0
initial_velocity_min = 150.0
initial_velocity_max = 300.0
gravity = Vector3(0, 0, 0)
damping_min = 500.0
damping_max = 500.0
scale_min = 3.0
scale_max = 6.0
scale_curve = SubResource("CurveTexture_explode")
color_ramp = SubResource("GradientTexture1D_splash")

[node name="ChargeSplashGreen" type="GPUParticles2D"]
emitting = false
amount = 20
process_material = SubResource("ParticleProcessMaterial_splash")
lifetime = 0.4
one_shot = true
explosiveness = 1.0
script = ExtResource("1_script")
metadata/pool_name = &"hit_sparks" 
# Note: Reusing hit_sparks logic/interface even if not in that pool, 
# strictly for the 'finished' signal handling if used directly.


=====================================
FILE: ./src/content/vfx/splash_heal_purple.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://splash_heal_purple"]

[ext_resource type="Script" path="res://src/content/vfx/hit_spark.gd" id="1_script"]

[sub_resource type="Gradient" id="Gradient_burst"]
offsets = PackedFloat32Array(0, 0.6, 1)
colors = PackedColorArray(1, 1, 1, 1, 0.7, 0.3, 1, 1, 0.2, 0, 0.4, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_burst"]
gradient = SubResource("Gradient_burst")

[sub_resource type="Curve" id="Curve_burst"]
_data = [Vector2(0, 0.5), 0.0, 3.0, 0, 0, Vector2(0.2, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), -2.0, 0.0, 0, 0]
point_count = 3

[sub_resource type="CurveTexture" id="CurveTexture_burst"]
curve = SubResource("Curve_burst")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_burst"]
particle_flag_disable_z = true
emission_shape = 1
emission_sphere_radius = 10.0
direction = Vector3(0, -1, 0)
spread = 180.0
initial_velocity_min = 100.0
initial_velocity_max = 200.0
gravity = Vector3(0, 0, 0)
scale_min = 4.0
scale_max = 8.0
scale_curve = SubResource("CurveTexture_burst")
color_ramp = SubResource("GradientTexture1D_burst")

[node name="HealSplashPurple" type="GPUParticles2D"]
emitting = false
amount = 50
process_material = SubResource("ParticleProcessMaterial_burst")
lifetime = 0.6
one_shot = true
explosiveness = 0.9
script = ExtResource("1_script")


=====================================
FILE: ./src/content/vfx/hit_spark.gd
=====================================
# src/vfx/hit_spark.gd
## A self-cleaning, poolable particle effect for hit sparks.
class_name HitSpark
extends GPUParticles2D

var _services


# --- Godot Lifecycle Methods ---


func _ready() -> void:
	self.finished.connect(_on_finished)


# --- Public Methods (IPoolable Contract) ---


## Activates the particle effect.
func activate(dependencies: Dictionary) -> void:
	_services = dependencies.get("services")
	assert(is_instance_valid(_services), "HitSpark requires a ServiceLocator dependency.")
	var direction = dependencies.get("direction", Vector2.RIGHT)

	process_mode = PROCESS_MODE_INHERIT
	visible = true
	self.rotation = direction.angle()
	restart()


## Deactivates the particle effect.
func deactivate() -> void:
	process_mode = PROCESS_MODE_DISABLED
	visible = false
	_services = null


# --- Signal Handlers ---


func _on_finished() -> void:
	if not is_instance_valid(_services):
		# This might happen if deactivated during a scene transition.
		return

	_services.object_pool.return_instance(self)

=====================================
FILE: ./src/content/vfx/hit_spark.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://c8g7f6e5d4b3a"]

[ext_resource type="Script" path="res://src/content/vfx/hit_spark.gd" id="1_hit_spark_script"]

[sub_resource type="Gradient" id="Gradient_1"]
offsets = PackedFloat32Array(0, 0.18, 0.65, 1)
colors = PackedColorArray(1, 1, 1, 1, 0.4, 1, 0.4, 1, 0.1, 0.6, 0.1, 1, 0, 0.2, 0, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_1"]
gradient = SubResource("Gradient_1")

[sub_resource type="Curve" id="Curve_1"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), 0.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_1"]
curve = SubResource("Curve_1")

[sub_resource type="Gradient" id="Gradient_2"]
colors = PackedColorArray(0.7, 1, 0.7, 1, 0.2, 1, 0.2, 1)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_2"]
gradient = SubResource("Gradient_2")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_1"]
particle_flag_disable_z = true
emission_shape = 1
emission_sphere_radius = 2.0
direction = Vector3(1, 0, 0)
spread = 180.0
initial_velocity_min = 200.0
initial_velocity_max = 500.0
gravity = Vector3(0, 0, 0)
damping_min = 800.0
damping_max = 1200.0
scale_min = 2.0
scale_max = 4.0
scale_curve = SubResource("CurveTexture_1")
color_ramp = SubResource("GradientTexture1D_1")
color_initial_ramp = SubResource("GradientTexture1D_2")

[node name="HitSpark" type="GPUParticles2D"]
emitting = false
amount = 24
process_material = SubResource("ParticleProcessMaterial_1")
lifetime = 0.4
one_shot = true
explosiveness = 1.0
fixed_fps = 60
script = ExtResource("1_hit_spark_script")
metadata/pool_name = &"hit_sparks"


=====================================
FILE: ./src/content/vfx/aura_charge_green.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://aura_charge_green"]

[sub_resource type="Gradient" id="Gradient_green"]
offsets = PackedFloat32Array(0, 0.2, 0.8, 1)
colors = PackedColorArray(0.8, 1, 0.8, 1, 0, 1, 0.2, 1, 0, 0.6, 0.1, 0.8, 0, 0.2, 0, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_green"]
gradient = SubResource("Gradient_green")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_aura"]
particle_flag_disable_z = true
emission_shape = 3
emission_box_extents = Vector3(25, 45, 1)
direction = Vector3(0, -1, 0)
spread = 180.0
initial_velocity_min = 20.0
initial_velocity_max = 60.0
gravity = Vector3(0, 0, 0)
radial_velocity_min = -100.0
radial_velocity_max = -20.0
tangential_accel_min = 50.0
tangential_accel_max = 100.0
scale_min = 2.0
scale_max = 5.0
color_ramp = SubResource("GradientTexture1D_green")
turbulence_enabled = true
turbulence_noise_strength = 10.0
turbulence_noise_scale = 5.0
turbulence_noise_speed_min = 2.0
turbulence_noise_speed_max = 4.0

[node name="ChargeAuraGreen" type="GPUParticles2D"]
amount = 80
process_material = SubResource("ParticleProcessMaterial_aura")
lifetime = 0.2
fixed_fps = 60
local_coords = true


=====================================
FILE: ./src/content/vfx/aura_heal_purple.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://aura_heal_purple"]

[sub_resource type="Gradient" id="Gradient_purple"]
offsets = PackedFloat32Array(0, 0.1, 0.7, 1)
colors = PackedColorArray(0.8, 0.6, 1, 1, 0.6, 0.2, 1, 1, 0.3, 0, 0.6, 0.8, 0.1, 0, 0.2, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_purple"]
gradient = SubResource("Gradient_purple")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_heal"]
particle_flag_disable_z = true
emission_shape = 3
emission_box_extents = Vector3(30, 50, 1)
direction = Vector3(0, -1, 0)
spread = 0.0
initial_velocity_min = 150.0
initial_velocity_max = 250.0
gravity = Vector3(0, 0, 0)
linear_accel_min = 50.0
linear_accel_max = 100.0
scale_min = 2.0
scale_max = 6.0
color_ramp = SubResource("GradientTexture1D_purple")
turbulence_enabled = true
turbulence_noise_strength = 8.0
turbulence_noise_scale = 3.0
turbulence_noise_speed = Vector3(0, 5, 0)

[node name="HealAuraPurple" type="GPUParticles2D"]
amount = 100
process_material = SubResource("ParticleProcessMaterial_heal")
lifetime = 0.4
fixed_fps = 60
local_coords = true


=====================================
FILE: ./src/content/vfx/splash_impact_red_large.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://splash_impact_red_large"]

[ext_resource type="Script" path="res://src/content/vfx/hit_spark.gd" id="1_script"]

[sub_resource type="Gradient" id="Gradient_red"]
colors = PackedColorArray(1, 0.2, 0.2, 1, 0.8, 0, 0, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_red"]
gradient = SubResource("Gradient_red")

[sub_resource type="Curve" id="Curve_explode"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), -2.5, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_explode"]
curve = SubResource("Curve_explode")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_red_splash_lg"]
particle_flag_disable_z = true
spread = 180.0
initial_velocity_min = 150.0
initial_velocity_max = 350.0
gravity = Vector3(0, 0, 0)
damping_min = 300.0
damping_max = 300.0
scale_min = 3.0
scale_max = 6.0
scale_curve = SubResource("CurveTexture_explode")
color_ramp = SubResource("GradientTexture1D_red")

[node name="SplashImpactRedLarge" type="GPUParticles2D"]
emitting = false
amount = 24
process_material = SubResource("ParticleProcessMaterial_red_splash_lg")
lifetime = 0.45
one_shot = true
explosiveness = 1.0
script = ExtResource("1_script")
metadata/pool_name = &"red_splashes_large"


=====================================
FILE: ./src/content/vfx/melee_slash.gd
=====================================
# src/content/vfx/melee_slash.gd
extends Node2D

@onready var sprite = $Sprite2D

func setup(size: Vector2, duration: float) -> void:
	# Texture is 1x1, so scale matches desired pixel size
	sprite.scale = size
	
	var tween = create_tween()
	# Fade alpha to 0
	tween.tween_property(sprite, "modulate:a", 0.0, duration).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_IN)
	tween.tween_callback(queue_free)


=====================================
FILE: ./src/content/shaders/entity/dissolve.gdshader
=====================================
// shaders/entity/dissolve.gdshader
shader_type canvas_item;

uniform sampler2D noise_texture;
uniform float fx_progress : hint_range(0.0, 1.0);
uniform vec4 border_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
uniform float border_width : hint_range(0.0, 0.1) = 0.02;

void fragment() {
	vec4 original_color = COLOR;
	// Sample the noise texture using screen-space UVs, which are
	// always available, instead of local UVs, which Polygon2D does not have.
	float noise_value = texture(noise_texture, SCREEN_UV).r;

	if (noise_value < fx_progress) {
		discard;
	} else if (noise_value < fx_progress + border_width) {
		COLOR = border_color;
	} else {
		COLOR = original_color;
	}
}

=====================================
FILE: ./src/content/shaders/entity/red_hit_flash_test.gdshader
=====================================
// shaders/entity/red_hit_flash_test.gdshader
shader_type canvas_item;

uniform vec4 tint_color : source_color = vec4(1.0, 0.0, 0.0, 1.0);
// The effect's progress, from 0.0 (start) to 1.0 (end).
uniform float fx_progress : hint_range(0.0, 1.0);

void fragment() {
    // Get the base color from the ColorRect
    vec4 original_color = COLOR;
    
    // As fx_progress goes from 0 to 1, intensity goes from 1 to 0.
    float intensity = 1.0 - fx_progress;
    
    // Mix the original color with the tint color
    vec3 mixed_rgb = mix(original_color.rgb, tint_color.rgb, intensity);
    
    // Apply the mixed color, preserving the original alpha
    COLOR = vec4(mixed_rgb, original_color.a);
}

=====================================
FILE: ./src/content/shaders/fullscreen/shockwave.gdshader
=====================================
shader_type canvas_item;

uniform vec2 center = vec2(0.5, 0.5);
uniform float force : hint_range(0.0, 0.5) = 0.05;
uniform float fx_progress : hint_range(0.0, 1.0) = 0.0;
uniform float thickness : hint_range(0.0, 0.5) = 0.1;

uniform sampler2D screen_texture : hint_screen_texture, filter_linear_mipmap;

void fragment() {
	// FIX: Optimization/Bugfix. If progress is 0, do no math, return original pixel.
	// This prevents the "center warping" artifact when the effect is idle.
	if (fx_progress <= 0.001) {
		COLOR = texture(screen_texture, SCREEN_UV);
	} else {
		float ratio = SCREEN_PIXEL_SIZE.x / SCREEN_PIXEL_SIZE.y;
		vec2 scaled_uv = (SCREEN_UV - vec2(0.5, 0.0)) / vec2(ratio, 1.0) + vec2(0.5, 0.0);
		vec2 scaled_center = (center - vec2(0.5, 0.0)) / vec2(ratio, 1.0) + vec2(0.5, 0.0);
		
		float dist = length(scaled_uv - scaled_center);
		
		float ripple_freq = 20.0; 
		float ripple = sin((dist - fx_progress) * ripple_freq);
		float mask = smoothstep(0.25, 0.0, abs(dist - fx_progress));
		float dist_scale = 1.0 + (dist * 2.0); 
		
		vec2 disp = normalize(scaled_uv - scaled_center) * ripple * force * mask * dist_scale;
		
		COLOR = texture(screen_texture, SCREEN_UV - disp);
	}
}


=====================================
FILE: ./src/content/shaders/fullscreen/vignette.gdshader
=====================================
shader_type canvas_item;

uniform vec4 vignette_color : source_color = vec4(0.7, 0.0, 0.0, 1.0);
uniform float intensity : hint_range(0.0, 1.0) = 0.0;
uniform float pulse_speed : hint_range(0.0, 10.0) = 3.0;

void fragment() {
	vec2 uv = SCREEN_UV - 0.5;
	float dist = length(uv);
	
	// FIX: Tightened gradient. 
	// Starts at 0.35 (near center) to ensure visibility.
	// Reaches full strength at 0.85 (visible corners). 
	// Previous was 1.2, which pushed the red too far off-screen.
	float mask = smoothstep(0.35, 0.85, dist);
	
	// Heartbeat Pulse Math
	float base_pulse = sin(TIME * pulse_speed);
	float heartbeat = pow(0.5 * (base_pulse + 1.0), 2.0); 
	
	float pulse_mod = 0.3 + (heartbeat * 0.7);
	
	vec4 output = vignette_color;
	output.a = mask * intensity * pulse_mod;
	
	COLOR = output;
}


=====================================
FILE: ./src/content/shaders/fullscreen/chromatic_aberration.gdshader
=====================================
shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, filter_linear_mipmap;
uniform float offset_strength : hint_range(0.0, 50.0) = 2.0;
uniform float fx_progress : hint_range(0.0, 1.0) = 0.0;

void fragment() {
	// Center Mask: Prevent warping in the middle of the screen
	float dist = length(SCREEN_UV - 0.5);
	// smoothstep(inner_radius, outer_radius, value)
	// This creates a hole in the center (0.0) blending to full strength (1.0) at the edges
	float center_mask = smoothstep(0.0, 0.6, dist);

	// Apply mask to intensity
	float intensity = fx_progress * offset_strength * center_mask;

	vec2 uv = SCREEN_UV;
	
	// Simple blur approximation: sample further apart for R/B channels
	vec4 red = texture(screen_texture, uv + vec2(SCREEN_PIXEL_SIZE.x * intensity, 0.0));
	vec4 green = texture(screen_texture, uv);
	vec4 blue = texture(screen_texture, uv - vec2(SCREEN_PIXEL_SIZE.x * intensity, 0.0));
	
	COLOR = vec4(red.r, green.g, blue.b, 1.0);
}


=====================================
FILE: ./src/content/levels/level_00.tscn
=====================================
[gd_scene load_steps=12 format=3 uid="uid://c6gxsalyacbd1"]

[ext_resource type="PackedScene" uid="uid://e0dt5jwwxndr" path="res://src/entities/enemies/spawners/patrolling_lancer_spawner.tscn" id="1_8girt"]
[ext_resource type="PackedScene" uid="uid://c1d2e3f4g5h6i" path="res://src/entities/enemies/minions/flying_patroller.tscn" id="4_ei412"]
[ext_resource type="PackedScene" uid="uid://c7d8faf0g1h2i" path="res://src/entities/enemies/minions/turret.tscn" id="13_5kto0"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_border"]
size = Vector2(50, 1440)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_ceiling"]
size = Vector2(2560, 50)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_floor_side"]
size = Vector2(800, 200)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_pit_wall"]
size = Vector2(50, 400)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_central_block"]
size = Vector2(200, 50)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_high_perch"]
size = Vector2(300, 50)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_oneway_bridge"]
size = Vector2(300, 20)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_spikes"]
size = Vector2(960, 50)

[node name="Level_00" type="Node2D"]

[node name="Background" type="ColorRect" parent="."]
z_index = -10
offset_right = 2560.0
offset_bottom = 1440.0
color = Color(0.0627451, 0.0627451, 0.0627451, 1)

[node name="Terrain" type="Node2D" parent="."]

[node name="LeftWall" type="StaticBody2D" parent="Terrain"]
position = Vector2(25, 720)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/LeftWall"]
shape = SubResource("RectangleShape2D_border")

[node name="Visual" type="Polygon2D" parent="Terrain/LeftWall"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-25, -720, 25, -720, 25, 720, -25, 720)

[node name="RightWall" type="StaticBody2D" parent="Terrain"]
position = Vector2(2535, 720)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/RightWall"]
shape = SubResource("RectangleShape2D_border")

[node name="Visual" type="Polygon2D" parent="Terrain/RightWall"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-25, -720, 25, -720, 25, 720, -25, 720)

[node name="Ceiling" type="StaticBody2D" parent="Terrain"]
position = Vector2(1280, 25)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/Ceiling"]
shape = SubResource("RectangleShape2D_ceiling")

[node name="Visual" type="Polygon2D" parent="Terrain/Ceiling"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-1280, -25, 1280, -25, 1280, 25, -1280, 25)

[node name="FloorLeft" type="StaticBody2D" parent="Terrain"]
position = Vector2(400, 1340)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/FloorLeft"]
shape = SubResource("RectangleShape2D_floor_side")

[node name="Visual" type="Polygon2D" parent="Terrain/FloorLeft"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-400, -100, 400, -100, 400, 100, -400, 100)

[node name="FloorRight" type="StaticBody2D" parent="Terrain"]
position = Vector2(2160, 1340)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/FloorRight"]
shape = SubResource("RectangleShape2D_floor_side")

[node name="Visual" type="Polygon2D" parent="Terrain/FloorRight"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-400, -100, 400, -100, 400, 100, -400, 100)

[node name="LeftPitWall" type="StaticBody2D" parent="Terrain"]
position = Vector2(775, 1440)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/LeftPitWall"]
position = Vector2(0, -200)
shape = SubResource("RectangleShape2D_pit_wall")

[node name="Visual" type="Polygon2D" parent="Terrain/LeftPitWall"]
position = Vector2(0, -200)
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-25, -200, 25, -200, 25, 200, -25, 200)

[node name="RightPitWall" type="StaticBody2D" parent="Terrain"]
position = Vector2(1785, 1440)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/RightPitWall"]
position = Vector2(0, -200)
shape = SubResource("RectangleShape2D_pit_wall")

[node name="Visual" type="Polygon2D" parent="Terrain/RightPitWall"]
position = Vector2(0, -200)
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-25, -200, 25, -200, 25, 200, -25, 200)

[node name="CentralBlock" type="StaticBody2D" parent="Terrain"]
position = Vector2(1280, 950)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/CentralBlock"]
shape = SubResource("RectangleShape2D_central_block")

[node name="Visual" type="Polygon2D" parent="Terrain/CentralBlock"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-100, -25, 100, -25, 100, 25, -100, 25)

[node name="LeftPerch" type="StaticBody2D" parent="Terrain"]
position = Vector2(175, 500)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/LeftPerch"]
shape = SubResource("RectangleShape2D_high_perch")

[node name="Visual" type="Polygon2D" parent="Terrain/LeftPerch"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-150, -25, 150, -25, 150, 25, -150, 25)

[node name="RightPerch" type="StaticBody2D" parent="Terrain"]
position = Vector2(2385, 500)
collision_layer = 128

[node name="CollisionShape2D" type="CollisionShape2D" parent="Terrain/RightPerch"]
shape = SubResource("RectangleShape2D_high_perch")

[node name="Visual" type="Polygon2D" parent="Terrain/RightPerch"]
color = Color(0.129412, 0.129412, 0.129412, 1)
polygon = PackedVector2Array(-150, -25, 150, -25, 150, 25, -150, 25)

[node name="Platforms" type="Node2D" parent="."]

[node name="LeftBridge" type="StaticBody2D" parent="Platforms"]
position = Vector2(1000, 1100)
collision_layer = 2

[node name="CollisionShape2D" type="CollisionShape2D" parent="Platforms/LeftBridge"]
shape = SubResource("RectangleShape2D_oneway_bridge")
one_way_collision = true

[node name="Visual" type="Polygon2D" parent="Platforms/LeftBridge"]
color = Color(0.192157, 0.192157, 0.192157, 1)
polygon = PackedVector2Array(-150, -10, 150, -10, 150, 10, -150, 10)

[node name="RightBridge" type="StaticBody2D" parent="Platforms"]
position = Vector2(1560, 1100)
collision_layer = 2

[node name="CollisionShape2D" type="CollisionShape2D" parent="Platforms/RightBridge"]
shape = SubResource("RectangleShape2D_oneway_bridge")
one_way_collision = true

[node name="Visual" type="Polygon2D" parent="Platforms/RightBridge"]
color = Color(0.192157, 0.192157, 0.192157, 1)
polygon = PackedVector2Array(-150, -10, 150, -10, 150, 10, -150, 10)

[node name="Hazards" type="Node2D" parent="."]

[node name="Spikes" type="StaticBody2D" parent="Hazards" groups=["hazard"]]
position = Vector2(1280, 1415)
collision_layer = 8

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hazards/Spikes"]
shape = SubResource("RectangleShape2D_spikes")

[node name="Visual" type="Polygon2D" parent="Hazards/Spikes"]
color = Color(0.901961, 0.901961, 0.901961, 1)
polygon = PackedVector2Array(-480, -25, 480, -25, 480, 25, -480, 25)

[node name="Spawns" type="Node2D" parent="."]

[node name="PlayerSpawn" type="Marker2D" parent="Spawns"]
position = Vector2(300, 1100)

[node name="BossSpawn" type="Marker2D" parent="Spawns"]
position = Vector2(2200, 1100)

[node name="Enemies" type="Node2D" parent="."]

[node name="PatrollingLancerSpawner" parent="Enemies" instance=ExtResource("1_8girt")]
position = Vector2(200, 400)

[node name="FlyingPatroller" parent="Enemies" instance=ExtResource("4_ei412")]
position = Vector2(1280, 600)

[node name="TurretLeft" parent="Enemies" instance=ExtResource("13_5kto0")]
position = Vector2(100, 400)

[node name="TurretRight" parent="Enemies" instance=ExtResource("13_5kto0")]
position = Vector2(2460, 400)


=====================================
FILE: ./src/shared/types/damage_info.gd
=====================================
# src/api/combat/damage_info.gd
## A typed Resource that defines a complete damage event.
class_name DamageInfo
extends Resource

# --- Editor Properties ---
@export var amount: int = 1
@export var bypass_invincibility: bool = false

# --- Member Variables ---
## A reference to the node that was the source of the damage.
var source_node: Node = null
## The global position where the impact occurred.
var impact_position: Vector2 = Vector2.ZERO
## The normal vector of the surface that was hit, used for directing VFX.
var impact_normal: Vector2 = Vector2.ZERO


=====================================
FILE: ./src/shared/types/input_frame.gd
=====================================
# src/shared/types/input_frame.gd
class_name InputFrame
extends RefCounted

var move_axis: float = 0.0
var up: bool = false
var down: bool = false

# Jump
var jump_just_pressed: bool = false
var jump_pressed: bool = false # Previously "jump_held"
var jump_released: bool = false

# Attack
var attack_just_pressed: bool = false
var attack_pressed: bool = false
var attack_released: bool = false

# Dash
var dash_pressed: bool = false


=====================================
FILE: ./src/shared/types/melee_attack_data.gd
=====================================
# src/api/combat/melee_attack_data.gd
@tool
## A data resource that defines the properties of a single melee attack.
## This allows for creating varied attacks without changing code.
class_name MeleeAttackData
extends Resource

@export_group("Core Properties")
## The Shape2D resource that defines the hitbox area.
@export var shape: Shape2D
## The local offset from the entity's origin where the hitbox should be centered.
@export var offset: Vector2 = Vector2.ZERO
## The base damage dealt by the attack.
@export var damage_amount: int = 1

@export_group("Visuals")
## The scene to instantiate for the telegraph. If null, uses the default.
@export var telegraph_scene: PackedScene

@export_group("Timing")
## The duration in seconds the hitbox remains active.
@export_range(0.05, 1.0, 0.01) var duration: float = 0.15
## The duration in seconds of the telegraph visual before the attack becomes active.
@export_range(0.0, 2.0, 0.05) var telegraph_duration: float = 0.3

@export_group("Feedback & Juice")
## The duration in seconds of hit-stop to apply on a successful hit.
@export_range(0.0, 0.5, 0.01) var hit_stop_duration: float = 0.0
## The screen shake effect to trigger on a successful hit.
@export var screen_shake_effect: ScreenShakeEffect
## The VFX to spawn at the impact point on a successful hit.
@export var hit_spark_effect: VFXEffect


=====================================
FILE: ./src/shared/types/damage_result.gd
=====================================
# src/api/combat/damage_result.gd
## A typed Resource for the return value of an `apply_damage` call.
class_name DamageResult
extends Resource

# --- Member Variables ---
## True if damage was successfully applied.
var was_damaged: bool = false
## The calculated knockback velocity that should be applied to the target.
var knockback_velocity: Vector2 = Vector2.ZERO


=====================================
FILE: ./src/shared/status_effects/invincibility_effect.gd
=====================================
# src/api/status_effects/invincibility_effect.gd
@tool
## A concrete status effect that grants immunity to damage.
class_name InvincibilityEffect
extends StatusEffect

func _init() -> void:
	effect_id = &"invincibility"

func on_apply(_target: Node, manager: Node) -> void:
	# We use the manager's tagging system to register immunity.
	if manager.has_method("add_tag"):
		manager.add_tag(&"invincible")

func on_remove(_target: Node, manager: Node) -> void:
	if manager.has_method("remove_tag"):
		manager.remove_tag(&"invincible")


=====================================
FILE: ./src/shared/status_effects/status_effect.gd
=====================================
# src/api/status_effects/status_effect.gd
@tool
## Base configuration resource for a temporary status effect (buff/debuff).
## Defines logic for application, removal, and per-frame updates.
class_name StatusEffect
extends Resource

@export var effect_id: StringName
@export_range(0.0, 60.0, 0.1) var duration: float = 0.0

## Called when the effect is first applied to the entity.
## [param target]: The Entity (CharacterBody2D).
## [param manager]: The StatusEffectComponent managing this effect.
func on_apply(_target: Node, _manager: Node) -> void:
	pass

## Called when the effect expires or is cleansed.
func on_remove(_target: Node, _manager: Node) -> void:
	pass

## Called every frame while active. Useful for DoTs or HoTs.
func on_tick(_delta: float, _target: Node, _manager: Node) -> void:
	pass


=====================================
FILE: ./src/shared/interfaces/IFXManager.gd
=====================================
# src/api/interfaces/IFXManager.gd
## The "interface" contract for a system that manages visual and feedback effects.
## This script defines the public API, abstracting components from the concrete
## implementation (e.g., the global FXManager autoload).
class_name IFXManager
extends Node

# --- Virtual Methods (The Contract) ---

func register_camera_shaker(_shaker: CameraShaker) -> void: pass
func unregister_camera_shaker() -> void: pass
func is_camera_shaker_registered() -> bool: return false
func request_screen_shake(_shake_effect: ScreenShakeEffect) -> void: pass
func play_vfx(_effect: VFXEffect, _global_position: Vector2, _direction: Vector2 = Vector2.ZERO) -> void: pass
func request_hit_stop(_duration: float) -> void: pass
func prewarm_shaders_async(_effects: Array[ShaderEffect], _prewarm_viewport: SubViewport) -> void: pass
func get_debug_stats() -> Dictionary: return {}
func increment_shader_count() -> void: pass
func decrement_shader_count() -> void: pass

## Applies a shader effect directly to a target CanvasItem.
func apply_shader_effect(
	_target_node: CanvasItem, _effect: ShaderEffect, _overrides: Dictionary, _opts: Dictionary
) -> Tween:
	return null

## Cancels any active shader effect on a specific node.
func cancel_effect_on_node(_target_node: CanvasItem) -> void: pass

=====================================
FILE: ./src/shared/interfaces/IInputProvider.gd
=====================================
# src/api/interfaces/IInputProvider.gd
## The interface contract for checking input state.
## Allows swapping the real Input singleton for a mock during testing.
class_name IInputProvider
extends RefCounted

func get_axis(_negative_action: StringName, _positive_action: StringName) -> float:
	return 0.0

func is_action_pressed(_action: StringName) -> bool:
	return false

func is_action_just_pressed(_action: StringName) -> bool:
	return false

func is_action_just_released(_action: StringName) -> bool:
	return false


=====================================
FILE: ./src/shared/interfaces/IPoolable.gd
=====================================
# src/api/interfaces/IPoolable.gd
## The "interface" contract for any scene that can be managed by the [ObjectPool].
class_name IPoolable
extends Node

# --- The Contract ---


## Prepares the node for use after being retrieved from the pool.
## Receives a dictionary of dependencies, which should include the ServiceLocator.
func activate(_dependencies: Dictionary = {}) -> void:
	pass


## Prepares the node to be returned to the pool's inactive list.
##
## CONTRACT: Any implementation of this method MUST release all external
## references it holds, especially references to services obtained from the
## ServiceLocator. This is critical for preventing memory leaks and crashes
## during scene transitions.
func deactivate() -> void:
	pass


=====================================
FILE: ./src/shared/interfaces/IObjectPool.gd
=====================================
# src/api/interfaces/IObjectPool.gd
## The "interface" contract for a system that manages pools of reusable nodes.
## This decouples systems from the concrete ObjectPool autoload, enabling
## substitution with fakes or mocks during testing.
class_name IObjectPool
extends Node

# --- Virtual Methods (The Contract) ---

## Retrieves an inactive instance from the specified pool.
func get_instance(_pool_name: StringName) -> Node:
	return null

## Returns an active instance to its pool.
func return_instance(_instance: Node) -> void:
	pass

## Returns all active instances in all pools to their inactive state.
func reset() -> void:
	pass

## Returns a dictionary containing the active/total counts for each pool.
func get_pool_stats() -> Dictionary:
	return {}

=====================================
FILE: ./src/shared/interfaces/ISceneController.gd
=====================================
# src/api/interfaces/ISceneController.gd
## The conceptual "interface" for all main scene controller scripts.
##
## This defines a formal contract for scenes that require explicit cleanup
## logic to be run by the SceneManager before the scene is changed.
class_name ISceneController
extends Node

# --- Virtual Methods ---


## Called by the SceneManager immediately before it changes the scene.
## This function can be async to allow for cleanup animations or sequences.
func scene_exiting() -> void:
	pass

=====================================
FILE: ./src/shared/interfaces/IDamageable.gd
=====================================
# src/api/interfaces/IDamageable.gd
## The "interface" contract for any component that can take damage.
## By extending IComponent, it ensures that any damageable object
## also respects the standard component lifecycle (setup, teardown).
class_name IDamageable
extends IComponent

# --- The Contract (Virtual Method) ---

## Applies damage to the object.
## [param damage_info]: A [DamageInfo] resource detailing the damage event.
## [return]: A [DamageResult] resource indicating the outcome.
func apply_damage(_damage_info: DamageInfo) -> DamageResult:
	push_warning("IDamageable.apply_damage() was called but not overridden by the implementer.")
	return DamageResult.new()


=====================================
FILE: ./src/shared/interfaces/IComponent.gd
=====================================
# src/api/interfaces/IComponent.gd
## The conceptual "interface" for all entity components.
##
## This script defines the formal contract that components like [HealthComponent]
## and [CombatComponent] adhere to. It is not meant to be instanced directly.
class_name IComponent
extends Node

# --- Virtual Methods ---


## Initializes the component and injects its dependencies.
##
## [param p_owner]: A reference to the node that owns this component.
## [param p_dependencies]: A dictionary of any other required nodes or resources.
func setup(_p_owner: Node, _p_dependencies: Dictionary = {}) -> void:
	pass


## Called when the owner is being destroyed to clean up connections and references.
func teardown() -> void:
	pass


=====================================
FILE: ./src/game/combat/attack_logic/lunge_logic.gd
=====================================
# src/combat/attack_logic/lunge_logic.gd
@tool
## Concrete AttackLogic for executing a high-speed, invulnerable dash.
class_name LungeLogic
extends AttackLogic


func get_telegraph_info(_owner: BaseEntity, _pattern: AttackPattern) -> Dictionary:
	var lunge_width = 800.0
	var owner_width = 60.0
	var x_offset = (lunge_width / 2.0) + (owner_width / 2.0)
	
	return {"size": Vector2(lunge_width, 50), "offset": Vector2(x_offset, 0)}


func execute(owner: BaseEntity, pattern: AttackPattern) -> Callable:
	if not owner.is_in_group(Identifiers.Groups.ENEMY):
		push_warning("LungeLogic can only be executed by an Enemy.")
		return Callable()

	var lunge_params = {"pattern": pattern}
	var sm: BaseStateMachine = owner.get_component(BaseStateMachine)
	return sm.change_state.bind(Identifiers.BossStates.LUNGE, lunge_params)


=====================================
FILE: ./src/game/combat/attack_logic/minion_volley_3_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://cbc89272af394"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://dw7h56g0o6aex" path="res://src/game/combat/attack_logic/volley_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")
logic = ExtResource("2_logic")
telegraph_duration = 0.6
attack_duration = 0.8
cooldown = 3.0
projectile_count = 3
volley_delay = 0.2

=====================================
FILE: ./src/game/combat/attack_logic/projectile_logic.gd
=====================================
# src/combat/attack_logic/projectile_logic.gd
@tool
## Concrete AttackLogic for firing one or more projectiles via the ProjectileShooterComponent.
class_name ProjectileLogic
extends AttackLogic


func get_telegraph_info(owner: BaseEntity, _pattern: AttackPattern) -> Dictionary:
	var facing_direction: float = owner.entity_data.facing_direction if "facing_direction" in owner.entity_data else 1.0
	return {"size": Vector2(100, 100), "offset": Vector2(facing_direction * 75, 0)}


func execute(owner: BaseEntity, pattern: AttackPattern) -> Callable:
	# Fetch the new component
	var shooter: ProjectileShooterComponent = owner.get_component(ProjectileShooterComponent)
	
	if not is_instance_valid(shooter):
		push_warning("ProjectileLogic: Entity '%s' lacks a ProjectileShooterComponent." % owner.name)
		return Callable()

	if pattern.projectile_count <= 1:
		return shooter.fire_shot_at_player.bind()
	else:
		return shooter.fire_volley.bind(pattern.projectile_count, pattern.volley_delay)


=====================================
FILE: ./src/game/combat/attack_logic/lunge_logic.tres
=====================================
[gd_resource type="Resource" script_class="LungeLogic" load_steps=2 format=3 uid="uid://b5o450wxs3d0w"]

[ext_resource type="Script" path="res://src/game/combat/attack_logic/lunge_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")

=====================================
FILE: ./src/game/combat/attack_logic/projectile_logic.tres
=====================================
[gd_resource type="Resource" script_class="ProjectileLogic" load_steps=2 format=3 uid="uid://c1w6fobw8biag"]

[ext_resource type="Script" uid="uid://citr6cda6jkw0" path="res://src/game/combat/attack_logic/projectile_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/game/combat/attack_logic/homing_omni_burst_logic.tres
=====================================
[gd_resource type="Resource" script_class="HomingOmniBurstLogic" load_steps=2 format=3 uid="uid://bwg6k1f2vxo7g"]

[ext_resource type="Script" uid="uid://dte2j2bevwl44" path="res://src/game/combat/attack_logic/homing_omni_burst_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")
projectile_count = 30


=====================================
FILE: ./src/game/combat/attack_logic/volley_logic.tres
=====================================
[gd_resource type="Resource" script_class="ProjectileLogic" load_steps=2 format=3 uid="uid://dw7h56g0o6aex"]

[ext_resource type="Script" path="res://src/game/combat/attack_logic/projectile_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/game/combat/attack_logic/attack_logic.gd
=====================================
# src/combat/attack_logic/attack_logic.gd
@tool
## The abstract base class for all boss attack execution logic.
## This implements the Strategy Pattern for boss attacks.
class_name AttackLogic
extends Resource


## Returns the visual information for this attack's telegraph.
## The dictionary should contain: { "size": Vector2, "offset": Vector2 }
## "offset" is the local position relative to the boss.
func get_telegraph_info(_owner: BaseEntity, _pattern: AttackPattern) -> Dictionary:
	# Default to a simple square
	var facing_direction: float = _owner.entity_data.get("facing_direction", 1.0)
	return {
		"size": Vector2(150, 150), "offset": Vector2(facing_direction * 100, 0)
	}


## Prepares and returns the attack action as a Callable.
## This is the core of the Command Pattern implementation.
func execute(_owner: BaseEntity, _pattern: AttackPattern) -> Callable:
	push_warning("AttackLogic.execute() was called but not overridden.")
	return Callable()  # Return an empty, safe callable

=====================================
FILE: ./src/game/combat/attack_logic/homing_omni_burst_logic.gd
=====================================
# src/combat/attack_logic/homing_omni_burst_logic.gd
@tool
## Concrete AttackLogic for a complex, multi-projectile homing attack.
class_name HomingOmniBurstLogic
extends AttackLogic

@export var projectile_count: int = 30


func get_telegraph_info(_owner: BaseEntity, _pattern: AttackPattern) -> Dictionary:
	return {"size": Vector2(100, 100), "offset": Vector2.ZERO}


func execute(owner: BaseEntity, _pattern: AttackPattern) -> Callable:
	return Callable(self, "_fire_omni_burst").bind(owner)


# --- Private Helper for Execution ---
func _fire_omni_burst(owner: BaseEntity) -> void:
	if not is_instance_valid(owner):
		return

	var object_pool: IObjectPool = owner._services.object_pool
	var player_node: Node = owner.get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if not is_instance_valid(player_node):
		return # Cannot fire homing shots without a player to home in on.
	
	var angle_step = TAU / projectile_count
	for i in range(projectile_count):
		var shot: HomingBossShot = object_pool.get_instance(Identifiers.Pools.HOMING_BOSS_SHOTS)
		if not is_instance_valid(shot):
			continue

		# config is now EnemyConfig
		shot.damage = owner.entity_data.config.homing_shot_damage
		shot.speed = owner.entity_data.config.homing_shot_speed
		shot.lifespan = owner.entity_data.config.homing_shot_lifespan

		var angle = i * angle_step
		shot.rotation = angle
		shot.global_position = owner.global_position
		
		var dependencies = {
			"object_pool": owner._services.object_pool,
			"combat_utils": owner._services.combat_utils,
			"player_ref": weakref(player_node)
		}
		shot.activate(dependencies)

=====================================
FILE: ./src/game/level_gen/level_build_data.gd
=====================================
# src/core/building/level_build_data.gd
@tool
## A custom Resource that acts as a data container for a parsed level.
##
## It holds all the necessary information for the [ArenaBuilder] to construct
## the level, including tile positions and entity spawn points.
class_name LevelBuildData
extends Resource


# --- Inner Classes ---
## A simple data container for a single minion spawn.
class MinionSpawnData:
	extends RefCounted
	var scene: PackedScene
	var position: Vector2

	func _init(p_scene: PackedScene, p_pos: Vector2) -> void:
		scene = p_scene
		position = p_pos


# --- Member Variables ---
var terrain_tiles: Array[Vector2] = []
var oneway_platforms: Array[Vector2] = []
var hazard_tiles: Array[Vector2] = []
var background_tiles: Array[Vector2i] = []
var player_spawn_pos: Vector2 = Vector2.ZERO
var boss_spawn_pos: Vector2 = Vector2.ZERO
var encounter_data_resource: EncounterData = null
var dimensions_tiles: Vector2i = Vector2i.ZERO
var minion_spawns: Array[MinionSpawnData] = []


=====================================
FILE: ./src/game/level_gen/arena_builder.gd
=====================================
# src/game/level_gen/arena_builder.gd
## An autoload that loads the level scene and manages entity injection.
##
## REFACTORED: Now uses 'level_scene' from EncounterData instead of procedural generation.
extends Node

# --- Constants ---
const BossSpawnShake = preload("res://src/core/data/effects/boss_spawn_shake.tres")
const LevelBuildDataScript = preload("res://src/game/level_gen/level_build_data.gd")

# --- Private Member Variables ---
var _current_build_data: LevelBuildData
var _current_level_container: Node

# --- Public Methods ---

## Asynchronously builds/loads the level and returns the root node.
func build_level_async() -> Node:
	_current_level_container = null
	
	var encounter_path: String = GameManager.state.current_encounter_path
	if encounter_path.is_empty():
		return _create_empty_container()

	var encounter_data: EncounterData = load(encounter_path)
	if not is_instance_valid(encounter_data):
		push_error("ArenaBuilder: Failed to load EncounterData at path: %s" % encounter_path)
		return _create_empty_container()

	# 1. Instantiate the Level Scene
	if not is_instance_valid(encounter_data.level_scene):
		push_error("ArenaBuilder: EncounterData has no 'level_scene' assigned.")
		return _create_empty_container()
		
	_current_level_container = encounter_data.level_scene.instantiate()
	
	# 2. Construct compatibility BuildData for EncounterScene
	_current_build_data = LevelBuildDataScript.new()
	_current_build_data.encounter_data_resource = encounter_data
	# UPDATE: 2560x1440 arena = ~52x29 tiles (at 50px tile size)
	_current_build_data.dimensions_tiles = Vector2i(52, 29) 
	
	# 3. Find Spawn Points
	var player_spawn = _current_level_container.find_child("PlayerSpawn")
	if player_spawn:
		_current_build_data.player_spawn_pos = player_spawn.position
	else:
		push_warning("ArenaBuilder: No 'PlayerSpawn' marker found in level scene.")
		
	var boss_spawn = _current_level_container.find_child("BossSpawn")
	if boss_spawn:
		_current_build_data.boss_spawn_pos = boss_spawn.position
	
	_current_level_container.set_meta("build_data", _current_build_data)

	# 4. Inject Dependencies into Pre-placed Entities (Minions)
	_inject_dependencies_recursive(_current_level_container)

	# 5. Spawn Dynamic Entities (Player, HUD)
	await get_tree().process_frame
	await _spawn_player_async()
	await _spawn_hud_async()
	
	return _current_level_container


## Spawns the boss defined in the encounter data.
func spawn_boss_async() -> Node:
	if not is_instance_valid(_current_build_data) or not is_instance_valid(_current_build_data.encounter_data_resource):
		return null
		
	var boss_scene: PackedScene = _current_build_data.encounter_data_resource.boss_scene
	if not boss_scene:
		return null
		
	var instance: Node = boss_scene.instantiate()
	if instance is Node2D:
		instance.global_position = _current_build_data.boss_spawn_pos
	
	if instance is BaseEntity:
		instance.inject_dependencies(ServiceLocator)
	
	_current_level_container.add_child(instance)
	await get_tree().process_frame

	if is_instance_valid(BossSpawnShake):
		ServiceLocator.fx_manager.request_screen_shake(BossSpawnShake)

	return instance


# --- Private Methods ---

func _create_empty_container() -> Node:
	var n = Node.new()
	n.name = "EmptyLevel"
	return n

func _spawn_player_async() -> void:
	var instance: Node = load(AssetPaths.SCENE_PLAYER).instantiate()
	if instance is Node2D:
		instance.global_position = _current_build_data.player_spawn_pos
	
	if instance is BaseEntity:
		instance.inject_dependencies(ServiceLocator)
	
	_current_level_container.add_child(instance)
	await get_tree().process_frame

func _spawn_hud_async() -> void:
	var instance: CanvasLayer = load(AssetPaths.SCENE_GAME_HUD).instantiate()
	_current_level_container.add_child(instance)
	await get_tree().process_frame

func _inject_dependencies_recursive(node: Node) -> void:
	if node is BaseEntity:
		node.inject_dependencies(ServiceLocator)
	
	for child in node.get_children():
		_inject_dependencies_recursive(child)


=====================================
FILE: ./src/game/vfx/camera_shaker.gd
=====================================
# src/core/systems/camera_shaker.gd
## A self-contained component that applies a procedural shake to a target Camera2D.
##
## It uses Perlin noise to generate a smooth, decaying shake effect by manipulating
## the target camera's `offset` property.
class_name CameraShaker
extends Node

# --- Public Member Variables ---
## A reference to the Camera2D node this shaker will control.
var target_camera: Camera2D = null

# --- Private Member Variables ---
var _noise := FastNoiseLite.new()
var _noise_y_offset: float = 0.0  # Use a different seed for the y-axis
var _shake_duration: float = 0.0
var _shake_timer: float = 0.0
var _shake_amplitude: float = 0.0
var _shake_frequency: float = 0.0

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_noise.noise_type = FastNoiseLite.TYPE_PERLIN
	_noise.seed = randi()
	_noise_y_offset = randf() * 1000.0


func _process(delta: float) -> void:
	if not is_instance_valid(target_camera):
		return

	if _shake_timer > 0:
		_shake_timer -= delta
		if _shake_timer <= 0:
			target_camera.offset = Vector2.ZERO
		else:
			var decay_progress: float = 1.0 - (_shake_timer / _shake_duration)
			var current_amplitude: float = _shake_amplitude * (1.0 - decay_progress)

			var time: float = Time.get_ticks_msec() * (_shake_frequency / 1000.0)
			var noise_x: float = _noise.get_noise_2d(time, 0)
			var noise_y: float = _noise.get_noise_2d(time, _noise_y_offset)

			target_camera.offset.x = noise_x * current_amplitude
			target_camera.offset.y = noise_y * current_amplitude
	else:
		target_camera.offset = Vector2.ZERO


# --- Public API ---


func start_shake(effect: ScreenShakeEffect) -> void:
	if not is_instance_valid(effect):
		push_error("CameraShaker: Invalid ScreenShakeEffect resource provided.")
		return

	_shake_amplitude = effect.amplitude
	_shake_frequency = effect.frequency
	_shake_duration = effect.duration
	_shake_timer = _shake_duration


=====================================
FILE: ./src/game/vfx/camera_manager.gd
=====================================
# src/core/systems/camera_manager.gd
## An autoloaded singleton responsible for all camera logic.
extends Node

# --- Public Methods ---


## Centers the camera on the arena for a pixel-perfect setup.
func center_camera_on_arena(camera: Camera2D, arena_size_tiles: Vector2i) -> void:
	if not is_instance_valid(camera):
		push_error("CameraManager: Invalid Camera2D provided.")
		return

	var arena_pixel_size = Vector2(arena_size_tiles) * Constants.TILE_SIZE
	camera.position = arena_pixel_size / 2.0


=====================================
FILE: ./src/game/vfx/bindings/fx_manager_adapter.gd
=====================================
# src/core/systems/fx_bindings/fx_manager_adapter.gd
## An adapter that implements multiple FX interfaces by delegating calls
## to the real FXManager autoload singleton. This script is registered as an
## autoload itself and should NOT have a matching class_name.
extends IFXManager

# --- Private Member Variables ---
var _real_fx_manager: Node

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	_real_fx_manager = get_node("/root/FXManager")
	assert(is_instance_valid(_real_fx_manager), "FXManagerAdapter could not find /root/FXManager")

# --- Interface Implementation ---
# These methods override the empty virtual methods in IFXManager.

func register_camera_shaker(shaker: CameraShaker) -> void:
	_real_fx_manager.register_camera_shaker(shaker)

func unregister_camera_shaker() -> void:
	_real_fx_manager.unregister_camera_shaker()

func is_camera_shaker_registered() -> bool:
	return _real_fx_manager.is_camera_shaker_registered()

func request_screen_shake(shake_effect: ScreenShakeEffect) -> void:
	_real_fx_manager.request_screen_shake(shake_effect)

func play_vfx(effect: VFXEffect, global_position: Vector2, direction: Vector2 = Vector2.ZERO) -> void:
	_real_fx_manager.play_vfx(effect, global_position, direction)

func request_hit_stop(duration: float) -> void:
	_real_fx_manager.request_hit_stop(duration)

func prewarm_shaders_async(effects: Array[ShaderEffect], prewarm_viewport: SubViewport) -> void:
	await _real_fx_manager.prewarm_shaders_async(effects, prewarm_viewport)

func get_debug_stats() -> Dictionary:
	return _real_fx_manager.get_debug_stats()

func increment_shader_count() -> void:
	_real_fx_manager.increment_shader_count()

func decrement_shader_count() -> void:
	_real_fx_manager.decrement_shader_count()

func apply_shader_effect(
	target_node: CanvasItem, effect: ShaderEffect, overrides: Dictionary, opts: Dictionary
) -> Tween:
	return _real_fx_manager.apply_shader_effect(target_node, effect, overrides, opts)

func cancel_effect_on_node(target_node: CanvasItem) -> void:
	_real_fx_manager.cancel_effect_on_node(target_node)


=====================================
FILE: ./src/game/vfx/camera_shaker.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://camera_shaker_scene_id"]

[ext_resource type="Script" path="res://src/game/vfx/camera_shaker.gd" id="1_shaker_script"]

[node name="CameraShaker" type="Node"]
script = ExtResource("1_shaker_script")

=====================================
FILE: ./src/game/vfx/fx_manager.gd
=====================================
# src/core/systems/fx_manager.gd
## An autoloaded singleton to handle purely aesthetic "game feel" effects.
##
## This separates feedback like hit-stop and screen shake from core gameplay
## logic, improving modularity and adhering to SRP.
extends Node

# --- Private Member Variables ---
var _is_hit_stop_active: bool = false
var _camera_shaker: CameraShaker = null
var _services: ServiceLocator
var _managed_effects: Dictionary = {}

var _active_shader_effects: int = 0


# --- Public Methods ---


func apply_shader_effect(
	target_node: CanvasItem, effect: ShaderEffect, overrides: Dictionary, opts: Dictionary
) -> Tween:
	if not is_instance_valid(target_node) or not is_instance_valid(effect):
		return null

	var target_id: int = target_node.get_instance_id()
	cancel_effect_on_node(target_node)

	var material_instance := effect.material.duplicate(true) as ShaderMaterial
	if not is_instance_valid(material_instance):
		push_error("FXManager: effect.material is not a ShaderMaterial.")
		return null

	if not overrides.is_empty():
		for param_name in overrides:
			material_instance.set_shader_parameter(param_name, overrides[param_name])

	_managed_effects[target_id] = {
		"original_material": target_node.material,
		"effect_material": material_instance
	}
	target_node.material = material_instance

	increment_shader_count()

	# FIX: Create the tween on the target node, not on FXManager (self).
	# This ensures the tween is automatically killed if the target node is freed.
	var tween: Tween = target_node.create_tween().set_parallel(false)
	
	tween.tween_property(
		material_instance, "shader_parameter/fx_progress", 1.0, effect.duration
	)

	var preserve_final_state: bool = opts.get("preserve_final_state", false)
	tween.tween_callback(_on_shader_effect_finished.bind(target_node, preserve_final_state))
	_managed_effects[target_id]["active_tween"] = tween

	return tween


func cancel_effect_on_node(target_node: CanvasItem) -> void:
	if not is_instance_valid(target_node):
		return
	var target_id: int = target_node.get_instance_id()
	if _managed_effects.has(target_id):
		var effect_data: Dictionary = _managed_effects[target_id]
		if is_instance_valid(effect_data.active_tween):
			effect_data.active_tween.kill()
		_on_shader_effect_finished(target_node, false)


func increment_shader_count() -> void:
	_active_shader_effects += 1


func decrement_shader_count() -> void:
	_active_shader_effects -= 1


func register_camera_shaker(shaker: CameraShaker) -> void:
	_camera_shaker = shaker


func unregister_camera_shaker() -> void:
	_camera_shaker = null


func is_camera_shaker_registered() -> bool:
	return is_instance_valid(_camera_shaker)


func request_screen_shake(shake_effect: ScreenShakeEffect) -> void:
	if is_instance_valid(_camera_shaker):
		_camera_shaker.start_shake(shake_effect)
	else:
		push_warning("FXManager: request_screen_shake called, but no CameraShaker is registered.")


func play_vfx(
	effect: VFXEffect, global_position: Vector2, direction: Vector2 = Vector2.ZERO
) -> void:
	if not is_instance_valid(effect):
		push_warning("FXManager: play_vfx called with an invalid VFXEffect resource.")
		return

	if effect.pool_key == &"":
		push_warning("FXManager: VFXEffect resource is missing a 'pool_key'.")
		return

	var services: ServiceLocator = _get_services()
	var vfx_instance: Node = services.object_pool.get_instance(effect.pool_key)
	if not is_instance_valid(vfx_instance):
		push_error("FXManager: Failed to get instance for pool key '%s'." % effect.pool_key)
		return

	vfx_instance.global_position = global_position

	if vfx_instance.has_method("activate"):
		var dependencies: Dictionary = {"services": services, "direction": direction}
		vfx_instance.call("activate", dependencies)


func request_hit_stop(duration: float) -> void:
	if _is_hit_stop_active:
		return

	_is_hit_stop_active = true

	var affected_nodes: Array[Node]
	affected_nodes.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.PLAYER))
	affected_nodes.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY))

	for node in affected_nodes:
		if is_instance_valid(node):
			node.set_deferred("process_mode", Node.PROCESS_MODE_DISABLED)

	var timer: SceneTreeTimer = get_tree().create_timer(duration, true, false, true)
	await timer.timeout

	if not get_tree():
		return

	for node in affected_nodes:
		if is_instance_valid(node):
			node.set_deferred("process_mode", Node.PROCESS_MODE_INHERIT)

	_is_hit_stop_active = false


func prewarm_shaders_async(effects: Array[ShaderEffect], prewarm_viewport: SubViewport) -> void:
	if not is_instance_valid(prewarm_viewport):
		push_error("FXManager: prewarm_shaders_async requires a valid SubViewport.")
		return

	print("FXManager: Starting shader pre-warm...")
	for effect in effects:
		if not is_instance_valid(effect) or not is_instance_valid(effect.material):
			continue

		var temp_rect := ColorRect.new()
		temp_rect.material = effect.material.duplicate(true)
		prewarm_viewport.add_child(temp_rect)

		await get_tree().process_frame

		temp_rect.queue_free()
	print("FXManager: Shader pre-warm complete.")


func get_debug_stats() -> Dictionary:
	var services: ServiceLocator = _get_services()
	var pool_stats: Dictionary = services.object_pool.get_pool_stats()
	var vfx_count: int = 0

	if pool_stats.has(Identifiers.Pools.HIT_SPARKS):
		vfx_count += pool_stats[Identifiers.Pools.HIT_SPARKS].active

	return {
		"active_vfx": vfx_count,
		"active_shaders": _active_shader_effects,
	}


# --- Private Methods ---


func _get_services() -> ServiceLocator:
	if not is_instance_valid(_services):
		_services = get_node("/root/ServiceLocator")
	return _services


func _on_shader_effect_finished(target_node: CanvasItem, preserve_final_state: bool) -> void:
	decrement_shader_count()

	if not is_instance_valid(target_node):
		return

	var target_id: int = target_node.get_instance_id()
	if not _managed_effects.has(target_id):
		return

	var effect_data: Dictionary = _managed_effects[target_id]
	var should_restore: bool = not target_node.is_queued_for_deletion() and not preserve_final_state

	if should_restore:
		target_node.material = effect_data.original_material

	_managed_effects.erase(target_id)


=====================================
FILE: ./src/projectiles/player_shot.tscn
=====================================
[gd_scene load_steps=11 format=3 uid="uid://cmdkxwvysirh1"]

[ext_resource type="Script" path="res://src/projectiles/player_shot.gd" id="1_4wg7x"]
[ext_resource type="Resource" uid="uid://green_splash_vfx_res" path="res://src/data/effects/green_splash_vfx.tres" id="2_vfx_res"]

[sub_resource type="Gradient" id="Gradient_trail"]
offsets = PackedFloat32Array(0, 0.2, 1)
colors = PackedColorArray(0.6, 1, 0.6, 1, 0.2, 1, 0.2, 1, 0, 0.2, 0, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_trail"]
gradient = SubResource("Gradient_trail")

[sub_resource type="Curve" id="Curve_scale"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), 0.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_scale"]
curve = SubResource("Curve_scale")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_flame"]
particle_flag_disable_z = true
emission_shape = 1
emission_sphere_radius = 4.0
direction = Vector3(-1, 0, 0)
spread = 15.0
initial_velocity_min = 50.0
initial_velocity_max = 150.0
gravity = Vector3(0, 0, 0)
scale_min = 4.0
scale_max = 8.0
scale_curve = SubResource("CurveTexture_scale")
color_ramp = SubResource("GradientTexture1D_trail")
turbulence_enabled = true
turbulence_noise_strength = 2.0

[sub_resource type="Gradient" id="Gradient_orb"]
interpolation_mode = 2
offsets = PackedFloat32Array(0, 0.2, 0.6, 1)
colors = PackedColorArray(1, 1, 1, 1, 0.5, 1, 0.5, 1, 0, 0.8, 0, 1, 0, 0.2, 0, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_orb"]
gradient = SubResource("Gradient_orb")
width = 32
height = 32
fill = 1
fill_from = Vector2(0.5, 0.5)
fill_to = Vector2(0.5, 0)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playershot"]
size = Vector2(20, 20)

[node name="PlayerShot" type="Area2D" groups=["player_projectile"]]
collision_layer = 1024
collision_mask = 148
script = ExtResource("1_4wg7x")
default_speed = 1000.0
impact_vfx = ExtResource("2_vfx_res")
metadata/pool_name = &"player_shots"

[node name="FlameTrail" type="GPUParticles2D" parent="."]
unique_name_in_owner = true
amount = 40
process_material = SubResource("ParticleProcessMaterial_flame")
lifetime = 0.4
local_coords = false
fixed_fps = 60

[node name="VisualSprite" type="Sprite2D" parent="."]
texture = SubResource("GradientTexture2D_orb")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playershot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-20, -20, 40, 40)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]


=====================================
FILE: ./src/projectiles/turret_shot.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://d1e2f3g4h5i6j"]

[ext_resource type="Script" path="res://src/projectiles/turret_shot.gd" id="1_turret_shot_script"]
[ext_resource type="Resource" uid="uid://red_splash_vfx_res" path="res://src/data/effects/red_splash_vfx.tres" id="2_splash"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_turretshot"]
size = Vector2(20, 20)

[node name="TurretShot" type="Area2D"]
collision_layer = 16
collision_mask = 193
script = ExtResource("1_turret_shot_script")
impact_vfx = ExtResource("2_splash")
metadata/pool_name = &"turret_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -10.0
offset_top = -10.0
offset_right = 10.0
offset_bottom = 10.0
pivot_offset = Vector2(10, 10)
color = Color(1, 0.2, 0.2, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_turretshot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-10, -10, 20, 20)

[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]


=====================================
FILE: ./src/projectiles/boss_shot.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://cxnmr7yrvchve"]

[ext_resource type="Script" path="res://src/projectiles/boss_shot.gd" id="1_4qgog"]
[ext_resource type="Resource" uid="uid://red_splash_large_vfx_res" path="res://src/data/effects/red_splash_large_vfx.tres" id="2_splash"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossshot"]
size = Vector2(60, 60)

[node name="BossShot" type="Area2D"]
collision_layer = 16
collision_mask = 65
script = ExtResource("1_4qgog")
damage = 2
impact_vfx = ExtResource("2_splash")
metadata/pool_name = &"boss_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
pivot_offset = Vector2(30, 30)
color = Color(1, 0.2, 0.2, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossshot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-30, -30, 60, 60)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]


=====================================
FILE: ./src/projectiles/turret_shot.gd
=====================================
# res://src/projectiles/turret_shot.gd
class_name TurretShot
extends BaseProjectile


func _ready() -> void:
	super._ready()
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)


=====================================
FILE: ./src/projectiles/player_shot.gd
=====================================
# res/src/projectiles/player_shot.gd
class_name PlayerShot
extends BaseProjectile

# Per-projectile tuneable default (Inspector-friendly).
@export var default_speed: float = 1000.0

@onready var flame_trail: GPUParticles2D = %FlameTrail

var _hit_instances: Dictionary = {}

func _ready() -> void:
	super._ready()


# Ensure the speed is set every time this instance is (re)activated by the pool.
func activate(p_dependencies: Dictionary) -> void:
	# First let the base class do its activation
	super.activate(p_dependencies)
	# Then apply player-shot-specific runtime defaults so they apply on reuse.
	speed = default_speed
	
	_hit_instances.clear()
	
	if is_instance_valid(flame_trail):
		flame_trail.restart()
		flame_trail.emitting = true


func deactivate() -> void:
	if is_instance_valid(flame_trail):
		flame_trail.emitting = false
	_hit_instances.clear()
	super.deactivate()


func _on_area_entered(area: Area2D) -> void:
	if not _is_active:
		return
	
	# Prevent double-processing the same target (e.g. if physics flushes strangely)
	var id = area.get_instance_id()
	if _hit_instances.has(id):
		return
	_hit_instances[id] = true
	
	# CLASH LOGIC: Player shots can destroy enemy projectiles.
	# If we have enough damage (health), we survive the hit.
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		_handle_projectile_clash(area)
		return # Do NOT call super, as base class would destroy us immediately.

	# Then proceed with the base collision handling for anything else.
	super._on_area_entered(area)


func _handle_projectile_clash(enemy_shot: Area2D) -> void:
	# 1. Determine incoming damage
	var incoming_dmg = 1
	if "damage" in enemy_shot:
		incoming_dmg = enemy_shot.damage
	
	# 2. Spawn Splash Visuals (Clash)
	_spawn_impact_vfx()
	
	# 3. Destroy Enemy Shot (It is consumed by the blast)
	if enemy_shot.has_method("destroy_with_impact"):
		enemy_shot.destroy_with_impact()
	elif enemy_shot.has_method("deactivate") and is_instance_valid(_object_pool):
		_object_pool.return_instance.call_deferred(enemy_shot)
	else:
		enemy_shot.queue_free()
	
	# 4. Apply Damage to Self (Durability)
	damage -= incoming_dmg
	
	# 5. Check Survival
	if damage <= 0:
		if is_instance_valid(_object_pool):
			_object_pool.return_instance.call_deferred(self)
		else:
			queue_free()
	else:
		# Survived with reduced damage
		pass


# Override base collision to ensure VFX spawn before destruction
func _handle_collision(target: Node) -> void:
	# BaseProjectile._handle_collision now handles _spawn_impact_vfx() automatically!
	super._handle_collision(target)


=====================================
FILE: ./src/projectiles/boss_shot.gd
=====================================
# res://src/projectiles/boss_shot.gd
class_name BossShot
extends BaseProjectile


func _ready() -> void:
	super._ready()
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)


=====================================
FILE: ./src/projectiles/homing_boss_shot.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://homing_boss_shot_scene"]

[ext_resource type="Script" path="res://src/projectiles/homing_boss_shot.gd" id="1_homing_shot_script"]
[ext_resource type="Resource" uid="uid://red_splash_vfx_res" path="res://src/data/effects/red_splash_vfx.tres" id="2_splash"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_homing_shot_body"]
size = Vector2(20, 20)

[node name="HomingBossShot" type="Area2D"]
collision_layer = 16
collision_mask = 65
script = ExtResource("1_homing_shot_script")
impact_vfx = ExtResource("2_splash")
metadata/pool_name = &"homing_boss_shots"

[node name="ColorRect" type="ColorRect" parent="."]
unique_name_in_owner = true
offset_left = -10.0
offset_top = -10.0
offset_right = 10.0
offset_bottom = 10.0
pivot_offset = Vector2(10, 10)
color = Color(1, 0.2, 0.2, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
unique_name_in_owner = true
shape = SubResource("RectangleShape2D_homing_shot_body")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-10, -10, 20, 20)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]


=====================================
FILE: ./src/projectiles/homing_boss_shot.gd
=====================================
# src/projectiles/homing_boss_shot.gd
class_name HomingBossShot
extends BaseProjectile

# --- Private Member Variables ---
var _player_ref: WeakRef
var _active_tween: Tween
var _pending_start_on_screen: bool = false

const FALLBACK_WAIT_SECONDS := 0.05


func _ready() -> void:
	super._ready() # Important to call the parent's _ready to create the timer.
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)


func _move(delta: float) -> void:
	if not _player_ref or not _player_ref.get_ref():
		super._move(delta) # Default non-homing movement
		return

	var player_node: Node = _player_ref.get_ref()
	var direction_to_player: Vector2 = (player_node.global_position - global_position).normalized()
	rotation = lerp_angle(rotation, direction_to_player.angle(), 0.05)
	global_position += transform.x * speed * delta


func activate(p_dependencies: Dictionary) -> void:
	super.activate(p_dependencies)
	
	_player_ref = p_dependencies.get("player_ref")
	assert(is_instance_valid(_player_ref), "HomingBossShot requires a 'player_ref' dependency.")

	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null

	visual.scale = Vector2.ONE
	collision_shape.scale = Vector2.ONE

	call_deferred("_maybe_schedule_shrink")


func deactivate() -> void:
	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null

	visual.scale = Vector2.ONE
	collision_shape.scale = Vector2.ONE

	_pending_start_on_screen = false
	_player_ref = null
	super.deactivate()


func _screen_entered_hook() -> void:
	if _pending_start_on_screen:
		_pending_start_on_screen = false
		_start_shrink_tween()


func _maybe_schedule_shrink() -> void:
	if not _is_active:
		return

	await get_tree().process_frame

	if not _is_active:
		return

	if _has_been_on_screen:
		_start_shrink_tween()
		return

	_pending_start_on_screen = true

	var timer: SceneTreeTimer = get_tree().create_timer(FALLBACK_WAIT_SECONDS)
	await timer.timeout

	if _pending_start_on_screen and _is_active:
		_pending_start_on_screen = false
		_start_shrink_tween()


func _start_shrink_tween() -> void:
	if not _is_active:
		return

	if is_instance_valid(_active_tween):
		_active_tween.kill()

	_active_tween = create_tween()
	_active_tween.set_trans(Tween.TRANS_LINEAR).set_ease(Tween.EASE_IN_OUT)
	_active_tween.tween_property(visual, "scale", Vector2.ZERO, lifespan)
	_active_tween.tween_property(collision_shape, "scale", Vector2.ZERO, lifespan)


=====================================
FILE: ./src/projectiles/base_projectile.gd
=====================================
# res/src/projectiles/base_projectile.gd
class_name BaseProjectile
extends Area2D

# --- Node References ---
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
# Visual is now resolved dynamically to support Sprites or ColorRects
var visual: CanvasItem 

# --- Public Properties ---
@export var speed: float = 400.0
@export var damage: int = 1
@export var lifespan: float = 5.0 # Default max lifetime for all projectiles
@export var direction: Vector2 = Vector2.RIGHT
@export var impact_vfx: VFXEffect ## Optional visual effect to spawn on collision

# --- Private Member Variables ---
var _object_pool: IObjectPool
var _fx_manager: IFXManager
var _combat_utils
var _is_active: bool = false
var _has_been_on_screen: bool = false
var _lifetime_timer: Timer
var _base_scale: Vector2 = Vector2.ONE

# --- Godot Lifecycle ---
func _ready() -> void:
	# Dynamic visual resolution
	if has_node("ColorRect"):
		visual = $ColorRect
	elif has_node("VisualSprite"):
		visual = $VisualSprite
	
	_base_scale = scale

	# Programmatically create a timer for every projectile instance.
	_lifetime_timer = Timer.new()
	_lifetime_timer.name = "LifetimeTimer"
	_lifetime_timer.one_shot = true
	add_child(_lifetime_timer)
	_lifetime_timer.timeout.connect(_on_lifetime_timer_timeout)


func _physics_process(delta: float) -> void:
	if not _is_active:
		return
	_move(delta)

# --- Virtual Hooks ---
func _move(delta: float) -> void:
	global_position += direction * speed * delta

## A safe "hook" for child classes to add logic without overriding the main function.
func _screen_entered_hook() -> void:
	pass

# --- IPoolable Contract ---
func activate(p_dependencies: Dictionary) -> void:
	_object_pool = p_dependencies.get("object_pool")
	_combat_utils = p_dependencies.get("combat_utils")
	_fx_manager = p_dependencies.get("fx_manager") # Optional dependency
	
	assert(is_instance_valid(_object_pool), "BaseProjectile requires an IObjectPool dependency.")
	assert(is_instance_valid(_combat_utils), "BaseProjectile requires a CombatUtils dependency.")
	
	# Override Damage & Scale if provided
	if p_dependencies.has("damage"):
		damage = p_dependencies.damage
	if p_dependencies.has("scale"):
		scale = p_dependencies.scale

	_has_been_on_screen = false
	visible = true
	_is_active = true
	process_mode = PROCESS_MODE_INHERIT
	_lifetime_timer.start(lifespan)
	
	if is_instance_valid(collision_shape):
		collision_shape.disabled = false

func deactivate() -> void:
	visible = false
	_is_active = false
	process_mode = PROCESS_MODE_DISABLED
	_lifetime_timer.stop()
	
	# Reset Transform
	scale = _base_scale
	
	if is_instance_valid(collision_shape):
		collision_shape.disabled = true
	_object_pool = null
	_combat_utils = null
	_fx_manager = null

# --- Public Destruction API ---

## Forces the projectile to destroy itself, playing its impact VFX first.
## Useful for when the projectile is destroyed by something other than a collision (e.g. Player Attack).
func destroy_with_impact() -> void:
	_spawn_impact_vfx()
	
	# Important: Disable collision immediately to prevent duplicate hits this frame
	if is_instance_valid(collision_shape):
		collision_shape.set_deferred("disabled", true)
	
	if is_instance_valid(_object_pool):
		_object_pool.return_instance.call_deferred(self)
	else:
		queue_free()

# --- Centralized Collision & Cleanup ---
func _handle_collision(target: Node) -> void:
	if target.is_in_group(Identifiers.Groups.SENSORS):
		return

	# Delegate destruction to the shared method
	# We also apply damage before destroying.
	var damageable: IDamageable = _combat_utils.find_damageable(target)
	if is_instance_valid(damageable):
		var impact_normal = -direction.normalized() if not direction.is_zero_approx() else Vector2.ZERO
		
		var damage_info = _combat_utils.create_damage_info(
			damage,
			self,
			global_position,
			impact_normal
		)
		damageable.apply_damage(damage_info)
	
	destroy_with_impact()

func _spawn_impact_vfx() -> void:
	if is_instance_valid(_fx_manager) and is_instance_valid(impact_vfx):
		var normal = -direction.normalized() if not direction.is_zero_approx() else Vector2.UP
		_fx_manager.play_vfx(impact_vfx, global_position, normal)

# --- Timer / On-screen handlers (signal targets) ---
func _on_lifetime_timer_timeout() -> void:
	if not _is_active:
		return
	if is_instance_valid(_object_pool):
		_object_pool.return_instance.call_deferred(self)

func _on_screen_entered() -> void:
	_has_been_on_screen = true
	_screen_entered_hook()

func _on_screen_exited() -> void:
	if not _is_active or not _has_been_on_screen:
		return
	if is_instance_valid(_object_pool):
		_object_pool.return_instance.call_deferred(self)

# --- Signal Handlers ---
func _on_body_entered(body: Node) -> void:
	if not _is_active:
		return
	_handle_collision(body)

func _on_area_entered(area: Area2D) -> void:
	if not _is_active:
		return
	_handle_collision(area)


=====================================
FILE: ./src/data/combat/attacks/lancer_poke.tres
=====================================
[gd_resource type="Resource" script_class="MeleeAttackData" load_steps=3 format=3 uid="uid://c1x2y304a5b6c"]

[ext_resource type="Script" uid="uid://yas33ux44jbi" path="res://src/shared/types/melee_attack_data.gd" id="1_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_lancerpoke"]
size = Vector2(80, 20)

[resource]
script = ExtResource("1_script")
shape = SubResource("RectangleShape2D_lancerpoke")
offset = Vector2(65, 0)
damage_amount = 1
duration = 0.15
telegraph_duration = 0.3
hit_stop_duration = 0.03


=====================================
FILE: ./src/data/combat/attacks/boss_lunge_melee.tres
=====================================
[gd_resource type="Resource" script_class="MeleeAttackData" load_steps=4 format=3 uid="uid://b1v2c3d4e5f6g"]

[ext_resource type="Script" path="res://src/shared/types/melee_attack_data.gd" id="1_script"]
[ext_resource type="Shape2D" uid="uid://c1b2d3e4f5g6h" path="res://src/entities/player/data/forward_attack_shape.tres" id="2_shape"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="3_hit_spark"]

[resource]
script = ExtResource("1_script")
shape = ExtResource("2_shape")
offset = Vector2(60, 0)
damage_amount = 2
duration = 0.2
telegraph_duration = 0.4
hit_stop_duration = 0.05
hit_spark_effect = ExtResource("3_hit_spark")


=====================================
FILE: ./src/data/combat/attacks/boss_quick_swipe.tres
=====================================
[gd_resource type="Resource" script_class="MeleeAttackData" load_steps=3 format=3 uid="uid://d1c2b3a4e5f6g"]

[ext_resource type="Script" uid="uid://yas33ux44jbi" path="res://src/shared/types/melee_attack_data.gd" id="1_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_b4h5g"]
size = Vector2(90, 25)

[resource]
script = ExtResource("1_script")
shape = SubResource("RectangleShape2D_b4h5g")
offset = Vector2(75, 0)
damage_amount = 1
duration = 0.15
telegraph_duration = 0.2
hit_stop_duration = 0.02


=====================================
FILE: ./src/data/player_config.tres
=====================================
[gd_resource type="Resource" script_class="PlayerConfig" load_steps=14 format=3 uid="uid://v472r2pi58n8"]

[ext_resource type="Script" uid="uid://bal1gtkcg7s8v" path="res://src/core/data/config/player_config.gd" id="1_script"]
[ext_resource type="Script" uid="uid://bcahx6le3w04x" path="res://src/core/data/config/damage_response_config.gd" id="2_dmg_resp"]
[ext_resource type="Shape2D" uid="uid://c1b2d3e4f5g6h" path="res://src/entities/player/data/forward_attack_shape.tres" id="3_shape"]
[ext_resource type="Shape2D" uid="uid://c0dt7jqwtnbr" path="res://src/entities/player/data/upward_attack_shape.tres" id="4_shape"]
[ext_resource type="Resource" path="res://src/data/audio/sfx_player_impact.tres" id="5_audio"]
[ext_resource type="PackedScene" path="res://src/content/vfx/aura_charge_green.tscn" id="6_aura_charge"]
[ext_resource type="PackedScene" path="res://src/content/vfx/splash_charge_green.tscn" id="7_splash_charge"]
[ext_resource type="PackedScene" path="res://src/content/vfx/aura_heal_purple.tscn" id="8_aura_heal"]
[ext_resource type="PackedScene" path="res://src/content/vfx/splash_heal_purple.tscn" id="9_splash_heal"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="10_dissolve"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="11_hit_spark"]
[ext_resource type="PackedScene" path="res://src/content/vfx/melee_slash.tscn" id="12_melee_slash"]

[sub_resource type="Resource" id="Resource_dmg"]
script = ExtResource("2_dmg_resp")
audio_cue = ExtResource("5_audio")
invincibility_duration = 1.5
knockback_speed = 400.0
hazard_knockback_speed = 400.0

[resource]
script = ExtResource("1_script")
max_health = 5
max_healing_charges = 1
heal_duration = 2.0
determination_per_charge = 5
damage_response = SubResource("Resource_dmg")
knockback_duration = 0.1
move_speed = 450.0
jump_force = 680.0
jump_release_dampener = 0.4
coyote_time = 0.1
jump_buffer = 0.1
fast_fall_gravity_multiplier = 1.4
max_air_jumps = 1
wall_slide_speed = 120.0
wall_coyote_time = 0.05
wall_jump_force_x = 1650.0
wall_jump_force_y = 680.0
dash_speed = 1400.0
dash_duration = 0.15
dash_cooldown = 0.5
forward_attack_shape = ExtResource("3_shape")
upward_attack_shape = ExtResource("4_shape")
attack_cooldown = 0.12
attack_duration = 0.1
attack_friction = 2000.0
charge_time = 0.35
level_2_charge_time = 1.12
level_2_damage = 3
pogo_force = 450.0
close_range_threshold = 75.0
hit_spark_effect = ExtResource("11_hit_spark")
vfx_charge_aura = ExtResource("6_aura_charge")
vfx_charge_splash = ExtResource("7_splash_charge")
vfx_heal_aura = ExtResource("8_aura_heal")
vfx_heal_splash = ExtResource("9_splash_heal")
vfx_dissolve = ExtResource("10_dissolve")
vfx_melee_slash = ExtResource("12_melee_slash")


=====================================
FILE: ./src/data/dialogue/dialogue_line.gd
=====================================
# src/data/dialogue/dialogue_line.gd
@tool
## A custom Resource holding the data for a single line of dialogue.
class_name DialogueLine
extends Resource

@export var speaker: String = ""
@export_multiline var text: String = ""
@export var portrait: Texture2D
@export var voice: AudioStream
@export_range(0.0, 5.0, 0.1) var wait_after: float = 0.2


=====================================
FILE: ./src/data/dialogue/test_conversation.tres
=====================================
[gd_resource type="Resource" script_class="DialogueData" load_steps=4 format=3 uid="uid://ce4ka1q3xh4bd"]

[ext_resource type="Script" uid="uid://duqmqwi2qjc7y" path="res://src/data/dialogue/dialogue_data.gd" id="1_dialogue_data"]
[ext_resource type="Script" uid="uid://cxxrvo55hssvv" path="res://src/data/dialogue/dialogue_line.gd" id="2_dialogue_line"]

[sub_resource type="Resource" id="DialogueLine_1"]
script = ExtResource("2_dialogue_line")
speaker = "BOX BATTLE"
text = "This is the first line of a test conversation."
wait_after = 0.2

[resource]
script = ExtResource("1_dialogue_data")
lines = Array[ExtResource("2_dialogue_line")]([SubResource("DialogueLine_1")])


=====================================
FILE: ./src/data/dialogue/dialogue_data.gd
=====================================
# src/data/dialogue/dialogue_data.gd
@tool
## A custom Resource that holds the data for a full conversation.
class_name DialogueData
extends Resource

## An array of DialogueLine resources that make up the conversation.
@export var lines: Array[DialogueLine] = []


=====================================
FILE: ./src/data/audio/sfx_player_footsteps.tres
=====================================
[gd_resource type="AudioStreamRandomizer" load_steps=2 format=3]

# TODO: Add footstep audio samples and configure randomization.


=====================================
FILE: ./src/data/audio/sfx_player_impact.tres
=====================================
[gd_resource type="Resource" script_class="AudioCue" load_steps=3 format=3]

[ext_resource type="Script" path="res://src/core/data/audio/audio_cue.gd" id="1_script"]
[ext_resource type="AudioStream" path="res://assets/audio/sfx/sfx_ui_error.mp3" id="2_sound"]

[resource]
script = ExtResource("1_script")
stream = ExtResource("2_sound")
volume_db = -5.0
pitch_scale = 1.0
pitch_randomness = 0.2
bus = &"SFX"


=====================================
FILE: ./src/data/default_pool_manifest.tres
=====================================
[gd_resource type="Resource" script_class="PoolManifest" load_steps=13 format=3]

[ext_resource type="Script" path="res://src/core/systems/pooling/pool_definition.gd" id="1_def"]
[ext_resource type="Script" path="res://src/core/systems/pooling/pool_manifest.gd" id="2_man"]
[ext_resource type="PackedScene" path="res://src/projectiles/player_shot.tscn" id="3_player_shot"]
[ext_resource type="PackedScene" path="res://src/projectiles/boss_shot.tscn" id="4_boss_shot"]
[ext_resource type="PackedScene" path="res://src/projectiles/turret_shot.tscn" id="5_minion_shot"]
[ext_resource type="PackedScene" path="res://src/projectiles/homing_boss_shot.tscn" id="6_homing"]
[ext_resource type="PackedScene" path="res://src/content/vfx/hit_spark.tscn" id="7_spark"]
[ext_resource type="PackedScene" path="res://src/content/vfx/splash_charge_green.tscn" id="8_green_splash"]
[ext_resource type="PackedScene" uid="uid://splash_impact_red" path="res://src/content/vfx/splash_impact_red.tscn" id="9_red_splash"]
[ext_resource type="PackedScene" uid="uid://splash_impact_red_large" path="res://src/content/vfx/splash_impact_red_large.tscn" id="10_red_splash_lg"]

[sub_resource type="Resource" id="Resource_player"]
script = ExtResource("1_def")
pool_key = &"player_shots"
scene = ExtResource("3_player_shot")
initial_size = 15

[sub_resource type="Resource" id="Resource_boss"]
script = ExtResource("1_def")
pool_key = &"boss_shots"
scene = ExtResource("4_boss_shot")
initial_size = 30

[sub_resource type="Resource" id="Resource_minion"]
script = ExtResource("1_def")
pool_key = &"minion_shots"
scene = ExtResource("5_minion_shot")
initial_size = 20

[sub_resource type="Resource" id="Resource_homing"]
script = ExtResource("1_def")
pool_key = &"homing_boss_shots"
scene = ExtResource("6_homing")
initial_size = 40

[sub_resource type="Resource" id="Resource_spark"]
script = ExtResource("1_def")
pool_key = &"hit_sparks"
scene = ExtResource("7_spark")
initial_size = 25

[sub_resource type="Resource" id="Resource_gsplash"]
script = ExtResource("1_def")
pool_key = &"green_splashes"
scene = ExtResource("8_green_splash")
initial_size = 10

[sub_resource type="Resource" id="Resource_rsplash"]
script = ExtResource("1_def")
pool_key = &"red_splashes"
scene = ExtResource("9_red_splash")
initial_size = 20

[sub_resource type="Resource" id="Resource_rsplash_lg"]
script = ExtResource("1_def")
pool_key = &"red_splashes_large"
scene = ExtResource("10_red_splash_lg")
initial_size = 10

[resource]
script = ExtResource("2_man")
pools = Array[ExtResource("1_def")]([
    SubResource("Resource_player"),
    SubResource("Resource_boss"),
    SubResource("Resource_minion"),
    SubResource("Resource_homing"),
    SubResource("Resource_spark"),
    SubResource("Resource_gsplash"),
    SubResource("Resource_rsplash"),
    SubResource("Resource_rsplash_lg")
])


=====================================
FILE: ./src/data/encounters/encounter_00.tres
=====================================
[gd_resource type="Resource" script_class="EncounterData" load_steps=8 format=3 uid="uid://4lptu40or7m1"]

[ext_resource type="Script" path="res://src/data/encounters/encounter_data.gd" id="1_encounter"]
[ext_resource type="PackedScene" uid="uid://dmej4a7ykn2q0" path="res://src/entities/enemies/bosses/base_boss.tscn" id="2_boss_scene"]
[ext_resource type="PackedScene" uid="uid://c7d8faf0g1h2i" path="res://src/entities/enemies/minions/turret.tscn" id="4_turret_scene"]
[ext_resource type="PackedScene" uid="uid://d9e8f7g6h5i4j" path="res://src/entities/enemies/spawners/patrolling_lancer_spawner.tscn" id="5_lancer_spawner"]
[ext_resource type="PackedScene" path="res://src/entities/enemies/minions/flying_patroller.tscn" id="6_flyer_scene"]
[ext_resource type="Script" path="res://src/core/sequencing/sequence_step.gd" id="7_sequence_step"]
[ext_resource type="Script" path="res://src/core/sequencing/steps/wait_step.gd" id="8_wait_step"]
[ext_resource type="Script" path="res://src/core/sequencing/steps/emit_step.gd" id="9_emit_step"]
[ext_resource type="PackedScene" path="res://src/content/levels/level_00.tscn" id="10_level_scene"]

[sub_resource type="Resource" id="Resource_8vxlc"]
script = ExtResource("8_wait_step")
duration = 0.7

[sub_resource type="Resource" id="Resource_p5j6y"]
script = ExtResource("9_emit_step")
event_name = &"encounter.spawn_boss_requested"
payload = null

[resource]
script = ExtResource("1_encounter")
level_scene = ExtResource("10_level_scene")
boss_scene = ExtResource("2_boss_scene")
minion_spawns = {
"F": ExtResource("6_flyer_scene"),
"P": ExtResource("5_lancer_spawner"),
"T": ExtResource("4_turret_scene")
}
intro_sequence = Array[ExtResource("7_sequence_step")]([SubResource("Resource_8vxlc"), SubResource("Resource_p5j6y")])


=====================================
FILE: ./src/data/encounters/encounter_data.gd
=====================================
# src/data/encounters/encounter_data.gd
@tool
## A custom Resource that defines a complete encounter or stage.
class_name EncounterData
extends Resource

# --- Editor Properties ---
@export_group("Scene")
## The pre-built level scene (.tscn) to instantiate.
@export var level_scene: PackedScene

@export_group("Boss")
@export var boss_scene: PackedScene

@export_group("Minions")
@export var minion_spawns: Dictionary = {}

@export_group("Sequencing")
## An array of SequenceStep resources that run when the encounter begins.
@export var intro_sequence: Array[SequenceStep] = []


=====================================
FILE: ./src/data/world_config.tres
=====================================
[gd_resource type="Resource" script_class="WorldConfig" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/core/data/config/world_config.gd" id="1_script"]

[resource]
script = ExtResource("1_script")
gravity = 1200.0
hit_stop_player_melee_close = 0.025
hit_stop_player_hurt = 0.04
hit_stop_boss_phase_change = 0.1
hit_stop_boss_death = 0.1


=====================================
FILE: ./src/data/effects/red_splash_vfx.tres
=====================================
[gd_resource type="Resource" script_class="VFXEffect" load_steps=3 format=3 uid="uid://red_splash_vfx_res"]

[ext_resource type="Script" path="res://src/core/data/effects/vfx_effect.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://splash_impact_red" path="res://src/content/vfx/splash_impact_red.tscn" id="2_scene"]

[resource]
script = ExtResource("1_script")
scene = ExtResource("2_scene")
pool_key = &"red_splashes"


=====================================
FILE: ./src/data/effects/green_splash_vfx.tres
=====================================
[gd_resource type="Resource" script_class="VFXEffect" load_steps=3 format=3 uid="uid://green_splash_vfx_res"]

[ext_resource type="Script" path="res://src/core/data/effects/vfx_effect.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://splash_charge_green" path="res://src/content/vfx/splash_charge_green.tscn" id="2_scene"]

[resource]
script = ExtResource("1_script")
scene = ExtResource("2_scene")
pool_key = &"green_splashes"


=====================================
FILE: ./src/data/effects/boss_shockwave_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://boss_shockwave_effect"]

[ext_resource type="Script" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="Material" uid="uid://shockwave_material" path="res://src/content/materials/shockwave_material.tres" id="2_mat"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_mat")
duration = 0.8
params = {
"center": Vector2(0.5, 0.5),
"force": 0.05,
"thickness": 0.15
}
priority = 10
coalesce_window = 0.0


=====================================
FILE: ./src/data/effects/red_splash_large_vfx.tres
=====================================
[gd_resource type="Resource" script_class="VFXEffect" load_steps=3 format=3 uid="uid://red_splash_large_vfx_res"]

[ext_resource type="Script" path="res://src/core/data/effects/vfx_effect.gd" id="1_script"]
[ext_resource type="PackedScene" uid="uid://splash_impact_red_large" path="res://src/content/vfx/splash_impact_red_large.tscn" id="2_scene"]

[resource]
script = ExtResource("1_script")
scene = ExtResource("2_scene")
pool_key = &"red_splashes_large"


=====================================
FILE: ./src/data/effects/heavy_impact_chromatic.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://heavy_impact_chromatic"]

[ext_resource type="Script" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="Material" uid="uid://chromatic_material" path="res://src/content/materials/chromatic_material.tres" id="2_mat"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_mat")
duration = 0.3
params = {
"offset_strength": 8.0
}
priority = 5
coalesce_window = 0.1


=====================================
FILE: ./src/data/effects/entity_hit_flash_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://entity_hit_flash_effect"]

[ext_resource type="Script" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="ShaderMaterial" uid="uid://entity_hit_flash_mat" path="res://src/content/materials/entity_hit_flash_material.tres" id="2_material"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_material")
duration = 0.12
target_scope = 0
coalesce_window = 0.1

=====================================
FILE: ./src/data/enemy_config.tres
=====================================
[gd_resource type="Resource" script_class="EnemyConfig" load_steps=5 format=3 uid="uid://cm4r58pku22ug"]

[ext_resource type="Script" uid="uid://c1ran020tmpwh" path="res://src/core/data/config/enemy_config.gd" id="1_script"]
[ext_resource type="Script" uid="uid://bcahx6le3w04x" path="res://src/core/data/config/damage_response_config.gd" id="2_dmg_resp"]
[ext_resource type="Resource" path="res://src/data/effects/red_splash_vfx.tres" id="3_red_splash"]

[sub_resource type="Resource" id="Resource_dmg"]
script = ExtResource("2_dmg_resp")
invincibility_duration = 0.1
knockback_speed = 0.0
hazard_knockback_speed = 0.0

[resource]
script = ExtResource("1_script")
boss_health = 30
boss_patrol_speed = 100.0
damage_response = SubResource("Resource_dmg")
boss_lunge_speed = 1200.0
homing_shot_damage = 1
homing_shot_speed = 250.0
homing_shot_lifespan = 10.0
projectile_muzzle_vfx = ExtResource("3_red_splash")


=====================================
FILE: ./src/entities/archetypes/player_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=16 format=3 uid="uid://player_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/_base/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://b1x2y3z4a5b6" path="res://src/entities/_base/components/combat_component.tscn" id="3_combat"]
[ext_resource type="PackedScene" uid="uid://c7d8e9f0g1h2" path="res://src/entities/_base/components/input_component.tscn" id="4_input"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/_base/components/base_state_machine.tscn" id="5_fsm"]
[ext_resource type="PackedScene" uid="uid://o9p0q1r2s3t4" path="res://src/entities/player/components/player_physics_component.tscn" id="6_phys"]
[ext_resource type="PackedScene" uid="uid://a1b2c3d4e5f6" path="res://src/entities/player/components/player_resource_component.tscn" id="8_res"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/_base/components/fx_component.tscn" id="9_fx"]
[ext_resource type="PackedScene" path="res://src/entities/player/components/jump_component.tscn" id="10_jump"]
[ext_resource type="PackedScene" path="res://src/entities/player/components/dash_component.tscn" id="11_dash"]
[ext_resource type="PackedScene" path="res://src/entities/player/components/heal_component.tscn" id="12_heal"]
[ext_resource type="PackedScene" path="res://src/entities/player/components/charge_attack_component.tscn" id="13_charge"]
[ext_resource type="PackedScene" path="res://src/entities/player/components/pogo_component.tscn" id="14_pogo"]
[ext_resource type="PackedScene" uid="uid://status_effect_component_scene" path="res://src/entities/_base/components/status_effect_component.tscn" id="15_status"]
[ext_resource type="PackedScene" uid="uid://visual_component_scene" path="res://src/entities/_base/components/visual_component.tscn" id="16_visual"]

[resource]
script = ExtResource("1_archetype")
components = [
	ExtResource("2_health"), 
	ExtResource("3_combat"), 
	ExtResource("4_input"), 
	ExtResource("5_fsm"), 
	ExtResource("9_fx"), 
	ExtResource("6_phys"), 
	ExtResource("8_res"),
	ExtResource("10_jump"),
	ExtResource("11_dash"),
	ExtResource("12_heal"),
	ExtResource("13_charge"),
	ExtResource("14_pogo"),
	ExtResource("15_status"),
	ExtResource("16_visual")
]


=====================================
FILE: ./src/entities/archetypes/boss_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=7 format=3 uid="uid://boss_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/_base/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/_base/components/base_state_machine.tscn" id="3_fsm"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/_base/components/fx_component.tscn" id="4_fx"]
[ext_resource type="PackedScene" uid="uid://projectile_shooter_component_scene" path="res://src/entities/_base/components/projectile_shooter_component.tscn" id="5_shooter"]
[ext_resource type="PackedScene" uid="uid://status_effect_component_scene" path="res://src/entities/_base/components/status_effect_component.tscn" id="6_status"]

[resource]
script = ExtResource("1_archetype")
components = [ExtResource("2_health"), ExtResource("3_fsm"), ExtResource("4_fx"), ExtResource("5_shooter"), ExtResource("6_status")]


=====================================
FILE: ./src/entities/archetypes/minion_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=7 format=3 uid="uid://turret_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/_base/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/_base/components/base_state_machine.tscn" id="3_fsm"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/_base/components/fx_component.tscn" id="4_fx"]
[ext_resource type="PackedScene" uid="uid://projectile_shooter_component_scene" path="res://src/entities/_base/components/projectile_shooter_component.tscn" id="5_shooter"]
[ext_resource type="PackedScene" uid="uid://status_effect_component_scene" path="res://src/entities/_base/components/status_effect_component.tscn" id="6_status"]

[resource]
script = ExtResource("1_archetype")
components = [ExtResource("2_health"), ExtResource("3_fsm"), ExtResource("4_fx"), ExtResource("5_shooter"), ExtResource("6_status")]


=====================================
FILE: ./src/entities/archetypes/entity_archetype.gd
=====================================
# src/entities/archetypes/entity_archetype.gd
@tool
## A data resource that defines the component-based structure of an entity.
##
## This acts as a blueprint, telling a BaseEntity which components to instance
## and attach to itself at runtime.
class_name EntityArchetype
extends Resource

## An array of PackedScene files, where each scene is a component
## (e.g., HealthComponent.tscn, InputComponent.tscn).
@export var components: Array[PackedScene] = []


=====================================
FILE: ./src/entities/README.md
=====================================
Entities: how to add components & states
=======================================

Purpose
-------
Explain the minimal conventions for adding new components and states to the entity system.

Component contract (example)
----------------------------
Create components by extending the ComponentInterface base. Keep them small and single-purpose.

Example components (GDScript):

# res://src/entities/ComponentInterface.gd
extends Node2D
class_name ComponentInterface

# Called once when the entity or builder attaches the component.
func setup(config: Dictionary) -> void:
    pass

# Called when the component or entity is being destroyed / swapped.
func teardown() -> void:
    pass

# Example concrete component: HealthComponent
# res://src/entities/components/HealthComponent.gd
extends ComponentInterface
class_name HealthComponent

@export var max_hp: int = 100
var hp: int = 100

func setup(config: Dictionary) -> void:
    if config.has("max_hp"):
        max_hp = int(config["max_hp"])
    hp = max_hp

func receive_damage(amount: int) -> void:
    hp -= amount
    if hp <= 0:
        _on_dead()

func _on_dead() -> void:
    # notify EventBus / play death FX via ObjectPool
    EventBus.emit("entity_dead", { "entity": get_parent() })
    queue_free()

State machine (example)
-----------------------
BaseState provides enter/exit and processing hooks. States are swapped by the entity's BaseStateMachine.

# res://src/core/BaseState.gd
extends Node
class_name BaseState

func enter(data = null) -> void: pass
func exit() -> void: pass
func physics_process(delta: float) -> void: pass

# res://src/core/BaseStateMachine.gd
extends Node
class_name BaseStateMachine

var current_state: BaseState = null

func change_state(new_state: BaseState, data = null) -> void:
    if current_state:
        current_state.exit()
        current_state.queue_free() # if state is a node instance
    current_state = new_state
    add_child(current_state)
    current_state.enter(data)

Best practices
--------------
- Keep state logic deterministic; side-effects should be limited and explicit.
- Components must clean themselves up in `teardown()` (disconnect signals, stop timers).
- Use the `EventBus` for cross-system signals rather than global references.
- Store tunable numbers in `.tres` resources and refer to them in `setup()`.

Example workflow to add a component
----------------------------------
1. Create `res://src/entities/components/MyComponent.gd` extending `ComponentInterface`.
2. Expose tuning via `@export` variables or read from a provided config dictionary in `setup()`.
3. Add the component as a child to the entity scene or let entity builder attach it at spawn time.
4. Ensure `teardown()` reverses all runtime connections.



=====================================
FILE: ./src/entities/_base/components/base_state_machine.gd
=====================================
# src/entities/components/base_state_machine.gd
@tool
## A reusable, node-based state machine that conforms to the IComponent interface.
class_name BaseStateMachine
extends IComponent

const MAX_HISTORY_SIZE = 5
var states: Dictionary = {}
var current_state: BaseState
var owner_node: Node
var state_history: Array[String] = []
var _current_state_key: StringName = &""


func _ready() -> void:
	process_priority = -10


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()


func _unhandled_input(event: InputEvent) -> void:
	if current_state:
		current_state.process_input(event)


func _physics_process(delta: float) -> void:
	if current_state:
		current_state.process_physics(delta)


func _exit_tree() -> void:
	teardown()


func setup(_p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = _p_owner
	assert(p_dependencies.has("states"), "StateMachine setup requires a 'states' dictionary.")
	assert(
		p_dependencies.has("initial_state_key"),
		"StateMachine setup requires an 'initial_state_key'."
	)
	
	self.states = p_dependencies["states"]
	var initial_state_key = p_dependencies["initial_state_key"]
	change_state(initial_state_key)


func teardown() -> void:
	if current_state:
		current_state.exit()

	for state in states.values():
		if is_instance_valid(state):
			state.teardown()
			state.free()

	states.clear()
	state_history.clear()
	current_state = null
	# FIX: Reset the key so components know the FSM is inactive
	_current_state_key = &""


func change_state(new_state_key, msg := {}) -> void:
	if not states.has(new_state_key):
		push_warning("StateMachine: Attempted to change to unknown state '%s'." % new_state_key)
		return
	if _current_state_key == new_state_key:
		return
	if current_state:
		current_state.exit()

	_current_state_key = new_state_key
	current_state = states[new_state_key]
	current_state.enter(msg)

	var state_name = str(new_state_key)
	state_history.push_front(state_name)
	if state_history.size() > MAX_HISTORY_SIZE:
		state_history.pop_back()


func get_current_state_key() -> StringName:
	return _current_state_key


=====================================
FILE: ./src/entities/_base/components/health_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dpl3w8xqyq1a2"]

[ext_resource type="Script" path="res://src/entities/_base/components/health_component.gd" id="1_health"]

[node name="HealthComponent" type="Node"]
script = ExtResource("1_health")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource", "damage_config", "status_effect_component", "fx_manager", "event_bus")


=====================================
FILE: ./src/entities/_base/components/telegraph_component.gd
=====================================
# src/entities/components/telegraph_component.gd
@tool
## A self-contained, reusable component for displaying attack telegraphs.
class_name TelegraphComponent
extends Node2D

# --- Signals ---
## Emitted when the telegraph's duration has finished.
signal telegraph_finished

# --- Node References ---
@onready var visual: ColorRect = $Visual

# --- Public Methods ---

## Configures and starts the telegraph visual and timer.
func start_telegraph(duration: float, p_size: Vector2, p_position: Vector2, p_color: Color) -> void:
	self.global_position = p_position
	visual.size = p_size
	visual.color = p_color
	# Center the ColorRect on the component's position.
	visual.position = -p_size / 2.0

	var tween = create_tween()
	tween.tween_interval(duration)
	await tween.finished

	if is_instance_valid(self):
		telegraph_finished.emit()
		queue_free()


=====================================
FILE: ./src/entities/_base/components/fx_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://g7h8i9j0k1l2"]

[ext_resource type="Script" path="res://src/entities/_base/components/fx_component.gd" id="1_fx"]

[node name="FXComponent" type="Node"]
script = ExtResource("1_fx")
metadata/REQUIRED_DEPS = PackedStringArray("visual_node", "fx_manager")

=====================================
FILE: ./src/entities/_base/components/visual_component.gd
=====================================
# src/entities/components/visual_component.gd
@tool
## Manages the entity's main visual sprite/rect state and high-level VFX sequences (Death).
## Acts as an abstraction layer so logic doesn't need to know if the visual is a Sprite, ColorRect, etc.
class_name VisualComponent
extends IComponent

var _visual_node: CanvasItem
var _fx_component: FXComponent
var _config: Resource

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_visual_node = p_dependencies.get("visual_node")
	_config = p_dependencies.get("config")
	
	# Link to sibling FXComponent if available
	if p_owner.has_method("get_component"):
		_fx_component = p_owner.get_component(FXComponent)
	
	# Initialize default color if it's a primitive shape
	if _visual_node is ColorRect or _visual_node is Polygon2D:
		# Use the Palette constant for Player if this is the Player
		if p_owner.is_in_group(Identifiers.Groups.PLAYER):
			set_color(Palette.COLOR_PLAYER)
		elif p_owner.is_in_group(Identifiers.Groups.ENEMY):
			# Bosses might override this later, but defaults are safe
			pass


## Sets the visual facing direction.
## [param direction]: Non-zero float. Positive = Right, Negative = Left.
func set_facing(direction: float) -> void:
	if not is_instance_valid(_visual_node) or is_zero_approx(direction):
		return
	
	# Only flip if the sign differs (simple optimization)
	var new_scale_x = abs(_visual_node.scale.x) * sign(direction)
	if not is_equal_approx(_visual_node.scale.x, new_scale_x):
		_visual_node.scale.x = new_scale_x


## Sets the base color of the visual node.
## Handles ColorRect, Polygon2D, and generic CanvasItems (via modulate).
func set_color(color: Color) -> void:
	if not is_instance_valid(_visual_node):
		return
		
	if "color" in _visual_node:
		_visual_node.color = color
	else:
		_visual_node.modulate = color


## Orchestrates the death visual sequence (e.g., dissolve shader).
func play_death_sequence() -> Tween:
	if not is_instance_valid(_fx_component):
		return null
	
	# Fallback to config if available, or allow manual injection later
	var effect = _config.vfx_dissolve if (_config and "vfx_dissolve" in _config) else null
	
	if not is_instance_valid(effect):
		push_warning("VisualComponent: No dissolve effect configured for death sequence.")
		return null
		
	return _fx_component.play_effect(
		effect, 
		{}, 
		{"preserve_final_state": true}
	)


=====================================
FILE: ./src/entities/_base/components/combat_component.gd
=====================================
# src/entities/components/combat_component.gd
@tool
## Centralizes player offensive logic (Melee & Projectiles), excluding Pogo.
class_name CombatComponent
extends IComponent

# --- Signals ---
signal damage_dealt

# --- Member Variables ---
var owner_node: CharacterBody2D
var p_data: PlayerStateData
var _object_pool: IObjectPool
var _fx_manager: IFXManager
var _combat_utils: Node

# --- Hitbox References ---
var _melee_hitbox: HitboxComponent

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	process_priority = 0

func _physics_process(delta: float) -> void:
	if not is_instance_valid(owner_node):
		return
	_update_timers(delta)

# --- Public Methods ---
func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.p_data = p_dependencies.get("data_resource")
	
	self._object_pool = p_dependencies.get("object_pool")
	self._fx_manager = p_dependencies.get("fx_manager")
	self._combat_utils = p_dependencies.get("combat_utils")
	
	# Inject Hitboxes
	_melee_hitbox = p_dependencies.get("melee_hitbox")
	
	if is_instance_valid(_melee_hitbox):
		if not _melee_hitbox.hit_detected.is_connected(_on_melee_hit_detected):
			_melee_hitbox.hit_detected.connect(_on_melee_hit_detected)

	assert(is_instance_valid(_object_pool), "CombatComponent requires 'object_pool'.")
	assert(is_instance_valid(_fx_manager), "CombatComponent requires 'fx_manager'.")
	assert(is_instance_valid(_combat_utils), "CombatComponent requires 'combat_utils'.")


func teardown() -> void:
	set_physics_process(false)
	if is_instance_valid(_melee_hitbox) and _melee_hitbox.hit_detected.is_connected(_on_melee_hit_detected):
		_melee_hitbox.hit_detected.disconnect(_on_melee_hit_detected)

	owner_node = null
	p_data = null
	_object_pool = null
	_fx_manager = null
	_combat_utils = null
	_melee_hitbox = null


## Fires a player projectile from the object pool.
func fire_shot(is_max_charge: bool = false) -> void:
	p_data.combat.attack_cooldown_timer = p_data.config.attack_cooldown

	var shot = _object_pool.get_instance(Identifiers.Pools.PLAYER_SHOTS)
	if not shot:
		return

	var shot_dir = Vector2(p_data.physics.facing_direction, 0)
	# We assume InputComponent is updating the buffer elsewhere
	if Input.is_action_pressed("ui_up"):
		shot_dir = Vector2.UP
	elif Input.is_action_pressed("ui_down"):
		shot_dir = Vector2.DOWN

	shot.direction = shot_dir
	shot.global_position = owner_node.global_position + (shot_dir * 60)
	
	var final_damage = 1
	var final_scale = Vector2.ONE
	
	if is_max_charge:
		final_damage = p_data.config.level_2_damage
		final_scale = Vector2(2.0, 2.0) # Visual size increase for level 2
	
	var dependencies = {
		"object_pool": _object_pool,
		"combat_utils": _combat_utils,
		"fx_manager": _fx_manager,
		"damage": final_damage,
		"scale": final_scale
	}
	shot.activate(dependencies)


# --- Private Methods ---

func _update_timers(delta: float) -> void:
	if not is_instance_valid(p_data):
		return
	p_data.combat.attack_cooldown_timer = max(0.0, p_data.combat.attack_cooldown_timer - delta)
	p_data.combat.attack_duration_timer = max(0.0, p_data.combat.attack_duration_timer - delta)


# --- Private Signal Handlers ---

func _on_melee_hit_detected(target: Node) -> void:
	var target_id = target.get_instance_id()
	if p_data.combat.hit_targets_this_swing.has(target_id):
		return

	p_data.combat.hit_targets_this_swing[target_id] = true
	
	# --- 1. Projectile Destruction Logic ---
	if target.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		# Trigger the projectile's own impact VFX (Red Splash)
		if target.has_method("destroy_with_impact"):
			target.destroy_with_impact()
		else:
			if is_instance_valid(_object_pool):
				_object_pool.return_instance.call_deferred(target)
			else:
				target.queue_free()
			
		# Spawn Player Hit Spark (Green Splash)
		_spawn_player_spark(target.global_position)
		
		damage_dealt.emit()
		return

	# --- 2. Entity Damage Logic ---
	var damageable = _combat_utils.find_damageable(target)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.source_node = owner_node
		var distance = owner_node.global_position.distance_to(target.global_position)
		
		var is_close_range = distance <= p_data.config.close_range_threshold
		damage_info.amount = 5 if is_close_range else 1
		damage_info.impact_position = target.global_position
		damage_info.impact_normal = (target.global_position - owner_node.global_position).normalized()

		var damage_result = damageable.apply_damage(damage_info)
		if damage_result.was_damaged:
			damage_dealt.emit()
			
			# NEW: Spawn Player's Spark on successful hit
			_spawn_player_spark(target.global_position)
			
			if is_close_range:
				_fx_manager.request_hit_stop(
					p_data.world_config.hit_stop_player_melee_close
				)


func _spawn_player_spark(pos: Vector2) -> void:
	if not is_instance_valid(_fx_manager) or not p_data.config.hit_spark_effect:
		return
	_fx_manager.play_vfx(p_data.config.hit_spark_effect, pos, Vector2.UP)


=====================================
FILE: ./src/entities/_base/components/hurtbox_component.gd
=====================================
# src/entities/components/hurtbox_component.gd
@tool
## A component that manages an Area2D to detect incoming damage sources.
##
## It polls for overlapping bodies and areas (Enemies, Hazards, Projectiles)
## and routes damage to the owner's [HealthComponent].
class_name HurtboxComponent
extends Area2D

# --- Dependencies ---
var _health_component: HealthComponent
var _combat_utils: Node # Service
var _object_pool: IObjectPool # Service
var _owner_entity: Node

# --- Configuration ---
# If true, this component will automatically find the HealthComponent on the parent.
@export var auto_wire_health: bool = true
# DEPRECATED: State change is now handled by the Entity listening to HealthComponent.
@export var hurt_response_state: StringName = &""

# --- Godot Lifecycle ---

func _ready() -> void:
	# Ensure we are monitoring to detect overlaps
	monitoring = true
	monitorable = true 

func _physics_process(_delta: float) -> void:
	if not is_instance_valid(_health_component) or _health_component.is_invincible():
		return

	# 1. Check Bodies (Enemies, Hazards)
	for body in get_overlapping_bodies():
		_process_contact(body)

	# 2. Check Areas (Projectiles, Hazards)
	for area in get_overlapping_areas():
		_process_contact(area)


# --- Public Methods (IComponent-like Setup) ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_owner_entity = p_owner
	
	if p_dependencies.has("services"):
		var services = p_dependencies["services"]
		_combat_utils = services.combat_utils
		_object_pool = services.object_pool
	else:
		_combat_utils = CombatUtils
		_object_pool = ObjectPoolAdapter

	if auto_wire_health and p_owner.has_method("get_component"):
		_health_component = p_owner.get_component(HealthComponent)


func teardown() -> void:
	set_physics_process(false)
	set_deferred("monitoring", false)
	_owner_entity = null
	_health_component = null
	_combat_utils = null
	_object_pool = null


# --- Private Logic ---

func _process_contact(target: Node) -> void:
	# CRITICAL FIX: Guard against mid-frame teardown.
	if not _combat_utils or not is_instance_valid(_health_component):
		return

	var is_hazard = target.is_in_group(Identifiers.Groups.HAZARD)
	var is_enemy = target.is_in_group(Identifiers.Groups.ENEMY)
	var is_proj = target.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE)

	if not (is_hazard or is_enemy or is_proj):
		return

	var impact_normal = (global_position - target.global_position).normalized()
	
	var damage_info = _combat_utils.create_damage_info(
		1, 
		target,
		global_position,
		impact_normal
	)

	# We apply damage. The HealthComponent will emit 'took_damage',
	# which the Player entity listens to for Knockback and State Change.
	_health_component.apply_damage(damage_info)

	if target.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		# Projectiles should destroy themselves, but as a backup/legacy behavior:
		if is_instance_valid(_object_pool):
			_object_pool.return_instance.call_deferred(target)


=====================================
FILE: ./src/entities/_base/components/melee_component.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://melee_component_scene"]

[ext_resource type="Script" path="res://src/entities/_base/components/melee_component.gd" id="1_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_placeholder"]
size = Vector2(10, 10)

[node name="MeleeComponent" type="Node2D"]
script = ExtResource("1_script")
metadata/REQUIRED_DEPS = PackedStringArray("services")

[node name="Hitbox" type="Area2D" parent="."]
collision_layer = 8
collision_mask = 0
monitorable = true

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hitbox"]
shape = SubResource("RectangleShape2D_placeholder")
disabled = true

=====================================
FILE: ./src/entities/_base/components/projectile_shooter_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://projectile_shooter_component_scene"]

[ext_resource type="Script" path="res://src/entities/_base/components/projectile_shooter_component.gd" id="1_shooter_script"]

[node name="ProjectileShooterComponent" type="Node2D"]
script = ExtResource("1_shooter_script")
metadata/REQUIRED_DEPS = PackedStringArray("services", "data_resource")


=====================================
FILE: ./src/entities/_base/components/status_effect_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://status_effect_component_scene"]

[ext_resource type="Script" path="res://src/entities/_base/components/status_effect_component.gd" id="1_script"]

[node name="StatusEffectComponent" type="Node"]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/_base/components/status_effect_component.gd
=====================================
# src/entities/components/status_effect_component.gd
@tool
## Manages temporary status effects (buffs/debuffs) and queryable tags.
## Example: Tracks "Invincibility", "Stun", "DoT".
class_name StatusEffectComponent
extends IComponent

# --- Inner Class for Runtime Tracking ---
class ActiveEffect:
	var source_resource: StatusEffect
	var time_remaining: float
	
	func _init(res: StatusEffect) -> void:
		source_resource = res
		time_remaining = res.duration

# --- Member Variables ---
var _owner_node: Node
var _active_effects: Array[ActiveEffect] = []
var _tags: Dictionary = {} # Map<StringName, int> (Tag -> Count)

# --- Godot Lifecycle ---
func _process(delta: float) -> void:
	if _active_effects.is_empty():
		return
	
	# Iterate backwards to allow safe removal during iteration
	for i in range(_active_effects.size() - 1, -1, -1):
		var active = _active_effects[i]
		
		# Execute Tick Logic (for DoTs/HoTs)
		if active.source_resource.has_method("on_tick"):
			active.source_resource.on_tick(delta, _owner_node, self)
		
		# Handle Duration
		if active.source_resource.duration > 0:
			active.time_remaining -= delta
			if active.time_remaining <= 0:
				_remove_active_effect_at(i)

# --- IComponent Contract ---
func setup(p_owner: Node, _p_dependencies: Dictionary = {}) -> void:
	_owner_node = p_owner

func teardown() -> void:
	# Cleanly remove all effects so they can execute their on_remove logic (cleanup tags)
	for i in range(_active_effects.size() - 1, -1, -1):
		_remove_active_effect_at(i)
	_active_effects.clear()
	_tags.clear()
	_owner_node = null

# --- Public API ---

## Applies a new status effect to the entity.
func apply_effect(effect_res: StatusEffect) -> void:
	if not is_instance_valid(effect_res):
		return
		
	var active = ActiveEffect.new(effect_res)
	_active_effects.append(active)
	
	# Trigger application logic (e.g., adding tags)
	effect_res.on_apply(_owner_node, self)


## Manually removes a specific effect instance.
func remove_effect_instance(effect_res: StatusEffect) -> void:
	for i in range(_active_effects.size() - 1, -1, -1):
		if _active_effects[i].source_resource == effect_res:
			_remove_active_effect_at(i)
			return


## Checks if a specific tag is currently active (Count > 0).
## e.g. has_tag("invincible")
func has_tag(tag: StringName) -> bool:
	return _tags.get(tag, 0) > 0


# --- Tag Management (Called by StatusEffect resources) ---

func add_tag(tag: StringName) -> void:
	if tag == &"": return
	_tags[tag] = _tags.get(tag, 0) + 1

func remove_tag(tag: StringName) -> void:
	if not _tags.has(tag): return
	_tags[tag] -= 1
	if _tags[tag] <= 0:
		_tags.erase(tag)

# --- Private ---

func _remove_active_effect_at(index: int) -> void:
	var active = _active_effects[index]
	if is_instance_valid(active.source_resource):
		active.source_resource.on_remove(_owner_node, self)
	_active_effects.remove_at(index)


=====================================
FILE: ./src/entities/_base/components/telegraph_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1i2c3d4e5f6g"]

[ext_resource type="Script" path="res://src/entities/_base/components/telegraph_component.gd" id="1_telegraph_script"]

[node name="TelegraphComponent" type="Node2D"]
script = ExtResource("1_telegraph_script")

[node name="Visual" type="ColorRect" parent="."]
offset_right = 40.0
offset_bottom = 40.0
color = Color(1, 1, 1, 0.392157)


=====================================
FILE: ./src/entities/_base/components/visual_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://visual_component_scene"]

[ext_resource type="Script" path="res://src/entities/_base/components/visual_component.gd" id="1_script"]

[node name="VisualComponent" type="Node"]
script = ExtResource("1_script")
metadata/REQUIRED_DEPS = PackedStringArray("visual_node", "config")


=====================================
FILE: ./src/entities/_base/components/input_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://c7d8e9f0g1h2"]

[ext_resource type="Script" path="res://src/entities/_base/components/input_component.gd" id="1_input"]

[node name="InputComponent" type="Node"]
script = ExtResource("1_input")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource")


=====================================
FILE: ./src/entities/_base/components/health_component.gd
=====================================
# src/entities/components/health_component.gd
@tool
class_name HealthComponent
extends IDamageable

# --- Signals ---
signal health_changed(current_health: int, max_health: int)
signal died
signal health_threshold_reached(health_percentage: float)
signal took_damage(damage_info: DamageInfo, damage_result: DamageResult)

const InvincibilityEffectScript = preload("res://src/shared/status_effects/invincibility_effect.gd")

# --- Member Variables ---
var entity_data: Resource
var owner_node: CharacterBody2D

var _max_health: int
var _invincibility_duration: float
var _knockback_speed: float
var _hazard_knockback_speed: float
var _damage_audio_cue: AudioCue 

var _active_invincibility_map: Dictionary = {} # Map<token_int, StatusEffect>
var _next_token_id: int = 1

var _fx_manager: IFXManager
var _event_bus
# REMOVED: _hit_spark_effect - Impact VFX are now handled by the Attacker.
var _audio_manager: Node 
var _status_effect_component: StatusEffectComponent 

# --- Lifecycle ---
func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

# --- Setup ---
func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.entity_data = p_dependencies.get("data_resource")
	
	self._fx_manager = p_dependencies.get("fx_manager")
	self._event_bus = p_dependencies.get("event_bus")
	self._status_effect_component = p_dependencies.get("status_effect_component")
	
	if p_dependencies.has("audio_manager"):
		self._audio_manager = p_dependencies.get("audio_manager")
	else:
		self._audio_manager = AudioManager

	var dmg_config = p_dependencies.get("damage_config")

	# Validate critical dependencies
	if not entity_data or not dmg_config or not _fx_manager or not _event_bus:
		push_error("HealthComponent.setup: Missing required dependencies.")
		return
		
	if not _status_effect_component:
		push_warning("HealthComponent: StatusEffectComponent missing. Invincibility will not work.")

	_max_health = entity_data.max_health
	
	_invincibility_duration = dmg_config.invincibility_duration
	_knockback_speed = dmg_config.knockback_speed
	_hazard_knockback_speed = dmg_config.hazard_knockback_speed
	_damage_audio_cue = dmg_config.audio_cue 

	entity_data.health = _max_health
	health_changed.emit(entity_data.health, _max_health)

func teardown() -> void:
	entity_data = null
	owner_node = null
	_fx_manager = null
	_event_bus = null
	_damage_audio_cue = null
	_audio_manager = null
	_status_effect_component = null
	_active_invincibility_map.clear()

# --- Logic ---
func apply_damage(damage_info: DamageInfo) -> DamageResult:
	var result := DamageResult.new()

	if not is_instance_valid(damage_info):
		return result

	if is_invincible() and not damage_info.bypass_invincibility:
		return result

	var health_before_damage: int = entity_data.health
	entity_data.health -= damage_info.amount
	health_changed.emit(entity_data.health, _max_health)

	# Apply post-hit invincibility via Status System
	if is_instance_valid(_status_effect_component) and _invincibility_duration > 0:
		var effect = InvincibilityEffectScript.new()
		effect.duration = _invincibility_duration
		_status_effect_component.apply_effect(effect)

	result.knockback_velocity = _calculate_knockback(damage_info.source_node)
	_check_for_threshold_crossing(health_before_damage, entity_data.health)

	result.was_damaged = true
	took_damage.emit(damage_info, result)

	# NOTE: VFX spawning moved to Attacker (CombatComponent/MeleeComponent).
	
	if result.was_damaged and is_instance_valid(_damage_audio_cue) and is_instance_valid(_audio_manager):
		_audio_manager.play_cue(_damage_audio_cue)

	if entity_data.health <= 0:
		died.emit()

	return result

func is_invincible() -> bool:
	if is_instance_valid(_status_effect_component):
		return _status_effect_component.has_tag(&"invincible")
	return false

# Legacy API Wrapper for Compatibility
func grant_invincibility(_requester: Object) -> int:
	if not is_instance_valid(_status_effect_component):
		return -1
		
	var token_id := _next_token_id
	_next_token_id += 1
	
	var effect = InvincibilityEffectScript.new()
	effect.duration = 0.0 # Infinite, manual removal
	_status_effect_component.apply_effect(effect)
	
	_active_invincibility_map[token_id] = effect
	return token_id

func release_invincibility(token: int) -> void:
	if not is_instance_valid(_status_effect_component):
		return
		
	if _active_invincibility_map.has(token):
		var effect = _active_invincibility_map[token]
		_status_effect_component.remove_effect_instance(effect)
		_active_invincibility_map.erase(token)

func _check_for_threshold_crossing(health_before: int, health_after: int) -> void:
	# LSP Fix: Use BaseEntity contract instead of duck typing
	var thresholds: Array[float] = []
	if owner_node is BaseEntity:
		thresholds = (owner_node as BaseEntity).get_health_thresholds()
		
	if thresholds.is_empty():
		return

	var old_percent: float = float(health_before) / _max_health
	var new_percent: float = float(health_after) / _max_health
	for threshold in thresholds:
		if old_percent > threshold and new_percent <= threshold:
			health_threshold_reached.emit(threshold)

func _calculate_knockback(source: Node) -> Vector2:
	if _knockback_speed == 0 or not is_instance_valid(source):
		return Vector2.ZERO
	var knockback_dir: Vector2 = (owner_node.global_position - source.global_position).normalized()
	var speed: float = _knockback_speed
	if source.is_in_group(Identifiers.Groups.HAZARD):
		speed = _hazard_knockback_speed
	return (knockback_dir + Vector2.UP * 0.5).normalized() * speed


=====================================
FILE: ./src/entities/_base/components/base_state_machine.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://i3j4k5l6m7n8"]

[ext_resource type="Script" path="res://src/entities/_base/components/base_state_machine.gd" id="1_fsm"]

[node name="StateMachine" type="Node"]
script = ExtResource("1_fsm")

=====================================
FILE: ./src/entities/_base/components/hitbox_component.gd
=====================================
# src/entities/components/hitbox_component.gd
@tool
## A component that wraps an Area2D to handle attack collision detection.
##
## It abstracts collision masking and signal reporting for melee/pogo attacks.
class_name HitboxComponent
extends Area2D

# --- Signals ---
signal hit_detected(target: Node)

# --- Exported Properties ---
## If true, configures masks to hit the Player. If false, hits Enemies.
@export var target_player: bool = false

# --- Node References ---
# We assume a CollisionShape2D is a direct child, standard for Area2D.
@onready var _shape_node: CollisionShape2D = $CollisionShape2D

# --- Godot Lifecycle ---
func _ready() -> void:
	# Hitboxes are "active" zones, not physical obstacles.
	monitorable = false
	monitoring = false
	
	# Standardize collision layer for hitboxes (Layer 9)
	collision_layer = PhysicsLayers.HITBOX
	
	# Configure masks based on intended target
	if target_player:
		collision_mask = PhysicsLayers.PLAYER_HURTBOX
	else:
		# Hit Enemies (4), Projectiles (16), and Hazards (8)
		collision_mask = PhysicsLayers.ENEMY | PhysicsLayers.ENEMY_PROJECTILE | PhysicsLayers.HAZARD

	if not body_entered.is_connected(_on_contact):
		body_entered.connect(_on_contact)
	if not area_entered.is_connected(_on_contact):
		area_entered.connect(_on_contact)


# --- Public API ---

## Enables the hitbox with specific shape parameters.
func activate(shape: Shape2D, position_offset: Vector2) -> void:
	if is_instance_valid(_shape_node):
		if shape:
			_shape_node.shape = shape
		_shape_node.position = position_offset
		_shape_node.set_deferred("disabled", false)
	
	set_deferred("monitoring", true)


## Disables the hitbox.
func deactivate() -> void:
	set_deferred("monitoring", false)
	if is_instance_valid(_shape_node):
		_shape_node.set_deferred("disabled", true)


## Manually sets the visual/logical offset of the shape (useful for debug/sync).
func set_shape_offset(offset: Vector2) -> void:
	if is_instance_valid(_shape_node):
		_shape_node.position = offset


# --- Private Logic ---

func _on_contact(target: Node) -> void:
	hit_detected.emit(target)


=====================================
FILE: ./src/entities/_base/components/input_component.gd
=====================================
# src/entities/_base/components/input_component.gd
@tool
## A component that centralizes all raw input polling.
## Uses Dependency Inversion to allow for input mocking in tests.
class_name InputComponent
extends IComponent

# --- Member Variables ---
var owner_node: CharacterBody2D
var p_data: Resource # PlayerStateData
var _input_provider: IInputProvider

## The strictly typed input state for the current frame.
var input: InputFrame = InputFrame.new()

# --- Godot Lifecycle Methods ---

func _ready() -> void:
	process_priority = -100

func _physics_process(_delta: float) -> void:
	if Engine.is_editor_hint():
		return

	if not is_instance_valid(owner_node) or not _input_provider:
		return

	# Reset frame state
	# (Optimization: We reuse the same instance to avoid GC churn, just overwriting values)
	
	# Use the provider instead of global Input
	input.move_axis = _input_provider.get_axis(Identifiers.Actions.MOVE_LEFT, Identifiers.Actions.MOVE_RIGHT)
	input.up = _input_provider.is_action_pressed(Identifiers.Actions.MOVE_UP)
	input.down = _input_provider.is_action_pressed(Identifiers.Actions.MOVE_DOWN)
	
	input.jump_just_pressed = _input_provider.is_action_just_pressed(Identifiers.Actions.JUMP)
	input.jump_pressed = _input_provider.is_action_pressed(Identifiers.Actions.JUMP)
	input.jump_released = _input_provider.is_action_just_released(Identifiers.Actions.JUMP)
	
	input.attack_pressed = _input_provider.is_action_pressed(Identifiers.Actions.ATTACK)
	input.attack_just_pressed = _input_provider.is_action_just_pressed(Identifiers.Actions.ATTACK)
	input.attack_released = _input_provider.is_action_just_released(Identifiers.Actions.ATTACK)
	
	input.dash_pressed = _input_provider.is_action_just_pressed(Identifiers.Actions.DASH)


# --- Public Methods ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.p_data = p_dependencies.get("data_resource")
	
	if p_dependencies.has("input_provider"):
		self._input_provider = p_dependencies["input_provider"]
	else:
		# Fallback for tests or standalone use
		self._input_provider = StandardInputProvider.new()

	if not p_data:
		push_error("InputComponent.setup: Missing 'data_resource' dependency.")
		return

func teardown() -> void:
	set_physics_process(false)
	owner_node = null
	p_data = null
	_input_provider = null
	# input = null # Keep the instance to avoid null checks, just leave it stale


=====================================
FILE: ./src/entities/_base/components/combat_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1x2y3z4a5b6"]

[ext_resource type="Script" path="res://src/entities/_base/components/combat_component.gd" id="1_combat"]

[node name="CombatComponent" type="Node"]
script = ExtResource("1_combat")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource", "object_pool", "fx_manager", "combat_utils", "services")

=====================================
FILE: ./src/entities/_base/components/fx_component.gd
=====================================
# src/entities/components/fx_component.gd
@tool
## A dedicated component for managing all entity-specific visual effects.
##
## CONTRACT: This component requires a "visual_node" and an "fx_manager" dependency.
## It will automatically discover a "HealthComponent" on its owner to trigger damage effects.
class_name FXComponent
extends IComponent

# --- Member Variables ---
var _owner: Node
var _visual_node: CanvasItem
var _health_component: HealthComponent
var _hit_effect: ShaderEffect  # Injected Dependency
var _fx_manager: IFXManager   # Holds a direct reference to the service.

# --- Godot Lifecycle Methods ---
func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self._owner = p_owner
	
	assert(p_dependencies.has("fx_manager"), "FXComponent requires an 'fx_manager' dependency.")
	self._fx_manager = p_dependencies.get("fx_manager")
	assert(is_instance_valid(_fx_manager), "Injected 'fx_manager' must be a valid IFXManager.")

	assert(p_dependencies.has("visual_node"), "FXComponent requires a 'visual_node' dependency.")
	_visual_node = p_dependencies.get("visual_node")
	assert(
		is_instance_valid(_visual_node) and _visual_node is CanvasItem,
		"'visual_node' must be a valid CanvasItem."
	)

	if _owner.has_method("get_component"):
		_health_component = _owner.get_component(HealthComponent)

	if is_instance_valid(_health_component):
		assert(
			p_dependencies.has("hit_effect"),
			"FXComponent requires a 'hit_effect' dependency when a HealthComponent is present."
		)
		_hit_effect = p_dependencies.get("hit_effect")
		assert(
			is_instance_valid(_hit_effect),
			"Injected 'hit_effect' must be a valid ShaderEffect resource."
		)
		if not _health_component.took_damage.is_connected(_on_owner_took_damage):
			_health_component.took_damage.connect(_on_owner_took_damage)

func teardown() -> void:
	if is_instance_valid(_fx_manager):
		_fx_manager.cancel_effect_on_node(_visual_node)

	if is_instance_valid(_health_component):
		if _health_component.took_damage.is_connected(_on_owner_took_damage):
			_health_component.took_damage.disconnect(_on_owner_took_damage)

	_visual_node = null
	_owner = null
	_health_component = null
	_fx_manager = null

# --- Public API ---
func play_effect(effect: ShaderEffect, overrides: Dictionary = {}, opts: Dictionary = {}) -> Tween:
	if not is_instance_valid(_visual_node):
		push_warning("FXComponent cannot play effect: visual node is invalid.")
		return null
	return _fx_manager.apply_shader_effect(_visual_node, effect, overrides, opts)

# --- Signal Handlers ---
func _on_owner_took_damage(_damage_info: DamageInfo, _damage_result: DamageResult) -> void:
	if is_instance_valid(_hit_effect):
		play_effect(_hit_effect)


=====================================
FILE: ./src/entities/_base/components/melee_component.gd
=====================================
# src/entities/components/melee_component.gd
@tool
## A generic, data-driven component for executing melee attacks.
##
## This component manages a hitbox Area2D and orchestrates the telegraph,
## attack duration, and damage application based on a provided MeleeAttackData resource.
class_name MeleeComponent
extends IComponent

# --- Signals ---
## Emitted when the attack successfully hits a valid target.
signal hit_confirmed
## Emitted when the full attack sequence (telegraph + duration) is complete.
signal attack_finished

# --- Constants ---
const DEFAULT_TELEGRAPH_SCENE = preload(AssetPaths.SCENE_TELEGRAPH_COMPONENT)

# --- Node References ---
@onready var hitbox: Area2D = $Hitbox
@onready var collision_shape: CollisionShape2D = $Hitbox/CollisionShape2D

# --- Private Member Variables ---
var _owner: BaseEntity
var _combat_utils: Node
var _fx_manager: IFXManager
var _current_attack_data: MeleeAttackData
var _hit_targets_this_swing: Dictionary = {}
var _is_attacking: bool = false

# --- IComponent Contract ---
func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self._owner = p_owner as BaseEntity
	self._combat_utils = p_dependencies.get("combat_utils")
	self._fx_manager = p_dependencies.get("fx_manager")
	
	assert(is_instance_valid(_owner), "MeleeComponent must be owned by a BaseEntity.")
	assert(is_instance_valid(_combat_utils), "MeleeComponent requires 'combat_utils'.")
	assert(is_instance_valid(_fx_manager), "MeleeComponent requires 'fx_manager'.")
	
	hitbox.body_entered.connect(_on_hitbox_body_entered)
	hitbox.area_entered.connect(_on_hitbox_area_entered)


func teardown() -> void:
	if is_instance_valid(hitbox):
		if hitbox.body_entered.is_connected(_on_hitbox_body_entered):
			hitbox.body_entered.disconnect(_on_hitbox_body_entered)
		if hitbox.area_entered.is_connected(_on_hitbox_area_entered):
			hitbox.area_entered.disconnect(_on_hitbox_area_entered)
	_owner = null
	_combat_utils = null
	_fx_manager = null


# --- Public API ---
## The main entry point to start a melee attack sequence.
func perform_attack(attack_data: MeleeAttackData) -> void:
	if _is_attacking or not is_instance_valid(attack_data):
		return

	_is_attacking = true
	_current_attack_data = attack_data
	_hit_targets_this_swing.clear()
	
	_execute_attack_sequence()


# --- Private Logic ---
func _execute_attack_sequence() -> void:
	var facing_direction = _owner.entity_data.facing_direction if "facing_direction" in _owner.entity_data else 1.0
	
	# --- 1. Telegraph Phase ---
	if _current_attack_data.telegraph_duration > 0.0:
		# OCP: Use the scene defined in data, fallback to default if null.
		var scene_to_instantiate = _current_attack_data.telegraph_scene
		if not scene_to_instantiate:
			scene_to_instantiate = DEFAULT_TELEGRAPH_SCENE
			
		var telegraph = scene_to_instantiate.instantiate()
		_owner.add_child(telegraph)
		
		var telegraph_size = _current_attack_data.shape.get_rect().size
		var telegraph_offset = _current_attack_data.offset
		var telegraph_position = _owner.global_position + (telegraph_offset * Vector2(facing_direction, 1.0))
		
		# Duck-typing check to ensure the custom scene supports the API
		if telegraph.has_method("start_telegraph"):
			telegraph.start_telegraph(
				_current_attack_data.telegraph_duration,
				telegraph_size,
				telegraph_position,
				Palette.COLOR_UI_PANEL_BG
			)
			await telegraph.telegraph_finished
		else:
			push_warning("Telegraph scene '%s' does not implement 'start_telegraph'. Skipping wait." % telegraph.name)
			telegraph.queue_free()
		
		# GUARD CLAUSE: Check if we are still valid after the wait
		if not is_instance_valid(self) or not is_instance_valid(_owner) or not is_instance_valid(collision_shape):
			return

	# --- 2. Attack Phase ---
	collision_shape.shape = _current_attack_data.shape
	hitbox.position = _current_attack_data.offset * Vector2(facing_direction, 1.0)
	
	hitbox.monitoring = true
	# Use the new dedicated hitbox layer.
	hitbox.collision_layer = PhysicsLayers.HITBOX
	
	if _owner.is_in_group(Identifiers.Groups.PLAYER):
		hitbox.collision_mask = PhysicsLayers.ENEMY | PhysicsLayers.ENEMY_PROJECTILE
	else:
		hitbox.collision_mask = PhysicsLayers.PLAYER_HURTBOX
	
	collision_shape.disabled = false
	
	await get_tree().create_timer(_current_attack_data.duration).timeout
	
	# GUARD CLAUSE: Check if we are still valid after the wait
	if not is_instance_valid(self) or not is_instance_valid(hitbox) or not is_instance_valid(collision_shape):
		return
		
	# --- 3. Cleanup ---
	collision_shape.disabled = true
	hitbox.monitoring = false
	hitbox.collision_layer = 0
	hitbox.collision_mask = 0
	
	_is_attacking = false
	attack_finished.emit()


func _process_hit(collider: Node) -> void:
	var target_id = collider.get_instance_id()
	if _hit_targets_this_swing.has(target_id):
		return

	_hit_targets_this_swing[target_id] = true
	
	var damageable: IDamageable = _combat_utils.find_damageable(collider)
	if is_instance_valid(damageable):
		var impact_normal = (collider.global_position - _owner.global_position).normalized()
		
		# DRY: Use factory method
		var damage_info = _combat_utils.create_damage_info(
			_current_attack_data.damage_amount,
			_owner,
			collider.global_position,
			impact_normal
		)
		
		var result := damageable.apply_damage(damage_info)
		if result.was_damaged:
			if is_instance_valid(_current_attack_data.hit_spark_effect):
				_fx_manager.play_vfx(
					_current_attack_data.hit_spark_effect,
					damage_info.impact_position,
					damage_info.impact_normal
				)
			
			if _current_attack_data.hit_stop_duration > 0.0:
				_fx_manager.request_hit_stop(_current_attack_data.hit_stop_duration)
			
			hit_confirmed.emit()


# --- Signal Handlers ---
func _on_hitbox_body_entered(body: Node) -> void:
	_process_hit(body)


func _on_hitbox_area_entered(area: Area2D) -> void:
	_process_hit(area)


=====================================
FILE: ./src/entities/_base/components/sensor_component.gd
=====================================
# src/entities/components/sensor_component.gd
@tool
## A component that wraps an Area2D to detect specific entities (e.g., Player).
##
## It can automatically update a boolean property on a data resource when
## the target enters or exits the area, removing boilerplate from the entity.
class_name SensorComponent
extends Area2D

# --- Signals ---
signal target_entered(body: Node)
signal target_exited(body: Node)

# --- Configuration ---
## The physics group to detect (e.g., "player").
@export var target_group: String = "player"

## Optional: The name of the boolean property to toggle on the entity's state data.
## Example: "is_player_in_range"
@export var state_property_name: StringName = &""

# --- Private Variables ---
var _data_resource: Resource
var _active_targets: Array[Node] = []

# --- Godot Lifecycle ---

func _ready() -> void:
	# Sensors are detectors, so they monitor but are not monitorable themselves.
	monitoring = true
	monitorable = false
	
	# Standard sensor configuration:
	# Layer 10 (512) = Sensors
	# Mask 1 (1) = Player (default, can be changed in editor)
	collision_layer = 512
	collision_mask = 1 
	
	if not body_entered.is_connected(_on_body_entered):
		body_entered.connect(_on_body_entered)
	if not body_exited.is_connected(_on_body_exited):
		body_exited.connect(_on_body_exited)


# --- Public API ---

## Sets up the component with the entity's data resource.
## This allows the sensor to write directly to the state data.
func setup(_p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	if p_dependencies.has("data_resource"):
		_data_resource = p_dependencies["data_resource"]


# --- Private Logic ---

func _update_state_property() -> void:
	if not _data_resource or state_property_name == &"":
		return
	
	# If we have at least one valid target in the area, the property is true.
	var is_active = not _active_targets.is_empty()
	# Only update if the property actually exists to prevent runtime errors
	if _data_resource.get(state_property_name) != null:
		_data_resource.set(state_property_name, is_active)


# --- Signal Handlers ---

func _on_body_entered(body: Node) -> void:
	if target_group != "" and not body.is_in_group(target_group):
		return
	
	if not _active_targets.has(body):
		_active_targets.append(body)
		_update_state_property()
		target_entered.emit(body)


func _on_body_exited(body: Node) -> void:
	if _active_targets.has(body):
		_active_targets.erase(body)
		_update_state_property()
		target_exited.emit(body)


=====================================
FILE: ./src/entities/_base/components/projectile_shooter_component.gd
=====================================
# src/entities/components/projectile_shooter_component.gd
@tool
## A component responsible for firing projectiles.
## It handles object pooling and targeting logic for ranged attacks.
class_name ProjectileShooterComponent
extends IComponent

# --- Dependencies ---
var _owner: Node2D
var _entity_data: Resource # BossStateData or MinionStateData
var _object_pool: IObjectPool
var _combat_utils: Node
var _targeting_system: Node
var _fx_manager: IFXManager # Need this for VFX

# --- Private Variables ---
var _active_volley_tween: Tween
var _player_node: Node2D

# --- IComponent Contract ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self._owner = p_owner as Node2D
	self._entity_data = p_dependencies.get("data_resource")
	self._object_pool = p_dependencies.get("object_pool")
	self._combat_utils = p_dependencies.get("combat_utils")
	self._targeting_system = p_dependencies.get("targeting_system")
	
	# Try to get FXManager from services (BaseEntity usually passes it)
	if p_dependencies.has("services"):
		self._fx_manager = p_dependencies.get("services").fx_manager
	
	assert(is_instance_valid(_owner), "ProjectileShooterComponent requires a Node2D owner.")
	assert(is_instance_valid(_entity_data), "ProjectileShooterComponent requires an entity data resource.")
	assert(is_instance_valid(_object_pool), "ProjectileShooterComponent requires 'object_pool'.")
	
	if not Engine.is_editor_hint():
		if not _targeting_system:
			_targeting_system = ServiceLocator.targeting_system
		_player_node = _targeting_system.get_first(Identifiers.Groups.PLAYER)


func teardown() -> void:
	if is_instance_valid(_active_volley_tween):
		_active_volley_tween.kill()
	_owner = null
	_entity_data = null
	_object_pool = null
	_combat_utils = null
	_player_node = null
	_targeting_system = null
	_fx_manager = null


# --- Public API ---

## Fires a sequence of shots with a delay between them.
func fire_volley(shot_count: int, delay: float) -> void:
	if is_instance_valid(_active_volley_tween):
		_active_volley_tween.kill()
	
	_active_volley_tween = create_tween()
	
	for i in range(shot_count):
		_active_volley_tween.tween_callback(fire_shot_at_player)
		if i < shot_count - 1:
			_active_volley_tween.tween_interval(delay)


## Fires a single shot directly at the player's current position.
func fire_shot_at_player() -> void:
	if not is_instance_valid(_owner):
		return
		
	if not is_instance_valid(_player_node) and is_instance_valid(_targeting_system):
		_player_node = _targeting_system.get_first(Identifiers.Groups.PLAYER)

	if not is_instance_valid(_player_node):
		return

	if _owner.get("_is_dead"):
		return

	var pool_key: StringName = _entity_data.projectile_pool_key
	if pool_key == &"":
		return

	var shot: Node = _object_pool.get_instance(pool_key)
	if not shot:
		return

	var direction = (_player_node.global_position - _owner.global_position).normalized()
	
	if "facing_direction" in _entity_data and not is_zero_approx(direction.x):
		_entity_data.facing_direction = sign(direction.x)

	if "direction" in shot:
		shot.direction = direction
	if "global_position" in shot:
		shot.global_position = _owner.global_position
	
	var dependencies = {
		"object_pool": _object_pool,
		"combat_utils": _combat_utils,
		"fx_manager": _fx_manager # Pass FXManager to projectile
	}
	
	if shot.has_method("activate"):
		shot.activate(dependencies)
		
	# --- Muzzle Flash VFX ---
	_spawn_muzzle_vfx(direction)


func _spawn_muzzle_vfx(dir: Vector2) -> void:
	if not is_instance_valid(_fx_manager) or not _entity_data or not _entity_data.config:
		return
		
	# Check if config has the property (EnemyConfig)
	if "projectile_muzzle_vfx" in _entity_data.config:
		var vfx = _entity_data.config.projectile_muzzle_vfx
		if is_instance_valid(vfx):
			_fx_manager.play_vfx(vfx, _owner.global_position, dir)


=====================================
FILE: ./src/entities/_base/states/state_entity_fall.gd
=====================================
# src/entities/states/state_entity_fall.gd
## A generic, shared state for any BaseEntity that is airborne and affected by gravity.
class_name StateEntityFall
extends BaseState

var _entity # Untyped to avoid cyclic parser error


func enter(_msg := {}) -> void:
	self._entity = owner


func process_physics(delta: float) -> void:
	if not is_instance_valid(_entity):
		return

	# UPDATE: gravity comes from world_config
	var gravity: float = _entity._services.world_config.gravity
	_entity.velocity.y += gravity * delta
	
	# Apply horizontal friction/drag
	_entity.velocity.x = move_toward(_entity.velocity.x, 0, 100 * delta)

	# Check for landing
	if _entity.is_on_floor():
		var idle_state_key = Identifiers.MinionStates.IDLE
		if _entity.is_in_group(Identifiers.Groups.ENEMY) and _entity.has_method("get_health_thresholds"):
			# Duck-typing check for Boss
			idle_state_key = Identifiers.BossStates.IDLE
		
		state_machine.change_state(idle_state_key)


=====================================
FILE: ./src/entities/_base/states/state_entity_patrol.gd
=====================================
# src/entities/common_states/state_entity_patrol.gd
## A generic state for moving an entity according to its MovementLogic.
class_name StateEntityPatrol
extends BaseState

var _entity: BaseEntity

func enter(_msg := {}) -> void:
	_entity = owner as BaseEntity
	# Reset timer if the entity has one for patrolling
	if _entity.has_node("PatrolTimer"):
		_entity.get_node("PatrolTimer").start()

func process_physics(delta: float) -> void:
	if not is_instance_valid(_entity):
		return

	# 1. Allow child classes (or injected logic) to check for state changes
	if _check_interrupts():
		return

	# 2. Execute Movement Logic
	var logic: MovementLogic
	
	# Polymorphic access to behavior.movement_logic
	if "entity_data" in _entity:
		var data = _entity.entity_data
		if "behavior" in data and data.behavior and data.behavior.movement_logic:
			logic = data.behavior.movement_logic
			
			# LSP Check: Ensure the data conforms to the BaseEntityData contract
			if data is BaseEntityData:
				_entity.velocity = logic.execute(delta, _entity, data)

# Virtual method for subclasses to override
func _check_interrupts() -> bool:
	return false


=====================================
FILE: ./src/entities/_base/states/state_entity_idle.gd
=====================================
# src/entities/common_states/state_entity_idle.gd
## A generic state that stops horizontal movement and checks for interruptions.
class_name StateEntityIdle
extends BaseState

var _entity: BaseEntity

func enter(_msg := {}) -> void:
	_entity = owner as BaseEntity
	_entity.velocity.x = 0

func process_physics(_delta: float) -> void:
	if _check_interrupts():
		return

# Virtual method for subclasses (AI logic)
func _check_interrupts() -> bool:
	return false


=====================================
FILE: ./src/entities/_base/scripts/base_entity.gd
=====================================
# src/entities/base_entity.gd
@tool
## The generic base class for all component-based entities in the game.
class_name BaseEntity
extends CharacterBody2D

# --- Editor Properties ---
@export var archetype: EntityArchetype

# --- Public Member Variables ---
@warning_ignore("unused_private_class_variable")
var _is_dead: bool = false

# --- Private Member Variables ---
var _components_initialized: bool = false
var _services
var _components: Dictionary = {}
var _components_by_interface: Dictionary = {}
var _player: CharacterBody2D


# --- Godot Lifecycle Methods ---
func _ready() -> void:
	if Engine.is_editor_hint():
		return
	
	# Deferred build to ensure Autoloads are ready
	call_deferred("build_entity")

func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

func _physics_process(_delta: float) -> void:
	if Engine.is_editor_hint() or _is_dead:
		return
	
	# Centralized physics execution.
	# Subclasses should update velocity before calling super._physics_process().
	move_and_slide()

func _exit_tree() -> void:
	# Defined to allow subclasses to call super._exit_tree() safely
	pass


# --- Public Methods ---

## The main entry point for self-construction.
func build_entity() -> void:
	if _components_initialized:
		return
		
	if not _services:
		_services = ServiceLocator
	
	# Safely access targeting system if available
	if _services and _services.get("targeting_system"):
		_player = _services.targeting_system.get_first(Identifiers.Groups.PLAYER)
	
	# CRITICAL: Instantiate components from the archetype before configuration
	_build_from_archetype()
	
	_on_build() 


## Retrieves a component from this entity by its script type or an interface it implements.
func get_component(type: Script) -> IComponent:
	if _components.has(type):
		return _components.get(type)

	if _components_by_interface.has(type):
		return _components_by_interface.get(type)

	return null


## Helper that asserts and provides a clear error if a required component is missing.
func require_component(type: Script) -> IComponent:
	var c = get_component(type)
	if not is_instance_valid(c):
		push_error("Missing required component: %s on entity %s" % [type.resource_path, name])
	return c


func inject_dependencies(p_services) -> void:
	_services = p_services


func teardown() -> void:
	# Auto-disconnect HealthComponent signals to prevent memory leaks
	var hc = get_component(HealthComponent)
	if is_instance_valid(hc):
		if hc.died.is_connected(_on_entity_died):
			hc.died.disconnect(_on_entity_died)
		if hc.health_changed.is_connected(_on_health_changed):
			hc.health_changed.disconnect(_on_health_changed)

	for child in get_children():
		if child is IComponent:
			child.teardown()
	
	_components.clear()
	_components_by_interface.clear()
	_components_initialized = false


func setup_components(
	shared_dependencies: Dictionary = {}, per_component_dependencies: Dictionary = {}
) -> void:
	if _components_initialized:
		return

	var base_shared_deps = shared_dependencies.duplicate()
	
	# ISP: Deconstruct ServiceLocator so components can request specific interfaces
	var s = _services if _services else ServiceLocator
	base_shared_deps["services"] = s # Legacy support
	base_shared_deps["event_bus"] = s.event_bus
	base_shared_deps["fx_manager"] = s.fx_manager
	base_shared_deps["object_pool"] = s.object_pool
	base_shared_deps["combat_utils"] = s.combat_utils
	base_shared_deps["grid_utils"] = s.grid_utils
	base_shared_deps["audio_manager"] = AudioManager
	
	# DIP: Inject Input Provider
	if s.get("input_provider"):
		base_shared_deps["input_provider"] = s.input_provider
	else:
		# Fallback to creating one if ServiceLocator isn't fully ready (rare)
		base_shared_deps["input_provider"] = StandardInputProvider.new()
	
	if s.get("targeting_system"):
		base_shared_deps["targeting_system"] = s.targeting_system

	# DIP: Auto-extract DamageResponseConfig if present in the main config.
	if base_shared_deps.has("config"):
		var cfg = base_shared_deps["config"]
		if cfg and cfg.get("damage_response") != null:
			base_shared_deps["damage_config"] = cfg.damage_response

	# Auto-inject sibling StatusEffectComponent if present
	var status_comp = get_component(StatusEffectComponent)
	if is_instance_valid(status_comp):
		base_shared_deps["status_effect_component"] = status_comp

	for child in get_children():
		if not (child is IComponent):
			continue

		var class_key: String = child.get_script().get_global_name()

		if child.has_meta("REQUIRED_DEPS"):
			var required = child.get_meta("REQUIRED_DEPS")
			var all_deps_for_check = base_shared_deps.duplicate()
			if per_component_dependencies.has(child):
				all_deps_for_check.merge(per_component_dependencies[child])
			
			if per_component_dependencies.has(class_key):
				all_deps_for_check.merge(per_component_dependencies[class_key])

			if not DependencyValidator.validate(child, all_deps_for_check, required):
				push_error("Dependency validation failed for %s. Aborting entity setup." % child.name)
				return

		var merged_deps := base_shared_deps.duplicate()

		if per_component_dependencies.has(child):
			merged_deps.merge(per_component_dependencies[child])

		if per_component_dependencies.has(class_key):
			merged_deps.merge(per_component_dependencies[class_key])

		if child.has_method("setup"):
			child.setup(self, merged_deps)

	# NEW: Auto-wire common components after setup
	var hc = get_component(HealthComponent)
	if is_instance_valid(hc):
		if not hc.died.is_connected(_on_entity_died):
			hc.died.connect(_on_entity_died)
		if not hc.health_changed.is_connected(_on_health_changed):
			hc.health_changed.connect(_on_health_changed)

	_components_initialized = true


# --- Protected Virtual Methods (for children to override) ---

func _on_build() -> void:
	pass

# Virtual signal handlers
func _on_entity_died() -> void:
	pass

func _on_health_changed(_current: int, _max: int) -> void:
	pass

## Virtual method: Returns specific health percentages (0.0 to 1.0) that trigger events.
## Default implementation returns empty. Subclasses (e.g. BaseBoss) should override this.
func get_health_thresholds() -> Array[float]:
	return []


# --- Private Methods ---
func _build_from_archetype() -> void:
	if not is_instance_valid(archetype):
		push_error("Entity '%s' is missing its Archetype resource." % name)
		return

	for component_scene in archetype.components:
		if is_instance_valid(component_scene):
			var component_instance = component_scene.instantiate()
			add_child(component_instance)
		else:
			push_warning("Archetype for '%s' contains an invalid component scene." % name)

	_cache_components_by_type()


func _cache_components_by_type() -> void:
	_components.clear()
	_components_by_interface.clear()
	
	for child in get_children():
		if not child is IComponent:
			continue

		var component_script: Script = child.get_script()
		_components[component_script] = child
		
		var base_script: Script = component_script.get_base_script()
		while is_instance_valid(base_script):
			if base_script.resource_path.is_empty() or base_script == IComponent:
				break
			_components_by_interface[base_script] = child
			base_script = base_script.get_base_script()


=====================================
FILE: ./src/entities/_base/scripts/base_state.gd
=====================================
# src/entities/components/base_state.gd
## The abstract base class for all entity states.
##
## Defines the lifecycle methods that every state must implement. States are
## responsible for handling logic for a specific entity behavior (e.g., moving,
## attacking, dashing).
class_name BaseState
extends Object

# --- Member Variables ---
var owner: Node
var state_machine: Node
var state_data: Resource

# --- Constructor ---


func _init(p_owner: Node, p_state_machine: Node, p_state_data: Resource) -> void:
	self.owner = p_owner
	self.state_machine = p_state_machine
	self.state_data = p_state_data


# --- Public Methods ---


## Called by the state machine upon exiting to break cyclic references.
func teardown() -> void:
	owner = null
	state_machine = null
	state_data = null


# --- Virtual Lifecycle Methods ---


## Called once when the state machine enters this state.
func enter(_msg := {}) -> void:
	pass


## Called once when the state machine exits this state.
func exit() -> void:
	pass


## Called every physics frame. Used for movement and physics-based logic.
func process_physics(_delta: float) -> void:
	pass


## Called during the `_unhandled_input` cycle. Used for immediate input reactions.
func process_input(_event: InputEvent) -> void:
	pass


=====================================
FILE: ./src/entities/enemies/spawners/spawner.gd
=====================================
# src/entities/spawners/spawner.gd
## A generic, reusable spawner for instantiating scenes at runtime.
##
## Manages a timer, tracks the number of active instances it has spawned,
## and ensures dependencies are injected into the newly created nodes.
class_name Spawner
extends Node2D

@export_group("Configuration")
## The scene that this spawner will instantiate.
@export var scene_to_spawn: PackedScene
## The delay in seconds between spawn attempts.
@export_range(0.1, 60.0, 0.1) var spawn_delay: float = 10.0
## The maximum number of active instances this spawner can manage at once.
@export_range(1, 10, 1) var max_spawned_instances: int = 1
## If true, the spawner will begin its timer as soon as it enters the scene.
@export var autostart: bool = true
## If true, the spawner will create its first instance immediately.
@export var spawn_on_start: bool = true

# --- Node References ---
@onready var timer: Timer = $Timer

# --- Private Member Variables ---
var _spawned_instances: Array[Node] = []
var _services: ServiceLocator

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	set_process(false)
	set_physics_process(false)
	
	if not Engine.is_editor_hint():
		_services = get_node("/root/ServiceLocator")
		assert(is_instance_valid(_services), "Spawner could not find ServiceLocator.")
		
		timer.wait_time = spawn_delay
		
		if spawn_on_start:
			_spawn_instance()
		
		if autostart:
			timer.start()


# --- Private Methods ---


func _spawn_instance() -> void:
	if not is_instance_valid(scene_to_spawn):
		push_warning("Spawner has no valid 'scene_to_spawn' configured.")
		return
	
	_spawned_instances = _spawned_instances.filter(
		func(instance): return is_instance_valid(instance)
	)

	if _spawned_instances.size() >= max_spawned_instances:
		return

	var new_instance: Node = scene_to_spawn.instantiate()
	
	if new_instance is BaseEntity:
		new_instance.inject_dependencies(_services)

	# Use call_deferred to prevent modifying the scene tree during _ready().
	get_parent().call_deferred("add_child", new_instance)
	if new_instance is Node2D:
		new_instance.global_position = self.global_position

	_spawned_instances.append(new_instance)


# --- Signal Handlers ---


func _on_timer_timeout() -> void:
	_spawn_instance()


=====================================
FILE: ./src/entities/enemies/spawners/spawner.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://c5t6u7v8w9x0y"]

[ext_resource type="Script" path="res://src/entities/enemies/spawners/spawner.gd" id="1_spawner_script"]

[node name="Spawner" type="Node2D"]
script = ExtResource("1_spawner_script")

[node name="Timer" type="Timer" parent="."]

[connection signal="timeout" from="Timer" to="." method="_on_timer_timeout"]


=====================================
FILE: ./src/entities/enemies/spawners/patrolling_lancer_spawner.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://d9e8f7g6h5i4j"]

[ext_resource type="PackedScene" uid="uid://c5t6u7v8w9x0y" path="res://src/entities/enemies/spawners/spawner.tscn" id="1_base_spawner"]
[ext_resource type="PackedScene" uid="uid://c0mbo7v8y9fg1" path="res://src/entities/enemies/minions/patrolling_lancer.tscn" id="2_lancer_scene"]

[node name="PatrollingLancerSpawner" instance=ExtResource("1_base_spawner")]
scene_to_spawn = ExtResource("2_lancer_scene")
spawn_delay = 7.0
max_spawned_instances = 5

=====================================
FILE: ./src/entities/enemies/bosses/attack_patterns/lunge_attack.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://y6g5o6f7h8ja"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/game/combat/attack_logic/lunge_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")
logic = ExtResource("2_logic")
telegraph_duration = 0.8
attack_duration = 0.5
cooldown = 2.0
projectile_count = 0
volley_delay = 0.0


=====================================
FILE: ./src/entities/enemies/bosses/attack_patterns/homing_omni_burst_pattern.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://dibqnlm2wg88d"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://bwg6k1f2vxo7g" path="res://src/game/combat/attack_logic/homing_omni_burst_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")
logic = ExtResource("2_logic")
telegraph_duration = 1.2
attack_duration = 1.0
cooldown = 3.5
projectile_count = 30
volley_delay = 0.0


=====================================
FILE: ./src/entities/enemies/bosses/attack_patterns/volley_3_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://cihbnl4747m0a"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://dw7h56g0o6aex" path="res://src/game/combat/attack_logic/volley_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")
logic = ExtResource("2_logic")
telegraph_duration = 0.5
attack_duration = 0.8
cooldown = 1.5
projectile_count = 3
volley_delay = 0.2


=====================================
FILE: ./src/entities/enemies/bosses/attack_patterns/volley_5_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://01x2y3a4b5c6"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://c1w6fobw8biag" path="res://src/game/combat/attack_logic/projectile_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")
logic = ExtResource("2_logic")
telegraph_duration = 0.6
attack_duration = 1.0
cooldown = 2.5
projectile_count = 5
volley_delay = 0.15


=====================================
FILE: ./src/entities/enemies/bosses/attack_patterns/attack_pattern.gd
=====================================
# src/entities/boss/attack_patterns/attack_pattern.gd
@tool
## A data resource that defines the properties of a single boss attack.
##
## This combines timing data with a swappable "AttackLogic" resource that
## contains the actual execution code for the attack (Strategy Pattern).
class_name AttackPattern
extends Resource

# --- Editor Properties ---
@export var logic: AttackLogic  ## The script that defines HOW this attack behaves.
@export var telegraph_duration: float = 0.5
@export var attack_duration: float = 0.1
@export var cooldown: float = 1.5

@export_group("Visuals")
## The scene to instantiate for the telegraph. If null, uses the default.
@export var telegraph_scene: PackedScene

@export_group("Attack-Specific Data")
# These parameters now live in the AttackPattern, where they belong.
@export var projectile_count: int = 1
@export var volley_delay: float = 0.2


=====================================
FILE: ./src/entities/enemies/bosses/attack_patterns/single_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://bve7t5ucr1k"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://c1w6fobw8biag" path="res://src/game/combat/attack_logic/projectile_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")
logic = ExtResource("2_logic")
telegraph_duration = 0.5
attack_duration = 0.1
cooldown = 0.75
projectile_count = 1
volley_delay = 0.0


=====================================
FILE: ./src/entities/enemies/bosses/boss_state_data.gd
=====================================
# src/entities/boss/boss_state_data.gd
@tool
## A Resource that holds all shared runtime state data for the Boss.
class_name BossStateData
extends BaseEntityData

# --- Configuration References ---
var behavior: BossBehavior

# --- Combat ---
var projectile_pool_key: StringName = &""

# --- Targeting ---
var is_player_in_close_range: bool = false


=====================================
FILE: ./src/entities/enemies/bosses/base_boss.tscn
=====================================
[gd_scene load_steps=14 format=3 uid="uid://dmej4a7ykn2q0"]

[ext_resource type="Script" uid="uid://5bkyx4fguxor" path="res://src/entities/enemies/bosses/base_boss.gd" id="1_26qjf"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_hit_flash"]
[ext_resource type="PackedScene" path="res://src/entities/_base/components/melee_component.tscn" id="3_melee_component"]
[ext_resource type="Resource" path="res://src/core/data/effects/boss_phase_change_shake.tres" id="7_phase_shake"]
[ext_resource type="Resource" path="res://src/core/data/effects/boss_death_shake.tres" id="8_death_shake"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="9_hit_spark_effect"]
[ext_resource type="Resource" path="res://src/entities/archetypes/boss_archetype.tres" id="10_archetype"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="18_dissolve_effect"]
[ext_resource type="Resource" uid="uid://cypy26d84f23b" path="res://src/entities/enemies/bosses/data/default_boss_behavior.tres" id="19_default_behavior"]
[ext_resource type="Script" uid="uid://c6b7cy6cfequ7" path="res://src/entities/_base/components/sensor_component.gd" id="20_sensor_script"]
[ext_resource type="Resource" uid="uid://s5xi3ciavs2n" path="res://src/entities/enemies/bosses/data/boss_state_machine_config.tres" id="21_sm_config"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossbody"]
size = Vector2(60, 60)

[sub_resource type="CircleShape2D" id="CircleShape2D_closetrigger"]
radius = 100.0

[node name="BaseBoss" type="CharacterBody2D"]
collision_layer = 4
collision_mask = 138
script = ExtResource("1_26qjf")
behavior = ExtResource("19_default_behavior")
state_machine_config = ExtResource("21_sm_config")
hit_flash_effect = ExtResource("2_hit_flash")
phase_change_shake_effect = ExtResource("7_phase_shake")
death_shake_effect = ExtResource("8_death_shake")
hit_spark_effect = ExtResource("9_hit_spark_effect")
dissolve_effect = ExtResource("18_dissolve_effect")
archetype = ExtResource("10_archetype")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
pivot_offset = Vector2(30, 30)
color = Color(1, 0.6, 0.6, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossbody")

[node name="MeleeComponent" parent="." instance=ExtResource("3_melee_component")]

[node name="CloseRangeDetector" type="Area2D" parent="."]
collision_layer = 512
monitorable = false
script = ExtResource("20_sensor_script")
state_property_name = &"is_player_in_close_range"

[node name="CollisionShape2D" type="CollisionShape2D" parent="CloseRangeDetector"]
shape = SubResource("CircleShape2D_closetrigger")


=====================================
FILE: ./src/entities/enemies/bosses/states/state_boss_melee.gd
=====================================
# src/entities/boss/states/state_boss_melee.gd
## A state that triggers a melee attack and waits for it to complete.
class_name BossStateMelee
extends BaseState

# --- Constants ---
const LungeMeleeAttackData = preload("res://src/data/combat/attacks/boss_lunge_melee.tres")

# --- Private Member Variables ---
var _melee_component: MeleeComponent


func enter(msg := {}) -> void:
	owner.velocity = Vector2.ZERO
	_melee_component = owner.get_component(MeleeComponent)
	
	if not is_instance_valid(_melee_component):
		push_error("BossStateMelee requires a MeleeComponent on the owner. Aborting attack.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return
	
	# Default to the lunge follow-up, but allow other states to specify a different attack.
	var attack_to_perform = msg.get("attack_data", LungeMeleeAttackData)
	
	_melee_component.attack_finished.connect(_on_attack_finished, CONNECT_ONE_SHOT)
	_melee_component.perform_attack(attack_to_perform)


func exit() -> void:
	if is_instance_valid(_melee_component) and _melee_component.attack_finished.is_connected(_on_attack_finished):
		_melee_component.attack_finished.disconnect(_on_attack_finished)


# --- Signal Handlers ---
func _on_attack_finished() -> void:
	if state_machine.current_state == self:
		# Use the cooldown from the attack we just performed.
		var attack_data = _melee_component._current_attack_data
		var cooldown_time = 1.0
		if is_instance_valid(attack_data):
			cooldown_time = attack_data.telegraph_duration + attack_data.duration + 0.5
		
		state_machine.change_state(Identifiers.BossStates.COOLDOWN, {"duration": cooldown_time})


=====================================
FILE: ./src/entities/enemies/bosses/states/state_boss_idle.gd
=====================================
# src/entities/boss/states/state_boss_idle.gd
## A specialized idle state for the Boss.
## It immediately selects the next attack pattern (Transient State).
class_name BossStateIdle
extends StateEntityIdle

func enter(msg := {}) -> void:
	super.enter(msg)
	
	# Boss Idle is unique: it immediately decides what to do next.
	# We can do this directly in enter() or via the interrupt check.
	_decide_next_action()

func _decide_next_action() -> void:
	# Removed strict casting to avoid cyclic dep
	var boss = owner
	if boss.current_attack_patterns.is_empty():
		push_warning("BossStateIdle: No attack patterns. Defaulting to Cooldown.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	var chosen_pattern: AttackPattern = boss.current_attack_patterns.pick_random()
	state_machine.change_state(Identifiers.BossStates.ATTACK, {"pattern": chosen_pattern})


=====================================
FILE: ./src/entities/enemies/bosses/states/state_boss_lunge.gd
=====================================
# src/entities/boss/states/state_boss_lunge.gd
## Executes a high-speed, invulnerable dash attack across the arena.
extends BaseState
class_name BossStateLunge

# --- Private Member Variables ---
var _boss # Untyped
var _health: HealthComponent
var _lunge_duration: float
var _invincibility_token: int

# --- State Lifecycle ---


func enter(msg := {}) -> void:
	self._boss = owner
	if not _boss:
		return

	_health = _boss.get_component(HealthComponent)

	var pattern: AttackPattern = msg.get("pattern")
	_lunge_duration = pattern.attack_duration if pattern else 0.5

	_invincibility_token = _health.grant_invincibility(self)
	_boss.velocity = Vector2(state_data.facing_direction * state_data.config.boss_lunge_speed, 0)


func exit() -> void:
	if is_instance_valid(_boss) and is_instance_valid(_health):
		_health.release_invincibility(_invincibility_token)


func process_physics(delta: float) -> void:
	_lunge_duration -= delta
	if _lunge_duration <= 0:
		# UPDATE: Use constant
		state_machine.change_state(Identifiers.CommonStates.MELEE)


=====================================
FILE: ./src/entities/enemies/bosses/states/state_boss_cooldown.gd
=====================================
# src/entities/boss/states/state_boss_cooldown.gd
## The state for when the boss is waiting after completing an attack.
extends BaseState
class_name BossStateCooldown

var _timer: float = 0.0

func enter(msg := {}) -> void:
	owner.velocity.x = 0
	_timer = msg.get("duration", 1.0) # Default to 1.0s if not provided

func process_physics(delta: float) -> void:
	_timer -= delta
	if _timer <= 0:
		state_machine.change_state(Identifiers.BossStates.PATROL)


=====================================
FILE: ./src/entities/enemies/bosses/states/state_boss_attack.gd
=====================================
# src/entities/boss/states/state_boss_attack.gd
## Handles the telegraph and execution of the boss's attacks.
class_name BossStateAttack
extends BaseState

# --- Constants ---
const DEFAULT_TELEGRAPH_SCENE = preload(AssetPaths.SCENE_TELEGRAPH_COMPONENT)

# --- Private Member Variables ---
var _current_pattern: AttackPattern
var _boss # Untyped to avoid cycles

# --- State Lifecycle ---


func enter(msg := {}) -> void:
	self._boss = owner
	if not _boss:
		push_error("BossStateAttack: Owner is not a BaseBoss. Aborting.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	if not msg.has("pattern") or not msg.pattern is AttackPattern:
		push_error("BossStateAttack: No valid 'pattern' provided. Aborting.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	_current_pattern = msg.get("pattern")
	_start_telegraph_and_attack()


# --- Private Methods ---


func _start_telegraph_and_attack() -> void:
	if not is_instance_valid(_current_pattern.logic):
		push_warning("AttackPattern is missing its 'logic' resource.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	# OCP: Use pattern-specific telegraph if available, else default.
	var scene_to_use = _current_pattern.telegraph_scene
	if not scene_to_use:
		scene_to_use = DEFAULT_TELEGRAPH_SCENE

	var telegraph = scene_to_use.instantiate()
	_boss.add_child(telegraph)

	var telegraph_info = _current_pattern.logic.get_telegraph_info(_boss, _current_pattern)
	var telegraph_size = telegraph_info.get("size", Vector2.ONE * 100)
	var relative_offset = telegraph_info.get("offset", Vector2.ZERO)

	var directional_offset = Vector2(
		relative_offset.x * _boss.entity_data.facing_direction, relative_offset.y
	)
	var telegraph_position = _boss.global_position + directional_offset

	if telegraph.has_method("start_telegraph"):
		telegraph.start_telegraph(
			_current_pattern.telegraph_duration,
			telegraph_size,
			telegraph_position,
			Palette.COLOR_UI_PANEL_BG
		)
		await telegraph.telegraph_finished
	else:
		# Fallback if custom scene doesn't match interface (prevents soft lock)
		telegraph.queue_free()
		await _boss.get_tree().create_timer(_current_pattern.telegraph_duration).timeout

	# Use a robust check to ensure the owner wasn't freed during the await.
	if not is_instance_valid(_boss):
		return

	var attack_command: Callable = _current_pattern.logic.execute(_boss, _current_pattern)
	if attack_command.is_valid():
		attack_command.call()

	if state_machine.current_state == self:
		# Pass the cooldown duration to the next state
		state_machine.change_state(Identifiers.BossStates.COOLDOWN, {"duration": _current_pattern.cooldown})


=====================================
FILE: ./src/entities/enemies/bosses/states/state_boss_patrol.gd
=====================================
# src/entities/boss/states/state_boss_patrol.gd
## A specialized patrol state for the Boss that inherits generic movement logic
## but adds specific interrupt conditions (Close Range Melee).
class_name BossStatePatrol
extends StateEntityPatrol

const QuickSwipeData = preload("res://src/data/combat/attacks/boss_quick_swipe.tres")
const PATROL_DURATION: float = 3.0

var _timer: float = 0.0

func enter(msg := {}) -> void:
	super.enter(msg)
	_timer = PATROL_DURATION

func process_physics(delta: float) -> void:
	# 1. Update Timer
	_timer -= delta
	if _timer <= 0:
		state_machine.change_state(Identifiers.BossStates.IDLE)
		return

	# 2. Run Generic Patrol Logic (Movement)
	super.process_physics(delta)

# Override the virtual method from StateEntityPatrol
func _check_interrupts() -> bool:
	# High-priority check: if player gets too close, interrupt patrol to attack.
	if state_data.is_player_in_close_range:
		state_machine.change_state(Identifiers.CommonStates.MELEE, {"attack_data": QuickSwipeData})
		return true
	
	return false


=====================================
FILE: ./src/entities/enemies/bosses/base_boss.gd
=====================================
# src/entities/boss/base_boss.gd
@tool
class_name BaseBoss
extends BaseEntity

# --- Editor Configuration ---
@export_group("Core Configuration")
@export var behavior: BossBehavior
@export var state_machine_config: StateMachineConfig

@export_group("Juice & Feedback")
@export var hit_flash_effect: ShaderEffect
@export var phase_change_shake_effect: ScreenShakeEffect
@export var death_shake_effect: ScreenShakeEffect
@export var hit_spark_effect: VFXEffect
@export var dissolve_effect: ShaderEffect

@export_group("State Scripts")
@export var state_idle_script: Script
@export var state_attack_script: Script
@export var state_cooldown_script: Script
@export var state_patrol_script: Script
@export var state_lunge_script: Script
@export var state_melee_script: Script

# --- Node References ---
# Note: visual_sprite managed by VisualComponent
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var close_range_detector: SensorComponent = $CloseRangeDetector

# --- Public Member Variables ---
var current_attack_patterns: Array[AttackPattern] = []
var phases_remaining: int = 3
var entity_data: BossStateData

var _visual_component: VisualComponent

# --- Godot Lifecycle Methods ---
func _get_configuration_warnings() -> PackedStringArray:
	var warnings = PackedStringArray()
	if not archetype:
		warnings.append("This node requires an EntityArchetype resource.")
	if not behavior:
		warnings.append("This node requires a BossBehavior resource.")
	elif is_instance_valid(behavior) and behavior.phase_1_patterns.is_empty():
		warnings.append("The assigned BossBehavior has no Phase 1 attack patterns.")
	if not state_machine_config:
		warnings.append("This node requires a StateMachineConfig resource.")
	return warnings


func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint():
		return

	if not is_in_group(Identifiers.Groups.ENEMY):
		add_to_group(Identifiers.Groups.ENEMY)
	
	ServiceLocator.targeting_system.register(self, Identifiers.Groups.ENEMY)

	_initialize_data()
	
	# Trigger internal build
	build_entity()


func _physics_process(delta: float) -> void:
	if Engine.is_editor_hint() or not is_instance_valid(entity_data):
		return
	
	# Calculate Gravity locally
	if not is_on_floor():
		velocity.y += entity_data.world_config.gravity * delta
	
	# Delegate execution to BaseEntity
	super._physics_process(delta)


func _exit_tree() -> void:
	super._exit_tree()
	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.ENEMY)


# --- Internal Build Logic ---
func _on_build() -> void:
	if is_instance_valid(close_range_detector):
		close_range_detector.setup(self, {"data_resource": entity_data})

	var hc: HealthComponent = get_component(HealthComponent)
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	var fc: FXComponent = get_component(FXComponent)
	
	# Create/Fetch VisualComponent if missing (Boss archetype usually doesn't include it in old version)
	_visual_component = get_component(VisualComponent)
	
	if not _visual_component:
		# Fallback: manually add if archetype wasn't updated yet (Safety)
		_visual_component = VisualComponent.new()
		add_child(_visual_component)

	var shared_deps := {
		"data_resource": entity_data, 
		"config": entity_data.config,
		"services": _services
		}

	var states: Dictionary = {}
	var initial_state_key = &""
	
	if state_machine_config:
		initial_state_key = state_machine_config.initial_state
		for def in state_machine_config.states:
			if def.state_script:
				states[def.key] = def.state_script.new(self, sm, entity_data)
	else:
		push_error("BaseBoss: Missing StateMachineConfig!")

	var raw_visual = get_node("ColorRect")

	var per_component_deps := {
		sm: {"states": states, "initial_state_key": initial_state_key},
		fc: {
			"visual_node": raw_visual, 
			"hit_effect": hit_flash_effect,
			"fx_manager": _services.fx_manager
			},
		hc: {
			"fx_manager": _services.fx_manager,
			"event_bus": _services.event_bus
			},
		_visual_component: {
			"visual_node": raw_visual,
			"config": entity_data.config # Allows VC to find effects
		}
	}

	setup_components(shared_deps, per_component_deps)
	
	# Set Boss Color Explicitly via Component
	_visual_component.set_color(Palette.COLOR_BOSS_PRIMARY)

	if hc:
		if not hc.health_threshold_reached.is_connected(_on_health_threshold_reached):
			hc.health_threshold_reached.connect(_on_health_threshold_reached)


# --- Public Methods ---
func teardown() -> void:
	set_physics_process(false)
	var hc: HealthComponent = get_component(HealthComponent)
	if is_instance_valid(hc):
		if hc.health_threshold_reached.is_connected(_on_health_threshold_reached):
			hc.health_threshold_reached.disconnect(_on_health_threshold_reached)

	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.ENEMY)

	super.teardown()
	entity_data = null
	_visual_component = null


func get_health_thresholds() -> Array[float]:
	if is_instance_valid(behavior):
		return [behavior.phase_2_threshold, behavior.phase_3_threshold]
	return []


# --- Override Virtual Handlers ---
func _on_entity_died() -> void:
	_die()

func _on_health_changed(current: int, max_val: int) -> void:
	var ev := BossHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	_services.event_bus.emit(EventCatalog.BOSS_HEALTH_CHANGED, ev)


# --- Private Methods ---
func _die() -> void:
	if _is_dead:
		return
	_is_dead = true

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.teardown()

	if is_instance_valid(close_range_detector):
		close_range_detector.monitoring = false

	collision_layer = 0
	collision_mask = 0
	set_physics_process(false)

	ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.ENEMY)

	if is_instance_valid(death_shake_effect):
		_services.fx_manager.request_screen_shake(death_shake_effect)
	
	_services.fx_manager.request_hit_stop(entity_data.world_config.hit_stop_boss_death)

	if is_instance_valid(_visual_component) and is_instance_valid(dissolve_effect):
		var fc: FXComponent = get_component(FXComponent)
		if fc:
			fc.play_effect(dissolve_effect, {}, {"preserve_final_state": true})

	var ev = BossDiedEvent.new()
	ev.boss_node = self
	_services.event_bus.emit(EventCatalog.BOSS_DIED, ev)


func _initialize_data() -> void:
	add_to_group(Identifiers.Groups.ENEMY)
	# Visual set color moved to build()
	
	if is_instance_valid(behavior):
		current_attack_patterns = behavior.phase_1_patterns
	entity_data = BossStateData.new()
	
	if not _services:
		_services = ServiceLocator

	entity_data.config = _services.enemy_config
	entity_data.world_config = _services.world_config
	
	entity_data.behavior = behavior
	entity_data.services = _services
	
	entity_data.projectile_pool_key = behavior.projectile_pool_key

	entity_data.max_health = entity_data.config.boss_health
	entity_data.health = entity_data.max_health


func _update_player_tracking() -> void:
	if is_instance_valid(_player):
		var dir_to_player: float = _player.global_position.x - global_position.x
		if not is_zero_approx(dir_to_player):
			entity_data.facing_direction = sign(dir_to_player)
	
	if is_instance_valid(_visual_component):
		_visual_component.set_facing(entity_data.facing_direction)


# --- Signal Handlers ---

func _on_health_threshold_reached(health_percentage: float) -> void:
	if not is_instance_valid(behavior):
		return

	var new_phases_remaining: int = phases_remaining
	if health_percentage <= behavior.phase_3_threshold and phases_remaining > 1:
		new_phases_remaining = 1
	elif health_percentage <= behavior.phase_2_threshold and phases_remaining > 2:
		new_phases_remaining = 2

	if new_phases_remaining != phases_remaining:
		phases_remaining = new_phases_remaining
		match phases_remaining:
			2:
				current_attack_patterns = behavior.phase_2_patterns
			1:
				current_attack_patterns = behavior.phase_3_patterns
		if is_instance_valid(phase_change_shake_effect):
			_services.fx_manager.request_screen_shake(phase_change_shake_effect)
		
		_services.fx_manager.request_hit_stop(
			entity_data.world_config.hit_stop_boss_phase_change
		)
		
		var ev = BossPhaseChangedEvent.new()
		ev.phases_remaining = phases_remaining
		_services.event_bus.emit(EventCatalog.BOSS_PHASE_CHANGED, ev)


func _on_health_component_health_changed(current: int, max_val: int) -> void:
	var ev := BossHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	_services.event_bus.emit(EventCatalog.BOSS_HEALTH_CHANGED, ev)


func _on_health_component_died() -> void:
	_die()


=====================================
FILE: ./src/entities/enemies/bosses/data/default_boss_behavior.tres
=====================================
[gd_resource type="Resource" script_class="BossBehavior" load_steps=9 format=3 uid="uid://cypy26d84f23b"]

[ext_resource type="Script" uid="uid://dni2it8b687id" path="res://src/entities/enemies/bosses/data/boss_behavior.gd" id="1_behavior_script"]
[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_pfqfc"]
[ext_resource type="Resource" uid="uid://bve7t5ucr1k" path="res://src/entities/enemies/bosses/attack_patterns/single_shot.tres" id="2_pattern_single"]
[ext_resource type="Resource" uid="uid://cihbnl4747m0a" path="res://src/entities/enemies/bosses/attack_patterns/volley_3_shot.tres" id="3_pattern_volley3"]
[ext_resource type="Resource" uid="uid://y6g5o6f7h8ja" path="res://src/entities/enemies/bosses/attack_patterns/lunge_attack.tres" id="4_pattern_lunge"]
[ext_resource type="Resource" uid="uid://01x2y3a4b5c6" path="res://src/entities/enemies/bosses/attack_patterns/volley_5_shot.tres" id="5_pattern_volley5"]
[ext_resource type="Resource" uid="uid://dibqnlm2wg88d" path="res://src/entities/enemies/bosses/attack_patterns/homing_omni_burst_pattern.tres" id="6_pattern_homing"]
[ext_resource type="Resource" path="res://src/entities/enemies/bosses/data/boss_patrol_movement.tres" id="7_movement_logic"]

[resource]
script = ExtResource("1_behavior_script")
phase_2_threshold = 0.7
phase_3_threshold = 0.4
movement_logic = ExtResource("7_movement_logic")
projectile_pool_key = &"boss_shots"
phase_1_patterns = Array[ExtResource("1_pfqfc")]([ExtResource("2_pattern_single")])
phase_2_patterns = Array[ExtResource("1_pfqfc")]([ExtResource("3_pattern_volley3"), ExtResource("4_pattern_lunge")])
phase_3_patterns = Array[ExtResource("1_pfqfc")]([ExtResource("5_pattern_volley5"), ExtResource("4_pattern_lunge"), ExtResource("6_pattern_homing")])


=====================================
FILE: ./src/entities/enemies/bosses/data/boss_state_machine_config.tres
=====================================
[gd_resource type="Resource" script_class="StateMachineConfig" load_steps=15 format=3 uid="uid://s5xi3ciavs2n"]

[ext_resource type="Script" uid="uid://n65f7l7vgpyh" path="res://src/core/data/config/state_definition.gd" id="1_def"]
[ext_resource type="Script" uid="uid://bhpvwtjqtlr08" path="res://src/core/data/config/state_machine_config.gd" id="2_cfg"]
[ext_resource type="Script" uid="uid://dnyvyoos5kkxy" path="res://src/entities/enemies/bosses/states/state_boss_idle.gd" id="3_idle"]
[ext_resource type="Script" uid="uid://bl6ot8t61nixu" path="res://src/entities/enemies/bosses/states/state_boss_attack.gd" id="4_attack"]
[ext_resource type="Script" uid="uid://dgok3ph2i0i47" path="res://src/entities/enemies/bosses/states/state_boss_cooldown.gd" id="5_cooldown"]
[ext_resource type="Script" uid="uid://bsmqi0p5h8urh" path="res://src/entities/enemies/bosses/states/state_boss_patrol.gd" id="6_patrol"]
[ext_resource type="Script" uid="uid://b47bmwcdrdd8d" path="res://src/entities/enemies/bosses/states/state_boss_lunge.gd" id="7_lunge"]
[ext_resource type="Script" uid="uid://cfirfsn8ugufx" path="res://src/entities/enemies/bosses/states/state_boss_melee.gd" id="8_melee"]

[sub_resource type="Resource" id="Resource_idle"]
script = ExtResource("1_def")
key = &"idle"
state_script = ExtResource("3_idle")

[sub_resource type="Resource" id="Resource_attack"]
script = ExtResource("1_def")
key = &"attack"
state_script = ExtResource("4_attack")

[sub_resource type="Resource" id="Resource_cooldown"]
script = ExtResource("1_def")
key = &"cooldown"
state_script = ExtResource("5_cooldown")

[sub_resource type="Resource" id="Resource_patrol"]
script = ExtResource("1_def")
key = &"patrol"
state_script = ExtResource("6_patrol")

[sub_resource type="Resource" id="Resource_lunge"]
script = ExtResource("1_def")
key = &"lunge"
state_script = ExtResource("7_lunge")

[sub_resource type="Resource" id="Resource_melee"]
script = ExtResource("1_def")
key = &"melee"
state_script = ExtResource("8_melee")

[resource]
script = ExtResource("2_cfg")
initial_state = &"cooldown"
states = Array[ExtResource("1_def")]([SubResource("Resource_idle"), SubResource("Resource_attack"), SubResource("Resource_cooldown"), SubResource("Resource_patrol"), SubResource("Resource_lunge"), SubResource("Resource_melee")])


=====================================
FILE: ./src/entities/enemies/bosses/data/boss_patrol_movement.tres
=====================================
[gd_resource type="Resource" script_class="PatrolMovementLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/enemies/minions/movement_logic/patrol_movement_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/enemies/bosses/data/boss_behavior.gd
=====================================
# src/entities/boss/data/boss_behavior.gd
@tool
## A data resource that defines a boss's complete combat behavior.
class_name BossBehavior
extends Resource

@export_group("Phase Configuration")
@export_range(0.0, 1.0, 0.01) var phase_2_threshold: float = 0.7
@export_range(0.0, 1.0, 0.01) var phase_3_threshold: float = 0.4

@export_group("Movement")
## Defines how the boss moves during the Patrol state.
@export var movement_logic: MovementLogic

@export_group("Attack Patterns")
@export var projectile_pool_key: StringName = &"boss_shots"
@export var phase_1_patterns: Array[AttackPattern] = []
@export var phase_2_patterns: Array[AttackPattern] = []
@export var phase_3_patterns: Array[AttackPattern] = []


=====================================
FILE: ./src/entities/enemies/minions/minion.gd
=====================================
# src/entities/minions/minion.gd
@tool
## A generic minion enemy, whose behavior is defined by a MinionBehavior resource.
class_name Minion
extends BaseEntity

# --- Editor Configuration ---
@export_group("Core Configuration")
@export var behavior: MinionBehavior
@export var state_machine_config: StateMachineConfig

@export_group("Juice & Feedback")
@export var hit_flash_effect: ShaderEffect
@export var hit_spark_effect: VFXEffect
@export var dissolve_effect: ShaderEffect

# --- Node References ---
# visual ref handled by component
@onready var attack_timer: Timer = $AttackTimer
@onready var range_detector: SensorComponent = $RangeDetector
@onready var range_detector_shape: CollisionShape2D = $RangeDetector/CollisionShape2D

# --- Public Member Variables ---
var entity_data: MinionStateData
var _visual_component: VisualComponent

# --- Godot Lifecycle Methods ---
func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	if not archetype:
		warnings.append("This node requires an EntityArchetype resource.")
	if not behavior:
		warnings.append("This node requires a MinionBehavior resource to function.")
	if not state_machine_config:
		warnings.append("This node requires a StateMachineConfig resource.")
	return warnings


func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint():
		return
	
	ServiceLocator.targeting_system.register(self, Identifiers.Groups.ENEMY)

	_initialize_data()
	build_entity()
	
	if entity_data.behavior.is_anchored:
		motion_mode = CharacterBody2D.MOTION_MODE_FLOATING


func _physics_process(delta: float) -> void:
	if _is_dead or not is_instance_valid(entity_data):
		return
	
	if entity_data.behavior.is_anchored:
		velocity = Vector2.ZERO
	elif not is_on_floor():
		velocity.y += entity_data.world_config.gravity * delta
		
	# Delegate to BaseEntity
	super._physics_process(delta)


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

func _exit_tree() -> void:
	super._exit_tree()
	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.ENEMY)


# --- Public Methods ---
func teardown() -> void:
	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.ENEMY)

	super.teardown()
	entity_data = null
	_visual_component = null


func update_player_tracking() -> void:
	_update_player_tracking()


func deactivate() -> void:
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.teardown()
	if is_instance_valid(attack_timer):
		attack_timer.stop()

	set_physics_process(false)
	if is_instance_valid(range_detector):
		range_detector.monitoring = false
	
	var melee_detector = get_node_or_null("MeleeRangeDetector")
	if is_instance_valid(melee_detector) and melee_detector is Area2D:
		melee_detector.monitoring = false


# --- Internal Build Logic ---
func _on_build() -> void:
	# Apply Behavior Config
	var circle_shape := CircleShape2D.new()
	circle_shape.radius = entity_data.behavior.detection_radius
	range_detector_shape.shape = circle_shape

	# Setup Sensors
	if is_instance_valid(range_detector):
		range_detector.setup(self, {"data_resource": entity_data})
	
	var melee_detector = get_node_or_null("MeleeRangeDetector")
	if is_instance_valid(melee_detector) and melee_detector is SensorComponent:
		melee_detector.setup(self, {"data_resource": entity_data})

	# Setup Components
	var hc: HealthComponent = get_component(HealthComponent)
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	var fc: FXComponent = get_component(FXComponent)
	
	# Dynamically add VisualComponent if missing (Minions likely rely on archetype update)
	_visual_component = get_component(VisualComponent)
	if not _visual_component:
		_visual_component = VisualComponent.new()
		add_child(_visual_component)

	var shared_deps := {
		"data_resource": entity_data,
		"config": entity_data.config,
		"services": _services
	}

	var states: Dictionary = {}
	var initial_state_key = &""
	
	if state_machine_config:
		# Prefer behavior's override if set, otherwise default to config's initial
		initial_state_key = entity_data.behavior.initial_state_key
		if initial_state_key == &"":
			initial_state_key = state_machine_config.initial_state
			
		for def in state_machine_config.states:
			if def.state_script:
				states[def.key] = def.state_script.new(self, sm, entity_data)
	else:
		push_error("Minion: Missing StateMachineConfig!")

	var raw_visual = get_node("Visual")

	var per_component_deps := {
		sm: {"states": states, "initial_state_key": initial_state_key},
		fc: {
			"visual_node": raw_visual, 
			"hit_effect": hit_flash_effect,
			"fx_manager": _services.fx_manager
			},
		hc: {
			"fx_manager": _services.fx_manager,
			"event_bus": _services.event_bus
			},
		_visual_component: {
			"visual_node": raw_visual
		}
	}

	setup_components(shared_deps, per_component_deps)
	
	# Minions rely on Polygon2D color property, handled by VisualComponent now.
	# We set a default color here if needed, or let VisualComponent handle generic init.
	_visual_component.set_color(Palette.COLOR_TERRAIN_SECONDARY)


func _safe_script(script_ref: Script, fallback_path: String) -> Script:
	if script_ref:
		return script_ref
	return load(fallback_path)


# --- Override Virtual Handlers ---
func _on_entity_died() -> void:
	_die()


# --- Private Methods ---
func _die() -> void:
	if _is_dead:
		return
	_is_dead = true

	collision_layer = 0
	collision_mask = 0
	deactivate()

	# Manual dissolve trigger because Minion death logic handles queue_free timing
	var fc: FXComponent = get_component(FXComponent)
	if is_instance_valid(dissolve_effect) and is_instance_valid(fc):
		var death_tween: Tween = fc.play_effect(dissolve_effect, {}, {"preserve_final_state": true})
		if is_instance_valid(death_tween):
			await death_tween.finished

	if is_instance_valid(self):
		queue_free()


func _initialize_data() -> void:
	add_to_group(Identifiers.Groups.ENEMY)
	entity_data = MinionStateData.new()
	
	if not _services:
		_services = ServiceLocator

	assert(is_instance_valid(behavior), "Minion requires a valid MinionBehavior resource.")
	entity_data.behavior = behavior
	entity_data.max_health = behavior.max_health
	entity_data.projectile_pool_key = behavior.projectile_pool_key
	entity_data.services = _services
	entity_data.config = _services.enemy_config
	entity_data.world_config = _services.world_config


func _update_player_tracking() -> void:
	if not is_instance_valid(_player):
		return

	var dir_to_player: float = _player.global_position.x - global_position.x
	if not is_zero_approx(dir_to_player):
		entity_data.facing_direction = sign(dir_to_player)
	
	if is_instance_valid(_visual_component):
		_visual_component.set_facing(entity_data.facing_direction)


# --- Signal Handlers ---
func _on_health_component_died() -> void:
	_die()


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/stationary_movement.tres
=====================================
[gd_resource type="Resource" script_class="StationaryMovementLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/enemies/minions/movement_logic/stationary_movement_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/patrol_movement.tres
=====================================
[gd_resource type="Resource" script_class="PatrolMovementLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/enemies/minions/movement_logic/patrol_movement_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/stationary_movement_logic.gd
=====================================
# src/entities/minions/movement_logic/stationary_movement_logic.gd
@tool
## A concrete movement strategy where the entity does not move at all.
class_name StationaryMovementLogic
extends MovementLogic


## Returns zero velocity, effectively keeping the entity stationary.
func execute(_delta: float, _entity: BaseEntity, _data: BaseEntityData) -> Vector2:
	return Vector2.ZERO


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/movement_logic.gd
=====================================
# src/entities/minions/movement_logic/movement_logic.gd
@tool
## The abstract base class for all entity movement strategies.
## Defines the contract for how an entity's velocity is calculated each frame.
class_name MovementLogic
extends Resource

## Calculates and returns the entity's velocity for the current physics frame.
## @param delta: The time elapsed since the last physics frame.
## @param entity: A reference to the BaseEntity executing this logic.
## @param data: The shared state data resource (must extend BaseEntityData).
## @return: The calculated velocity vector for the current frame.
func execute(_delta: float, _entity: BaseEntity, _data: BaseEntityData) -> Vector2:
	push_warning("MovementLogic.execute() was called but not overridden by the implementer.")
	return Vector2.ZERO


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/flying_patrol.tres
=====================================
[gd_resource type="Resource" script_class="FlyingPatrolMovementLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/enemies/minions/movement_logic/flying_patrol_movement_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")
patrol_speed = 150.0


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/flying_patrol_movement_logic.gd
=====================================
# src/entities/minions/movement_logic/flying_patrol_movement_logic.gd
@tool
## A concrete movement strategy for an entity that moves vertically between
## two explicit waypoints, ignoring gravity.
class_name FlyingPatrolMovementLogic
extends MovementLogic

@export var patrol_speed: float = 150.0

# Store the patrol points on a per-instance basis to support multiple entities.
var _patrol_points: Dictionary = {}


func execute(delta: float, entity: BaseEntity, _data: BaseEntityData) -> Vector2:
	var instance_id = entity.get_instance_id()
	
	# Initialize patrol points on the first run for this specific instance.
	if not _patrol_points.has(instance_id):
		# Define patrol points using our clear Grid Coordinate system.
		var top_patrol_grid_pos = Vector2i(16, 10)
		var top_point = GridUtils.grid_to_world(top_patrol_grid_pos)
		var bottom_point = entity.global_position
		
		_patrol_points[instance_id] = {
			"top": top_point,
			"bottom": bottom_point,
			"target": top_point
		}
	
	var patrol_data = _patrol_points[instance_id]
	var target_position = patrol_data.target
	
	# This is a kinematic movement. We directly manipulate the position.
	entity.global_position = entity.global_position.move_toward(target_position, patrol_speed * delta)
	
	# If the target is reached, switch to the other point.
	if entity.global_position.distance_to(target_position) < 1.0:
		if target_position == patrol_data.top:
			patrol_data.target = patrol_data.bottom
		else:
			patrol_data.target = patrol_data.top
	
	return Vector2.ZERO


=====================================
FILE: ./src/entities/enemies/minions/movement_logic/patrol_movement_logic.gd
=====================================
# src/entities/minions/movement_logic/patrol_movement_logic.gd
@tool
## A concrete movement strategy where the entity moves back and forth,
## reversing direction when it hits a wall.
class_name PatrolMovementLogic
extends MovementLogic

## Moves the entity horizontally. Preserves vertical velocity (gravity).
func execute(_delta: float, entity: BaseEntity, data: BaseEntityData) -> Vector2:
	var new_velocity := entity.velocity
	
	# Note: Gravity is handled by the BaseEntity's _physics_process.
	# We just handle the horizontal patrol logic here.
	
	if entity.is_on_wall():
		data.facing_direction *= -1.0

	# Cast config to EnemyConfig to access patrol speed safely.
	# If config is not EnemyConfig, this will fail gracefully (null check or 0 speed).
	var enemy_config = data.config as EnemyConfig
	var speed = enemy_config.boss_patrol_speed if enemy_config else 0.0

	new_velocity.x = data.facing_direction * speed
	return new_velocity


=====================================
FILE: ./src/entities/enemies/minions/minion_state_data.gd
=====================================
# src/entities/minions/minion_state_data.gd
@tool
## A Resource that holds all shared runtime state data for a Minion.
class_name MinionStateData
extends BaseEntityData

# --- Configuration References ---
var behavior: MinionBehavior

# --- Combat ---
var is_invincible: bool = false
var projectile_pool_key: StringName = &""

# --- Targeting ---
var is_player_in_range: bool = false
var is_player_in_melee_range: bool = false


=====================================
FILE: ./src/entities/enemies/minions/states/state_minion_attack.gd
=====================================
# src/entities/minions/states/state_minion_attack.gd
## A generic state that handles the telegraph and execution of a minion's attack.
class_name MinionStateAttack
extends BaseState

# --- Constants ---
const DEFAULT_TELEGRAPH_SCENE = preload(AssetPaths.SCENE_TELEGRAPH_COMPONENT)

# --- Private Member Variables ---
var _minion # Untyped
var _current_pattern: AttackPattern


func enter(msg := {}) -> void:
	self._minion = owner
	if not is_instance_valid(_minion):
		state_machine.change_state(Identifiers.MinionStates.IDLE)
		return

	if not msg.has("pattern") or not msg.pattern is AttackPattern:
		push_error("MinionStateAttack: No valid 'pattern' provided. Aborting.")
		state_machine.change_state(Identifiers.MinionStates.IDLE)
		return

	_current_pattern = msg.get("pattern")
	_start_telegraph_and_attack()


func _start_telegraph_and_attack() -> void:
	if not is_instance_valid(_current_pattern.logic):
		push_warning("Minion's AttackPattern is missing its 'logic' resource.")
		state_machine.change_state(Identifiers.MinionStates.IDLE)
		return

	# OCP: Use pattern-specific telegraph if available, else default.
	var scene_to_use = _current_pattern.telegraph_scene
	if not scene_to_use:
		scene_to_use = DEFAULT_TELEGRAPH_SCENE

	var telegraph = scene_to_use.instantiate()
	_minion.add_child(telegraph)

	var telegraph_info: Dictionary = _current_pattern.logic.get_telegraph_info(_minion, _current_pattern)
	var telegraph_size: Vector2 = telegraph_info.get("size", Vector2.ONE * 100)
	var relative_offset: Vector2 = telegraph_info.get("offset", Vector2.ZERO)

	var directional_offset := Vector2(
		relative_offset.x * _minion.entity_data.facing_direction, relative_offset.y
	)
	var telegraph_position: Vector2 = _minion.global_position + directional_offset

	if telegraph.has_method("start_telegraph"):
		telegraph.start_telegraph(
			_current_pattern.telegraph_duration,
			telegraph_size,
			telegraph_position,
			Palette.COLOR_UI_PANEL_BG
		)
		await telegraph.telegraph_finished
	else:
		telegraph.queue_free()
		await _minion.get_tree().create_timer(_current_pattern.telegraph_duration).timeout

	if not is_instance_valid(_minion):
		return

	var attack_command: Callable = _current_pattern.logic.execute(_minion, _current_pattern)
	if attack_command.is_valid():
		attack_command.call()

	if state_machine.current_state == self:
		_minion.attack_timer.wait_time = _current_pattern.cooldown
		_minion.attack_timer.start()
		# Return to patrol so the minion moves during its attack cooldown.
		state_machine.change_state("patrol")


=====================================
FILE: ./src/entities/enemies/minions/states/state_minion_patrol.gd
=====================================
# src/entities/minions/states/state_minion_patrol.gd
## A specialized patrol state for Minions.
## Inherits generic movement but adds specific AI interrupts.
class_name MinionStatePatrol
extends StateEntityPatrol

var _minion # Untyped

func enter(msg := {}) -> void:
	super.enter(msg)
	_minion = owner

func _check_interrupts() -> bool:
	if not is_instance_valid(_minion):
		return false

	# --- Priority 1: Melee Interrupt ---
	if state_data.is_player_in_melee_range:
		if _minion.get_component(MeleeComponent):
			_minion.velocity = Vector2.ZERO
			_minion.attack_timer.stop() 
			state_machine.change_state(Identifiers.CommonStates.MELEE)
			return true

	# --- Priority 2: Ranged Attack ---
	if (
		state_data.is_player_in_range
		and _minion.attack_timer.is_stopped()
		and not state_data.behavior.attack_patterns.is_empty()
	):
		_minion.update_player_tracking()
		var pattern: AttackPattern = state_data.behavior.attack_patterns.pick_random()
		_minion.attack_timer.wait_time = pattern.cooldown
		_minion.attack_timer.start()
		
		if is_instance_valid(pattern.logic):
			var attack_command: Callable = pattern.logic.execute(_minion, pattern)
			if attack_command.is_valid():
				attack_command.call()
	
	return false


=====================================
FILE: ./src/entities/enemies/minions/states/state_minion_melee.gd
=====================================
# src/entities/minions/states/state_minion_melee.gd
## A state that triggers a minion's melee attack.
class_name MinionStateMelee
extends BaseState

# --- Constants ---
const LancerPokeData = preload("res://src/data/combat/attacks/lancer_poke.tres")

# --- Private Member Variables ---
var _melee_component: MeleeComponent
var _minion # Untyped


func enter(_msg := {}) -> void:
	self._minion = owner
	_minion.velocity = Vector2.ZERO
	_melee_component = _minion.get_component(MeleeComponent)
	
	if not is_instance_valid(_melee_component):
		push_error("MinionStateMelee requires a MeleeComponent on the owner. Aborting.")
		state_machine.change_state(Identifiers.MinionStates.IDLE)
		return
	
	_melee_component.attack_finished.connect(_on_attack_finished, CONNECT_ONE_SHOT)
	_melee_component.perform_attack(LancerPokeData)


func exit() -> void:
	if is_instance_valid(_melee_component) and _melee_component.attack_finished.is_connected(_on_attack_finished):
		_melee_component.attack_finished.disconnect(_on_attack_finished)


func process_physics(_delta: float) -> void:
	# If the player leaves the melee zone during the attack, immediately go back to patrolling.
	if not state_data.is_player_in_melee_range:
		state_machine.change_state(Identifiers.CommonStates.PATROL)
		return


# --- Signal Handlers ---
func _on_attack_finished() -> void:
	if state_machine.current_state == self:
		var attack_data = _melee_component._current_attack_data
		if is_instance_valid(attack_data) and is_instance_valid(_minion.attack_timer):
			_minion.attack_timer.wait_time = 2.0 
			_minion.attack_timer.start()
		
		state_machine.change_state(Identifiers.CommonStates.PATROL)


=====================================
FILE: ./src/entities/enemies/minions/states/state_minion_idle.gd
=====================================
# src/entities/minions/states/state_minion_idle.gd
## A specialized idle state for Minions.
class_name MinionStateIdle
extends StateEntityIdle

var _minion # Untyped

func enter(msg := {}) -> void:
	super.enter(msg)
	_minion = owner

func _check_interrupts() -> bool:
	if not is_instance_valid(_minion):
		return false

	# 1. Melee Check
	if state_data.is_player_in_melee_range and _minion.attack_timer.is_stopped():
		if _minion.get_component(MeleeComponent):
			state_machine.change_state(Identifiers.CommonStates.MELEE)
			return true

	# 2. Ranged Attack Check
	if state_data.is_player_in_range and _minion.attack_timer.is_stopped():
		if not state_data.behavior.attack_patterns.is_empty():
			state_machine.change_state(Identifiers.MinionStates.ATTACK, {"pattern": state_data.behavior.attack_patterns.pick_random()})
			return true

	# 3. Default to Patrol if ready
	if _minion.attack_timer.is_stopped():
		state_machine.change_state(Identifiers.CommonStates.PATROL)
		return true
		
	return false


=====================================
FILE: ./src/entities/enemies/minions/patrolling_lancer.tscn
=====================================
[gd_scene load_steps=12 format=3 uid="uid://c0mbo7v80afg1"]

[ext_resource type="Script" uid="uid://4xepmjomesfc" path="res://src/entities/enemies/minions/minion.gd" id="1_minion_script"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_hit_flash"]
[ext_resource type="PackedScene" path="res://src/entities/_base/components/melee_component.tscn" id="3_melee_component"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="4_hit_spark_effect"]
[ext_resource type="Resource" path="res://src/entities/archetypes/minion_archetype.tres" id="5_archetype"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="6_dissolve_effect"]
[ext_resource type="Resource" uid="uid://d2b4w7h1qxy5c" path="res://src/entities/enemies/minions/data/patrolling_lancer_behavior.tres" id="7_lancer_behavior"]
[ext_resource type="Script" uid="uid://c6b7cy6cfequ7" path="res://src/entities/_base/components/sensor_component.gd" id="8_sensor_script"]
[ext_resource type="Resource" uid="uid://dfvpyyu7iy8by" path="res://src/entities/enemies/minions/data/minion_state_machine_config.tres" id="9_sm_config"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_minionbody"]
size = Vector2(50, 50)

[sub_resource type="CircleShape2D" id="CircleShape2D_meleetrigger"]
radius = 90.0

[node name="PatrollingLancer" type="CharacterBody2D" groups=["enemy"]]
collision_layer = 4
collision_mask = 138
script = ExtResource("1_minion_script")
behavior = ExtResource("7_lancer_behavior")
state_machine_config = ExtResource("9_sm_config")
hit_flash_effect = ExtResource("2_hit_flash")
hit_spark_effect = ExtResource("4_hit_spark_effect")
dissolve_effect = ExtResource("6_dissolve_effect")
archetype = ExtResource("5_archetype")

[node name="Visual" type="Polygon2D" parent="."]
color = Color(0.9, 0.4, 0.4, 1)
polygon = PackedVector2Array(-25, -25, 25, -25, 25, 25, -25, 25)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_minionbody")

[node name="AttackTimer" type="Timer" parent="."]
one_shot = true

[node name="RangeDetector" type="Area2D" parent="." groups=["sensors"]]
collision_layer = 512
monitorable = false
script = ExtResource("8_sensor_script")
state_property_name = &"is_player_in_range"

[node name="CollisionShape2D" type="CollisionShape2D" parent="RangeDetector"]
shape = SubResource("CircleShape2D_meleetrigger")

[node name="MeleeRangeDetector" type="Area2D" parent="." groups=["sensors"]]
collision_layer = 512
monitorable = false
script = ExtResource("8_sensor_script")
state_property_name = &"is_player_in_melee_range"

[node name="CollisionShape2D" type="CollisionShape2D" parent="MeleeRangeDetector"]
shape = SubResource("CircleShape2D_meleetrigger")

[node name="MeleeComponent" parent="." instance=ExtResource("3_melee_component")]


=====================================
FILE: ./src/entities/enemies/minions/turret.tscn
=====================================
[gd_scene load_steps=11 format=3 uid="uid://c7d8faf0g1h2i"]

[ext_resource type="Script" uid="uid://4xepmjomesfc" path="res://src/entities/enemies/minions/minion.gd" id="1_minion_script"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_hit_flash"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="3_hit_spark_effect"]
[ext_resource type="Resource" path="res://src/entities/archetypes/minion_archetype.tres" id="4_archetype"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="5_dissolve_effect"]
[ext_resource type="Resource" uid="uid://dp642amrtq5i3" path="res://src/entities/enemies/minions/data/turret_behavior.tres" id="6_turret_behavior"]
[ext_resource type="Script" path="res://src/entities/_base/components/sensor_component.gd" id="7_sensor_script"]
[ext_resource type="Resource" path="res://src/entities/enemies/minions/data/minion_state_machine_config.tres" id="8_sm_config"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_minionbody"]
size = Vector2(50, 50)

[sub_resource type="CircleShape2D" id="CircleShape2D_rangedetector"]
radius = 400.0

[node name="Turret" type="CharacterBody2D" groups=["enemy"]]
collision_layer = 4
collision_mask = 138
script = ExtResource("1_minion_script")
behavior = ExtResource("6_turret_behavior")
state_machine_config = ExtResource("8_sm_config")
hit_flash_effect = ExtResource("2_hit_flash")
hit_spark_effect = ExtResource("3_hit_spark_effect")
dissolve_effect = ExtResource("5_dissolve_effect")
archetype = ExtResource("4_archetype")

[node name="Visual" type="Polygon2D" parent="."]
color = Color(0.490196, 0.490196, 0.490196, 1)
polygon = PackedVector2Array(-25, -25, 25, -25, 25, 25, -25, 25)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_minionbody")

[node name="AttackTimer" type="Timer" parent="."]
wait_time = 2.0
one_shot = true

[node name="RangeDetector" type="Area2D" parent="." groups=["sensors"]]
collision_layer = 512
collision_mask = 1
script = ExtResource("7_sensor_script")
state_property_name = &"is_player_in_range"

[node name="CollisionShape2D" type="CollisionShape2D" parent="RangeDetector"]
shape = SubResource("CircleShape2D_rangedetector")


=====================================
FILE: ./src/entities/enemies/minions/flying_patroller.tscn
=====================================
[gd_scene load_steps=11 format=3 uid="uid://c1d2e3f4g5h6i"]

[ext_resource type="Script" uid="uid://4xepmjomesfc" path="res://src/entities/enemies/minions/minion.gd" id="1_minion_script"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_hit_flash"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="3_hit_spark_effect"]
[ext_resource type="Resource" path="res://src/entities/archetypes/minion_archetype.tres" id="4_archetype"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="5_dissolve_effect"]
[ext_resource type="Resource" path="res://src/entities/enemies/minions/data/flying_patroller_behavior.tres" id="6_flying_behavior"]
[ext_resource type="Script" path="res://src/entities/_base/components/sensor_component.gd" id="7_sensor_script"]
[ext_resource type="Resource" path="res://src/entities/enemies/minions/data/minion_state_machine_config.tres" id="8_sm_config"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_minionbody"]
size = Vector2(40, 40)

[sub_resource type="CircleShape2D" id="CircleShape2D_rangedetector"]
radius = 500.0

[node name="FlyingPatroller" type="CharacterBody2D" groups=["enemy"]]
collision_layer = 4
collision_mask = 138
script = ExtResource("1_minion_script")
behavior = ExtResource("6_flying_behavior")
state_machine_config = ExtResource("8_sm_config")
hit_flash_effect = ExtResource("2_hit_flash")
hit_spark_effect = ExtResource("3_hit_spark_effect")
dissolve_effect = ExtResource("5_dissolve_effect")
archetype = ExtResource("4_archetype")

[node name="Visual" type="Polygon2D" parent="."]
color = Color(0.4, 0.8, 0.9, 1)
polygon = PackedVector2Array(-20, -20, 20, -20, 20, 20, -20, 20)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_minionbody")

[node name="AttackTimer" type="Timer" parent="."]
wait_time = 2.5
one_shot = true

[node name="RangeDetector" type="Area2D" parent="." groups=["sensors"]]
collision_layer = 512
collision_mask = 1
script = ExtResource("7_sensor_script")
state_property_name = &"is_player_in_range"

[node name="CollisionShape2D" type="CollisionShape2D" parent="RangeDetector"]
shape = SubResource("CircleShape2D_rangedetector")


=====================================
FILE: ./src/entities/enemies/minions/data/minion_behavior.gd
=====================================
# src/entities/minions/data/minion_behavior.gd
@tool
## A data resource that defines a minion's complete combat behavior.
##
## This combines base stats with swappable logic resources for movement and
## attacks, allowing for the creation of varied minion types from a single
## generic Minion scene.
class_name MinionBehavior
extends Resource

@export_group("Stats")
@export_range(1, 100, 1) var max_health: int = 3

@export_group("State & Movement")
@export var initial_state_key: StringName = &"fall"
# A flag to determine if the entity should be immune to physics pushback.
@export var is_anchored: bool = false
@export var movement_logic: MovementLogic

@export_group("Combat")
@export_range(50, 1000, 10) var detection_radius: float = 400.0
@export var projectile_pool_key: StringName = &"turret_shots"
@export var attack_patterns: Array[AttackPattern] = []

=====================================
FILE: ./src/entities/enemies/minions/data/patrolling_lancer_behavior.tres
=====================================
[gd_resource type="Resource" script_class="MinionBehavior" load_steps=5 format=3 uid="uid://d2b4w7h1qxy5c"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_nohdh"]
[ext_resource type="Script" uid="uid://d2at2rq33qwur" path="res://src/entities/enemies/minions/data/minion_behavior.gd" id="1_script"]
[ext_resource type="Resource" path="res://src/entities/enemies/minions/movement_logic/patrol_movement.tres" id="2_movement"]
[ext_resource type="Resource" uid="uid://cihbnl4747m0a" path="res://src/entities/enemies/bosses/attack_patterns/volley_3_shot.tres" id="3_attack_pattern"]

[resource]
script = ExtResource("1_script")
max_health = 5
initial_state_key = &"patrol"
is_anchored = false
movement_logic = ExtResource("2_movement")
detection_radius = 400.0
projectile_pool_key = &"minion_shots"
attack_patterns = Array[ExtResource("1_nohdh")]([ExtResource("3_attack_pattern")])


=====================================
FILE: ./src/entities/enemies/minions/data/flying_patroller_behavior.tres
=====================================
[gd_resource type="Resource" script_class="MinionBehavior" load_steps=5 format=3]

[ext_resource type="Script" path="res://src/entities/enemies/minions/data/minion_behavior.gd" id="1_script"]
[ext_resource type="Resource" path="res://src/entities/enemies/minions/movement_logic/flying_patrol.tres" id="2_movement"]
[ext_resource type="Script" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="3_attack_pattern_script"]
[ext_resource type="Resource" path="res://src/game/combat/attack_logic/minion_volley_3_shot.tres" id="4_attack_pattern"]

[resource]
script = ExtResource("1_script")
max_health = 2
initial_state_key = &"patrol"
is_anchored = true
movement_logic = ExtResource("2_movement")
detection_radius = 500.0
projectile_pool_key = &"minion_shots"
attack_patterns = Array[ExtResource("3_attack_pattern_script")]([ExtResource("4_attack_pattern")])


=====================================
FILE: ./src/entities/enemies/minions/data/turret_behavior.tres
=====================================
[gd_resource type="Resource" script_class="MinionBehavior" load_steps=5 format=3 uid="uid://dp642amrtq5i3"]

[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/enemies/bosses/attack_patterns/attack_pattern.gd" id="1_s7dvt"]
[ext_resource type="Script" uid="uid://d2at2rq33qwur" path="res://src/entities/enemies/minions/data/minion_behavior.gd" id="1_script"]
[ext_resource type="Resource" path="res://src/entities/enemies/minions/movement_logic/stationary_movement.tres" id="2_movement"]
[ext_resource type="Resource" uid="uid://bve7t5ucr1k" path="res://src/entities/enemies/bosses/attack_patterns/single_shot.tres" id="3_attack_pattern"]

[resource]
script = ExtResource("1_script")
max_health = 3
initial_state_key = &"idle"
is_anchored = true
movement_logic = ExtResource("2_movement")
detection_radius = 400.0
projectile_pool_key = &"minion_shots"
attack_patterns = Array[ExtResource("1_s7dvt")]([ExtResource("3_attack_pattern")])


=====================================
FILE: ./src/entities/enemies/minions/data/minion_state_machine_config.tres
=====================================
[gd_resource type="Resource" script_class="StateMachineConfig" load_steps=13 format=3 uid="uid://dfvpyyu7iy8by"]

[ext_resource type="Script" uid="uid://n65f7l7vgpyh" path="res://src/core/data/config/state_definition.gd" id="1_def"]
[ext_resource type="Script" uid="uid://bhpvwtjqtlr08" path="res://src/core/data/config/state_machine_config.gd" id="2_cfg"]
[ext_resource type="Script" uid="uid://buddf5jdhvkt8" path="res://src/entities/enemies/minions/states/state_minion_idle.gd" id="3_idle"]
[ext_resource type="Script" uid="uid://dakqidln1rfck" path="res://src/entities/enemies/minions/states/state_minion_attack.gd" id="4_attack"]
[ext_resource type="Script" uid="uid://ck4xvx0sjhmpp" path="res://src/entities/enemies/minions/states/state_minion_melee.gd" id="5_melee"]
[ext_resource type="Script" uid="uid://c8l8fjwub7sq5" path="res://src/entities/enemies/minions/states/state_minion_patrol.gd" id="6_patrol"]
[ext_resource type="Script" uid="uid://bx3sbubexqh1r" path="res://src/entities/_base/states/state_entity_fall.gd" id="7_fall"]

[sub_resource type="Resource" id="Resource_idle"]
script = ExtResource("1_def")
key = &"idle"
state_script = ExtResource("3_idle")

[sub_resource type="Resource" id="Resource_attack"]
script = ExtResource("1_def")
key = &"attack"
state_script = ExtResource("4_attack")

[sub_resource type="Resource" id="Resource_melee"]
script = ExtResource("1_def")
key = &"melee"
state_script = ExtResource("5_melee")

[sub_resource type="Resource" id="Resource_patrol"]
script = ExtResource("1_def")
key = &"patrol"
state_script = ExtResource("6_patrol")

[sub_resource type="Resource" id="Resource_fall"]
script = ExtResource("1_def")
key = &"fall"
state_script = ExtResource("7_fall")

[resource]
script = ExtResource("2_cfg")
initial_state = &"fall"
states = Array[ExtResource("1_def")]([SubResource("Resource_idle"), SubResource("Resource_attack"), SubResource("Resource_melee"), SubResource("Resource_patrol"), SubResource("Resource_fall")])


=====================================
FILE: ./src/entities/player/player.tscn
=====================================
[gd_scene load_steps=22 format=3 uid="uid://c6vknl71ea1bo"]

[ext_resource type="Script" uid="uid://bymbb3pjo71tf" path="res://src/entities/player/player.gd" id="1_4d1td"]
[ext_resource type="Resource" path="res://src/entities/archetypes/player_archetype.tres" id="2_archetype"]
[ext_resource type="Resource" uid="uid://entity_hit_flash_effect" path="res://src/data/effects/entity_hit_flash_effect.tres" id="3_hit_flash"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_damage_shake.tres" id="4_shake_effect"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="5_hit_spark_effect"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="15_dissolve_effect"]
[ext_resource type="Script" path="res://src/entities/_base/components/hurtbox_component.gd" id="16_hurtbox_script"]
[ext_resource type="Script" path="res://src/entities/_base/components/hitbox_component.gd" id="17_hitbox_script"]
[ext_resource type="Resource" path="res://src/entities/player/data/player_state_machine_config.tres" id="18_sm_config"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerbody"]
size = Vector2(40, 80)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_hurtbox"]
size = Vector2(42, 82)

[node name="Player" type="CharacterBody2D"]
collision_mask = 138
script = ExtResource("1_4d1td")
hit_flash_effect = ExtResource("3_hit_flash")
damage_shake_effect = ExtResource("4_shake_effect")
hit_spark_effect = ExtResource("5_hit_spark_effect")
dissolve_effect = ExtResource("15_dissolve_effect")
state_machine_config = ExtResource("18_sm_config")
archetype = ExtResource("2_archetype")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -40.0
offset_right = 20.0
offset_bottom = 40.0
pivot_offset = Vector2(20, 40)
color = Color(0.941176, 0.941176, 0.941176, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playerbody")

[node name="MeleeHitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 148
script = ExtResource("17_hitbox_script")

[node name="CollisionShape2D" type="CollisionShape2D" parent="MeleeHitbox"]
position = Vector2(70, 0)
shape = SubResource("RectangleShape2D_playerbody")
disabled = true

[node name="PogoHitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 150
script = ExtResource("17_hitbox_script")

[node name="CollisionShape2D" type="CollisionShape2D" parent="PogoHitbox"]
shape = SubResource("RectangleShape2D_playerbody")
disabled = true

[node name="Hurtbox" type="Area2D" parent="."]
collision_layer = 64
collision_mask = 28
script = ExtResource("16_hurtbox_script")
hurt_response_state = &"hurt"

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hurtbox"]
shape = SubResource("RectangleShape2D_hurtbox")


=====================================
FILE: ./src/entities/player/player.gd
=====================================
# src/entities/player/player.gd
@tool
class_name Player
extends BaseEntity

# --- Signals ---
signal health_changed(current_health, max_health)
signal died

# --- Constants ---
const ACTION_ALLOWED_STATES = [
	&"move",
	&"fall",
	&"jump",
	&"wall_slide"
]

# --- Editor Properties ---
@export_group("Juice & Feedback")
@export var hit_flash_effect: ShaderEffect = null
@export var damage_shake_effect: ScreenShakeEffect = null
@export var hit_spark_effect: VFXEffect = null

@export_group("Configuration")
@export var state_machine_config: StateMachineConfig = null

# --- Node References ---
@onready var healing_timer: Timer = $HealingTimer
@onready var melee_hitbox: HitboxComponent = $MeleeHitbox
@onready var pogo_hitbox: HitboxComponent = $PogoHitbox
@onready var hurtbox: HurtboxComponent = $Hurtbox

# --- Data ---
var entity_data: PlayerStateData

# --- Components ---
var _visual_component: VisualComponent

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint():
		return

	add_to_group(Identifiers.Groups.PLAYER)
	ServiceLocator.targeting_system.register(self, Identifiers.Groups.PLAYER)
	
	entity_data = PlayerStateData.new()
	
	build_entity()

	entity_data.combat.healing_charges = 0
	get_component(PlayerResourceComponent).on_damage_dealt()
	entity_data.combat.determination_counter = 0
	
	# FIX: Initialize Hitbox Position (70 offset)
	if is_instance_valid(melee_hitbox):
		melee_hitbox.set_shape_offset(Vector2(70.0, 0.0))


func _physics_process(delta: float) -> void:
	if _is_dead:
		return
	_update_timers(delta)
	
	# Update Visuals via Component
	var facing = entity_data.physics.facing_direction
	if is_instance_valid(_visual_component):
		_visual_component.set_facing(facing)
	
	# POLISH: Sync Hitbox Debug Position (70 offset)
	if is_instance_valid(melee_hitbox):
		var debug_offset = Vector2(70.0 * facing, 0.0)
		melee_hitbox.set_shape_offset(debug_offset)
	
	# Delegate actual movement to base class
	super._physics_process(delta)


func _exit_tree() -> void:
	super._exit_tree()
	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.PLAYER)


# --- Internal Build Logic ---
func _on_build() -> void:
	if not _services:
		_services = ServiceLocator

	entity_data.config = _services.player_config
	entity_data.world_config = _services.world_config
	
	entity_data.max_health = entity_data.config.max_health
	entity_data.health = entity_data.max_health

	# Cache Components
	var hc: HealthComponent = get_component(HealthComponent)
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	var fc: FXComponent = get_component(FXComponent)
	var cc: CombatComponent = get_component(CombatComponent)
	var rc: PlayerResourceComponent = get_component(PlayerResourceComponent)
	var pc: PogoComponent = get_component(PogoComponent)
	var healc: HealComponent = get_component(HealComponent)
	_visual_component = get_component(VisualComponent)

	var shared_deps := {
		"data_resource": entity_data, 
		"config": entity_data.config,
		"services": _services
	}

	var states: Dictionary = {}
	var initial_state_key = &""
	
	if state_machine_config:
		initial_state_key = state_machine_config.initial_state
		for def in state_machine_config.states:
			if def.state_script:
				states[def.key] = def.state_script.new(self, sm, entity_data)
	else:
		push_error("Player: Missing StateMachineConfig!")

	var raw_visual_node = get_node("ColorRect")

	var per_component_deps := {
		sm: {"states": states, "initial_state_key": initial_state_key},
		fc: {
			"visual_node": raw_visual_node, 
			"hit_effect": hit_flash_effect,
			"fx_manager": _services.fx_manager
			},
		hc: {
			"fx_manager": _services.fx_manager,
			"event_bus": _services.event_bus
			},
		cc: {
			"object_pool": _services.object_pool,
			"fx_manager": _services.fx_manager,
			"combat_utils": _services.combat_utils,
			"services": _services,
			"melee_hitbox": melee_hitbox
			},
		rc: {
			"event_bus": _services.event_bus
			},
		pc: {
			"pogo_hitbox": pogo_hitbox,
			"services": _services,
			"fx_manager": _services.fx_manager
		},
		healc: {
			"resource_component": rc,
			"event_bus": _services.event_bus
		},
		_visual_component: {
			"visual_node": raw_visual_node
		}
	}

	setup_components(shared_deps, per_component_deps)

	if is_instance_valid(hurtbox):
		hurtbox.setup(self, {"services": _services})

	if rc:
		if cc and not cc.damage_dealt.is_connected(rc.on_damage_dealt):
			cc.damage_dealt.connect(rc.on_damage_dealt)
		if pc and not pc.damage_dealt.is_connected(rc.on_damage_dealt):
			pc.damage_dealt.connect(rc.on_damage_dealt)

	if pc and not pc.pogo_bounce_requested.is_connected(_on_pogo_bounce_requested):
		pc.pogo_bounce_requested.connect(_on_pogo_bounce_requested)
	
	# NEW: Wire up Centralized Damage Response
	if hc and not hc.took_damage.is_connected(_on_took_damage):
		hc.took_damage.connect(_on_took_damage)


# --- Public Methods ---
func teardown() -> void:
	var cc: CombatComponent = get_component(CombatComponent)
	var rc: PlayerResourceComponent = get_component(PlayerResourceComponent)
	var pc: PogoComponent = get_component(PogoComponent)
	var hc: HealthComponent = get_component(HealthComponent)

	if is_instance_valid(rc):
		if is_instance_valid(cc) and cc.damage_dealt.is_connected(rc.on_damage_dealt):
			cc.damage_dealt.disconnect(rc.on_damage_dealt)
		if is_instance_valid(pc) and pc.damage_dealt.is_connected(rc.on_damage_dealt):
			pc.damage_dealt.disconnect(rc.on_damage_dealt)

	if is_instance_valid(pc) and pc.pogo_bounce_requested.is_connected(_on_pogo_bounce_requested):
		pc.pogo_bounce_requested.disconnect(_on_pogo_bounce_requested)

	if is_instance_valid(healing_timer):
		if healing_timer.timeout.is_connected(_on_healing_timer_timeout):
			healing_timer.timeout.disconnect(_on_healing_timer_timeout)
	
	if is_instance_valid(hc) and hc.took_damage.is_connected(_on_took_damage):
		hc.took_damage.disconnect(_on_took_damage)
	
	if is_instance_valid(hurtbox):
		hurtbox.teardown()
	
	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.PLAYER)

	super.teardown()
	entity_data = null
	_visual_component = null


# --- Override Virtual Handlers ---
func _on_entity_died() -> void:
	_die()

func _on_health_changed(current: int, max_val: int) -> void:
	var ev = PlayerHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	_services.event_bus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev)
	health_changed.emit(current, max_val)


# --- Centralized Damage Response ---
func _on_took_damage(_info: DamageInfo, result: DamageResult) -> void:
	# FIX: Guard against mid-teardown execution
	if not is_instance_valid(entity_data) or not is_instance_valid(result):
		return

	if not result.was_damaged:
		return
		
	# Apply Knockback
	velocity = result.knockback_velocity
	
	# Change State
	var sm = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		# PUNISHMENT: Lose healing charge if hit while healing
		if sm.get_current_state_key() == Identifiers.PlayerStates.HEAL:
			var rc = get_component(PlayerResourceComponent)
			if rc:
				rc.consume_healing_charge()
		
		sm.change_state(Identifiers.PlayerStates.HURT)
		
	# Trigger Shake
	if is_instance_valid(damage_shake_effect) and _services.fx_manager.is_camera_shaker_registered():
		_services.fx_manager.request_screen_shake(damage_shake_effect)
		_services.fx_manager.request_hit_stop(entity_data.world_config.hit_stop_player_hurt)


# --- Private Methods ---
func _die() -> void:
	if _is_dead:
		return
	_is_dead = true

	collision_layer = 0
	collision_mask = 0
	set_physics_process(false)
	
	if not Engine.is_editor_hint():
		ServiceLocator.targeting_system.unregister(self, Identifiers.Groups.PLAYER)
	
	if is_instance_valid(hurtbox):
		hurtbox.teardown()

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.teardown()
	
	# Delegate death visuals
	if is_instance_valid(_visual_component):
		var tween: Tween = _visual_component.play_death_sequence()
		if is_instance_valid(tween):
			await tween.finished

	died.emit()


func _update_timers(delta: float) -> void:
	if not is_instance_valid(entity_data):
		return
	
	entity_data.physics.knockback_timer = max(0.0, entity_data.physics.knockback_timer - delta)


# --- Signal Handlers ---

func _on_healing_timer_timeout() -> void:
	# Handled by HealComponent now, but signal connection remains in build for safety
	pass 


func _on_pogo_bounce_requested() -> void:
	var physics = get_component(PlayerPhysicsComponent)
	if physics:
		physics.perform_pogo_bounce()
	
	entity_data.physics.can_dash = true
	entity_data.physics.air_jumps_left = entity_data.config.max_air_jumps
	get_component(BaseStateMachine).change_state(Identifiers.PlayerStates.FALL)


=====================================
FILE: ./src/entities/player/components/pogo_component.gd
=====================================
# src/entities/player/components/pogo_component.gd
@tool
## Dedicated component for handling the "Pogo" (downward strike) mechanic.
class_name PogoComponent
extends IComponent

# --- Signals ---
signal pogo_bounce_requested
signal damage_dealt

# --- Dependencies ---
var _owner_node: CharacterBody2D
var _p_data: PlayerStateData
var _hitbox: HitboxComponent
var _object_pool: IObjectPool
var _combat_utils: Node 
var _fx_manager: IFXManager

# --- Godot Lifecycle ---

func _ready() -> void:
	process_priority = 0

# --- IComponent Contract ---

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_owner_node = p_owner as CharacterBody2D
	_p_data = p_dependencies.get("data_resource")
	_hitbox = p_dependencies.get("pogo_hitbox")
	
	_object_pool = p_dependencies.get("object_pool")
	_combat_utils = p_dependencies.get("combat_utils")
	_fx_manager = p_dependencies.get("fx_manager")

	assert(is_instance_valid(_owner_node), "PogoComponent requires a CharacterBody2D owner.")
	assert(is_instance_valid(_p_data), "PogoComponent requires PlayerStateData.")
	assert(is_instance_valid(_object_pool), "PogoComponent requires 'object_pool'.")
	assert(is_instance_valid(_combat_utils), "PogoComponent requires 'combat_utils'.")
	assert(is_instance_valid(_fx_manager), "PogoComponent requires 'fx_manager'.")
	
	if is_instance_valid(_hitbox):
		# Configure hitbox specifically for Pogo
		# Layer 8 (128) = Solid World, Layer 2 (2) = Platforms
		_hitbox.collision_mask |= PhysicsLayers.SOLID_WORLD | PhysicsLayers.PLATFORMS
		
		if not _hitbox.hit_detected.is_connected(_on_hit_detected):
			_hitbox.hit_detected.connect(_on_hit_detected)

func teardown() -> void:
	if is_instance_valid(_hitbox):
		if _hitbox.hit_detected.is_connected(_on_hit_detected):
			_hitbox.hit_detected.disconnect(_on_hit_detected)
	
	_owner_node = null
	_p_data = null
	_hitbox = null
	_object_pool = null
	_combat_utils = null
	_fx_manager = null

# --- Private Logic ---

func _on_hit_detected(target: Node) -> void:
	if not _p_data.combat.is_pogo_attack:
		return
	if not is_instance_valid(target):
		return

	var should_bounce = false

	# Case 1: Hit an Enemy Projectile (destroy it with impact)
	if target.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		should_bounce = true
		
		# 1. Destroy Enemy Projectile (Red Splash)
		if target.has_method("destroy_with_impact"):
			target.destroy_with_impact()
		else:
			_object_pool.return_instance.call_deferred(target)
			
		# 2. Spawn Player Hit Spark (Green Splash)
		_spawn_player_spark(target.global_position)

	# Case 2: Hit a Damageable Entity (Enemy)
	var damageable = _combat_utils.find_damageable(target)
	if is_instance_valid(damageable):
		should_bounce = true
		# DRY: Use factory method (Pogo pierces i-frames)
		var damage_info = _combat_utils.create_damage_info(
			1,
			_owner_node,
			target.global_position,
			Vector2.UP,
			true 
		)
		
		var result = damageable.apply_damage(damage_info)
		if result.was_damaged:
			damage_dealt.emit()

	# Case 3: Hit World Geometry
	if target is PhysicsBody2D and (target.collision_layer & (PhysicsLayers.SOLID_WORLD | PhysicsLayers.PLATFORMS)) != 0:
		should_bounce = true
	elif target.is_in_group(Identifiers.Groups.WORLD):
		should_bounce = true

	if should_bounce:
		pogo_bounce_requested.emit()


func _spawn_player_spark(pos: Vector2) -> void:
	if not is_instance_valid(_fx_manager) or not _p_data.config.hit_spark_effect:
		return
	_fx_manager.play_vfx(_p_data.config.hit_spark_effect, pos, Vector2.UP)


=====================================
FILE: ./src/entities/player/components/player_resource_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://a1b2c3d4e5f6"]

[ext_resource type="Script" path="res://src/entities/player/components/player_resource_component.gd" id="1_res"]

[node name="PlayerResourceComponent" type="Node"]
script = ExtResource("1_res")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource", "event_bus")

=====================================
FILE: ./src/entities/player/components/heal_component.tscn
=====================================
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/player/components/heal_component.gd" id="1_script"]

[node name="HealComponent" type="Node"]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/player/components/player_jump_helper.gd
=====================================
# src/entities/player/components/player_jump_helper.gd
## A stateless helper class that centralizes all jump-related logic for the Player.
class_name PlayerJumpHelper
extends RefCounted

# --- Public Methods ---

## Checks all possible jump conditions in a prioritized order and executes one if valid.
static func try_jump(owner: Node, p_data: Resource) -> bool:
	if not is_instance_valid(owner):
		return false

	var physics = owner.get_component(PlayerPhysicsComponent)
	var sm = owner.get_component(BaseStateMachine)

	if not is_instance_valid(physics) or not is_instance_valid(sm):
		return false

	# 1. Wall Jump (Highest Priority)
	if p_data.physics.wall_coyote_timer > 0:
		physics.perform_wall_jump()
		sm.change_state(Identifiers.PlayerStates.JUMP)
		return true

	# 2. Ground Jump (includes coyote time)
	if owner.is_on_floor() or p_data.physics.coyote_timer > 0:
		sm.change_state(Identifiers.PlayerStates.JUMP)
		return true

	# 3. Air Jump
	if p_data.physics.air_jumps_left > 0:
		sm.change_state(Identifiers.PlayerStates.JUMP, {"is_air_jump": true})
		return true

	return false


## Checks if the player is standing on a one-way platform.
## Useful for other components to avoid conflicting with drop logic.
static func is_standing_on_platform(owner: Node) -> bool:
	if not is_instance_valid(owner) or not owner is CharacterBody2D:
		return false

	for i in range(owner.get_slide_collision_count()):
		var collision = owner.get_slide_collision(i)
		var collider = collision.get_collider()
		
		if not is_instance_valid(collider):
			continue

		# Must be standing ON it (Normal pointing up)
		if collision.get_normal().dot(Vector2.UP) < 0.5:
			continue 
		
		# Check Layer
		if collider is CollisionObject2D:
			if (collider.collision_layer & PhysicsLayers.PLATFORMS) != 0:
				return true
		
		# Check Group (Legacy Fallback)
		if collider.is_in_group(Identifiers.Groups.ONEWAY_PLATFORMS):
			return true
			
	return false


## Checks if the player is attempting to drop through a one-way platform.
static func try_platform_drop(owner: Node) -> bool:
	if not is_instance_valid(owner) or not owner is CharacterBody2D:
		return false

	for i in range(owner.get_slide_collision_count()):
		var collision = owner.get_slide_collision(i)
		var collider = collision.get_collider()
		
		if not is_instance_valid(collider):
			continue

		if collision.get_normal().dot(Vector2.UP) < 0.5:
			continue 
		
		var is_platform = false
		
		if collider is CollisionObject2D:
			if (collider.collision_layer & PhysicsLayers.PLATFORMS) != 0:
				is_platform = true
		
		if not is_platform and collider.is_in_group(Identifiers.Groups.ONEWAY_PLATFORMS):
			is_platform = true
			
		if is_platform:
			# Nudge down to bypass the one-way threshold
			owner.position.y += 2 
			
			var sm = owner.get_component(BaseStateMachine)
			if sm:
				sm.change_state(Identifiers.PlayerStates.FALL)
			return true

	return false


=====================================
FILE: ./src/entities/player/components/pogo_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://pogo_component_scene_uid"]

[ext_resource type="Script" path="res://src/entities/player/components/pogo_component.gd" id="1_script"]

[node name="PogoComponent" type="Node"]
script = ExtResource("1_script")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource", "pogo_hitbox", "services")


=====================================
FILE: ./src/entities/player/components/jump_component.tscn
=====================================
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/player/components/jump_component.gd" id="1_script"]

[node name="JumpComponent" type="Node"]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/player/components/jump_component.gd
=====================================
# src/entities/player/components/jump_component.gd
@tool
class_name JumpComponent
extends IComponent

const JumpHelper = preload("res://src/entities/player/components/player_jump_helper.gd")

var _owner_node # Typed as Player
var _p_data: PlayerStateData
var _state_machine: BaseStateMachine
var _input_component: InputComponent

func _ready() -> void:
	process_priority = 0

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_owner_node = p_owner
	_p_data = p_dependencies.get("data_resource")
	_state_machine = _owner_node.get_component(BaseStateMachine)
	_input_component = _owner_node.get_component(InputComponent)

func _physics_process(_delta: float) -> void:
	if Engine.is_editor_hint():
		return
	if not is_instance_valid(_owner_node) or not is_instance_valid(_state_machine):
		return
	
	if not _state_machine.get_current_state_key() in Identifiers.PlayerStates.MOVE: # Fallback check
		var key = _state_machine.get_current_state_key()
		if key != Identifiers.PlayerStates.MOVE and key != Identifiers.PlayerStates.FALL and key != Identifiers.PlayerStates.JUMP and key != Identifiers.PlayerStates.WALL_SLIDE:
			return

	if _input_component.input.jump_just_pressed:
		var is_holding_down = _input_component.input.down
		
		if is_holding_down:
			if JumpHelper.try_platform_drop(_owner_node):
				return
		
		JumpHelper.try_jump(_owner_node, _p_data)

func teardown() -> void:
	set_physics_process(false)
	_owner_node = null
	_p_data = null
	_state_machine = null
	_input_component = null


=====================================
FILE: ./src/entities/player/components/dash_component.gd
=====================================
# src/entities/player/components/dash_component.gd
@tool
class_name DashComponent
extends IComponent

var _owner_node # Typed as Player
var _p_data: PlayerStateData
var _state_machine: BaseStateMachine
var _input_component: InputComponent

func _ready() -> void:
	process_priority = 0

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_owner_node = p_owner
	_p_data = p_dependencies.get("data_resource")
	_state_machine = _owner_node.get_component(BaseStateMachine)
	_input_component = _owner_node.get_component(InputComponent)

func _physics_process(delta: float) -> void:
	if Engine.is_editor_hint():
		return
	if not is_instance_valid(_owner_node):
		return

	_update_timers(delta)

	var state = _state_machine.get_current_state_key()
	if state == Identifiers.PlayerStates.ATTACK or state == Identifiers.PlayerStates.HURT or state == Identifiers.PlayerStates.HEAL or state == Identifiers.PlayerStates.DASH:
		return

	if (
		_input_component.input.dash_pressed
		and _p_data.physics.can_dash
		and _p_data.physics.dash_cooldown_timer <= 0
	):
		_state_machine.change_state(Identifiers.PlayerStates.DASH, {})

func teardown() -> void:
	set_physics_process(false)
	_owner_node = null
	_p_data = null
	_state_machine = null
	_input_component = null

func _update_timers(delta: float) -> void:
	if not is_instance_valid(_p_data):
		return
	_p_data.physics.dash_cooldown_timer = max(0.0, _p_data.physics.dash_cooldown_timer - delta)
	_p_data.physics.dash_duration_timer = max(0.0, _p_data.physics.dash_duration_timer - delta)


=====================================
FILE: ./src/entities/player/components/heal_component.gd
=====================================
# src/entities/player/components/heal_component.gd
@tool
class_name HealComponent
extends IComponent

# --- Signals ---
## Emitted when the healing channel completes successfully.
signal healing_complete

# --- Constants ---
const JumpHelper = preload("res://src/entities/player/components/player_jump_helper.gd")

# --- Dependencies ---
var _owner_node: CharacterBody2D
var _p_data: PlayerStateData
var _resource_component: PlayerResourceComponent
var _event_bus: EventBus
var _input_component: InputComponent
var _state_machine: BaseStateMachine

# --- Internals ---
var _timer: Timer

func _ready() -> void:
	# Run before JumpComponent (0) to intercept Down+Jump
	process_priority = -1

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_owner_node = p_owner as CharacterBody2D
	_p_data = p_dependencies.get("data_resource")
	_resource_component = p_dependencies.get("resource_component")
	_event_bus = p_dependencies.get("event_bus")
	
	# Resolve sibling components via Owner (standard pattern)
	if _owner_node.has_method("get_component"):
		_input_component = _owner_node.get_component(InputComponent)
		_state_machine = _owner_node.get_component(BaseStateMachine)
	
	# Create the timer dynamically
	_timer = Timer.new()
	_timer.name = "InternalHealingTimer"
	_timer.one_shot = true
	_timer.timeout.connect(_on_timeout)
	add_child(_timer)

func teardown() -> void:
	if is_instance_valid(_timer):
		_timer.stop()
		_timer.queue_free()
	_owner_node = null
	_p_data = null
	_resource_component = null
	_event_bus = null
	_input_component = null
	_state_machine = null

# --- Physics Process (Input Polling) ---

func _physics_process(_delta: float) -> void:
	if Engine.is_editor_hint() or not is_instance_valid(_owner_node):
		return
		
	# Only allow starting heal from Move/Idle/Fall states (mostly Grounded check covers it)
	# But we specifically check state to avoid re-triggering while already healing or hurting
	var current_state = _state_machine.get_current_state_key()
	if current_state == Identifiers.PlayerStates.HEAL or current_state == Identifiers.PlayerStates.HURT:
		return

	if _input_component.input.jump_just_pressed and _input_component.input.down:
		_try_start_heal()

# --- Public API ---

func start_healing() -> void:
	if not is_instance_valid(_p_data): return
	_timer.start(_p_data.config.heal_duration)

func cancel_healing() -> void:
	if is_instance_valid(_timer):
		_timer.stop()

func is_healing() -> bool:
	return is_instance_valid(_timer) and not _timer.is_stopped()

# --- Private Methods ---

func _try_start_heal() -> void:
	# 1. Check Resources
	if _p_data.combat.healing_charges <= 0:
		return
		
	# 2. Check Physical State (Must be grounded and still)
	if not _owner_node.is_on_floor():
		return
		
	# 3. Check Platform Conflict
	# If we are standing on a one-way platform, Down+Jump means DROP, not HEAL.
	if JumpHelper.is_standing_on_platform(_owner_node):
		return
		
	# 4. Transition
	# Stop momentum
	_owner_node.velocity.x = 0
	_state_machine.change_state(Identifiers.PlayerStates.HEAL)


func _on_timeout() -> void:
	if not is_instance_valid(_p_data):
		return

	# 1. Increment Health
	_p_data.health = min(_p_data.health + 1, _p_data.max_health)
	
	# 2. Consume Resource
	if is_instance_valid(_resource_component):
		_resource_component.consume_healing_charge()
	
	# 3. Emit Global Event (Update HUD)
	if is_instance_valid(_event_bus):
		var ev = PlayerHealthChangedEvent.new()
		ev.current_health = _p_data.health
		ev.max_health = _p_data.max_health
		_event_bus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev)
	
	# 4. Spawn VFX
	_spawn_heal_splash()
	
	# 5. Notify State Machine
	healing_complete.emit()

func _spawn_heal_splash() -> void:
	if not is_instance_valid(_owner_node) or not _p_data.config.vfx_heal_splash:
		return
		
	var splash = _p_data.config.vfx_heal_splash.instantiate()
	splash.global_position = _owner_node.global_position
	splash.emitting = true
	
	# Add to the world container (sibling of player)
	_owner_node.add_sibling(splash)


=====================================
FILE: ./src/entities/player/components/player_physics_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://o9p0q1r2s3t4"]

[ext_resource type="Script" path="res://src/entities/player/components/player_physics_component.gd" id="1_phys"]

[node name="PlayerPhysicsComponent" type="Node"]
script = ExtResource("1_phys")

=====================================
FILE: ./src/entities/player/components/player_physics_component.gd
=====================================
# src/entities/player/components/player_physics_component.gd
@tool
## Manages all direct physics interactions for the player character.
## Acts as the gatekeeper for the 'velocity' property and physics timers.
class_name PlayerPhysicsComponent
extends IComponent

# --- Member Variables ---
var owner_node # Typed as Player in logic
var p_data: PlayerStateData

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	process_priority = -50


func _physics_process(delta: float) -> void:
	if Engine.is_editor_hint():
		return
	if not is_instance_valid(owner_node):
		return

	# --- Jump Buffering Logic ---
	# We poll input here so buffering works in ALL states (Attack, Fall, etc.)
	var input_comp: InputComponent = owner_node.get_component(InputComponent)
	if is_instance_valid(input_comp) and input_comp.input.jump_just_pressed:
		p_data.physics.jump_buffer_timer = p_data.config.jump_buffer

	_update_timers(delta)
	
	if owner_node.is_on_wall() and not owner_node.is_on_floor():
		p_data.physics.wall_coyote_timer = p_data.config.wall_coyote_time
		p_data.physics.last_wall_normal = owner_node.get_wall_normal()


# --- Private Methods ---


func _update_timers(delta: float) -> void:
	if not is_instance_valid(p_data):
		return
	p_data.physics.coyote_timer = max(0.0, p_data.physics.coyote_timer - delta)
	p_data.physics.wall_coyote_timer = max(0.0, p_data.physics.wall_coyote_timer - delta)
	p_data.physics.jump_buffer_timer = max(0.0, p_data.physics.jump_buffer_timer - delta)


# --- Public Methods ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner
	self.p_data = p_dependencies.get("data_resource")


func teardown() -> void:
	set_physics_process(false)
	owner_node = null
	p_data = null


# --- Movement API ---

## Standard horizontal movement based on Input.
func apply_horizontal_movement() -> void:
	var input_component: InputComponent = owner_node.get_component(InputComponent)
	if not is_instance_valid(input_component):
		return
	var move_axis = input_component.input.move_axis
	owner_node.velocity.x = move_axis * p_data.config.move_speed
	if not is_zero_approx(move_axis):
		p_data.physics.facing_direction = sign(move_axis)


## Applies gravity to the vertical velocity.
func apply_gravity(delta: float, multiplier: float = 1.0) -> void:
	owner_node.velocity.y += p_data.world_config.gravity * multiplier * delta


## Applies an instant vertical force.
func jump(force: float) -> void:
	owner_node.velocity.y = -force


## Sets the full velocity vector immediately (used for Dashing/Recoil).
func set_velocity(new_velocity: Vector2) -> void:
	owner_node.velocity = new_velocity


## Reduces the vertical velocity (used for variable jump height).
func damp_jump() -> void:
	if owner_node.velocity.y < 0:
		owner_node.velocity.y *= p_data.config.jump_release_dampener


## Applies friction/drag to bring velocity to zero (Affects X and Y).
func apply_friction(amount: float, delta: float) -> void:
	owner_node.velocity = owner_node.velocity.move_toward(Vector2.ZERO, amount * delta)


## Applies friction only to the horizontal axis (Preserves Gravity).
func apply_horizontal_friction(amount: float, delta: float) -> void:
	owner_node.velocity.x = move_toward(owner_node.velocity.x, 0.0, amount * delta)


## Executes the physical reaction to a pogo hit.
func perform_pogo_bounce() -> void:
	owner_node.velocity.y = -p_data.config.pogo_force
	# Nudge up slightly to prevent immediate re-collision issues
	owner_node.position.y -= 1


## Checks if the conditions for performing a wall slide are met.
func can_wall_slide() -> bool:
	var ic: InputComponent = owner_node.get_component(InputComponent)
	if not is_instance_valid(ic):
		return false
	var move_axis = ic.input.move_axis
	return (
		p_data.physics.wall_coyote_timer > 0
		and not owner_node.is_on_floor()
		and move_axis != 0
		and sign(move_axis) == -p_data.physics.last_wall_normal.x
	)


## Applies the velocity and resets timers for a wall jump.
func perform_wall_jump() -> void:
	owner_node.velocity.y = -p_data.config.wall_jump_force_y
	owner_node.velocity.x = p_data.physics.last_wall_normal.x * p_data.config.wall_jump_force_x
	p_data.physics.coyote_timer = 0
	p_data.physics.wall_coyote_timer = 0


=====================================
FILE: ./src/entities/player/components/charge_attack_component.tscn
=====================================
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/player/components/charge_attack_component.gd" id="1_script"]

[node name="ChargeAttackComponent" type="Node"]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/player/components/charge_attack_component.gd
=====================================
# src/entities/player/components/charge_attack_component.gd
@tool
class_name ChargeAttackComponent
extends IComponent

const AURA_START_DELAY: float = 0.25

var _owner_node # Typed as Player
var _p_data: PlayerStateData
var _state_machine: BaseStateMachine
var _input_component: InputComponent
var _combat_component: CombatComponent

var _aura_instance: Node2D

func _ready() -> void:
	process_priority = 0

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	_owner_node = p_owner
	_p_data = p_dependencies.get("data_resource")
	_state_machine = _owner_node.get_component(BaseStateMachine)
	_input_component = _owner_node.get_component(InputComponent)
	_combat_component = _owner_node.get_component(CombatComponent)
	
	var aura_scene = _p_data.config.vfx_charge_aura
	if is_instance_valid(_owner_node) and is_instance_valid(aura_scene):
		_aura_instance = aura_scene.instantiate()
		_aura_instance.emitting = false
		_owner_node.add_child(_aura_instance)

func _physics_process(delta: float) -> void:
	if Engine.is_editor_hint():
		return
	if not is_instance_valid(_owner_node):
		return
	
	# 1. Update Timers
	if _p_data.combat.is_charging and _input_component.input.attack_pressed:
		_p_data.combat.charge_timer += delta

	# 2. Update Visuals
	var should_emit = _p_data.combat.is_charging and _p_data.combat.charge_timer >= AURA_START_DELAY
	
	if is_instance_valid(_aura_instance):
		if _aura_instance.emitting != should_emit:
			_aura_instance.emitting = should_emit
		
		if _p_data.combat.charge_timer >= _p_data.config.level_2_charge_time:
			_aura_instance.scale = Vector2(1.5, 1.5)
		else:
			_aura_instance.scale = Vector2(1.0, 1.0)

	# 3. Handle Inputs
	if _input_component.input.attack_just_pressed:
		_p_data.combat.is_charging = true
		_p_data.combat.charge_timer = 0.0

	if _input_component.input.attack_released:
		if _p_data.combat.is_charging:
			_try_execute_attack()
			_p_data.combat.is_charging = false

func _try_execute_attack() -> void:
	if _state_machine.states.is_empty():
		return

	var state = _state_machine.get_current_state_key()
	if state == Identifiers.PlayerStates.HURT or state == Identifiers.PlayerStates.DASH or state == Identifiers.PlayerStates.HEAL:
		return

	if _p_data.combat.charge_timer >= _p_data.config.charge_time:
		var is_lvl_2 = _p_data.combat.charge_timer >= _p_data.config.level_2_charge_time
		_combat_component.fire_shot(is_lvl_2)
		_spawn_release_splash(is_lvl_2)
	elif _input_component.input.down:
		_state_machine.change_state(Identifiers.PlayerStates.POGO, {})
	else:
		_state_machine.change_state(Identifiers.PlayerStates.ATTACK, {})

func _spawn_release_splash(is_large: bool = false) -> void:
	if not is_instance_valid(_owner_node):
		return
	
	var splash_scene = _p_data.config.vfx_charge_splash
	if not is_instance_valid(splash_scene):
		return

	var splash = splash_scene.instantiate()
	var offset = Vector2(_p_data.physics.facing_direction * 60, 0)
	splash.global_position = _owner_node.global_position + offset
	
	if is_large:
		splash.scale = Vector2(1.5, 1.5)
	
	splash.emitting = true
	
	# FIX: Add as sibling of player (puts it in the Level inside the Viewport)
	# instead of adding to current_scene (The Root Window).
	_owner_node.add_sibling(splash)

func teardown() -> void:
	set_physics_process(false)
	if is_instance_valid(_aura_instance):
		_aura_instance.queue_free()
	_aura_instance = null
	_owner_node = null
	_p_data = null
	_state_machine = null
	_input_component = null
	_combat_component = null


=====================================
FILE: ./src/entities/player/components/dash_component.tscn
=====================================
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/player/components/dash_component.gd" id="1_script"]

[node name="DashComponent" type="Node"]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/player/components/player_resource_component.gd
=====================================
# src/entities/player/components/player_resource_component.gd
@tool
## Manages the player's resource economy (Determination and Healing).
class_name PlayerResourceComponent
extends IComponent

# --- Member Variables ---
var owner_node: BaseEntity
var p_data: PlayerStateData
var _event_bus: EventBus

# --- Public Methods ---
func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as BaseEntity
	self.p_data = p_dependencies.get("data_resource")
	
	self._event_bus = p_dependencies.get("event_bus")
	assert(is_instance_valid(_event_bus), "PlayerResourceComponent requires an EventBus.")


func teardown() -> void:
	owner_node = null
	p_data = null
	_event_bus = null


## Called when the player successfully deals damage to an enemy.
func on_damage_dealt() -> void:
	if p_data.combat.healing_charges >= p_data.combat.max_healing_charges:
		return

	p_data.combat.determination_counter += 1
	if p_data.combat.determination_counter >= p_data.config.determination_per_charge:
		p_data.combat.determination_counter = 0
		p_data.combat.healing_charges += 1
		_emit_healing_charges_changed_event()


## Consumes one healing charge.
func consume_healing_charge() -> void:
	if p_data.combat.healing_charges > 0:
		p_data.combat.healing_charges -= 1
		_emit_healing_charges_changed_event()


# --- Private Methods ---
func _emit_healing_charges_changed_event() -> void:
	var ev = PlayerHealingChargesChangedEvent.new()
	ev.current_charges = p_data.combat.healing_charges
	_event_bus.emit(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, ev)


=====================================
FILE: ./src/entities/player/states/state_jump.gd
=====================================
# src/entities/player/states/state_jump.gd
## Handles the player's upward movement (jump).
extends BaseState

var _physics: PlayerPhysicsComponent
var _input: InputComponent


func enter(msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	_input = owner.get_component(InputComponent)

	if msg.get("is_air_jump", false):
		state_data.physics.air_jumps_left -= 1

	_physics.jump(state_data.config.jump_force)
	state_data.physics.coyote_timer = 0


func process_physics(delta: float) -> void:
	_physics.apply_horizontal_movement()

	if _input.input.jump_just_pressed:
		if state_data.physics.air_jumps_left > 0:
			_perform_air_jump()

	if _input.input.jump_released:
		_physics.damp_jump()

	_apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	if _physics.can_wall_slide():
		state_machine.change_state(Identifiers.PlayerStates.WALL_SLIDE)
		return


func _apply_gravity(delta: float) -> void:
	_physics.apply_gravity(delta)
	if owner.velocity.y > 0.0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


func _perform_air_jump() -> void:
	state_data.physics.air_jumps_left -= 1
	_physics.jump(state_data.config.jump_force)


=====================================
FILE: ./src/entities/player/states/state_dash.gd
=====================================
# src/entities/player/states/state_dash.gd
extends BaseState

var _dash_direction: Vector2
var _invincibility_token: int
var _health: HealthComponent
var _physics: PlayerPhysicsComponent

func enter(_msg := {}):
	_health = owner.get_component(HealthComponent)
	_physics = owner.get_component(PlayerPhysicsComponent)

	state_data.physics.can_dash = false
	state_data.physics.dash_duration_timer = state_data.config.dash_duration
	state_data.physics.dash_cooldown_timer = state_data.config.dash_cooldown

	_invincibility_token = _health.grant_invincibility(self)

	_dash_direction = _get_dash_direction()
	_physics.set_velocity(_dash_direction * state_data.config.dash_speed)


func exit():
	if is_instance_valid(owner) and is_instance_valid(_health):
		_health.release_invincibility(_invincibility_token)

	# Stop momentum on exit
	if is_instance_valid(_physics):
		var current_vel = owner.velocity
		# Stop velocity on axes we dashed on
		if _dash_direction.y != 0:
			current_vel.y = 0.0
		if _dash_direction.x != 0:
			current_vel.x = 0.0
		_physics.set_velocity(current_vel)


func process_physics(_delta: float):
	if state_data.physics.dash_duration_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


func _get_dash_direction() -> Vector2:
	var ic: InputComponent = owner.get_component(InputComponent)
	var dir = Vector2.ZERO

	# 1. Horizontal Input
	dir.x = ic.input.move_axis

	# 2. Vertical Input
	if ic.input.up:
		dir.y = -1.0
	elif ic.input.down:
		dir.y = 1.0

	# 3. Fallback: If no input, dash forward
	if dir == Vector2.ZERO:
		dir.x = state_data.physics.facing_direction

	# Normalize to ensure diagonal dashes aren't faster
	return dir.normalized()


=====================================
FILE: ./src/entities/player/states/state_heal.gd
=====================================
# src/entities/player/states/state_heal.gd
# Handles the player's healing state.
extends BaseState

var _heal_component: HealComponent
var _aura_instance: Node2D
var _tween: Tween

func enter(_msg := {}):
	owner.velocity = Vector2.ZERO
	
	_heal_component = owner.get_component(HealComponent)
	if not is_instance_valid(_heal_component):
		# Safety fallback
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	# Listen for completion
	if not _heal_component.healing_complete.is_connected(_on_healing_complete):
		_heal_component.healing_complete.connect(_on_healing_complete, CONNECT_ONE_SHOT)

	_heal_component.start_healing()

	# Visuals (Aura)
	var aura_scene = state_data.config.vfx_heal_aura
	if is_instance_valid(aura_scene):
		_aura_instance = aura_scene.instantiate()
		owner.add_child(_aura_instance)
		_aura_instance.position = Vector2(0, 0) 
		_aura_instance.scale = Vector2(0.2, 0.2)
		
		_tween = owner.create_tween()
		_tween.tween_property(_aura_instance, "scale", Vector2(1.0, 1.0), state_data.config.heal_duration)\
			.set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_IN)


func exit():
	# Cancel logic in component (stops timer)
	if is_instance_valid(_heal_component):
		_heal_component.cancel_healing()
		# Disconnect signal if we exited early (e.g. damaged)
		if _heal_component.healing_complete.is_connected(_on_healing_complete):
			_heal_component.healing_complete.disconnect(_on_healing_complete)

	if is_instance_valid(_tween):
		_tween.kill()
	if is_instance_valid(_aura_instance):
		_aura_instance.queue_free()


func process_physics(_delta: float):
	# Interrupt conditions (Movement input)
	if (
		not Input.is_action_pressed("ui_down")
		or not Input.is_action_pressed("ui_jump")
		or not is_zero_approx(owner.velocity.x)
		or not owner.is_on_floor()
	):
		state_machine.change_state(Identifiers.PlayerStates.MOVE)


func _on_healing_complete() -> void:
	state_machine.change_state(Identifiers.PlayerStates.MOVE)


=====================================
FILE: ./src/entities/player/states/state_wall_slide.gd
=====================================
# src/entities/player/states/state_wall_slide.gd
# Handles the player's wall sliding state.
extends BaseState

var _physics: PlayerPhysicsComponent
var _input: InputComponent


func enter(_msg := {}):
	_physics = owner.get_component(PlayerPhysicsComponent)
	_input = owner.get_component(InputComponent)
	state_data.physics.can_dash = true
	state_data.physics.air_jumps_left = state_data.config.max_air_jumps


func exit():
	if state_data.physics.last_wall_normal != Vector2.ZERO:
		state_data.physics.facing_direction = sign(state_data.physics.last_wall_normal.x)


func process_physics(delta: float):
	var gravity = state_data.world_config.gravity
	var wall_slide_speed = state_data.config.wall_slide_speed
	owner.velocity.y = min(owner.velocity.y + gravity * delta, wall_slide_speed)

	state_data.physics.facing_direction = sign(-state_data.physics.last_wall_normal.x)

	if _input.input.jump_just_pressed:
		_physics.perform_wall_jump()
		state_machine.change_state(Identifiers.PlayerStates.JUMP)
		return

	var move_axis = _input.input.move_axis
	if move_axis * -state_data.physics.last_wall_normal.x < 0.8:
		state_machine.change_state(Identifiers.PlayerStates.FALL)
		return

	if state_data.physics.wall_coyote_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)
		return

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return


=====================================
FILE: ./src/entities/player/states/state_attack.gd
=====================================
# src/entities/player/states/state_attack.gd
## This state handles the player's melee attack.
class_name PlayerStateAttack
extends BaseState

var _input: InputComponent
var _physics: PlayerPhysicsComponent
var _player # Untyped

# --- State Lifecycle ---

func enter(_msg := {}) -> void:
	_player = owner
	_input = owner.get_component(InputComponent)
	_physics = owner.get_component(PlayerPhysicsComponent)
	
	state_data.combat.hit_targets_this_swing.clear()
	
	state_data.combat.attack_duration_timer = state_data.config.attack_duration
	state_data.combat.attack_cooldown_timer = state_data.config.attack_cooldown
	
	var is_up_attack = _input.input.up
	var facing = state_data.physics.facing_direction
	
	if is_instance_valid(_player) and is_instance_valid(_player.melee_hitbox):
		var shape = state_data.config.forward_attack_shape
		# Offset calculation: Body Half-Width (20) + Hitbox Half-Width (50) = 70
		var offset = Vector2(facing * 70, 0)
		var rotation_angle = 0.0
		
		if is_up_attack:
			shape = state_data.config.upward_attack_shape
			# Offset: Top of Body (-40) - Margin (20) = -60
			offset = Vector2(0, -60)
			rotation_angle = deg_to_rad(-90)
		elif facing < 0:
			rotation_angle = deg_to_rad(180)
			
		_player.melee_hitbox.activate(shape, offset)
		
		# Spawn Visual
		_spawn_visual(shape.get_rect().size, offset, rotation_angle)


func exit() -> void:
	state_data.combat.hit_targets_this_swing.clear()
	if is_instance_valid(_player) and is_instance_valid(_player.melee_hitbox):
		_player.melee_hitbox.deactivate()


func process_physics(delta: float) -> void:
	if is_instance_valid(_physics):
		# Apply gravity so the player falls during the attack
		_physics.apply_gravity(delta)
		# Apply friction only to horizontal movement to stop forward momentum
		_physics.apply_horizontal_friction(state_data.config.attack_friction, delta)

	if state_data.combat.attack_duration_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


func _spawn_visual(size: Vector2, offset: Vector2, rot: float) -> void:
	var scene = state_data.config.vfx_melee_slash
	if not is_instance_valid(scene) or not is_instance_valid(_player):
		return
		
	var visual = scene.instantiate()
	visual.position = offset
	visual.rotation = rot
	_player.add_child(visual) # Add as child so it follows player during the swing
	
	if visual.has_method("setup"):
		visual.setup(size, state_data.config.attack_duration)


=====================================
FILE: ./src/entities/player/states/state_pogo.gd
=====================================
# src/entities/player/states/state_pogo.gd
## Handles the player's downward pogo attack state.
class_name PlayerStatePogo
extends BaseState

var _physics: PlayerPhysicsComponent
var _player # Untyped

# --- State Lifecycle ---

func enter(_msg := {}) -> void:
	_player = owner
	_physics = owner.get_component(PlayerPhysicsComponent)
	
	state_data.combat.is_pogo_attack = true
	state_data.combat.attack_duration_timer = state_data.config.attack_duration
	
	# Direct Actuation
	var shape_size = Vector2(40, 40) # Default playerbody size (width only relevant here)
	if is_instance_valid(_player) and is_instance_valid(_player.pogo_hitbox):
		# Reuse existing shape logic, but update offset
		# Bottom of Body (40) + Margin (20) = 60
		_player.pogo_hitbox.activate(null, Vector2(0, 60))
		
		# Fetch shape size if possible for accurate visual
		var col = _player.pogo_hitbox.get_node_or_null("CollisionShape2D")
		if col and col.shape:
			shape_size = col.shape.get_rect().size
	
	_spawn_visual(shape_size)
	
	# IMMEDIATE CHECK:
	if _player.is_on_floor():
		if _check_pogo_ground_bounce():
			return


func exit() -> void:
	state_data.combat.is_pogo_attack = false
	if is_instance_valid(_player) and is_instance_valid(_player.pogo_hitbox):
		_player.pogo_hitbox.deactivate()


func process_physics(delta: float) -> void:
	_physics.apply_gravity(delta)

	if owner.is_on_floor():
		if _check_pogo_ground_bounce():
			return
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	if state_data.combat.attack_duration_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


func _check_pogo_ground_bounce() -> bool:
	if not is_instance_valid(_player) or not is_instance_valid(_player.pogo_hitbox):
		return false

	if _player.pogo_hitbox.monitoring:
		var bodies = _player.pogo_hitbox.get_overlapping_bodies()
		for body in bodies:
			if body == owner: continue
			if _is_valid_bounce_surface(body):
				_trigger_bounce()
				return true

	var space_state = _player.get_world_2d().direct_space_state
	var query = PhysicsShapeQueryParameters2D.new()
	
	var shape_node = _player.pogo_hitbox.get_node_or_null("CollisionShape2D")
	if not is_instance_valid(shape_node):
		return false
		
	query.shape = shape_node.shape
	var offset = Vector2(0, 60) # Update sync offset
	query.transform = Transform2D(0.0, _player.global_position + offset)
	query.collision_mask = PhysicsLayers.SOLID_WORLD | PhysicsLayers.PLATFORMS
	query.exclude = [_player.get_rid()]
	
	var result = space_state.intersect_shape(query, 1)
	if not result.is_empty():
		_trigger_bounce()
		return true
				
	return false


func _is_valid_bounce_surface(body: Node) -> bool:
	if body is PhysicsBody2D:
		var layer = body.collision_layer
		if (layer & (PhysicsLayers.SOLID_WORLD | PhysicsLayers.PLATFORMS)) != 0:
			return true
	if body.is_in_group(Identifiers.Groups.WORLD):
		return true
	return false


func _trigger_bounce() -> void:
	if _player.has_method("_on_pogo_bounce_requested"):
		_player._on_pogo_bounce_requested()


func _spawn_visual(size: Vector2) -> void:
	var scene = state_data.config.vfx_melee_slash
	if not is_instance_valid(scene) or not is_instance_valid(_player):
		return
		
	var visual = scene.instantiate()
	visual.position = Vector2(0, 60) # Offset 60
	visual.rotation = deg_to_rad(90)
	_player.add_child(visual)
	
	if visual.has_method("setup"):
		visual.setup(size, state_data.config.attack_duration)


=====================================
FILE: ./src/entities/player/states/state_hurt.gd
=====================================
# src/entities/player/states/state_hurt.gd
## Handles the player's knockback and stun state after taking damage.
extends BaseState

var _physics: PlayerPhysicsComponent


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	state_data.physics.knockback_timer = state_data.config.knockback_duration
	state_data.combat.is_charging = false
	
	# FIX: Healing cancellation is now handled automatically by StateHeal.exit()
	# if the player was in the Heal state when hit.


func process_physics(delta: float) -> void:
	_physics.apply_gravity(delta)
	# Apply high drag/friction during knockback
	owner.velocity.x = move_toward(owner.velocity.x, 0, 800 * delta)

	if state_data.physics.knockback_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


=====================================
FILE: ./src/entities/player/states/state_fall.gd
=====================================
# src/entities/player/states/state_fall.gd
## Handles the player's falling state (downward vertical movement).
extends BaseState

const JumpHelper = preload("res://src/entities/player/components/player_jump_helper.gd")

var _physics: PlayerPhysicsComponent
var _input: InputComponent


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	_input = owner.get_component(InputComponent)


func process_physics(delta: float) -> void:
	_physics.apply_horizontal_movement()
	_apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	if _physics.can_wall_slide():
		state_machine.change_state(Identifiers.PlayerStates.WALL_SLIDE)
		return

	if _input.input.jump_just_pressed:
		JumpHelper.try_jump(owner, state_data)


func _apply_gravity(delta: float) -> void:
	var gravity_multiplier = 1.0
	if _input.input.down:
		gravity_multiplier = state_data.config.fast_fall_gravity_multiplier
	_physics.apply_gravity(delta, gravity_multiplier)


=====================================
FILE: ./src/entities/player/states/state_move.gd
=====================================
# src/entities/player/states/state_move.gd
## Handles the player's grounded movement state.
extends BaseState

var _physics: PlayerPhysicsComponent


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	# UPDATE: config.max_air_jumps
	state_data.physics.air_jumps_left = state_data.config.max_air_jumps
	state_data.physics.can_dash = true
	
	# Jump Buffer Check: If the player pressed jump right before landing, execute it now.
	if state_data.physics.jump_buffer_timer > 0:
		state_data.physics.jump_buffer_timer = 0.0
		state_machine.change_state(Identifiers.PlayerStates.JUMP)


func process_physics(delta: float) -> void:
	# UPDATE: config.coyote_time
	state_data.physics.coyote_timer = state_data.config.coyote_time

	_physics.apply_gravity(delta)
	_physics.apply_horizontal_movement()

	if not owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.FALL)
		return


=====================================
FILE: ./src/entities/player/data/player_state_data.gd
=====================================
# src/entities/player/data/player_state_data.gd
@tool
## A Resource that holds all shared runtime state data for the Player.
## Acts as a container for domain-specific data chunks.
class_name PlayerStateData
extends BaseEntityData

# --- Sub-Data Containers ---
var physics: PlayerPhysicsData = PlayerPhysicsData.new()
var combat: PlayerCombatData = PlayerCombatData.new()

# --- Configuration References ---
# Note: 'config' and 'world_config' are inherited from BaseEntityData.
# 'config' is typed as Resource in the base, but holds PlayerConfig at runtime.


=====================================
FILE: ./src/entities/player/data/player_state_machine_config.tres
=====================================
[gd_resource type="Resource" script_class="StateMachineConfig" load_steps=13 format=3]

[ext_resource type="Script" path="res://src/core/data/config/state_definition.gd" id="1_def"]
[ext_resource type="Script" path="res://src/core/data/config/state_machine_config.gd" id="2_cfg"]
[ext_resource type="Script" path="res://src/entities/player/states/state_move.gd" id="3_move"]
[ext_resource type="Script" path="res://src/entities/player/states/state_jump.gd" id="4_jump"]
[ext_resource type="Script" path="res://src/entities/player/states/state_fall.gd" id="5_fall"]
[ext_resource type="Script" path="res://src/entities/player/states/state_dash.gd" id="6_dash"]
[ext_resource type="Script" path="res://src/entities/player/states/state_wall_slide.gd" id="7_slide"]
[ext_resource type="Script" path="res://src/entities/player/states/state_attack.gd" id="8_attack"]
[ext_resource type="Script" path="res://src/entities/player/states/state_hurt.gd" id="9_hurt"]
[ext_resource type="Script" path="res://src/entities/player/states/state_heal.gd" id="10_heal"]
[ext_resource type="Script" path="res://src/entities/player/states/state_pogo.gd" id="11_pogo"]

[sub_resource type="Resource" id="Resource_move"]
script = ExtResource("1_def")
key = &"move"
state_script = ExtResource("3_move")

[sub_resource type="Resource" id="Resource_jump"]
script = ExtResource("1_def")
key = &"jump"
state_script = ExtResource("4_jump")

[sub_resource type="Resource" id="Resource_fall"]
script = ExtResource("1_def")
key = &"fall"
state_script = ExtResource("5_fall")

[sub_resource type="Resource" id="Resource_dash"]
script = ExtResource("1_def")
key = &"dash"
state_script = ExtResource("6_dash")

[sub_resource type="Resource" id="Resource_slide"]
script = ExtResource("1_def")
key = &"wall_slide"
state_script = ExtResource("7_slide")

[sub_resource type="Resource" id="Resource_attack"]
script = ExtResource("1_def")
key = &"attack"
state_script = ExtResource("8_attack")

[sub_resource type="Resource" id="Resource_hurt"]
script = ExtResource("1_def")
key = &"hurt"
state_script = ExtResource("9_hurt")

[sub_resource type="Resource" id="Resource_heal"]
script = ExtResource("1_def")
key = &"heal"
state_script = ExtResource("10_heal")

[sub_resource type="Resource" id="Resource_pogo"]
script = ExtResource("1_def")
key = &"pogo"
state_script = ExtResource("11_pogo")

[resource]
script = ExtResource("2_cfg")
initial_state = &"fall"
states = Array[ExtResource("1_def")]([
    SubResource("Resource_move"),
    SubResource("Resource_jump"),
    SubResource("Resource_fall"),
    SubResource("Resource_dash"),
    SubResource("Resource_slide"),
    SubResource("Resource_attack"),
    SubResource("Resource_hurt"),
    SubResource("Resource_heal"),
    SubResource("Resource_pogo")
])


=====================================
FILE: ./src/entities/player/data/upward_attack_shape.tres
=====================================
[gd_resource type="RectangleShape2D" load_steps=0 format=3 uid="uid://c0dt7jqwtnbr"]

[resource]
size = Vector2(60, 60)


=====================================
FILE: ./src/entities/player/data/player_combat_data.gd
=====================================
# src/entities/player/data/player_combat_data.gd
@tool
class_name PlayerCombatData
extends Resource

# --- Resources ---
var max_healing_charges: int = 1
var healing_charges: int = 0:
	set(value):
		healing_charges = clamp(value, 0, max_healing_charges)
var determination_counter: int = 0

# --- State ---
var hit_targets_this_swing: Dictionary = {}
var is_charging: bool = false
var is_pogo_attack: bool = false

# --- Timers ---
var attack_duration_timer: float = 0.0
var attack_cooldown_timer: float = 0.0
var charge_timer: float = 0.0
var pogo_fall_prevention_timer: float = 0.0


=====================================
FILE: ./src/entities/player/data/player_physics_data.gd
=====================================
# src/entities/player/data/player_physics_data.gd
@tool
class_name PlayerPhysicsData
extends Resource

# --- State ---
var facing_direction: int = 1
var air_jumps_left: int = 0
var last_wall_normal: Vector2 = Vector2.ZERO
var velocity: Vector2 = Vector2.ZERO # Cached velocity for some state calculations

# --- Flags ---
var can_dash: bool = true

# --- Timers ---
var coyote_timer: float = 0.0
var wall_coyote_timer: float = 0.0
var dash_duration_timer: float = 0.0
var dash_cooldown_timer: float = 0.0
var knockback_timer: float = 0.0
var jump_buffer_timer: float = 0.0 # Tracks recent jump inputs


=====================================
FILE: ./src/entities/player/data/forward_attack_shape.tres
=====================================
[gd_resource type="RectangleShape2D" load_steps=0 format=3 uid="uid://c1b2d3e4f5g6h"]

[resource]
size = Vector2(100, 80)


