╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ████████╗ ██████╗ ██████╗  ██████╗                                         ║
║   ╚══██╔══╝██╔═══██╗██╔══██╗██╔═══██╗                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ╚██████╔╝██████╔╝╚██████╔╝                                        ║
║      ╚═╝    ╚═════╝ ╚═════╝  ╚═════╝                                         ║
║                                                                              ║
║                  Immediate Work Items & Actionable Tasks                     ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 1: THE CORE SYSTEMS REFACTOR                      ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This phase is our highest priority. We will refactor the existing code to  ║
║   align with professional design principles. This is the hard, foundational ║
║   work that enables all future features to be built cleanly and efficiently. ║
║                                                                              ║
║   ■  1. Implement the Event Bus                                              ║
║      ░  WHY: This is the new central nervous system for the game. It will    ║
║      ░  decouple all our systems, from UI to gameplay to audio, making the   ║
║      ░  entire codebase more modular and easier to manage (Dependency Inversion).║
║      ░  HOW:                                                                 ║
║      ░    1. Create a new autoload singleton: `EventBus.gd`.                 ║
║      ░    2. Implement three core functions: `on(event, callback)`,          ║
║      ░       `off(event, callback)`, and `emit(event, payload)`.             ║
║      ░    3. Create `EventCatalog.gd` to store all event names as constants. ║
║      ░    4. Refactor existing direct signal connections (e.g., in `game_hud.gd`)║
║      ░       to use the Event Bus. The HUD will listen for global events like ║
║      ░       `EventCatalog.PLAYER_HEALTH_CHANGED` instead of connecting directly.║
║                                                                              ║
║   ■  2. Refactor Player to use the State Pattern                             ║
║      ░  WHY: `player.gd` is a large, monolithic script. This refactor will   ║
║      ░  decouple the logic for each state into its own class, making the     ║
║      ░  system cleaner and easier to extend (Open/Closed Principle).         ║
║      ░  HOW: Follow the detailed plan to create a `states` subdirectory for  ║
║      ░  the player, create a `PlayerState` base class, and migrate the logic ║
║      ░  for each state into its own file. `player.gd` will become a "Context"║
║      ░  that simply manages the current state object.                        ║
║                                                                              ║
║   ■  3. Implement the Centralized Sequencer                                  ║
║      ░  WHY: To eliminate scattered `Timer` nodes and `await` calls for      ║
║      ░  scripted events. This provides a clean, readable way to create       ║
║      ░  cinematic sequences like boss intros or multi-stage attacks.         ║
║      ░  HOW: Create a new autoload singleton: `Sequencer.gd`. Implement a    ║
║      ░  `run_sequence(steps: Array)` function that can process a list of     ║
║      ░  commands like `wait`, `emit` (on Event Bus), and `call` (a function).║
║                                                                              ║
║   ■  4. Refactor Base Boss to use the State Pattern                          ║
║      ░  WHY: To mirror the player's clean architecture, preparing the boss   ║
║      ░  for the advanced "kitchen sink" mechanics planned for a later phase. ║
║      ░  HOW: Apply the exact same State Pattern as used for the Player,      ║
║      ░  creating a `states` subdirectory and migrating state logic into      ║
║      ░  separate, focused class files.                                       ║
║                                                                              ║
║   ■  5. Refactor ArenaBuilder using Single Responsibility Principle (SRP)    ║
║      ░  WHY: `ArenaBuilder.gd` currently has too many jobs. Separating these ║
║      ░  roles will make the level generation pipeline more robust and easier ║
║      ░  to maintain.                                                         ║
║      ░  HOW: Split the current logic into three new classes:                 ║
║      ░    - `LevelParser.gd`: Reads data from layout/encounter files.        ║
║      ░    - `TerrainBuilder.gd`: Creates the static level geometry (tiles).  ║
║      ░    - `EncounterDirector.gd`: Spawns all dynamic entities (player, boss).║
║      ░  `ArenaBuilder.gd` will become a simple coordinator of these new classes.║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            PHASE 2: DATA-DRIVEN & VISUAL FOUNDATION                  ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   This phase separates hard-coded values from our logic and builds the key   ║
║   visual components needed to achieve our "Framer + Geometry Wars" aesthetic.║
║                                                                              ║
║   ■  1. Implement Data-Driven Configs (JSON)                                 ║
║      ░  WHY: To centralize all tuning and balancing numbers (damage, health, ║
║      ░  cooldowns) into external, human-readable files. This allows for rapid║
║      ░  iteration without changing any code.                                 ║
║      ░  HOW: Create a `Config.gd` singleton that loads `.json` files on start.║
║      ░  Move all combat-related values from `Constants.gd` into a new        ║
║      ░  `combat_config.json`. Refactor code to pull values from this config. ║
║                                                                              ║
║   ■  2. Implement the Global Palette System                                  ║
║      ░  WHY: To enforce a consistent, project-wide color scheme. This is a   ║
║      ░  critical prerequisite for the UI overhaul.                           ║
║      ░  HOW: Create a `Palette.gd` singleton. Define the 32-step grayscale   ║
║      ░  array and create semantic constant names (e.g., `COLOR_PLAYER`).     ║
║      ░  Replace all hard-coded colors with calls to this new Palette.        ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 3: GAMEPLAY & FEEL ENHANCEMENT                    ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   With a solid architecture, we can now focus on making the game feel amazing.║
║                                                                              ║
║   □  1. Refine Player Combat Mechanics ("Game Juice")                        ║
║      ░  □ Enhanced Melee Hitbox: Implement a two-part hitbox where the inner ║
║      ░    box deals 1.5x damage and the outer deals 1.0x damage.             ║
║      ░  □ Input Buffering: Add buffering for attack and dash inputs.         ║
║      ░  □ Pogo-Fall Prevention: Add a brief grace period after a pogo to     ║
║      ░    prevent accidental fast-falling.                                   ║
║                                                                              ║
║   □  2. Implement "Kitchen Sink" Base Boss Features                          ║
║      ░  □ Health Phases: Boss transitions to new states at health thresholds.║
║      ░  □ Armor/Weak Points: Implement an `is_armored` state.                ║
║      ░  □ Clear Attack Telegraphing: Create a dedicated `Telegraph` state.   ║
║                                                                              ║
║   □  3. Implement a Minion Enemy Type                                        ║
║      ░  Create a simple Turret enemy to test our data-driven spawning and    ║
║      ░  component-based architecture (e.g., by reusing the HealthComponent). ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██           PHASE 4: FUTURE EXPANSION & DEFERRED TASKS                 ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of lower-priority goals to be addressed after the core loop is solid.║
║                                                                              ║
║   □  UI Overhaul Part 1: The `StyledMenuItem`                                ║
║      ░  WHY: To create the cornerstone visual component for our new UI. We   ║
║      ░  will perfect this one piece before replacing the entire menu system. ║
║      ░  HOW: Create a new scene, `StyledMenuItem.tscn`, that extends `Control`.║
║      ░  It will use the `_draw()` function and shaders to render itself      ║
║      ░  procedurally with frosted glass, backlighting, and reactive effects, ║
║      ░  all driven by the `Palette` and `EventBus`.                          ║
║                                                                              ║
║   ░  Full UI System Replacement (using `StyledMenuItem`)                     ║
║   ░  Diegetic UI Implementation                                              ║
║   ░  Dynamic Music Layering System                                           ║
║   ░  Adaptive Boss AI Tactics Layer                                          ║
║   ░  Player Loadout System                                                   ║
║   ░  Special Game Modes (Boss Rush, Time Attack)                             ║
║   ░  Cleanup or remove `test_ui` scene and related dev assets.               ║
║   ░  Screen Shake (Explicitly deferred to avoid visual noise during debugging)║
║   ░  Dynamic Camera (Explicitly deferred per design decision)                ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝