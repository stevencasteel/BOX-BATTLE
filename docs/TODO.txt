╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ████████╗ ██████╗ ██████╗  ██████╗                                         ║
║   ╚══██╔══╝██╔═══██╗██╔══██╗██╔═══██╗                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ╚██████╔╝██████╔╝╚██████╔╝                                        ║
║      ╚═╝    ╚═════╝ ╚═════╝  ╚═════╝                                         ║
║                                                                              ║
║                    Strategic Development Plan & Actionable Tasks             ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 1: FORTIFICATION & PRODUCTION PIPELINES           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Build the safety net. Harden the project against regressions and     ║
║   streamline core workflows to enable rapid, confident development.          ║
║                                                                              ║
║   █ Architecture & Testing                                                   ║
║   ░ Implement the Automated Testing Framework (GUT) to safeguard all         ║
║   ░ future work. This is the highest priority architectural task.            ║
║   ░                                                                          ║
║   ░ □ Integrate the Godot Unit Test (GUT) framework into src/tests/.         ║
║   ░ □ Write initial unit tests for critical, non-visual components:          ║
║   ░   - HealthComponent: Damage application, invincibility, death signal.    ║
║   ░   - PlayerResourceComponent: Determination-to-charge conversion.         ║
║   ░   - ObjectPool: get_instance/return_instance lifecycle.                  ║
║   ░ □ Create a headless integration test to run an encounter for 600         ║
║   ░   frames and assert that no errors are thrown.                           ║
║   ░ □ Update the GitHub Actions CI workflow to run all tests on push.        ║
║                                                                              ║
║   █ Production & Tooling                                                     ║
║   ░ Establish professional-grade tooling for debugging and UI management.    ║
║   ░                                                                          ║
║   ░ □ Implement a Centralized Logging System (LogManager.gd autoload)        ║
║   ░   to replace all print() calls with structured, leveled logging.         ║
║   ░ □ Create a central main_theme.tres resource to unify all UI fonts,       ║
║   ░   colors, and styles, pulling values from Palette.gd.                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            PHASE 2: CONTENT EXPANSION & VISUAL IDENTITY              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Build out the core game experience and implement the signature       ║
║   "Aesthetic Maximalism" visual identity through shaders and feedback.       ║
║                                                                              ║
║   █ Gameplay & Design                                                        ║
║   ░ Transform the single encounter into a playable game loop.                ║
║   ░                                                                          ║
║   ░ □ Implement the Core Game Loop:                                          ║
║   ░   - Create WorldState.tres to track defeated bosses.                     ║
║   ░   - Create a SaveManager using ConfigFile to save/load progress.         ║
║   ░   - Build a functional "Stage Select" screen.                            ║
║   ░ □ Generalize the Boss Attack System to empower design:                   ║
║   ░   - Expand AttackPattern.gd with an AttackType enum and more data.       ║
║   ░   - Refactor StateBossAttack into a generic executor.                    ║
║                                                                              ║
║   █ Juice & Feedback (Game Feel) - CURRENT FOCUS                             ║
║   ░ The focus is now on tangible "game feel" to make interactions satisfying.║
║   ░                                                                          ║
║   ░ □ Implement Screen Shake via FXManager for player damage and boss attacks║
║   ░ □ Implement Hit-Stop via FXManager for close-range melee hits on boss.   ║
║   ░ □ Create and pool a basic "hit spark" particle effect via VFXManager.    ║
║   ░ □ Implement the Full Shader Strategy:                                    ║
║   ░   - Develop an "FX Cookbook" registry in FXManager.                      ║
║   ░   - Implement entity shaders (Hit-Flash, Dissolve).                      ║
║   ░   - Implement UI shaders (SDF Panels for menus).                         ║
║   ░   - Implement fullscreen shaders (Shockwave).                            ║
║                                                                              ║
║   █ Systems & Narrative                                                      ║
║   ░ Flesh out supporting systems required for a complete experience.         ║
║   ░                                                                          ║
║   ░ □ Implement the basic functionality for the DialogueManager and          ║
║   ░   DialogueBox to enable storytelling.                                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 3: POLISHING & PROFESSIONALIZATION                ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Add the features that elevate the project from a great prototype to  ║
║   a shippable, high-quality product, focusing on accessibility and depth.    ║
║                                                                              ║
║   █ Accessibility & Internationalization                                     ║
║   ░ Ensure the game is playable by the widest possible audience.             ║
║   ░                                                                          ║
║   ░ □ Abstract all user-facing text for localization using tr("KEY").        ║
║   ░ □ Implement Control Remapping in the Controls Screen.                    ║
║   ░ □ Implement Colorblind Modes via Palette texture swapping.               ║
║                                                                              ║
║   █ Advanced Mechanics & Game Feel                                           ║
║   ░ Add mechanical depth and a final layer of authored polish.               ║
║   ░                                                                          ║
║   ░ □ Develop a Stun/Poise System for the boss to reward aggression.         ║
║   ░ □ Refactor key moments (player attack, boss intros) to be driven by      ║
║   ░   AnimationPlayer for more authored, cinematic sequences.                ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                    FUTURE CONSIDERATIONS & DEFERRED TASKS            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of lower-priority goals for future consideration.                   ║
║                                                                              ║
║   ░ Fast-Fall: Holding 'Down' in the air increases gravity.                  ║
║   ░ Diegetic UI Implementation (UI integrated into the game world).          ║
║   ░ Advanced Boss AI (Adaptive tactics, environmental interaction).          ║
║   ░ Player Loadout System (Alternative weapons or abilities).                ║
║   ░ Special Game Modes (Boss Rush, Time Attack).                             ║
║   ░ Automated Component Dependency Injection (reduce entity setup boilerplate).║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝



Add dust on landing, walking, touching wall, and jumping from wall.




Older TODO need to investigate again.

# Phase 2 Audit & Elevation Plan

## Snapshot of what’s strong already

* **Centralized FX service**: `FXManager` already cleanly owns screenshake, hit-stop, VFX pooling, prewarm, and camera registration, which is a great separation of concerns for “juice” orchestration. You’re already calling it from gameplay (e.g., Player and Boss).  &#x20;
* **Composable entities**: Componentized player/boss with a state machine that’s DI-friendly via `setup(p_owner, p_dependencies)` and teardown hygiene. That’s very SOLID. &#x20;
* **Damage pipeline**: `HealthComponent` as the single source of truth for invincibility, knockback, and signals (`took_damage`, `died`) is a solid foundation to hook FX and gameplay.&#x20;
* **Events & identifiers**: A global EventBus and typed events are already in use (e.g., boss phase change, healing charges). This supports Dependency Inversion across systems. &#x20;

---

## 1) Juice & Feedback — Elevate the Shader Strategy (and unify FX)

### Key risks/gaps

* **Two managers present**: There’s a `vfx_manager.gd` and a production `FXManager`; only the latter is autoloaded. Remove/rename the legacy script to avoid drift. (Project docs explicitly list `FXManager` as an autoload.)&#x20;
* **Shader effects are not first-class**: VFX pooling exists, but shader FX are not yet modeled as reusable resources or scheduled/stacked like other FX.

### Elevated design (future-proof + SOLID)

**A. Promote shaders to first-class “FX” alongside particles/VFX**

* Introduce `ShaderEffect` (Resource) with:

  * `shader: Shader`
  * `params: Dictionary<String, Variant|Curve>` (supports static or animated values)
  * `duration: float`
  * `target_scope: enum { ENTITY, UI, FULLSCREEN }`
  * `priority: int` (for conflict resolution)
* Add `IFxEffect` interface semantics (or documented contract) so `FXManager` treats `VFXEffect`, `ScreenShakeEffect`, and `ShaderEffect` uniformly (Open/Closed). `FXManager` remains the single façade (DIP).

**B. Binding layer per scope**

* **EntityShaderBinding**: Attaches a temporary `ShaderMaterial` to a `CanvasItem`/`Sprite/Polygon2D/ColorRect`, pushes/restores original material safely, animates params via Tween. Handles **Hit-Flash** and **Dissolve** without leaking. (Entities already expose clear visuals: e.g., Player `ColorRect` at `$ColorRect` and Boss visual nodes.) &#x20;
* **UIShaderBinding**: Applies SDF panel shader to `Control` via theme or per-node `Material`. Encourages design tokens (see below).
* **FullscreenShaderBinding**: A dedicated `CanvasLayer` with a `ColorRect` + `ShaderMaterial` stack; `FXManager.trigger_fullscreen(shader_effect, world_pos?)` injects effects (Shockwave converts world→screen, queues by priority, cleans up).

**C. Effect graph (optional but future-proof)**

* If you foresee multiple overlapping fullscreen shaders (Shockwave + Chromatic Aberration + Bloom mask), model a lightweight “EffectGraph”:

  * A queue of `ShaderEffect` with priorities and **mutual exclusion rules** (e.g., only one exposure-changing effect active).
  * Blends via cumulative uniforms where safe (e.g., max ripple amplitude).
* Keep graph in `FXManager` to avoid coupling gameplay to render internals.

**D. Non-obvious wins**

* **Prewarming & shader cache**: Add `FXManager.prewarm_shaders([ShaderEffect])` mirroring your VFX prewarm to avoid hitching on first use. (You already prewarm pooled nodes; extend the idea to shader variants.)&#x20;
* **Performance guardrails**: `FXManager` tracks a per-frame cost budget; if frame time exceeds a threshold, degrade effect quality (shorter duration, fewer iterations) or skip low-priority FX.
* **Param curves**: Let `params` accept `Curve` resources so designers can sculpt intensity/time without code.
* **Conflict policies**: Screenshake already has clear calls; extend with **priority + override windows** (e.g., boss phase shake overrides minor hit shakes for 0.3s). You’re already calling shakes from Player/Boss. &#x20;
* **Testbed scene**: A `res://tools/fx_playground.tscn` with toggles for each effect, param sliders, and a performance readout to rapidly iterate without booting gameplay.

### Concrete Phase 2 tasks (refined)

* **Task 1 (FX Cookbook for Shaders)**

  * Implement `ShaderEffect.tres` assets and `FXManager.play_shader(effect, target, opts={})`.
  * Provide bindings for `ENTITY`, `UI`, `FULLSCREEN`.
  * Unit test: ensuring materials restore on teardown (esp. entity death and scene changes).
* **Task 2 (Entity Shaders)**

  * **Hit-Flash**: Use `HealthComponent.took_damage` to apply a 0.08–0.12s flash; you already emit `took_damage` with `DamageInfo`. Tie into it.&#x20;
  * **Dissolve**: Triggered in `die()` paths for Player/Boss/Minions; ensure it cannot conflict with Hit-Flash (priority rules).
* **Task 3 (UI SDF)**

  * Add `Theme` with **design tokens** (radius, border thickness, spacing scale, brand colors). Use one SDF shader to produce borders/fills/shadows across panels. Have a single “Aesthetic Maximalism” token sheet.
* **Task 4 (Fullscreen Shockwave)**

  * `FXManager.trigger_shockwave(world_pos)` on boss phase change (you already call hit-stop + shake there—perfect insertion point).&#x20;

**Acceptance checks**

* Damage → flash visible; phase change → shockwave + hit-stop + shake; material restoration verified when an entity queues free; worst-case overlapping FX maintain framerate and prioritize correctly.

---

## 2) Gameplay & Design — Core Loop & Save

### Gaps & design edges

* World/loop scaffolding is light; Stage Select and saves are not yet implemented.
* You already track boss health and emit phase/health events (great). Persisting which bosses are cleared will complete the loop.&#x20;

### Elevated design

**A. Versioned, multi-slot Save**

* `SaveManager` (autoload) manages **profile slots** (e.g., `Slot_1`, `Slot_2`, `Slot_3`).
* **Schema**:
  `WorldState { version:int, bosses:{<boss_id>: {defeated:bool, best_time:float, deaths:int}}, options_ref:<guid> }`
* **Atomic writes**: Save to `*.tmp`, then rename; keep a `.bak` of the last good file.
* **Migration**: On load, if `version < CURRENT`, run registered migrators.
* **Separation of concerns**: Keep **user options** (video, audio) separate from **progress**.

**B. Encounter Registry**

* A `EncounterRegistry.tres` listing available stages (id, name, scene path, thumbnail) so `StageSelect.tscn` can **data-drive** its UI, not hardcode. The registry decouples content shipping from UI logic.

**C. Stage Select screen**

* On `_ready()`, `SaveManager.load_active_slot()` and filter registry; enable/disable buttons with medallions/times.
* UX: show boss card, defeat state, PB time, and a flashy SDF-framed button (uses your new UI shader).

**D. Tests**

* Unit test `SaveManager`: write/read parity; corrupted file fallback; migration path N→N+1.

**Where to hook in current code**

* You already funnel boss phase/health through events; add a **win event** from boss `die()` to update world state. You call `die()` in boss on health zero; emit a `BOSS_DEFEATED` with an ID you store on the boss. &#x20;

---

## 3) Systems & Narrative — Dialogue

### Audit

* `DialogueManager.gd` exists (empty) and `DialogueBox` is in progress with typewriter intent. You have `DialogueData.tres` samples. Good direction, needs flow control & extensibility.&#x20;

### Elevated design

**A. Resource-driven dialogue graph (lightweight)**

* `DialogueData` becomes a mini graph: `lines: Array[DialogueLine]`, optional `branches: Array[DialogueBranch]` with simple conditions (e.g., `boss_defeated("turret")`).
* Conditions implemented via **Query Interface** on `DialogueManager`, not by reading save files directly (Dependency Inversion: manager depends on an abstract `IWorldQuery` you implement using `SaveManager`).

**B. Tags & signals**

* Support **inline tags** (e.g., `[shake]`, `[sfx:blipA]`, `[fx:shockwave]`) that emit signals instead of hard-coding presentation. `DialogueBox` listens and animates UI/SDF or triggers FX via `FXManager`. Separation of concerns: Manager = state, Box = view.

**C. Typewriter polish**

* Variable CPS, optional easing `Curve`, auto-skip on hold, and **smart pauses** on punctuation.
* Accessibility: instant reveal on input; queue mode for multi-line; per-character sfx with pitch variance.

**D. Future-proof**

* Localisation hooks: Each `DialogueLine` carries a key, not raw text (or supports both); swap table per language.

---

## Visual Identity — “Aesthetic Maximalism” without chaos

* **Design Tokens**: `ThemeTokens.tres` (spacing scale, corner radius, border widths, shadow ramp, gradients list, primary/secondary palettes). Your `Palette` constants can seed this.&#x20;
* **Single SDF panel shader** with params from tokens: corner radius, border width, inner glow, hatch pattern toggle, animation seed. Drive hover/press/alert states via uniform changes not separate shaders.
* **Motion language**: micro-tweens (100–180ms), overshoot 1.05, settle to 1.0 with spring; consistent across buttons/modals/stage cards.

---

## SOLID Scorecard (how the plan maps)

* **S**: Shader bindings split by scope; `DialogueManager` vs `DialogueBox`; `SaveManager` vs `EncounterRegistry`.
* **O**: `FXManager` extended to new effect types without modifying callers; `Dialogue` adds tags/branches without altering the runner API.
* **L**: `IFxEffect` contract keeps any new effect substitutable.
* **I**: UI doesn’t need screenshake APIs; it listens to FX tags only. Gameplay doesn’t know how shaders render.
* **D**: Gameplay posts events; `FXManager`, `SaveManager`, `DialogueManager` subscribe. You already use EventBus patterns across the code.&#x20;

---

## Prioritized Phase 2 Backlog (impact → effort)

1. **Shader FX foundation (ENTITY/UI/FULLSCREEN bindings)**

   * `ShaderEffect` resource + `FXManager.play_shader()`
   * Shockwave fullscreen; Hit-Flash; Dissolve; UI SDF panel v1
     *Accept*: Hit-Flash on damage; Dissolve on death; Shockwave on phase change; UI panels themed.

2. **Design Tokens + SDF Theme integration**

   * One shader, many looks; stage cards & menus adopt tokens
     *Accept*: All panels/badges use same shader and tokens; hover/press transitions consistent.

3. **Encounter Registry + Stage Select**

   * Data-driven, thumbnails, defeat status, time PB
     *Accept*: Disabling/enabling and badges reflect `WorldState`.

4. **SaveManager v1 (versioned, atomic, multi-slot)**

   * WorldState schema + migrator scaffolding
     *Accept*: Corrupt file test passes; slots switch; migration stub is callable.

5. **Dialogue v1 (runner + box + tags)**

   * Typewriter polish, skip logic, `[fx:*]` tag to `FXManager`
     *Accept*: Branch by a simple world query; tags fire without coupling.

6. **FX Testbed + Performance budget**

   * Prewarm path for shaders; frame budget degrade path
     *Accept*: Toggle 3+ overlapping effects with steady frametime; low-priority FX drop under load.

---

## Not-obvious pitfalls & mitigations

* **Material leaks**: Always store/restore the previous `material` on entities; guard against `queue_free()` mid-tween (cancel/cleanup). (Your components already have good teardown patterns—reuse those.)&#x20;
* **Manager drift**: Delete/rename `vfx_manager.gd` to avoid confusion with `FXManager`.&#x20;
* **Event storms**: Debounce rapid damage events to not stack infinite Hit-Flashes; let `FXManager` coalesce by priority.
* **Save corruption**: Atomic writes + `.bak` restore; unit tests for both.
* **Over-maximalism**: Let tokens define restraint: limit concurrent UI patterns; use one SDF shader with parameterized patterns.

---

## Tiny code-level contracts (just enough to align)

**ShaderEffect.tres (concept)**

```
class_name ShaderEffect
extends Resource
@export var shader: Shader
@export var duration: float = 0.15
@export var priority: int = 0
@export_enum("ENTITY","UI","FULLSCREEN") var scope := 0
@export var params := {} # { "intensity": 1.0, "tint": Color, "curve": Curve, ... }
```

**FXManager surface (additions)**

```
func play_shader(effect: ShaderEffect, target: Node, opts := {}): void
func trigger_shockwave(world_pos: Vector2): void # convenience wrapper
func prewarm_shaders(effects: Array[ShaderEffect]): void
```

(Backed by scope-specific bindings that do all attach/animate/restore work.)

---

## Where to hook today (concrete)

* **Player damage** → you already request shake/hit-stop and play a hit spark in `_on_health_component_took_damage`—just also call `FXManager.play_shader(hit_flash_effect, self.visual_sprite)`.&#x20;
* **Boss phase change** → extend the existing phase change branch to call `trigger_shockwave(boss.global_position)` alongside shake/hit-stop.&#x20;
* **Entity death** → in `HealthComponent.died` subscribers (Player/Boss/Minion), run `Dissolve` before `queue_free()`. You’re already centralizing death notification.&#x20;

---





Aug 19th TODO from GPT-5. Currently working on this stuff.


===============================================================================
| TODO.txt — FX & Shader Refactor (Mobile Renderer)                                |
| Project: Steven Casteel / Box Battle                                         |
| Purpose: Major overhaul to stabilize .gdshader usage on Mobile renderer, finish   |
|          FX + audio pipelines, and apply Godot 4.4 best practices across the repo |
===============================================================================

ASCII GUIDE: keep this file purely procedural. Use it as the single source of truth
for tasks, ordered PRs, acceptance criteria, and quick implementation notes.

--------------------------------------------------------------------------------
PHASE SUMMARY (HIGH-LEVEL)
--------------------------------------------------------------------------------
  [PHASE 1] Stabilize .gdshader usage on Mobile renderer
  [PHASE 2] Complete and formalize the data-driven FX system
  [PHASE 3] Performance-safe shader patterns & anti-patterns
  [PHASE 4] Audio architecture overhaul (mobile-ready)
  [PHASE 5] Scene & code organization, SOLID idioms (Godot 4.4)
  [PHASE 6] Concrete deliverables & ordered tasks (PR list)
  [PHASE 7] Guardrails, linting, CI checks, docs, QA

--------------------------------------------------------------------------------
PHASE 1 — STABILIZE .GDSHADER (MOBILE RENDERER)
--------------------------------------------------------------------------------
  - Task 1.1: File & Material basics
    * Ensure every runtime FX shader starts with: "shader_type canvas_item;"
    * Convert VisualShader FX used at runtime into text `.gdshader` files.
    * ALWAYS apply ShaderMaterial instances to the node that is actually drawing.
    * Rule: duplicate materials when changing per-node parameters. Never mutably edit
      a shared material at runtime.

  - Task 1.2: Color-space & texture hints
    * Enforce `: source_color` on any albedo/palette sampler declarations.
    * Add a lint rule to scan `.gdshader` files for `sampler2D .*: source_color` hints.

  - Task 1.3: Shader Globals
    * Add global shader uniforms in Project Settings as the canonical place for
      shared values (e.g., fx_global_time, vignette_intensity, pal_index).
    * Add a `ShaderGlobalsOverride` node pattern for level-specific overrides.

  - Task 1.4: Mobile constraints baked into shader style
    * Avoid heavy branching/loops and minimize texture lookups.
    * Pack maps into channels wherever possible (RGB packing).
    * Prefer vertex-computed offsets for distortion effects when possible.

  - Task 1.5: Modular shader includes
    * Create `res://shaders/includes/` and add small, composable `.gdshaderinc`
      files: common_math, color, noise, fx_blend.

  - Task 1.6: Pre-warm materials
    * Add a warm-up routine that compiles important shaders early (staggered
      across frames to avoid hitching on startup).

  - Task 1.7: Renderer verification
    * Confirm `Rendering -> Renderer = Mobile` in Project Settings; document
      behavior and planned fallbacks for older/compat mode.

--------------------------------------------------------------------------------
PHASE 2 — DATA-DRIVEN FX (FINISH THE SYSTEM)
--------------------------------------------------------------------------------
  - Core responsibilities (separate concerns):
    1) Effect Definition (resource): ShaderEffect.gd / VFXEffect.gd
    2) Binding (helpers): EntityShaderBinding.gd (bind/unbind only)
    3) Orchestration (singleton): FXManager.gd (duplicate/apply/drive/teardown)

  - Task 2.1: Standard parameter contract (required across shaders)
    * Per-node shaders must declare:
        uniform float fx_progress;       // 0 -> 1 lifetime driver
        uniform float fx_intensity;      // artist control
        global uniform float fx_global_time; // optional
    * Fullscreen shaders must declare:
        uniform sampler2D SCREEN_TEXTURE; // when used as blit
        uniform vec2 viewport_size;

  - Task 2.2: Effect Resource fields
    * material: ShaderMaterial (reference)
    * duration: float
    * fullscreen: bool
    * default_params: Dictionary
    * sound: AudioStream | AudioStreamRandomizer (optional)
    * tags: Array[String]

  - Task 2.3: FXManager responsibilities
    * Listen to EventBus (damage, heal, parry, low_hp, phase_change) and
      map events -> ShaderEffect resources.
    * Duplicate material instances when applying to nodes.
    * Drive `fx_progress` via Tween or in `_process` (consistent timing).
    * Return materials/nodes to ObjectPool on completion.
    * Provide a warm-up compile pass for top N materials.

  - Task 2.4: Binding behaviour (EntityShaderBinding)
    * Only: bind/unbind/apply parameter dictionary to a given CanvasItem.
    * Do not handle timers, tweens, or lifecycle — orchestration only.

  - Task 2.5: Object pooling
    * Use existing ObjectPool autoload to recycle ShaderMaterial instances,
      GPUParticles2D nodes, ColorRect post layers, and Audio player nodes.

  - Example flows (implementation notes)
    * Hit Flash (per-node): duplicate material -> set fx_progress=0 -> animate -> on
      complete restore previous material.
    * Phase Pulse (fullscreen): enable post layer (ColorRect), animate fx_progress,
      disable layer when done.

--------------------------------------------------------------------------------
PHASE 3 — SHADER PATTERNS & ANTI-PATTERNS
--------------------------------------------------------------------------------
  - Color textures = sRGB. Require `: source_color` on declarations.
  - Default to mediump/half precision mental model on mobile; avoid heavy
    precision-dependent effects.
  - Combine multiple maps into channels to minimize samplers.
  - Reuse shaders and materials; only duplicate when parameters change.
  - Minimize dynamic indexing and branching in fragment shaders.

--------------------------------------------------------------------------------
PHASE 4 — AUDIO PIPELINE (MOBILE READY)
--------------------------------------------------------------------------------
  - Bus layout:
      Master
        ├─ SFX  (short, non-streamed, WAV or small OGG)  // cap polyphony
        ├─ UI   (one-shots, non-positional)
        └─ Music (streaming OGG)  // crossfade via AudioManager
    * Put a Master limiter; gentle compressor on Music for ducking.

  - Import rules:
    * SFX < ~1s -> WAV (decode cost but faster playback); otherwise OGG if size
      is critical. Music/ambience -> OGG streaming.

  - AudioManager features:
    * Pools of AudioStreamPlayer2D (positional SFX) and AudioStreamPlayer
      (non-positional UI/music).
    * `play_sfx(tag, pos)`, `play_ui(tag)`, `play_music(track, crossfade_sec=1.5)`
    * Voice caps per category; implement quietest/oldest stealing.
    * Integrate AudioStreamRandomizer resources for natural variation.

--------------------------------------------------------------------------------
PHASE 5 — SCENE & CODE ORGANIZATION (SOLID + GODOT 4.4 IDIOMS)
--------------------------------------------------------------------------------
  - Autoloads: keep them thin and focused — do not put gameplay state in singletons.
    Examples: FXManager, AudioManager, EventBus, ObjectPool, Router, GlobalState.

  - Component-first nodes: Health, Damageable, VFXAnchor. Use Groups for discovery.

  - Resource-driven definitions: Effect resources, audio sets, curves should be
    .tres resources referenced by scenes and code (no hardcoded paths in scripts).

  - Asset graph discipline: shaders in `res://shaders/`, materials in
    `res://materials/`, effects in `res://data/effects/`, audio in `res://audio/`.

  - Editor-safety: do not rely on editor-only signals for runtime logic.

--------------------------------------------------------------------------------
PHASE 6 — CONCRETE DELIVERABLES & PR ORDER
--------------------------------------------------------------------------------
  PR 01 — shader-foundation
    * Add `res://shaders/includes/` files.
    * Convert critical VisualShaders to `.gdshader` text variants.
    * Add shader parameter contract enforcement linter (script).

  PR 02 — fx-manager-completion
    * Finalize FXManager orchestration (duplicate/apply/drive/teardown).
    * Implement warm-up pass for top materials.
    * Hook FXManager into EventBus mapping table (event -> effect resource).

  PR 03 — audio-bus-and-pool
    * Implement bus layout (Master/SFX/UI/Music), add limiter.
    * Add Audio import presets and AudioManager pooling + voice caps.

  PR 04 — resources-and-samples
    * Add `ShaderEffect` resources for hit-flash, dissolve, palette-swap,
      fullscreen pulse. Include small sample scenes to preview each.

  PR 05 — docs-and-tests
    * Add "How to add a new effect in 5 minutes" doc, shader lint rule,
      CI hooks for missing resource checks, and mobile QA checklist.

  PR 06 — profiling-and-fixes
    * Device profiling harness, baseline captures, and targeted shader fixes.

  Note: Execute PRs in order. Break each PR into bite-sized commits with clear
  atomic messages (e.g., "Add shader include: common_math.gdshaderinc").

--------------------------------------------------------------------------------
PHASE 7 — GUARDRAILS, LINTING, QA
--------------------------------------------------------------------------------
  - Add a shader lint script (CI-friendly) that validates:
    * presence of `shader_type canvas_item` (for FX shaders)
    * required uniforms (`fx_progress`, `fx_intensity`) for effect shaders
    * `: source_color` on color sampler declarations
  - Disk-check CI: fail if a scene references a missing resource path.
  - Enforce: "no set_shader_parameter on shared materials" rule in reviews.
  - Add a mobile QA checklist: test on at least two device tiers, collect
    profile captures for before/after (frame time, active FX count, shader
    compile stalls).

--------------------------------------------------------------------------------
IMPLEMENTATION NOTES & QUICK LOOKUPS
--------------------------------------------------------------------------------
  - Shader apply pattern (pseudocode):

    var inst = effect.material.duplicate()
    for key,val in effect.default_params:
        inst.set_shader_parameter(key, val)
    target.material = inst
    FXManager.drive_progress(inst, effect.duration)
    on_complete: restore previous material or return inst to pool

  - Parameter contract reminder:
      uniform float fx_progress; // 0..1
      uniform float fx_intensity;
      global uniform float fx_global_time;

  - Shader include files to create:
      res://shaders/includes/common_math.gdshaderinc
      res://shaders/includes/color.gdshaderinc
      res://shaders/includes/noise.gdshaderinc
      res://shaders/includes/fx_blend.gdshaderinc

  - Audio tips:
      Master at -6dB headroom; SFX ~-6dB; Music ~-10dB to start. Limiters as safety.
      Pool small AudioStreamPlayers and cap voices per bus.

--------------------------------------------------------------------------------
ACCEPTANCE CRITERIA (for the whole refactor)
--------------------------------------------------------------------------------
  - .gdshader-based FX behave identically (visual parity within +/- subjective
    tolerance) on Mobile renderer and Desktop (compat mode optional fallback).
  - No startup or runtime shader compile hitching greater than a single frame
    after warm-up pass runs.
  - CI enforces shader param contract and missing resource checks.
  - Audio bus + pooling in place; voice caps prevent crashes/overload on device.
  - Designers can create a new ShaderEffect resource, drop it into an effect map,
    and see the result in the sample preview scene within ~5 minutes.

--------------------------------------------------------------------------------
HAND-OFF CHECKLIST FOR THE IMPLEMENTER (Gemini AI)
--------------------------------------------------------------------------------
  1) Implement PR 01 (shader-foundation)
  2) Implement PR 02 (fx-manager-completion)
  3) Implement PR 03 (audio-bus-and-pool)
  4) Create sample resources & scenes (PR 04)
  5) Add docs, lints, and CI hooks (PR 05)
  6) Run device profiling, fix hotspots (PR 06)

--------------------------------------------------------------------------------
NOT-OBVIOUS TIPS & GOTCHAS (from transcripts + repo audit)
--------------------------------------------------------------------------------
  - Always duplicate ShaderMaterials before mutation — this prevents hard-to-see
    issues where multiple nodes share a reference and unexpectedly change.
  - Use `: source_color` texture hints to avoid gamma/space mismatch; these are
    commonly missed when porting from desktop to mobile.
  - Warm compiles: compile-heavy shaders early and stagger the warm-up across
    frames rather than trying to do everything on frame 1.
  - Keep the FXManager as the single place that mutates ShaderMaterial instances.
  - Don’t rely on editor-only events like `Resource.changed` for runtime flows.

--------------------------------------------------------------------------------
QUICK-START: "Do this now" (first 48 hours)
--------------------------------------------------------------------------------
  1) Create `res://shaders/includes/` and add `common_math.gdshaderinc`.
  2) Add shader lint script (scan repository for `.gdshader` files).
  3) Convert 1–2 critical VisualShaders to text shaders (hit-flash + pulse).
  4) Implement material duplicate + apply pattern in FXManager (minimal).
  5) Add Master/SFX/UI/Music buses and a Master limiter in the audio panel.

--------------------------------------------------------------------------------
REVISION HISTORY
--------------------------------------------------------------------------------
  - v1.0 — Initial overhaul TODO — contains full-phase breakdown, PR order,
           acceptance criteria, and quick-start.

===============================================================================
END OF TODO.txt
===============================================================================

