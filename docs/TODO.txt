╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║   ████████╗ ██████╗ ██████╗  ██████╗                                         ║
║   ╚══██╔══╝██╔═══██╗██╔══██╗██╔═══██╗                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ██║   ██║██║  ██║██║   ██║                                        ║
║      ██║   ╚██████╔╝██████╔╝╚██████╔╝                                        ║
║      ╚═╝    ╚═════╝ ╚═════╝  ╚═════╝                                         ║
║                                                                              ║
║                    Strategic Development Plan & Actionable Tasks             ║
║                                                                              ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 1: FORTIFICATION & PRODUCTION PIPELINES           ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Build the safety net. Harden the project against regressions and     ║
║   streamline core workflows to enable rapid, confident development.          ║
║                                                                              ║
║   █ Architecture & Testing                                                   ║
║   ░ Implement the Automated Testing Framework (GUT) to safeguard all         ║
║   ░ future work. This is the highest priority architectural task.            ║
║   ░                                                                          ║
║   ░ □ Integrate the Godot Unit Test (GUT) framework into src/tests/.         ║
║   ░ □ Write initial unit tests for critical, non-visual components:          ║
║   ░   - HealthComponent: Damage application, invincibility, death signal.    ║
║   ░   - PlayerResourceComponent: Determination-to-charge conversion.         ║
║   ░   - ObjectPool: get_instance/return_instance lifecycle.                  ║
║   ░ □ Create a headless integration test to run an encounter for 600         ║
║   ░   frames and assert that no errors are thrown.                           ║
║   ░ □ Update the GitHub Actions CI workflow to run all tests on push.        ║
║                                                                              ║
║   █ Production & Tooling                                                     ║
║   ░ Establish professional-grade tooling for debugging and UI management.    ║
║   ░                                                                          ║
║   ░ □ Implement a Centralized Logging System (LogManager.gd autoload)        ║
║   ░   to replace all print() calls with structured, leveled logging.         ║
║   ░ □ Create a central main_theme.tres resource to unify all UI fonts,       ║
║   ░   colors, and styles, pulling values from Palette.gd.                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██            PHASE 2: CONTENT EXPANSION & VISUAL IDENTITY              ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Build out the core game experience and implement the signature       ║
║   "Aesthetic Maximalism" visual identity through shaders and feedback.       ║
║                                                                              ║
║   █ Gameplay & Design                                                        ║
║   ░ Transform the single encounter into a playable game loop.                ║
║   ░                                                                          ║
║   ░ □ Implement the Core Game Loop:                                          ║
║   ░   - Create WorldState.tres to track defeated bosses.                     ║
║   ░   - Create a SaveManager using ConfigFile to save/load progress.         ║
║   ░   - Build a functional "Stage Select" screen.                            ║
║   ░ □ Generalize the Boss Attack System to empower design:                   ║
║   ░   - Expand AttackPattern.gd with an AttackType enum and more data.       ║
║   ░   - Refactor StateBossAttack into a generic executor.                    ║
║                                                                              ║
║   █ Juice & Feedback (Game Feel) - CURRENT FOCUS                             ║
║   ░ The focus is now on tangible "game feel" to make interactions satisfying.║
║   ░                                                                          ║
║   ░ □ Implement Screen Shake via FXManager for player damage and boss attacks║
║   ░ □ Implement Hit-Stop via FXManager for close-range melee hits on boss.   ║
║   ░ □ Create and pool a basic "hit spark" particle effect via VFXManager.    ║
║   ░ □ Implement the Full Shader Strategy:                                    ║
║   ░   - Develop an "FX Cookbook" registry in FXManager.                      ║
║   ░   - Implement entity shaders (Hit-Flash, Dissolve).                      ║
║   ░   - Implement fullscreen shaders (Shockwave).                            ║
║                                                                              ║
║   █ Systems & Narrative                                                      ║
║   ░ Flesh out supporting systems required for a complete experience.         ║
║   ░                                                                          ║
║   ░ □ Implement the basic functionality for the DialogueManager and          ║
║   ░   DialogueBox to enable storytelling.                                    ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██              PHASE 3: POLISHING & PROFESSIONALIZATION                ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   Goal: Add the features that elevate the project from a great prototype to  ║
║   a shippable, high-quality product, focusing on accessibility and depth.    ║
║                                                                              ║
║   █ Accessibility & Internationalization                                     ║
║   ░ Ensure the game is playable by the widest possible audience.             ║
║   ░                                                                          ║
║   ░ □ Abstract all user-facing text for localization using tr("KEY").        ║
║   ░ □ Implement Control Remapping in the Controls Screen.                    ║
║   ░ □ Implement Colorblind Modes via Palette texture swapping.               ║
║                                                                              ║
║   █ Advanced Mechanics & Game Feel                                           ║
║   ░ Add mechanical depth and a final layer of authored polish.               ║
║   ░                                                                          ║
║   ░ □ Develop a Stun/Poise System for the boss to reward aggression.         ║
║   ░ □ Refactor key moments (player attack, boss intros) to be driven by      ║
║   ░   AnimationPlayer for more authored, cinematic sequences.                ║
║                                                                              ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║  ██                    FUTURE CONSIDERATIONS & DEFERRED TASKS            ██  ║
║  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║
║                                                                              ║
║   A list of lower-priority goals for future consideration.                   ║
║                                                                              ║
║   ░ Fast-Fall: Holding 'Down' in the air increases gravity.                  ║
║   ░ Diegetic UI Implementation (UI integrated into the game world).          ║
║   ░ Advanced Boss AI (Adaptive tactics, environmental interaction).          ║
║   ░ Player Loadout System (Alternative weapons or abilities).                ║
║   ░ Special Game Modes (Boss Rush, Time Attack).                             ║
║   ░ Automated Component Dependency Injection (reduce entity setup boilerplate).║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝



Add dust on landing, walking, touching wall, and jumping from wall.






Nice — I pulled the dump apart and distilled **only** the concrete ideas that still need implementation. I removed duplication and grouped related items so you can pick work by area. No fluff — just actionable items with a one-line acceptance check for each.

# High-level implementation checklist (grouped & prioritized)

## Shader foundation & mobile renderer (PHASE 1)

1. Create `res://shaders/includes/` and add modular `.gdshaderinc` files (common\_math, color, noise, fx\_blend).
   *Accept:* includes exist and are used by at least two shaders.

2. Convert critical VisualShaders to text `.gdshader` files (hit-flash, pulse).
   *Accept:* two converted shaders visually match originals.

3. Enforce shader header + sampler hints: ensure `shader_type canvas_item;` and `: source_color` where needed — add lint check.
   *Accept:* lint script flags missing headers/hints and passes repo.

4. Implement shader global uniforms pattern + `ShaderGlobalsOverride` node for level overrides.
   *Accept:* fx\_global\_time and one override parameter can be set per-level.

5. Add a shader prewarm/stagger routine that compiles important shaders across frames.
   *Accept:* targeted shaders are compiled before first in-game use without a single-frame hitch.

6. Add mobile-specific shader rules: pack maps into channels, avoid loops/branching; document required precision model.
   *Accept:* short doc added and one shader refactored to channel-packed maps.

## Data-driven FX system (PHASE 2)

7. Create `ShaderEffect` Resource (fields: shader/material, duration, scope enum, default\_params, priority, tags, optional sound).
   *Accept:* Resource type exists and can be authored in editor.

8. Implement `FXManager.play_shader(effect: ShaderEffect, target, opts := {})` + `prewarm_shaders(effects:Array)`.
   *Accept:* API callable and used by a sample effect.

9. Implement scope-specific bindings: `EntityShaderBinding`, `UIShaderBinding`, `FullscreenShaderBinding` (bind/restore without leaking).
   *Accept:* Binding duplicates/restores material reliably under node free/scene change.

10. Model shader effects the same as other FX (particles/screen shakes) — unify through an IFxEffect contract or documented contract.
    *Accept:* FXManager treats ShaderEffect and VFXEffect the same in mapping.

11. Implement object pooling for ShaderMaterial instances used by FX (use ObjectPool autoload).
    *Accept:* pool returns recycled instances and reduces repeated allocations.

12. Add `FXManager` budget tracking + basic backpressure / degrade policy (skip low-priority FX when over budget).
    *Accept:* when budget exceeded, low-priority effects are skipped and reported by a debug overlay.

13. Add an FX testbed scene `tools/fx_playground.tscn` to preview/iterate effects and show performance readout.
    *Accept:* playground shows effect toggles, param sliders, and concurrent-FX count.

14. Hook common events -> effects mapping: EventBus → FXManager mapping table (damage → hit-flash, phase change → shockwave).
    *Accept:* mappings are data-driven and can be updated without code changes.

## Shader patterns, anti-patterns & lints (PHASE 3)

15. Add lint/check script that validates effect shaders declare required uniforms (`fx_progress`, `fx_intensity`) and `shader_type canvas_item`.
    *Accept:* CI lint runs and enforces rules.

16. Standardize shader parameter contract and document it (fx\_progress, fx\_intensity, optional fx\_global\_time, SCREEN\_TEXTURE for fullscreen).
    *Accept:* doc + a simple example shader that follows contract.

17. Implement `material = material.duplicate()` pattern enforcement (lint or QA warning) to avoid shared-material mutation.
    *Accept:* at least one lint rule or runtime assert exists.

## Audio pipeline (PHASE 4)

18. Implement Audio bus layout (Master / SFX / UI / Music) with a Master limiter/compressor preset.
    *Accept:* buses exist and Master limiter is routable.

19. Implement `AudioManager` with pools of `AudioStreamPlayer2D` and non-positional players, voice caps and stealing logic, and APIs `play_sfx(tag, pos)`, `play_ui(tag)`, `play_music(track, crossfade_sec)`.
    *Accept:* SFX pool plays positional sounds and respects voice cap.

20. Add import presets & AudioStreamRandomizer support for natural SFX variation.
    *Accept:* example SFX uses AudioStreamRandomizer and plays randomized variations.

## Scene & code organization (PHASE 5)

21. Remove/rename legacy `vfx_manager.gd` to avoid confusion with `FXManager` (or deprecate it).
    *Accept:* no duplicate-named manager in autoloads.

22. Enforce directory conventions: shaders/, materials/, data/effects/, audio/. Move/organize resources accordingly.
    *Accept:* at least one resource moved and scenes updated.

23. Expand `setup(owner, dependencies)` DI pattern across autoload-using components; add façade interfaces (e.g., `IEventBus`) with default autoload provider.
    *Accept:* two components refactored to accept injected providers and tests use fakes.

## Save, Stage Select & Encounter Registry (GAMEPLAY)

24. Implement `SaveManager` with multi-slot, versioned schema, atomic writes (`*.tmp` -> rename) and `.bak` fallback + migrator hook.
    *Accept:* save/load works with slot switching; corruption fallback works in test.

25. Implement `EncounterRegistry.tres` (id, scene path, thumbnail, meta) and data-driven StageSelect that reads it.
    *Accept:* StageSelect is data-driven and reflects registry status.

26. Emit `BOSS_DEFEATED` event and write boss state to SaveManager when boss dies.
    *Accept:* defeating a boss updates save state and StageSelect reflects it.

## Dialogue & Narrative (SYSTEMS)

27. Harden `DialogueManager` into a resource-driven runner: `DialogueData` as a small graph with `DialogueLine`s and optional `DialogueBranch` conditions.
    *Accept:* manager can run a `DialogueData` asset and follow linear/branching flows.

28. Implement dialogue inline tags (`[fx:shockwave]`, `[sfx:blip]`, `[shake]`) and wiring so `DialogueBox` emits signals that `FXManager`/AudioManager can bind to.
    *Accept:* tags trigger effects/sfx when a line plays.

29. Add `IWorldQuery` abstraction used by Dialogue for conditions (backed by SaveManager).
    *Accept:* branch conditions evaluated via injected query provider.

30. Typewriter polish: variable CPS, curve-driven reveal, instant reveal on input, and per-character sfx.
    *Accept:* user input reveals text and per-character sfx plays.

## Tests, CI & QA (PHASE 7)

31. Integrate GUT tests for: material-restore on FX teardown; SaveManager write/read and migration; EventBus fakes for unit tests.
    *Accept:* GUT tests run in CI (headless where possible) and pass.

32. Add a CI job to run shader lint and missing-resource checks (disk-check).
    *Accept:* CI fails when shader contract/lint fails or scene references missing resource.

33. Add performance/device QA harness for shader profiling (capture baseline), and an acceptance test that prewarms shaders and confirms no big compile spike.
    *Accept:* test produces a perf report and prewarm reduces first-use hitch.

## Small / developer ergonomics items

34. Add `FXManager.get_budget_status()` and a debug overlay that shows concurrent FX, queued tweens, frame delta.
    *Accept:* overlay toggles and shows meaningful numbers.

35. Add `EventBus.bind_weak(node, event, callable)` helper (auto-unsubscribe on node free).
    *Accept:* helper exists and prevents dangling listeners.

36. Add `fx_playground.tscn` automation to CI (smoke-run) to visually sanity-check effects (non-blocking).
    *Accept:* test runs the playground scene in headless/smoke mode without errors.

37. Add a short "How to add a ShaderEffect" cookbook doc and a one-page mobile-shader checklist in repo.
    *Accept:* doc present and referenced from README.

## PR / delivery plan (top practical order)

* PR A: shader-foundation (includes/, convert 1–2 shaders, shader lint). (items 1–3, 15–16)
* PR B: FXManager + ShaderEffect + bindings + prewarm + testbed. (items 7–14, 5, 34)
* PR C: AudioManager + bus + pools + presets. (items 18–20)
* PR D: SaveManager + EncounterRegistry + StageSelect. (items 24–26)
* PR E: DialogueManager runner + tags + world-query contract. (items 27–30)
* PR F: Tests & CI: GUT integration, shader lint in CI, performance harness. (items 31–33, 36)
* PR G: Cleanup & docs: rename legacy vfx\_manager, move folders, add cookbook. (items 21–23, 37)

---





ChatGPT-5:
Nice — I read through the repo snapshot you uploaded and did targeted web research on Godot best practices so my recommendations are both grounded in your code and current engine guidance. Below is an audit focused on not-obvious problems I found, followed by concrete, professional evolutions (prioritized) you can apply immediately.

Quick summary (one-paragraph)

Your codebase already follows many strong patterns: componentized entities, Resource-driven tuning, typed event payloads, and an intentional effort to move away from hidden global dependencies (you’ve added setup() patterns). That puts you several steps ahead of most hobby projects. The things that remain risky are subtle: shared-material mutation, event storms / implicit global coupling via autoloads, shader compile stutters on mobile, and some testability friction that comes from how singletons are used. I’ll show why those are risky, point to exact files in your tree, and propose professional, low-friction patterns to evolve each area.   

Not-obvious findings (with evidence)

Shared ShaderMaterial mutation risk (visual/material leaks).

You already have code and docs calling out this problem (explicit “duplicate materials when changing per-node parameters. Never mutably edit a shared material at runtime” and the FXComponent behavior around restoring materials). That indicates you've hit this in practice. Mutating a shared ShaderMaterial at runtime causes unexpected visual changes across multiple instances and is a common source of “why did this other entity change?” bugs.  

EventBus/autoload convenience → hidden dependency/test friction.

You use many autoloads (EventBus, FXManager, ObjectPool, etc.) listed in project.godot. Autoloads are fine in Godot, but they hide dependencies and make unit tests harder unless every consumer accepts injected overrides. Your repo has partial moves to setup() for explicit dependencies (good!), but some code still emits/consumes globally which risks tight coupling at scale.  

Event storm / FX stacking edge-cases.

The EventBus emits directly and prunes dead listeners, but high-frequency events (damage ticks, rapid collisions) need coalescing/debouncing at the manager-level to avoid flooding the FX pipeline (and wasting shader/CPU/Tween budgets). Your docs mention “coalesce by priority” but I don’t see a dedicated debouncing layer yet.  

Shader compile / runtime hitch risks on mobile.

You’ve implemented a dissolve shader and an FX prewarm plan in the TODOs (good), but Godot shader pipeline compilation can hitch at first run on device if not prewarmed/staggered — especially on mobile GPUs. There are engine docs and community posts that recommend prewarming/compiling shaders ahead of first display. ; see Godot docs on shader pipeline compilation. (Godot Documentation)

Test/CI gaps vs. architecture changes.

You have GUT present (addon code and test scaffolding) and clear TODOs to fully integrate CI and headless runs. That’s the right move; missing items are: standardized test doubles for autoloads, headless integration scenarios, and CI hooks that run deterministic smoke tests. 

Concrete next-level evolutions (professional patterns)

I prioritized high-impact / low-risk changes first.

1) Make FX/Shader usage robust and predictable (High priority)

API: Add FXManager.play_shader(effect: ShaderEffect, target: Node, opts := {}) and FXManager.prewarm_shaders(effects: Array[ShaderEffect]). (You already proposed these — implement them.) This centralizes lifecycle, duplication, and fallback rules. 

Material handling rule (enforced in FXComponent): Always call material = material.duplicate() (or ShaderMaterial.new() + set shader/resource parameters) before changing uniforms or starting a tween; restore or free it on finish. Add assert/lint to detect writes to .material on shared resource. (Your TODO explicitly mentions this pattern; make it code-enforced.) 

Prewarm pipeline: On game start, call FXManager.prewarm_shaders() that sets each important material on a hidden canvas node for 1 frame, then removes it — stagger across frames to avoid a single hitch. This follows Godot guidance for pipeline precompilation. (Godot Documentation)

2) Harden event / FX budget (High priority)

Coalescing layer: Add an EventCoalescer inside FXManager (or as a small middleware autoload) that:

collapses repeated hit_flash events from same entity within X ms,

applies priority (UI effects > boss phase > small hits) and drops low priority when budget reached,

exposes simple metrics (current concurrent FX).

This pattern prevents FX over-saturation and is often used in commercial games. (You already flagged it; implement it now.) 

Backpressure policy: When frame time goes above threshold, pause low-priority FX for N frames rather than queueing unlimited tweens.

3) Make autoload usage explicit and testable (Medium priority)

Prefer injection at construction: Continue the setup(owner, dependencies) pattern and expand it: where autoloads are used in gameplay-critical components, pass an object implementing a small interface rather than calling the global directly. You already use this pattern in InputComponent.setup and BaseStateMachine.setup. Enforce by linting for EventBus. usages in non-orchestrator components.  

Autoload façade + replaceable provider: Keep autoloads, but wrap them behind a small façade interface (e.g., IEventBus), then have the autoload register itself as the default provider. Tests can then inject a lightweight fake. This gives engine-idiomatic singletons with testable substitution — it’s the simplest practical inversion-of-control for Godot. Web docs discuss autoload pros/cons; this is the standard compromise. (Godot Documentation, Game Development Stack Exchange)

4) Strengthen the EventBus and typed events (Medium)

Typed events everywhere: You’ve made typed event resources (e.g., PlayerHealthChangedEvent) — expand this to critical event flows and remove ambiguous dict payloads. Typed resources improve discoverability and auto-complete. 

Auto-unsubscribe helpers: Provide a helper that binds a listener and auto-unsubscribes on node-free to avoid leaks — you already partially prune dead owners; add an ergonomic EventBus.bind_weak(node, event, callable) helper to reduce user errors. 

5) CI + testing hygiene (Medium)

GUT + headless CI: Finalize headless integration test that instantiates ArenaBuilder and runs a short simulated encounter for X frames and asserts “no error logs.” Add GUT to GitHub Actions and run in the matrix for target platforms you support (headless Linux for logic, device/Android smoke for shaders if possible). The GUT repo is your anchor and has patterns for doubles & spies. (GitHub) 

Autoload fakes: Add a tests/fakes/ folder with simple fakes for EventBus, ObjectPool, FXManager — inject via setup() into components when tests run. This pattern will let you get true unit tests (fast) and keep a small number of integration tests that exercise autoloads.

6) Shader & mobile: anti-patterns to avoid (Quick checklist)

Avoid complex loops and per-pixel heavy branches on mobile; pack maps into channels; avoid many texture lookups per fragment. You already have TODOs for channel packing and modular includes — formalize these as a shaders/includes/ library.  (Godot Documentation)

Small/“not obvious” code-level suggestions you can add in 1–2 commits

Lint rule that flags .material writes to Node unless the write uses .duplicate() first. (Prevents accidental shared-material mutation.)

Add FXManager.get_budget_status() (returns current concurrent shader count, queued tweens, frame delta) and a debug overlay showing it.

Central LogManager that replaces free print() in runtime-critical modules — easier to search test logs and add levels (info/warn/error). Your docs already recommend this. 

Add an fx_playground.tscn automated test that runs each ShaderEffect for its full duration to detect shader compile/visual regressions in CI. You already have tools/fx_playground.* for iteration — reuse it in tests. 

Short prioritized roadmap (what to ship first)

Material duplication + FXManager API + prewarm (small, high payoff). 

Event coalescing + priority/backpressure (prevents noisy regressions). 

GUT CI + autoload fakes + headless integration (ensures future refactors are safe).  (GitHub)

Add linters (shader header checks, .material mutation detection) and the debug FX budget overlay. 

Sources I used (engine guidance + community experience)

Godot official docs: CanvasItem / shader guidance and pre-compilation notes. (Godot Documentation)

Godot docs: singletons/autoload discussion and best-practice tradeoffs. (Godot Documentation)

Signal/Event bus best practices / tutorials (Gdquest). (GDQuest)

GUT (Godot Unit Test) — repo & testing patterns. (GitHub)

Your repo: project.godot autoload list, FXComponent, EventBus, shader files, FX TODOs and docs.