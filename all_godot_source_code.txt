=====================================
        DIRECTORY TREE
=====================================
.
├── LICENSE
├── README.md
├── all_godot_source_code.txt
├── assets
│   ├── audio
│   │   ├── audio-license.txt
│   │   ├── music
│   │   │   ├── title-screen-loop.mp3
│   │   │   └── title-screen-loop.mp3.import
│   │   └── sfx
│   │       ├── menu-back.mp3
│   │       ├── menu-back.mp3.import
│   │       ├── menu-error.mp3
│   │       ├── menu-error.mp3.import
│   │       ├── menu-move.mp3
│   │       ├── menu-move.mp3.import
│   │       ├── menu-select.mp3
│   │       ├── menu-select.mp3.import
│   │       ├── start-chime.mp3
│   │       └── start-chime.mp3.import
│   ├── fonts
│   │   ├── MPLUSRounded1c-Black.ttf
│   │   ├── MPLUSRounded1c-Black.ttf.import
│   │   ├── MPLUSRounded1c-Bold.ttf
│   │   ├── MPLUSRounded1c-Bold.ttf.import
│   │   ├── MPLUSRounded1c-ExtraBold.ttf
│   │   ├── MPLUSRounded1c-ExtraBold.ttf.import
│   │   ├── MPLUSRounded1c-Light.ttf
│   │   ├── MPLUSRounded1c-Light.ttf.import
│   │   ├── MPLUSRounded1c-Medium.ttf
│   │   ├── MPLUSRounded1c-Medium.ttf.import
│   │   ├── MPLUSRounded1c-Regular.ttf
│   │   ├── MPLUSRounded1c-Regular.ttf.import
│   │   ├── MPLUSRounded1c-Thin.ttf
│   │   ├── MPLUSRounded1c-Thin.ttf.import
│   │   └── OFL.txt
│   └── sprites
│       └── ui
│           ├── checkbox
│           │   ├── checkbox-checked.png
│           │   ├── checkbox-checked.png.import
│           │   ├── checkbox-unchecked.png
│           │   └── checkbox-unchecked.png.import
│           ├── cursors
│           │   ├── cursor-default-black.svg
│           │   ├── cursor-default-black.svg.import
│           │   ├── cursor_default.png
│           │   ├── cursor_default.png.import
│           │   ├── cursor_default_white.svg
│           │   ├── cursor_default_white.svg.import
│           │   ├── cursor_default_white_filled.svg
│           │   ├── cursor_default_white_filled.svg.import
│           │   ├── cursor_pointer.png
│           │   └── cursor_pointer.png.import
│           ├── icons
│           │   ├── icon-sound-off-black.svg
│           │   ├── icon-sound-off-black.svg.import
│           │   ├── icon-sound-off-white.svg
│           │   ├── icon-sound-off-white.svg.import
│           │   ├── icon-sound-off.png
│           │   ├── icon-sound-off.png.import
│           │   ├── icon-sound-on-black.svg
│           │   ├── icon-sound-on-black.svg.import
│           │   ├── icon-sound-on-white.svg
│           │   ├── icon-sound-on-white.svg.import
│           │   ├── icon-sound-on.png
│           │   └── icon-sound-on.png.import
│           ├── menu
│           │   ├── menu-cursor.png
│           │   ├── menu-cursor.png.import
│           │   ├── menu-item-back.png
│           │   ├── menu-item-back.png.import
│           │   ├── menu-item-controls.png
│           │   ├── menu-item-controls.png.import
│           │   ├── menu-item-credits.png
│           │   ├── menu-item-credits.png.import
│           │   ├── menu-item-options.png
│           │   ├── menu-item-options.png.import
│           │   ├── menu-item-sound.png
│           │   ├── menu-item-sound.png.import
│           │   ├── menu-item-start.png
│           │   └── menu-item-start.png.import
│           ├── slider
│           │   ├── slider-knob.png
│           │   ├── slider-knob.png.import
│           │   ├── slider-track.png
│           │   └── slider-track.png.import
│           └── title
│               ├── box_battle_title.png
│               └── box_battle_title.png.import
├── create_all_godot_source_code_terminal_prompt.txt
├── default_bus_layout.tres
├── icon.svg
├── icon.svg.import
├── progess
│   └── progress_001-1.jpg
├── project.godot
└── src
    ├── arenas
    │   ├── arena_00_encounter.gd
    │   ├── arena_00_encounter.gd.uid
    │   ├── arena_00_layout.gd
    │   └── arena_00_layout.gd.uid
    ├── core
    │   ├── asset_paths.gd
    │   ├── asset_paths.gd.uid
    │   ├── audio_manager.gd
    │   ├── audio_manager.gd.uid
    │   ├── constants.gd
    │   ├── constants.gd.uid
    │   ├── cursor_manager.gd
    │   ├── cursor_manager.gd.uid
    │   ├── settings.gd
    │   └── settings.gd.uid
    ├── entities
    │   ├── boss
    │   │   ├── base_boss.gd
    │   │   ├── base_boss.gd.uid
    │   │   └── base_boss.tscn
    │   └── player
    │       ├── player.gd
    │       ├── player.gd.uid
    │       └── player.tscn
    ├── projectiles
    │   ├── boss_shot.gd
    │   ├── boss_shot.gd.uid
    │   ├── boss_shot.tscn
    │   ├── player_shot.gd
    │   ├── player_shot.gd.uid
    │   └── player_shot.tscn
    ├── scenes
    │   ├── game
    │   │   ├── game.gd
    │   │   ├── game.gd.uid
    │   │   └── game.tscn
    │   └── main
    │       ├── main.gd
    │       ├── main.gd.uid
    │       └── main.tscn
    └── ui
        ├── components
        │   └── custom_slider
        │       ├── custom_slider.gd
        │       └── custom_slider.gd.uid
        ├── global_hud
        │   ├── global_hud.gd
        │   ├── global_hud.gd.uid
        │   └── global_hud.tscn
        ├── menu_manager
        │   ├── menu_manager.gd
        │   └── menu_manager.gd.uid
        └── screens
            ├── controls_menu
            │   ├── controls_menu.gd
            │   ├── controls_menu.gd.uid
            │   └── controls_menu.tscn
            ├── credits_menu
            │   ├── credits_menu.gd
            │   ├── credits_menu.gd.uid
            │   └── credits_menu.tscn
            ├── options_menu
            │   ├── options_menu.gd
            │   ├── options_menu.gd.uid
            │   └── options_menu.tscn
            ├── sound_menu
            │   ├── sound_menu.gd
            │   ├── sound_menu.gd.uid
            │   └── sound_menu.tscn
            └── title_screen
                ├── title_screen.gd
                ├── title_screen.gd.uid
                └── title_screen.tscn

36 directories, 137 files



=====================================
FILE: ./project.godot
=====================================
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Box Battle"
run/main_scene="res://src/scenes/main/main.tscn"
config/features=PackedStringArray("4.4", "Mobile")
config/icon="res://icon.svg"

[autoload]

Settings="*res://src/core/settings.gd"
AudioManager="*res://src/core/audio_manager.gd"
CursorManager="*res://src/core/cursor_manager.gd"
Constants="*res://src/core/constants.gd"
AssetPaths="*res://src/core/asset_paths.gd"
GlobalHud="*res://src/ui/global_hud/global_hud.tscn"

[display]

window/size/viewport_width=1000
window/size/viewport_height=1000
window/size/resizable=false
window/stretch/mode="canvas_items"

[input]

ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194319,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":13,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":0,"axis_value":-1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
]
}
ui_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194321,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":14,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":0,"axis_value":1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
]
}
ui_up={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194320,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":11,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":1,"axis_value":-1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
]
}
ui_down={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194322,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":0,"button_index":12,"pressure":0.0,"pressed":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":0,"axis":1,"axis_value":1.0,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
]
}
ui_jump={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":32,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":88,"physical_keycode":88,"key_label":0,"unicode":120,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":46,"physical_keycode":46,"key_label":0,"unicode":46,"location":0,"echo":false,"script":null)
]
}
ui_attack={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":67,"physical_keycode":67,"key_label":0,"unicode":99,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":44,"physical_keycode":44,"key_label":0,"unicode":44,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":true,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777218,"physical_keycode":16777218,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":2,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
ui_dash={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":90,"physical_keycode":90,"key_label":0,"unicode":122,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":47,"physical_keycode":47,"key_label":0,"unicode":47,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":true,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777217,"physical_keycode":16777217,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":3,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="player"
2d_physics/layer_2="world"
2d_physics/layer_3="enemy"
2d_physics/layer_4="hazard"
2d_physics/layer_5="enemy_projectile"
2d_physics/layer_6="player_hitbox"
2d_physics/layer_7="player_hurtbox"

[rendering]

renderer/rendering_method="mobile"
environment/defaults/default_clear_color=Color(0, 0, 0, 1)



=====================================
FILE: ./src/arenas/arena_00_encounter.gd
=====================================
# src/arenas/arena_00_encounter.gd
#
# This file defines the dynamic entities and patterns for Arena 00.
# It acts as a "level script" or "director" for the fight.
extends Node

# --- BOSS DATA ---
# Preload the boss scene using the safe path from our singleton.
const BOSS_SCENE = preload(AssetPaths.SCENE_BASE_BOSS)
# The character in the layout that marks the boss's spawn point.
const BOSS_SPAWN_MARKER = "&"

# --- PLAYER DATA ---
const PLAYER_SPAWN_MARKER = "@"


=====================================
FILE: ./src/arenas/arena_00_layout.gd
=====================================
# src/arenas/arena_00_layout.gd
#
# This file defines the physical terrain for Arena 00.
# It is a simple, open box for testing and debugging.
extends Node

# --- COORDINATE LEGEND ---
#
#    A B C D E F G H I J K L M N O P Q R S T
# 1  # # # # # # # # # # # # # # # # # # # #
# 2  # . . . . . . . . . . . . . . . . . . #
# 3  # . . . . @ . . . . . . . . . . . . . #
# 4  # . . . . . . . . . . . . & . . . . . #
# 5  # . . . . . . . . . # - - # . . . . . #
# 6  # . . . . . . . . . # . . # . . . . . #
# 7  # . . . . . . . . . # - - # . . . . . #
# 8  # . . . . . . . . . # . . # . . . . . #
# 9  # . . . . . . . . . # . . # . . . . . #
# 10 # . . . . . . . . . # . . # . . . . . #
# 11 # . . . . . . . . . . . . . . . . . . #
# 12 # . . . . . . . . . . . . . . . . . . #
# 13 # . . . . . . . . . # # # # . . . . . #
# 14 # . . . . . . . . . # # # # . . . . . #
# 15 # . . . . . . . . . # # # # . . . . . #
# 16 # # # # . . . . . . # # # # . . . . . #
# 17 # # # # . . . . . . # # # # . . . . . #
# 18 # # # # . . . . . . . . . . . . . . . #
# 19 # . . . . . . . . . . . . . . . . . . #
# 20 # # # # # # # # # # # # # # # ^ ^ ^ # #
#
# --- TERRAIN LEGEND ---
# # = Solid Wall/Floor
# - = Oneway Platform
# ^ = Hazard
# . = Empty Space
#
# --- ENTITY MARKERS (For visual reference only) ---
# @ = Player Spawn
# & = Boss Spawn
#
const TERRAIN_DATA = [
	"####################", # 1
	"#..................#", # 2
	"#....@.............#", # 3
	"#............&.....#", # 4
	"#.........#--#.....#", # 5
	"#.........#..#.....#", # 6
	"#.........#--#.....#", # 7
	"#.........#..#.....#", # 8
	"#.........#..#.....#", # 9
	"#.........#..#.....#", # 10
	"#..................#", # 11
	"#..................#", # 12
	"#.........####.....#", # 13
	"#.........####.....#", # 14
	"#.........####.....#", # 15
	"####......####.....#", # 16
	"####......####.....#", # 17
	"####...............#", # 18
	"#..................#", # 19
	"###############^^^##"  # 20
]



=====================================
FILE: ./src/core/asset_paths.gd
=====================================
# src/core/asset_paths.gd
#
# This singleton provides a central registry for all asset file paths.
# If an asset is moved or renamed, we only need to update the path in this
# one file, preventing broken references throughout the project.
extends Node

# --- Scenes ---
const SCENE_MAIN = "res://src/scenes/main/main.tscn"
const SCENE_GAME = "res://src/scenes/game/game.tscn"
const SCENE_TITLE_SCREEN = "res://src/ui/screens/title_screen/title_screen.tscn"
const SCENE_OPTIONS_MENU = "res://src/ui/screens/options_menu/options_menu.tscn"
const SCENE_SOUND_MENU = "res://src/ui/screens/sound_menu/sound_menu.tscn"
const SCENE_CONTROLS_MENU = "res://src/ui/screens/controls_menu/controls_menu.tscn"
const SCENE_CREDITS_MENU = "res://src/ui/screens/credits_menu/credits_menu.tscn"
const SCENE_PLAYER = "res://src/entities/player/player.tscn"
const SCENE_BASE_BOSS = "res://src/entities/boss/base_boss.tscn"
const SCENE_PLAYER_SHOT = "res://src/projectiles/player_shot.tscn"
const SCENE_BOSS_SHOT = "res://src/projectiles/boss_shot.tscn"

# --- Scripts ---
const SCRIPT_MENU_MANAGER = "res://src/ui/menu_manager/menu_manager.gd"
const SCRIPT_CUSTOM_SLIDER = "res://src/ui/components/custom_slider/custom_slider.gd"
const SCRIPT_ARENA_00_LAYOUT = "res://src/arenas/arena_00_layout.gd"
const SCRIPT_ARENA_00_ENCOUNTER = "res://src/arenas/arena_00_encounter.gd"

# --- Audio ---
const AUDIO_MUSIC_TITLE = "res://assets/audio/music/title-screen-loop.mp3"
const AUDIO_SFX_MENU_BACK = "res://assets/audio/sfx/menu-back.mp3"
const AUDIO_SFX_MENU_ERROR = "res://assets/audio/sfx/menu-error.mp3"
const AUDIO_SFX_MENU_MOVE = "res://assets/audio/sfx/menu-move.mp3"
const AUDIO_SFX_MENU_SELECT = "res://assets/audio/sfx/menu-select.mp3"
const AUDIO_SFX_START_CHIME = "res://assets/audio/sfx/start-chime.mp3"

# --- Fonts ---
const FONT_BLACK = "res://assets/fonts/MPLUSRounded1c-Black.ttf"
const FONT_BOLD = "res://assets/fonts/MPLUSRounded1c-Bold.ttf"
const FONT_REGULAR = "res://assets/fonts/MPLUSRounded1c-Regular.ttf"

# --- UI Sprites ---
const SPRITE_TITLE = "res://assets/sprites/ui/title/box_battle_title.png"
const SPRITE_MENU_CURSOR = "res://assets/sprites/ui/menu/menu-cursor.png"
const SPRITE_MENU_ITEM_START = "res://assets/sprites/ui/menu/menu-item-start.png"
const SPRITE_MENU_ITEM_OPTIONS = "res://assets/sprites/ui/menu/menu-item-options.png"
const SPRITE_MENU_ITEM_SOUND = "res://assets/sprites/ui/menu/menu-item-sound.png"
const SPRITE_MENU_ITEM_CONTROLS = "res://assets/sprites/ui/menu/menu-item-controls.png"
const SPRITE_MENU_ITEM_CREDITS = "res://assets/sprites/ui/menu/menu-item-credits.png"
const SPRITE_MENU_ITEM_BACK = "res://assets/sprites/ui/menu/menu-item-back.png"
const SPRITE_CURSOR_DEFAULT = "res://assets/sprites/ui/cursors/cursor_default.png"
const SPRITE_CURSOR_POINTER = "res://assets/sprites/ui/cursors/cursor_pointer.png"
const SPRITE_SLIDER_TRACK = "res://assets/sprites/ui/slider/slider-track.png"
const SPRITE_SLIDER_KNOB = "res://assets/sprites/ui/slider/slider-knob.png"
const SPRITE_CHECKBOX_CHECKED = "res://assets/sprites/ui/checkbox/checkbox-checked.png"
const SPRITE_CHECKBOX_UNCHECKED = "res://assets/sprites/ui/checkbox/checkbox-unchecked.png"
const SPRITE_ICON_SOUND_ON = "res://assets/sprites/ui/icons/icon-sound-on.png"
const SPRITE_ICON_SOUND_OFF = "res://assets/sprites/ui/icons/icon-sound-off.png"


=====================================
FILE: ./src/core/audio_manager.gd
=====================================
# src/core/audio_manager.gd
#
# This singleton is responsible for all audio playback. By centralizing all
# audio logic here, any other script can simply call `AudioManager.play_sfx()`
# without worrying about the implementation details.
extends Node

var sfx_players = []
var sfx_player_index = 0
var music_player: AudioStreamPlayer

func _ready():
	for i in range(Constants.NUM_SFX_PLAYERS):
		var player = AudioStreamPlayer.new()
		add_child(player)
		player.bus = "SFX"
		sfx_players.append(player)

	music_player = AudioStreamPlayer.new()
	add_child(music_player)
	music_player.bus = "Music"

func _process(_delta):
	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Master"), linear_to_db(Settings.master_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Master"), Settings.master_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("Music"), linear_to_db(Settings.music_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Music"), Settings.music_muted)

	AudioServer.set_bus_volume_db(AudioServer.get_bus_index("SFX"), linear_to_db(Settings.sfx_volume))
	AudioServer.set_bus_mute(AudioServer.get_bus_index("SFX"), Settings.sfx_muted)

# --- Public Functions ---

func play_sfx(sound_path: String):
	var player = sfx_players[sfx_player_index]
	player.stream = load(sound_path)
	player.play()
	sfx_player_index = (sfx_player_index + 1) % Constants.NUM_SFX_PLAYERS

func play_music(music_path: String):
	# ROBUSTNESS FIX: Check the resource path instead of the instance.
	# This correctly prevents the music from restarting if it's already playing.
	if music_player.stream and music_player.stream.resource_path == music_path and music_player.playing:
		return

	music_player.stream = load(music_path)
	music_player.play()

func stop_music():
	music_player.stop()


=====================================
FILE: ./src/core/constants.gd
=====================================
# src/core/constants.gd
#
# This singleton holds global game design constants. Centralizing these values
# makes it much easier to balance and tune the game's feel without having to
# hunt through multiple files.
extends Node

# --- Audio ---
const NUM_SFX_PLAYERS = 8 # The number of sound effects that can play at once.

# --- Arena Design ---
const TILE_SIZE = 50

# --- General Physics ---
const GRAVITY = 1200.0

# --- Player Physics ---
const PLAYER_SPEED = 450.0
const PLAYER_JUMP_FORCE = 680.0
const POGO_FORCE = 450.0
const COYOTE_TIME = 0.1
const JUMP_BUFFER = 0.1
const JUMP_RELEASE_DAMPENER = 0.4
const WALL_COYOTE_TIME = 0.05
# Set to 0 to disable double jump for testing. Set back to 1 to re-enable.
const MAX_AIR_JUMPS = 0
const DASH_SPEED = 1400.0
const DASH_DURATION = 0.15
const DASH_COOLDOWN = 0.5
const WALL_SLIDE_SPEED = 120.0
const WALL_JUMP_FORCE_X = 1650.0
const WALL_JUMP_FORCE_Y = 680.0

# --- Player Combat & Health ---
const PLAYER_MAX_HEALTH = 5
const PLAYER_HEAL_DURATION = 2.0 # How many seconds it takes to heal.
const PLAYER_MAX_HEALING_CHARGES = 1 # The maximum number of heal charges the player can store.
const ATTACK_COOLDOWN = 0.12
const CHARGE_TIME = 0.35
const ATTACK_DURATION = 0.1
const KNOCKBACK_SPEED = 700.0
const KNOCKBACK_DURATION = 0.1
const HAZARD_KNOCKBACK_SPEED = 400.0
const DETERMINATION_PER_CHARGE = 10
const PLAYER_INVINCIBILITY_DURATION = 1.5

# --- Boss Stats ---
const BOSS_HEALTH = 30


=====================================
FILE: ./src/core/cursor_manager.gd
=====================================
# src/core/cursor_manager.gd
#
# This singleton manages the game's custom "fake" cursor, giving us full
# control over its appearance on all platforms. It draws on a high layer
# to ensure it's always on top of other UI and game elements.
extends CanvasLayer

var cursor_sprite: TextureRect

# We preload our cursor images using the AssetPaths singleton for safety and clarity.
const CURSOR_DEFAULT = preload(AssetPaths.SPRITE_CURSOR_DEFAULT)
const CURSOR_POINTER = preload(AssetPaths.SPRITE_CURSOR_POINTER)

func _ready():
	# A high layer number ensures the cursor renders above everything else.
	layer = 10
	# Hide the computer's default mouse cursor.
	Input.set_mouse_mode(Input.MOUSE_MODE_HIDDEN)

	cursor_sprite = TextureRect.new()
	cursor_sprite.texture = CURSOR_DEFAULT

	# CRITICAL: This makes our cursor sprite "click-through," so it never
	# blocks mouse events intended for buttons or objects underneath it.
	cursor_sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE

	add_child(cursor_sprite)

func _process(_delta):
	# On every frame, our custom cursor's position is synced to the real mouse position.
	cursor_sprite.position = get_viewport().get_mouse_position()

# Public function to change the cursor's appearance (e.g., when hovering a button).
func set_pointer_state(is_pointing: bool):
	if is_pointing:
		cursor_sprite.texture = CURSOR_POINTER
	else:
		cursor_sprite.texture = CURSOR_DEFAULT


=====================================
FILE: ./src/core/settings.gd
=====================================
# src/core/settings.gd
#
# This script is a "Singleton" (also known as an "Autoload" in Godot).
# A singleton is a script that Godot loads once at the very start of the game
# and is always available globally. We can access its variables from any other
# script in the project, which makes it perfect for managing game-wide settings.
#
# We defined this as a singleton in: Project -> Project Settings -> Autoload
extends Node

# --- Audio Settings ---
# These variables store the current sound settings for the game.
# The '@export' keyword tells Godot to show this variable in the Inspector panel
# when this node is viewed in the editor. While we don't edit it there for a
# singleton, it's a common way to mark important, configurable variables.

# A 'float' is a number that can have a decimal point (e.g., 0.5, 1.0).
# Volume values typically range from 0.0 (silent) to 1.0 (full volume).
@export var master_volume: float = 1.0
@export var music_volume: float = 1.0
@export var sfx_volume: float = 1.0

# A 'bool' is a boolean value, which can only be 'true' or 'false'.
# We use these to track whether a sound category is muted.
@export var master_muted: bool = false
@export var music_muted: bool = true # Start with music muted by default.
@export var sfx_muted: bool = false


=====================================
FILE: ./src/entities/boss/base_boss.gd
=====================================
# src/entities/boss/base_boss.gd
#
# This is the foundational script for all bosses in the game. It handles
# shared logic like health, taking damage, gravity, and a basic attack.
extends CharacterBody2D

# Preload the projectile scene using the safe path from our singleton.
const BossShotScene = preload(AssetPaths.SCENE_BOSS_SHOT)

# --- Boss Stats ---
var health = Constants.BOSS_HEALTH

func _ready():
	# Add to the "enemy" group so the player's attacks can find it.
	add_to_group("enemy")

func _physics_process(delta):
	# Apply gravity if the boss is not on the floor.
	if not is_on_floor():
		velocity.y += Constants.GRAVITY * delta
	move_and_slide()

# This function is called by the player's attacks.
func take_damage(damage_amount: int):
	health -= damage_amount
	print("Boss took ", damage_amount, " damage! Health remaining: ", health)
	if health <= 0:
		die()

func die():
	print("Boss has been defeated!")
	# We can add animations and effects here later.
	queue_free()

# --- Attack Logic ---
# This function is connected to the ShotTimer's timeout signal.
func _on_shot_timer_timeout():
	fire_shot()

func fire_shot():
	var shot_instance = BossShotScene.instantiate()
	# Spawn the shot 50 pixels to the left of the boss's center.
	shot_instance.position = global_position + Vector2(-50, 0)
	# Add the shot to the main game scene tree.
	get_parent().add_child(shot_instance)


=====================================
FILE: ./src/entities/boss/base_boss.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://dmej4a7ykn2q0"]

[ext_resource type="Script" path="res://src/entities/boss/base_boss.gd" id="1_26qjf"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossbody"]
size = Vector2(60, 60)

[node name="BaseBoss" type="CharacterBody2D"]
collision_layer = 4
collision_mask = 3
script = ExtResource("1_26qjf")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.6, 0.6, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossbody")

[node name="ShotTimer" type="Timer" parent="."]
wait_time = 2.0
autostart = true

[connection signal="timeout" from="ShotTimer" to="." method="_on_shot_timer_timeout"]


=====================================
FILE: ./src/entities/player/player.gd
=====================================
# src/entities/player/player.gd
#
# This script defines the player's complete behavior using a finite state machine
# to manage its actions like moving, jumping, dashing, and attacking.
extends CharacterBody2D

# --- Node References ---
@onready var hitbox: Area2D = $Hitbox
@onready var hurtbox: Area2D = $Hurtbox
@onready var invincibility_timer: Timer = $InvincibilityTimer
@onready var healing_timer: Timer = $HealingTimer
@onready var hitbox_shape: CollisionShape2D = $Hitbox/CollisionShape2D

# --- Preloads ---
const PlayerShotScene = preload(AssetPaths.SCENE_PLAYER_SHOT)

# --- State Machine ---
enum State {MOVE, JUMP, FALL, DASH, WALL_SLIDE, ATTACK, HURT, HEAL}
var state: State = State.FALL

# --- Player Stats & Timers ---
var health = Constants.PLAYER_MAX_HEALTH
var air_jumps_left = 0
var coyote_timer = 0.0
var jump_buffer_timer = 0.0
var wall_coyote_timer = 0.0
var knockback_timer = 0.0
var is_invincible = false
var facing_direction = 1
var last_wall_normal = Vector2.ZERO

# --- NEW: Healing & Determination ---
var determination_counter = 0
var healing_charges = 0

# Attack and Dash Timers
var dash_duration_timer = 0.0
var dash_cooldown_timer = 0.0
var attack_duration_timer = 0.0
var attack_cooldown_timer = 0.0
var is_charging = false
var charge_timer = 0.0
var is_pogo_attack = false
var can_dash = true


# --- Engine Functions ---

func _ready():
	add_to_group("player")
	hitbox.body_entered.connect(_on_hitbox_body_entered)
	hitbox.area_entered.connect(_on_hitbox_area_entered)
	hurtbox.area_entered.connect(_on_hurtbox_area_entered)
	# The body_entered signal for the hurtbox is no longer needed.
	# If it's still connected in the editor, it will now point to a non-existent function,
	# which is harmless but can be disconnected in the editor for ultimate cleanliness.


func _physics_process(delta):
	# --- Update Timers ---
	coyote_timer = max(0.0, coyote_timer - delta)
	jump_buffer_timer = max(0.0, jump_buffer_timer - delta)
	dash_cooldown_timer = max(0.0, dash_cooldown_timer - delta)
	dash_duration_timer = max(0.0, dash_duration_timer - delta)
	attack_duration_timer = max(0.0, attack_duration_timer - delta)
	attack_cooldown_timer = max(0.0, attack_cooldown_timer - delta)
	knockback_timer = max(0.0, knockback_timer - delta)
	wall_coyote_timer = max(0.0, wall_coyote_timer - delta)

	# --- Handle Global Inputs ---
	_handle_input(delta)

	# --- State Machine Logic (calculates velocity) ---
	match state:
		State.MOVE: state_move(delta)
		State.JUMP: state_jump(delta)
		State.FALL: state_fall(delta)
		State.DASH: state_dash()
		State.WALL_SLIDE: state_wall_slide()
		State.ATTACK: state_attack()
		State.HURT: state_hurt(delta)
		State.HEAL: state_heal()

	move_and_slide()
	
	_check_for_contact_damage()
	
	if is_on_wall():
		wall_coyote_timer = Constants.WALL_COYOTE_TIME
		last_wall_normal = get_wall_normal()


func _handle_input(delta):
	if Input.is_action_just_pressed("ui_jump"):
		jump_buffer_timer = Constants.JUMP_BUFFER

	# Only check for attacks if not already in an uninterruptible state.
	if state in [State.ATTACK, State.HURT, State.HEAL]: return
	
	if Input.is_action_just_pressed("ui_attack") and attack_cooldown_timer <= 0:
		is_charging = true; charge_timer = 0.0
	if is_charging and Input.is_action_pressed("ui_attack"):
		charge_timer += delta
	if Input.is_action_just_released("ui_attack"):
		if is_charging:
			if charge_timer >= Constants.CHARGE_TIME: _fire_shot()
			else: change_state(State.ATTACK)
			is_charging = false

# --- State Functions ---

func state_move(delta):
	coyote_timer = Constants.COYOTE_TIME
	
	# Check for healing input
	var is_holding_heal = Input.is_action_pressed("ui_down") and Input.is_action_pressed("ui_jump")
	if is_holding_heal and healing_charges > 0:
		change_state(State.HEAL)
		return # Stop processing in this state
		
	_apply_horizontal_movement()
	velocity.y += Constants.GRAVITY * delta
	if not is_on_floor(): change_state(State.FALL)
	if jump_buffer_timer > 0: _perform_jump()

	if Input.is_action_just_pressed("ui_dash") and can_dash and dash_cooldown_timer <= 0:
		change_state(State.DASH)

func state_jump(delta):
	_apply_horizontal_movement()
	_apply_gravity(delta)
	_check_for_landing()
	_check_for_wall_slide()

	if Input.is_action_just_pressed("ui_dash") and can_dash and dash_cooldown_timer <= 0:
		change_state(State.DASH)
	
	if jump_buffer_timer > 0 and air_jumps_left > 0:
		_perform_air_jump()

func state_fall(delta):
	_apply_horizontal_movement()
	_apply_gravity(delta)
	_check_for_landing()
	_check_for_wall_slide()

	if jump_buffer_timer > 0:
		if wall_coyote_timer > 0: _perform_wall_jump()
		elif coyote_timer > 0: _perform_jump()
		elif air_jumps_left > 0: _perform_air_jump()
		
	if Input.is_action_just_pressed("ui_dash") and can_dash and dash_cooldown_timer <= 0:
		change_state(State.DASH)

func state_wall_slide():
	velocity.y = min(velocity.y + Constants.GRAVITY * get_physics_process_delta_time(), Constants.WALL_SLIDE_SPEED)
	facing_direction = -last_wall_normal.x

	if jump_buffer_timer > 0:
		_perform_wall_jump(); return

	if Input.get_axis("ui_left", "ui_right") * -last_wall_normal.x < 0.8:
		change_state(State.FALL)
	if wall_coyote_timer <= 0:
		change_state(State.FALL)
	if is_on_floor():
		change_state(State.MOVE)

func state_dash():
	velocity = _get_dash_direction() * Constants.DASH_SPEED
	if dash_duration_timer <= 0: velocity = Vector2.ZERO; change_state(State.FALL)

func state_attack():
	velocity = Vector2.ZERO
	if attack_duration_timer <= 0:
		hitbox_shape.call_deferred("set", "disabled", true); is_pogo_attack = false
		change_state(State.FALL)

func state_hurt(delta):
	velocity.y += Constants.GRAVITY * delta
	if knockback_timer <= 0: change_state(State.FALL)

# --- NEW: Healing State Logic ---
func state_heal():
	velocity = Vector2.ZERO
	
	var is_holding_heal = Input.is_action_pressed("ui_down") and Input.is_action_pressed("ui_jump")
	var moved = not is_zero_approx(Input.get_axis("ui_left", "ui_right"))
	
	if not is_holding_heal or moved or not is_on_floor():
		_cancel_heal()
		change_state(State.MOVE) # Transition to move after canceling

# --- State Change & Helper Functions ---

func change_state(new_state: State):
	if state == new_state: return
	
	if state == State.WALL_SLIDE:
		if last_wall_normal != Vector2.ZERO:
			facing_direction = last_wall_normal.x
	
	state = new_state
	match state:
		State.JUMP:
			jump_buffer_timer = 0; coyote_timer = 0
			velocity.y = -Constants.PLAYER_JUMP_FORCE
		State.DASH:
			can_dash = false
			dash_duration_timer = Constants.DASH_DURATION
			dash_cooldown_timer = Constants.DASH_COOLDOWN
		State.ATTACK:
			_perform_melee_attack()
		State.WALL_SLIDE:
			can_dash = true
			air_jumps_left = Constants.MAX_AIR_JUMPS
		State.HURT:
			is_charging = false
			_cancel_heal() # Cancel heal if you get hurt
			knockback_timer = Constants.KNOCKBACK_DURATION
		State.HEAL:
			healing_timer.start(Constants.PLAYER_HEAL_DURATION)
			print("Healing started...")


func _apply_horizontal_movement():
	if state in [State.DASH, State.HURT, State.ATTACK, State.WALL_SLIDE, State.HEAL]: return
	var input_direction = Input.get_axis("ui_left", "ui_right")
	velocity.x = input_direction * Constants.PLAYER_SPEED
	if input_direction != 0: facing_direction = sign(input_direction)

func _apply_gravity(delta):
	if velocity.y < 0 and Input.is_action_just_released("ui_jump"):
		velocity.y *= Constants.JUMP_RELEASE_DAMPENER
	velocity.y += Constants.GRAVITY * delta
	if state == State.JUMP and velocity.y > 0.0:
		change_state(State.FALL)

func _check_for_landing():
	if is_on_floor() and state in [State.FALL, State.JUMP]:
		can_dash = true
		air_jumps_left = Constants.MAX_AIR_JUMPS
		change_state(State.MOVE)

func _check_for_wall_slide():
	if state != State.JUMP and state != State.FALL:
		return
		
	var input_dir = Input.get_axis("ui_left", "ui_right")
	if wall_coyote_timer > 0 and not is_on_floor() and input_dir != 0 and sign(input_dir) == -last_wall_normal.x:
		change_state(State.WALL_SLIDE)

func _get_dash_direction():
	if Input.is_action_pressed("ui_up"): return Vector2.UP
	if Input.is_action_pressed("ui_down"): return Vector2.DOWN
	return Vector2(facing_direction, 0)

# --- Action Functions ---

func _perform_jump():
	change_state(State.JUMP)

func _perform_air_jump():
	velocity.y = -Constants.PLAYER_JUMP_FORCE
	air_jumps_left -= 1
	jump_buffer_timer = 0

func _perform_wall_jump():
	velocity.y = -Constants.WALL_JUMP_FORCE_Y
	velocity.x = last_wall_normal.x * Constants.WALL_JUMP_FORCE_X
	state = State.JUMP
	jump_buffer_timer = 0
	coyote_timer = 0
	wall_coyote_timer = 0

func _perform_melee_attack():
	attack_duration_timer = Constants.ATTACK_DURATION
	attack_cooldown_timer = Constants.ATTACK_COOLDOWN
	hitbox_shape.disabled = false
	is_pogo_attack = false
	if Input.is_action_pressed("ui_down"):
		is_pogo_attack = true; hitbox.position = Vector2(0, 60)
		# Call the new check. If it succeeds, the pogo is handled instantly.
		if _check_for_immediate_pogo():
			return # Stop here, the pogo was triggered.
	elif Input.is_action_pressed("ui_up"):
		hitbox.position = Vector2(0, -60)
	else:
		hitbox.position = Vector2(facing_direction * 60, 0)

func _fire_shot():
	attack_cooldown_timer = Constants.ATTACK_COOLDOWN
	var shot_direction = Vector2(facing_direction, 0)
	if Input.is_action_pressed("ui_up"): shot_direction = Vector2.UP
	elif Input.is_action_pressed("ui_down"): shot_direction = Vector2.DOWN
	var shot_instance = PlayerShotScene.instantiate()
	shot_instance.direction = shot_direction
	shot_instance.position = global_position + (shot_direction * 60)
	get_parent().add_child(shot_instance)

func _check_for_immediate_pogo() -> bool:
	# Proactively checks if the pogo hitbox is already overlapping a valid surface.
	var space_state = get_world_2d().direct_space_state
	var hitbox_shape_res = hitbox_shape.shape
	
	var query = PhysicsShapeQueryParameters2D.new()
	query.shape = hitbox_shape_res
	query.transform = hitbox.global_transform
	# Check against world (2), enemy (4), and hazard (8) layers.
	query.collision_mask = 14
	
	var results = space_state.intersect_shape(query)
	
	if not results.is_empty():
		_trigger_pogo(results[0].collider)
		return true # Signal success
	
	return false # Signal failure

func _trigger_pogo(pogo_target):
	# This is now the single source of truth for all pogo actions.
	hitbox_shape.call_deferred("set", "disabled", true) # Disable hitbox after one hit.
	is_pogo_attack = false # Ensure we don't pogo twice.
	
	can_dash = true
	velocity.y = -Constants.POGO_FORCE
	air_jumps_left = Constants.MAX_AIR_JUMPS
	dash_duration_timer = 0
	change_state(State.FALL) # Force state to FALL to re-evaluate logic.
	
	# --- POGO TARGET LOGIC ---
	# Check if we hit a valid pogo target.
	if pogo_target:
		# If it's an enemy, deal damage and gain determination.
		if pogo_target.has_method("take_damage"):
			pogo_target.take_damage(1)
			_on_damage_dealt()
		# If it's a projectile, destroy it.
		elif pogo_target.is_in_group("enemy_projectile"):
			pogo_target.queue_free()

func take_damage(damage_amount: int, damage_source = null):
	if is_invincible: return
	health -= damage_amount
	print("Player took %s damage! Health: %s" % [damage_amount, health])
	is_invincible = true
	invincibility_timer.start(Constants.PLAYER_INVINCIBILITY_DURATION)
	change_state(State.HURT)
	if damage_source:
		var knockback_direction = (global_position - damage_source.global_position).normalized()
		var knockback_strength = Constants.KNOCKBACK_SPEED
		if damage_source.is_in_group("hazard"): knockback_strength = Constants.HAZARD_KNOCKBACK_SPEED
		velocity = (knockback_direction + Vector2.UP * 0.5).normalized() * knockback_strength
	if health <= 0: die()

func die():
	print("Player has been defeated! Reloading stage.")
	get_tree().call_deferred("reload_current_scene")

func _check_for_contact_damage():
	for i in range(get_slide_collision_count()):
		var collision = get_slide_collision(i)
		if not collision: continue

		var body_hit = collision.get_collider()
		if not body_hit: continue

		if body_hit.is_in_group("enemy") or body_hit.is_in_group("hazard"):
			take_damage(1, body_hit)
			break

func _on_damage_dealt():
	if healing_charges >= Constants.PLAYER_MAX_HEALING_CHARGES:
		return

	determination_counter += 1
	print("Determination: %d/%d" % [determination_counter, Constants.DETERMINATION_PER_CHARGE])
	if determination_counter >= Constants.DETERMINATION_PER_CHARGE:
		determination_counter = 0
		healing_charges += 1
		print("Healing charge gained! Total charges: %d" % healing_charges)

func _cancel_heal():
	if healing_timer.is_stopped(): return
	healing_timer.stop()
	print("Healing canceled.")


# --- Signal Callbacks ---

func _on_hitbox_body_entered(body):
	if is_pogo_attack: 
		# Let the centralized pogo function handle all the logic.
		_trigger_pogo(body)
	elif body.is_in_group("enemy"):
		body.take_damage(1)
		_on_damage_dealt()
		hitbox_shape.call_deferred("set", "disabled", true)

func _on_hitbox_area_entered(area):
	if is_pogo_attack and area.is_in_group("enemy_projectile"): _trigger_pogo(area)

func _on_hurtbox_area_entered(area):
	if area.is_in_group("enemy_projectile"):
		take_damage(1, area); area.queue_free()

func _on_invincibility_timer_timeout():
	is_invincible = false

func _on_healing_timer_timeout():
	if state == State.HEAL:
		health = min(health + 1, Constants.PLAYER_MAX_HEALTH)
		healing_charges -= 1
		print("Healing successful! Health: %d. Charges left: %d" % [health, healing_charges])
		change_state(State.MOVE)



=====================================
FILE: ./src/entities/player/player.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://c6vknl71ea1bo"]

[ext_resource type="Script" path="res://src/entities/player/player.gd" id="1_4d1td"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerbody"]
size = Vector2(40, 40)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerhitbox"]
size = Vector2(40, 40)

[node name="Player" type="CharacterBody2D"]
collision_layer = 1
collision_mask = 14
script = ExtResource("1_4d1td")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.941176, 0.941176, 0.941176, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playerbody")

[node name="Hitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 20

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hitbox"]
shape = SubResource("RectangleShape2D_playerhitbox")
disabled = true

[node name="Hurtbox" type="Area2D" parent="."]
collision_layer = 64
collision_mask = 28

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hurtbox"]
shape = SubResource("RectangleShape2D_playerbody")

[node name="InvincibilityTimer" type="Timer" parent="."]
one_shot = true

[node name="HealingTimer" type="Timer" parent="."]
one_shot = true

[connection signal="timeout" from="InvincibilityTimer" to="." method="_on_invincibility_timer_timeout"]
[connection signal="timeout" from="HealingTimer" to="." method="_on_healing_timer_timeout"]


=====================================
FILE: ./src/projectiles/boss_shot.gd
=====================================
# src/projectiles/boss_shot.gd
#
# Controls the behavior of the boss's projectile.
extends Area2D

var direction = Vector2.LEFT
var speed = 400.0

func _ready():
	# This projectile's purpose is to be detected by the player's hurtbox.
	# The physics layers are set in the scene file.
	add_to_group("enemy_projectile")

func _physics_process(delta):
	position += direction * speed * delta

# This function is not used because the projectile itself doesn't need to detect
# things. Instead, the player's hurtbox detects this projectile. We leave the
# Area2D's monitoring property on by default, but we don't connect its signals.


=====================================
FILE: ./src/projectiles/boss_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cxnmr7yrvchve"]

[ext_resource type="Script" path="res://src/projectiles/boss_shot.gd" id="1_4qgog"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossshot"]
size = Vector2(60, 60)

[node name="BossShot" type="Area2D"]
collision_layer = 16
collision_mask = 0
script = ExtResource("1_4qgog")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.8, 0.4, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossshot")


=====================================
FILE: ./src/projectiles/player_shot.gd
=====================================
# src/projectiles/player_shot.gd
#
# Controls the behavior of the player's charged projectile.
extends Area2D

var direction = Vector2.RIGHT
var speed = 1000.0
var damage = 2 # Charged shots do more damage than melee

func _ready():
	# Connect signals to handle collisions with both solid bodies and other areas.
	body_entered.connect(_on_body_entered)
	area_entered.connect(_on_area_entered)

func _physics_process(delta):
	position += direction * speed * delta

func _on_body_entered(body):
	# Check if the body hit is an enemy.
	if body.is_in_group("enemy"):
		body.take_damage(damage)
		queue_free() # Destroy self on hit.
		return # Stop further processing.

	# Check if the body hit is part of the solid world.
	if body.is_in_group("world"):
		queue_free() # Destroy self on hitting a wall.

# This function is called when this projectile's area overlaps with another Area2D.
func _on_area_entered(area):
	# Check if the area we hit is an enemy projectile.
	if area.is_in_group("enemy_projectile"):
		# Destroy both this projectile and the enemy one.
		queue_free()
		area.queue_free()


=====================================
FILE: ./src/projectiles/player_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cmdkxwvysirh1"]

[ext_resource type="Script" path="res://src/projectiles/player_shot.gd" id="1_4wg7x"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playershot"]
size = Vector2(40, 40)

[node name="PlayerShot" type="Area2D"]
collision_layer = 0
collision_mask = 22
script = ExtResource("1_4wg7x")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.5, 0.8, 1, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playershot")


=====================================
FILE: ./src/scenes/game/game.gd
=====================================
# src/scenes/game/game.gd
#
# This script orchestrates the setup of an arena battle. It loads a layout
# and an encounter file, builds the terrain from that data, and spawns the
# required entities like the player and boss.
extends Node

# --- Preloads ---
# Preload all required scenes and scripts via the AssetPaths singleton.
const PlayerScene = preload(AssetPaths.SCENE_PLAYER)
const ArenaLayout = preload(AssetPaths.SCRIPT_ARENA_00_LAYOUT)
const ArenaEncounter = preload(AssetPaths.SCRIPT_ARENA_00_ENCOUNTER)

func _ready():
	# Instantiate our data-only scripts to access their constants.
	var layout = ArenaLayout.new()
	var encounter = ArenaEncounter.new()

	var player_spawn_pos = Vector2.ZERO
	var boss_spawn_pos = Vector2.ZERO

	# --- Build Terrain and Find Spawns ---
	# Read the layout data and build the physical world tile by tile.
	for y in range(layout.TERRAIN_DATA.size()):
		var row_string = layout.TERRAIN_DATA[y]
		for x in range(row_string.length()):
			var tile_char = row_string[x]
			# Use the TILE_SIZE from our Constants singleton for positioning.
			var tile_pos = Vector2(x * Constants.TILE_SIZE, y * Constants.TILE_SIZE) + Vector2(Constants.TILE_SIZE / 2.0, Constants.TILE_SIZE / 2.0)

			match tile_char:
				'#':
					_create_solid_tile(tile_pos)
				'-':
					_create_oneway_platform(tile_pos)
				'^':
					_create_hazard_tile(tile_pos)
				# Check for entity markers defined in the encounter script.
				encounter.PLAYER_SPAWN_MARKER:
					player_spawn_pos = tile_pos
				encounter.BOSS_SPAWN_MARKER:
					boss_spawn_pos = tile_pos

	# --- Spawn Entities ---
	_spawn_player(player_spawn_pos)
	_spawn_boss(boss_spawn_pos, encounter.BOSS_SCENE)


# --- Helper Functions for Spawning and Building ---

func _spawn_player(pos: Vector2):
	var player_instance = PlayerScene.instantiate()
	player_instance.global_position = pos
	add_child(player_instance)

func _spawn_boss(pos: Vector2, scene: PackedScene):
	if scene == null: return
	var boss_instance = scene.instantiate()
	boss_instance.global_position = pos
	add_child(boss_instance)

func _create_solid_tile(pos: Vector2):
	var static_body = StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = 2 # Corresponds to "world" layer
	static_body.add_to_group("world")
	var collision_shape = CollisionShape2D.new()
	var rectangle_shape = RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)
	add_child(static_body)

func _create_oneway_platform(pos: Vector2):
	var static_body = StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = 2 # Corresponds to "world" layer
	static_body.add_to_group("world")
	var collision_shape = CollisionShape2D.new()
	collision_shape.one_way_collision = true
	var rectangle_shape = RectangleShape2D.new()
	# Make the platform thin for one-way collision to work best
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, 10)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)
	add_child(static_body)

# --- THIS IS THE FIX ---
# A hazard is now both a "world" object (layer 2) and a "hazard" object (layer 8).
# The player's body collides with layer 2, making it solid.
# The player's hurtbox detects layer 8, making it deal damage.
func _create_hazard_tile(pos: Vector2):
	var static_body = StaticBody2D.new()
	static_body.position = pos
	# Set the layer to be the sum of the world layer (2) and the hazard layer (8).
	static_body.collision_layer = 10
	static_body.add_to_group("world")
	static_body.add_to_group("hazard")
	var collision_shape = CollisionShape2D.new()
	var rectangle_shape = RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)
	add_child(static_body)


=====================================
FILE: ./src/scenes/game/game.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://game_scene_unique_id"]

[ext_resource type="Script" path="res://src/scenes/game/game.gd" id="1_game_script"]

[node name="Game" type="Node"]
script = ExtResource("1_game_script")


=====================================
FILE: ./src/scenes/main/main.gd
=====================================
# src/scenes/main/main.gd
# This is the main entry point for the game, as defined in project.godot.
# Its only job is to immediately load and switch to the first real scene,
# which is our title screen.
extends Node

func _ready():
	# Using AssetPaths makes this transition type-safe and easy to manage.
	# 'call_deferred' waits until the current frame is finished before changing scenes,
	# which prevents potential physics or node errors during the switch.
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/scenes/main/main.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bt1c5p8wphc4a"]

[ext_resource type="Script" uid="uid://coxyesem6rn3k" path="res://src/scenes/main/main.gd" id="1_main_script"]

[node name="Main" type="Node"]
script = ExtResource("1_main_script")



=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.gd
=====================================
# src/ui/components/custom_slider/custom_slider.gd
#
# A self-contained, reusable custom slider component. It emits a 'value_changed'
# signal that the parent menu (SoundMenu) listens for.
extends TextureRect

signal value_changed(value)

var knob: TextureRect
var is_dragging = false
var min_x = 0.0
var max_x = 0.0
var drag_offset = 0.0
var _initial_value = -1.0

func _ready():
	# Load textures using safe paths from the AssetPaths singleton.
	self.texture = load(AssetPaths.SPRITE_SLIDER_TRACK)
	
	knob = TextureRect.new()
	knob.texture = load(AssetPaths.SPRITE_SLIDER_KNOB)
	add_child(knob)
	
	# Connect signals for mouse interaction.
	knob.mouse_entered.connect(_on_knob_mouse_entered)
	knob.mouse_exited.connect(_on_knob_mouse_exited)
	
	# Wait for the node's size and position to be finalized before calculating bounds.
	await get_tree().process_frame
	
	knob.position.y = (size.y - knob.size.y) / 2
	min_x = global_position.x
	max_x = global_position.x + size.x - knob.size.x
	
	if _initial_value >= 0.0:
		var new_x_pos = min_x + (max_x - min_x) * _initial_value
		# 'clamp' ensures the value stays within the min/max range.
		knob.global_position.x = clamp(new_x_pos, min_x, max_x)

# Public function called by the Sound Menu to set the initial volume.
func set_value(initial_value: float):
	_initial_value = initial_value

func _process(_delta):
	# This code only runs if the user is actively dragging the knob.
	if is_dragging:
		var global_mouse_pos = get_global_mouse_position()
		# Move the knob to follow the mouse, but clamped within the slider's bounds.
		knob.global_position.x = clamp(global_mouse_pos.x - drag_offset, min_x, max_x)
		
		if (max_x - min_x) > 0:
			# Calculate the current value as a fraction (0.0 to 1.0).
			var current_value = (knob.global_position.x - min_x) / (max_x - min_x)
			# Emit our custom signal, sending the new value to the sound menu.
			emit_signal("value_changed", current_value)

# This function handles mouse clicks on the slider track.
func _gui_input(event):
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		var knob_rect = knob.get_global_rect()
		
		if event.is_pressed():
			# Check if the click was on the knob to initiate dragging.
			if knob_rect.has_point(event.global_position):
				is_dragging = true
				# Calculate offset to make dragging feel smooth and natural.
				drag_offset = event.global_position.x - knob.global_position.x
		else:
			# When the button is released, stop dragging.
			is_dragging = false
			# Reset the cursor if the mouse is no longer over the knob.
			if not knob_rect.has_point(get_global_mouse_position()):
				CursorManager.set_pointer_state(false)
			drag_offset = 0.0

func _on_knob_mouse_entered():
	CursorManager.set_pointer_state(true)

func _on_knob_mouse_exited():
	# Only reset the cursor if we are NOT currently dragging the knob.
	# This prevents the cursor from flickering while dragging.
	if not is_dragging:
		CursorManager.set_pointer_state(false)


=====================================
FILE: ./src/ui/global_hud/global_hud.gd
=====================================
# src/ui/global_hud/global_hud.gd
#
# This autoloaded scene is always present. Its main job is to manage the
# global mute button that appears in the top-right corner of menu screens.
extends Control

# Preload icons into constants for performance and safety.
const ICON_SOUND_ON = preload(AssetPaths.SPRITE_ICON_SOUND_ON)
const ICON_SOUND_OFF = preload(AssetPaths.SPRITE_ICON_SOUND_OFF)

var mute_button: TextureButton

const MENU_SCENES = [
	AssetPaths.SCENE_TITLE_SCREEN,
	AssetPaths.SCENE_OPTIONS_MENU,
	AssetPaths.SCENE_SOUND_MENU,
	AssetPaths.SCENE_CONTROLS_MENU,
	AssetPaths.SCENE_CREDITS_MENU,
]

func _ready():
	mute_button = TextureButton.new()
	add_child(mute_button)

	var padding = 40
	# Wait for the viewport to be ready before positioning.
	await get_tree().process_frame

	# FIX: Revert to the original, correct positioning logic.
	# The dynamic calculation was flawed because the button's size is 0 before its texture is set.
	mute_button.position = Vector2(get_viewport_rect().size.x - 120, padding)

	# Connect signals for interaction.
	mute_button.pressed.connect(_on_mute_button_pressed)
	mute_button.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
	mute_button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

	# Set the initial icon state.
	_update_icon()

func _process(_delta):
	if not get_tree().current_scene: return

	var current_scene_path = get_tree().current_scene.scene_file_path
	mute_button.visible = current_scene_path in MENU_SCENES

	if mute_button.visible:
		var is_muted_in_settings = Settings.music_muted
		var icon_is_off = mute_button.texture_normal == ICON_SOUND_OFF

		# If the setting and the icon are out of sync, update the icon.
		if is_muted_in_settings != icon_is_off:
			_update_icon()

func _on_mute_button_pressed():
	# Toggle the setting, play a sound, and update the icon.
	Settings.music_muted = not Settings.music_muted
	AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_SELECT)
	_update_icon()

func _update_icon():
	# Set the button's texture based on the current setting.
	if Settings.music_muted:
		mute_button.texture_normal = ICON_SOUND_OFF
	else:
		mute_button.texture_normal = ICON_SOUND_ON


=====================================
FILE: ./src/ui/global_hud/global_hud.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dpcsg3wmlvabm"]

[ext_resource type="Script" path="res://src/ui/global_hud/global_hud.gd" id="1_hud_script"]

[node name="GlobalHUD" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
mouse_filter = 2
script = ExtResource("1_hud_script")


=====================================
FILE: ./src/ui/menu_manager/menu_manager.gd
=====================================
# src/ui/menu_manager/menu_manager.gd
#
# A reusable script for creating keyboard and mouse-navigable menus. An instance
# of this is created by each menu scene to manage its own set of buttons.
extends Node

# --- Inner Class: MenuItem ---
# A simple data structure to bundle a button node with its "type" (for sounds).
class MenuItem:
	var button: TextureButton
	var type: String

	func _init(btn: TextureButton, btn_type: String):
		self.button = btn
		self.type = btn_type

# --- Variables ---
var menu_items = []
var current_selection = 0
var cursor_left: TextureRect
var cursor_right: TextureRect

func _ready():
	# Create the cursor sprites using the safe path from AssetPaths.
	cursor_left = TextureRect.new()
	cursor_left.texture = load(AssetPaths.SPRITE_MENU_CURSOR)
	cursor_left.flip_h = true # Point it inwards.
	add_child(cursor_left)

	cursor_right = TextureRect.new()
	cursor_right.texture = load(AssetPaths.SPRITE_MENU_CURSOR)
	add_child(cursor_right)

	cursor_left.visible = false
	cursor_right.visible = false

# The main setup function, called by the parent menu scene.
func setup_menu(items: Array):
	menu_items = items
	if menu_items.is_empty(): return

	for i in range(menu_items.size()):
		var menu_item = menu_items[i]
		# Connect signals for each button.
		# When the mouse enters a button, we call our own function to handle it.
		menu_item.button.mouse_entered.connect(_on_mouse_entered.bind(i))
		# When the mouse leaves, we tell the cursor manager to reset the cursor state.
		menu_item.button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))
		# When the button is pressed (by click or keyboard), we handle the sound.
		menu_item.button.pressed.connect(_on_item_pressed.bind(i))

	# Set the initial selection to the first item.
	current_selection = 0
	# Wait one frame to ensure all buttons have their positions calculated.
	await get_tree().process_frame
	# Now update the cursors to point to the first item.
	_update_cursors()
	cursor_left.visible = true
	cursor_right.visible = true

# Catches unhandled input for keyboard/controller navigation.
func _unhandled_input(event):
	if event.is_action_pressed("ui_down"):
		_change_selection(1)
	elif event.is_action_pressed("ui_up"):
		_change_selection(-1)
	elif event.is_action_pressed("ui_accept"):
		if not menu_items.is_empty():
			menu_items[current_selection].button.emit_signal("pressed")

# Plays context-specific sounds based on the button type.
func _on_item_pressed(index: int):
	if index < 0 or index >= menu_items.size(): return

	var item_type = menu_items[index].type
	match item_type:
		"BACK":
			AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_BACK)
		"START":
			AudioManager.play_sfx(AssetPaths.AUDIO_SFX_START_CHIME)
		_: # Default case for "SELECT" or any other type.
			AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_SELECT)

# Handles the logic for changing the selected item via keyboard.
func _change_selection(amount: int):
	if menu_items.size() <= 1:
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_ERROR)
		return

	var new_selection = (current_selection + amount + menu_items.size()) % menu_items.size()

	if new_selection != current_selection:
		current_selection = new_selection
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_MOVE)
		_update_cursors()
	else:
		# This case can happen if there's only one item.
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_ERROR)

# Called when the mouse pointer enters a button's collision shape.
func _on_mouse_entered(index: int):
	CursorManager.set_pointer_state(true)
	if current_selection != index:
		current_selection = index
		AudioManager.play_sfx(AssetPaths.AUDIO_SFX_MENU_MOVE)
		_update_cursors()

# Moves the visual cursors to frame the currently selected button.
func _update_cursors():
	if menu_items.is_empty(): return

	var selected_button = menu_items[current_selection].button
	var button_pos = selected_button.position
	var button_size = selected_button.size
	var cursor_padding = 40

	cursor_left.position.x = button_pos.x - cursor_left.size.x - cursor_padding
	cursor_left.position.y = button_pos.y + (button_size.y - cursor_left.size.y) / 2

	cursor_right.position.x = button_pos.x + button_size.x + cursor_padding
	cursor_right.position.y = button_pos.y + (button_size.y - cursor_right.size.y) / 2


=====================================
FILE: ./src/ui/screens/controls_menu/controls_menu.gd
=====================================
# src/ui/screens/controls_menu/controls_menu.gd
#
# Displays a static list of the game's controls.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)
	var bold_font = load(AssetPaths.FONT_BOLD)
	var regular_font = load(AssetPaths.FONT_REGULAR)

	# --- Title ---
	var title_label = Label.new()
	title_label.text = "Controls"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 96)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80

	# --- Controls List ---
	# FIX: Restoring the original, more detailed controls data.
	var controls_data = [
		{ "action": "Movement", "keys": "Arrow Keys / WASD / Mouse" },
		{ "action": "Primary Action", "keys": "X / . / Space / Left-Click" },
		{ "action": "Secondary Action", "keys": "C / , / Shift / Right-Click" },
		{ "action": "Tertiary Action", "keys": "Z / / / Ctrl / Middle-Click" },
		{ "action": "Pause / Menu", "keys": "Enter / P / Escape" },
		{ "action": "Back / Cancel", "keys": "Escape / Backspace" }
	]

	var start_y = 300
	var item_gap = 70

	for i in range(controls_data.size()):
		var data = controls_data[i]
		var y_pos = start_y + i * item_gap

		var action_label = Label.new()
		action_label.text = data.action
		add_child(action_label)
		action_label.add_theme_font_override("font", bold_font)
		action_label.add_theme_font_size_override("font_size", 36)
		# FIX: Restoring original x-size for alignment.
		action_label.size.x = 390
		action_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
		action_label.position = Vector2(0, y_pos)

		var keys_label = Label.new()
		keys_label.text = data.keys
		add_child(keys_label)
		keys_label.add_theme_font_override("font", regular_font)
		keys_label.add_theme_font_size_override("font_size", 36)
		# FIX: Restoring original x-position for alignment.
		keys_label.position = Vector2(460, y_pos)

	# --- Back Button ---
	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position.x = (get_viewport_rect().size.x - back_button.size.x) / 2
	back_button.position.y = 800
	back_button.pressed.connect(_on_back_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(back_button, "BACK")])

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)


=====================================
FILE: ./src/ui/screens/controls_menu/controls_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cghquk5y1qjwg"]

[ext_resource type="Script" path="res://src/ui/screens/controls_menu/controls_menu.gd" id="1_controls_script"]

[node name="ControlsMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_controls_script")


=====================================
FILE: ./src/ui/screens/credits_menu/credits_menu.gd
=====================================
# src/ui/screens/credits_menu/credits_menu.gd
#
# Displays game credits using a RichTextLabel to handle formatted text and URLs.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)

	var title_label = Label.new()
	title_label.text = "Credits"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 96)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80

	# --- Credits RichTextLabel ---
	var credits_label = RichTextLabel.new()
	add_child(credits_label)
	credits_label.mouse_filter = Control.MOUSE_FILTER_PASS
	credits_label.add_theme_font_override("normal_font", load(AssetPaths.FONT_REGULAR))
	credits_label.add_theme_font_size_override("normal_font_size", 38)
	credits_label.add_theme_color_override("default_color", Color.WHITE)
	credits_label.position = Vector2(0, 220)
	credits_label.size.x = get_viewport_rect().size.x
	credits_label.size.y = 550
	credits_label.bbcode_enabled = true # This MUST be true to parse the [url] tags.

	credits_label.text = """
[center]A Game By Steven Casteel[/center]
[center][url=https://www.stevencasteel.com/]www.stevencasteel.com[/url][/center]

[center]Built with the [url=https://godotengine.org/]Godot Engine[/url][/center]
[center]AI-Assisted by [url=https://gemini.google.com/]Gemini[/url][/center]

[center]Find me on [url=https://www.youtube.com/@stevencasteel]YouTube[/url] and [url=http://github.com/stevencasteel]GitHub[/url][/center]
"""
	# --- Connect Signals for RichTextLabel ---
	credits_label.meta_clicked.connect(_on_meta_clicked)
	credits_label.meta_hover_started.connect(func(_meta): CursorManager.set_pointer_state(true))
	credits_label.meta_hover_ended.connect(func(_meta): CursorManager.set_pointer_state(false))

	# --- Back Button ---
	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position.x = (get_viewport_rect().size.x - back_button.size.x) / 2
	back_button.position.y = 800
	back_button.pressed.connect(_on_back_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(back_button, "BACK")])

# Called when a URL inside the RichTextLabel is clicked.
func _on_meta_clicked(meta):
	# OS.shell_open() opens the URL in the user's default web browser.
	OS.shell_open(str(meta))

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)


=====================================
FILE: ./src/ui/screens/credits_menu/credits_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b8txy2d7jrhwg"]

[ext_resource type="Script" path="res://src/ui/screens/credits_menu/credits_menu.gd" id="1_credits_script"]

[node name="CreditsMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_credits_script")


=====================================
FILE: ./src/ui/screens/options_menu/options_menu.gd
=====================================
# src/ui/screens/options_menu/options_menu.gd
#
# Manages the Options menu, which acts as a hub to navigate to other screens.
extends Control

const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)
	
	# --- Create UI Elements ---
	var title_label = Label.new()
	title_label.text = "Options"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 96)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80
	
	var sound_button = TextureButton.new()
	sound_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_SOUND)
	add_child(sound_button)
	sound_button.position = Vector2((get_viewport_rect().size.x - sound_button.size.x) / 2, 300)
	
	var controls_button = TextureButton.new()
	controls_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_CONTROLS)
	add_child(controls_button)
	controls_button.position = Vector2((get_viewport_rect().size.x - controls_button.size.x) / 2, 450)

	var credits_button = TextureButton.new()
	credits_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_CREDITS)
	add_child(credits_button)
	credits_button.position = Vector2((get_viewport_rect().size.x - credits_button.size.x) / 2, 600)
	
	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position = Vector2((get_viewport_rect().size.x - back_button.size.x) / 2, 800)
	
	# --- Connect Signals ---
	sound_button.pressed.connect(_on_sound_button_pressed)
	controls_button.pressed.connect(_on_controls_button_pressed)
	credits_button.pressed.connect(_on_credits_button_pressed)
	back_button.pressed.connect(_on_back_button_pressed)
	
	# --- Initialize Menu Navigation ---
	var menu = MenuManager.new()
	add_child(menu)
	
	var menu_items = [
		MenuManager.MenuItem.new(sound_button, "SELECT"),
		MenuManager.MenuItem.new(controls_button, "SELECT"),
		MenuManager.MenuItem.new(credits_button, "SELECT"),
		MenuManager.MenuItem.new(back_button, "BACK")
	]
	menu.setup_menu(menu_items)

# --- Button Press Handlers ---

func _on_sound_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_SOUND_MENU)

func _on_controls_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_CONTROLS_MENU)

func _on_credits_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_CREDITS_MENU)

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/ui/screens/options_menu/options_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://ddgtf7n0tqvot"]

[ext_resource type="Script" path="res://src/ui/screens/options_menu/options_menu.gd" id="1_options_script"]

[node name="OptionsMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_options_script")


=====================================
FILE: ./src/ui/screens/sound_menu/sound_menu.gd
=====================================
# src/ui/screens/sound_menu/sound_menu.gd
#
# Manages the sound settings screen, connecting UI elements to the global
# Settings singleton so changes are applied in real-time.
extends Control

const CustomSliderScript = preload(AssetPaths.SCRIPT_CUSTOM_SLIDER)
const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# We need to store references to our UI elements to update them in _process
var master_volume_label: Label
var music_volume_label: Label
var sfx_volume_label: Label
var master_mute_checkbox: TextureButton
var music_mute_checkbox: TextureButton
var sfx_mute_checkbox: TextureButton

func _ready():
	var title_font = load(AssetPaths.FONT_BLACK)

	var title_label = Label.new()
	title_label.text = "Sound Settings"
	add_child(title_label)
	title_label.add_theme_font_override("font", title_font)
	title_label.add_theme_font_size_override("font_size", 80)
	title_label.size.x = get_viewport_rect().size.x
	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	title_label.position.y = 80

	# FIX: The 'initial_mute' argument is no longer needed here.
	_create_volume_row("MASTER", 300, Settings.master_volume, "master")
	_create_volume_row("MUSIC", 450, Settings.music_volume, "music")
	_create_volume_row("SFX", 600, Settings.sfx_volume, "sfx")

	var back_button = TextureButton.new()
	back_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_BACK)
	add_child(back_button)
	back_button.position.x = (get_viewport_rect().size.x - back_button.size.x) / 2
	back_button.position.y = 800
	back_button.pressed.connect(_on_back_button_pressed)

	var menu = MenuManager.new()
	add_child(menu)
	menu.setup_menu([MenuManager.MenuItem.new(back_button, "BACK")])

# This function now runs every frame to ensure the UI is always in sync.
func _process(_delta):
	# Sync volume labels
	master_volume_label.text = str(int(Settings.master_volume * 100))
	music_volume_label.text = str(int(Settings.music_volume * 100))
	sfx_volume_label.text = str(int(Settings.sfx_volume * 100))
	
	# Sync checkboxes
	_update_checkbox_texture(master_mute_checkbox, Settings.master_muted)
	_update_checkbox_texture(music_mute_checkbox, Settings.music_muted)
	_update_checkbox_texture(sfx_mute_checkbox, Settings.sfx_muted)

# FIX: The 'initial_mute' parameter has been removed from the function definition.
func _create_volume_row(label_text: String, y_pos: int, initial_volume: float, type: String):
	var row_label = Label.new()
	row_label.text = label_text
	add_child(row_label)
	row_label.add_theme_font_override("font", load(AssetPaths.FONT_BOLD))
	row_label.add_theme_font_size_override("font_size", 48)
	row_label.size.x = 250
	row_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	row_label.position = Vector2(40, y_pos)

	var slider = CustomSliderScript.new()
	add_child(slider)
	slider.set_value(initial_volume)
	slider.position = Vector2(300, y_pos + 25)

	var volume_label = Label.new()
	volume_label.add_theme_font_override("font", load(AssetPaths.FONT_REGULAR))
	volume_label.add_theme_font_size_override("font_size", 48)
	volume_label.size.x = 100
	volume_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	volume_label.position = Vector2(720, y_pos)
	add_child(volume_label)

	var checkbox = TextureButton.new()
	checkbox.position = Vector2(850, y_pos + 14)
	add_child(checkbox)
	
	match type:
		"master":
			master_volume_label = volume_label
			master_mute_checkbox = checkbox
			slider.value_changed.connect(func(new_value): Settings.master_volume = new_value)
			checkbox.pressed.connect(func(): Settings.master_muted = not Settings.master_muted)
		"music":
			music_volume_label = volume_label
			music_mute_checkbox = checkbox
			slider.value_changed.connect(func(new_value): Settings.music_volume = new_value)
			checkbox.pressed.connect(func(): Settings.music_muted = not Settings.music_muted)
		"sfx":
			sfx_volume_label = volume_label
			sfx_mute_checkbox = checkbox
			slider.value_changed.connect(func(new_value): Settings.sfx_volume = new_value)
			checkbox.pressed.connect(func(): Settings.sfx_muted = not Settings.sfx_muted)

func _update_checkbox_texture(button_ref: TextureButton, is_muted: bool):
	var new_texture = load(AssetPaths.SPRITE_CHECKBOX_UNCHECKED)
	if is_muted:
		new_texture = load(AssetPaths.SPRITE_CHECKBOX_CHECKED)
	
	if button_ref.texture_normal != new_texture:
		button_ref.texture_normal = new_texture

func _on_back_button_pressed():
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)



=====================================
FILE: ./src/ui/screens/sound_menu/sound_menu.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bapc10ey0j27g"]

[ext_resource type="Script" path="res://src/ui/screens/sound_menu/sound_menu.gd" id="1_sound_script"]

[node name="SoundMenu" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_sound_script")


=====================================
FILE: ./src/ui/screens/title_screen/title_screen.gd
=====================================
# src/ui/screens/title_screen/title_screen.gd
#
# This script controls the main title screen. It displays the game title, menu
# buttons, plays the title music, and sets up menu navigation.
extends Control

# Preload the MenuManager script using the safe path from AssetPaths.
const MenuManager = preload(AssetPaths.SCRIPT_MENU_MANAGER)

func _ready():
	# Wait one frame to ensure singletons like AudioManager are fully ready.
	await get_tree().process_frame
	AudioManager.play_music(AssetPaths.AUDIO_MUSIC_TITLE)

	# --- Create UI Elements ---
	var title_graphic = TextureRect.new()
	title_graphic.texture = load(AssetPaths.SPRITE_TITLE)
	add_child(title_graphic)
	# Center the graphic horizontally.
	title_graphic.position = Vector2((get_viewport_rect().size.x - title_graphic.size.x) / 2, 220)

	var start_button = TextureButton.new()
	start_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_START)
	add_child(start_button)
	start_button.position = Vector2((get_viewport_rect().size.x - start_button.size.x) / 2, 450)

	var options_button = TextureButton.new()
	options_button.texture_normal = load(AssetPaths.SPRITE_MENU_ITEM_OPTIONS)
	add_child(options_button)
	options_button.position = Vector2((get_viewport_rect().size.x - options_button.size.x) / 2, 600)

	# --- Connect Signals ---
	start_button.pressed.connect(_on_start_button_pressed)
	options_button.pressed.connect(_on_options_button_pressed)

	# --- Initialize Menu Navigation ---
	var menu = MenuManager.new()
	add_child(menu)
	
	var menu_items = [
		MenuManager.MenuItem.new(start_button, "START"),
		MenuManager.MenuItem.new(options_button, "SELECT")
	]
	menu.setup_menu(menu_items)

# --- Signal Handler Functions ---

func _on_start_button_pressed():
	# Use AssetPaths to safely change to the gameplay scene.
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_GAME)

func _on_options_button_pressed():
	# Use AssetPaths to safely change to the options menu.
	get_tree().call_deferred("change_scene_to_file", AssetPaths.SCENE_OPTIONS_MENU)


=====================================
FILE: ./src/ui/screens/title_screen/title_screen.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cglqfxtqgxwul"]

[ext_resource type="Script" path="res://src/ui/screens/title_screen/title_screen.gd" id="1_title_script"]

[node name="TitleScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
script = ExtResource("1_title_script")


